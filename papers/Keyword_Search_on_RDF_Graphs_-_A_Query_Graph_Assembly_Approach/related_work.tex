\section{Related Work} \label{sec:related_work}

There are many proposals dedicated to keyword search problem on relational database (RDB for short) and graph data. We summarize them into three categories as illustrated in Figure \ref{fig:related_work_category}. The first category exploits the ``schema'' of RDB, so we call them schema based approaches, including DBXplorer \cite{agrawal2002dbxplorer}, DISCOVER \cite{hristidis2002discover}, SPARK \cite{luo2007spark}, and so on. According to foreign/primary key relationships between tables, these approaches first build a ``schema graph''. Then based on the schema graph, they find join trees to infer the query pattern's structure, namely, SQL. 
%DBXplorer and DISCOVER concentrate on how to find the optimal join tree on the schema graph. SPARK focuses on IR-style ranking method to rank the heterogeneous join trees. 
To cope with the ambiguity of keywords, MetaMatch \cite{bergamaschi2011keyword} proposes a Hungarian bipartite matching algorithm as a joint disambiguation mechanism of mapping keyword tokens into records in RDB. However, MetaMatch still relies on the schema graph to infer SQL structure. As we know, RDF employs ``schema-less'' feature, thus it is impossible to rely on the underlying schema structure to generate query graphs for an RDF dataset.  

\begin{figure} [t]
	\centering
	\scalebox{0.8}[0.9]
	{
		\resizebox{\linewidth}{!}
		{
			\includegraphics[scale=1.0]{visio_pics/related_work_category.pdf}
		}
	}
	\caption{Related Work of Keyword Search Problem.}
	\label{fig:related_work_category}
	\vspace{-0.2in}
\end{figure}

Due to the lack of schema in RDF repository, some existing work (such as SUMG \cite{tran2009top} and SUMM \cite{le2014scalable}) propose class based summarization techniques to generate ``summary graph''. Firstly they leverage the hierarchy of RDF class nodes to generate the summary graph $G_S$, which is much smaller than $G$. Then the graph exploration algorithms can be employed on $G_S$ to retrieve relevant answers. However, the summary graph in SUMG collapses all the entities of the same class into one summary vertex. Thus it loses detailed information about relations between entities of the same class, which may lead to incomplete or incorrect answers.

The last category is employing graph exploration algorithms directly on ``data graphs'', to find small size structures connecting all keywords. The data graph can be derived from RDB as well as RDF dataset. In RDB, each record is modeled as an vertex, and a foreign/primary key relationship between two records is regarded as an edge. In RDF context, subjects and objects are regarded as vertices, and an triple is an edge connecting two corresponding vertices. Therefore, the data graph based approaches can be used in both RDB and RDF context. Formally, given a data graph $G$, the keyword search problem is defined to find a minimum connected tree \cite{ding2007finding} or subgraph \cite{elbassuoni2011keyword} over $G$ that covers all the keyword terms by the tree/subgraph's nodes/edges. The problem definition is similar to the group Steiner tree (GST for short) problem, which is NP-complete. BANKS \cite{bhalotia2002keyword}, BANKS II \cite{kacholia2005bidirectional}, and BLINKS \cite{he2007blinks} are search based approximate algorithms, whereas DPBF \cite{ding2007finding} is a dynamic programming algorithm that can find the exact optimal result, with parameterized time complexity.

As illustrated in Figure \ref{fig:related_work_category}, both data graph based and summary graph based approaches can be used in RDF repository. There are two common drawbacks in these two categories. 

The first one is that they do not intend to \emph{understand} the input keywords. One common assumption in existing work is that the smaller of the result tree's size the more semantic it contains, which should be more interesting to users. For example, the widely adopted GST model as well as its variants, such as r-radius Steiner graph \cite{li2008ease} and multi-center induced graph \cite{qin2009querying}. However, this \emph{implicit} semantic representation of keywords is not good at result's accuracy, since they do not comprehend the query intention behind the keywords.

The second one is that their online search algorithm's complexity depends on the underlying graph size. Some graph exploration algorithms like BANKS, BANKS II, and BLINKS build distance matrix over $G$ to speed up exploration. The size of distance matrix becomes prohibitively expensive when handling large RDF graphs. DPBF's complexity is $O(3^l|V|+2^l(|V|log|V|+|E|))$, where $l$ is the number of keywords. Although $l$ is small, the algorithm's performance still depends on the scale of $G$. As graph scale increases, efficiency is still a challenging issue. The derived summary graph is smaller than the original data graph, but the size of summary graph still subjects to the \emph{structuredness} of data graph. Open-domain RDF datasets usually have complicated class hierarchy and heterogeneous relations, which lead to a high variance in their structuredness. Obviously, an ideal algorithm on large graph requires that its time complexity does not depend on the underlying data graph size. This is another motivation of our solution. 

There are some work based on the ``supervised learning'' technique to interpret the query intention of keywords into structured queries \cite{pound2012interpreting}. They require manually annotated query logs to train a semantic term classifier and interpreting templates offline. We believe that it is quite expensive (even impossible) to employ human efforts to annotate comprehensive training data when coping with large RDF datasets. 

NL-QA \cite{unger2012template,yahya2012natural,zou2014natural} is another related area. The difference is that NL-QA system takes NL sentences rather than keywords as input. As mentioned in Section \ref{sec:introduction}, keywords do not have syntax structure, so that we can not derive query graph structures from dependency trees \cite{de2008stanford} like \cite{yahya2012natural,zou2014natural}. Even so, our system is still competitive (ranked at top-3) with other NL-QA systems in the QALD-6 competition. 