\section{Introduction} \label{sec:introduction}

RDF data is enjoying an increasing popularity as information extraction and archiving techniques advance. Many efforts such as DBpedia \cite{lehmann2015dbpedia} and Freebase \cite{bollacker2008freebase} have produced large scale RDF repositories. The use of RDF data has further gained popularity due to the launching of ``knowledge graph'' by Google and Linked Open Data project by W3C. One of fundamental issues in RDF data management is how to help end users obtain the desired information conveniently from RDF repositories, which has become a challenging problem and attracted lots of attentions in the database community . Although SPARQL is a standard query language to access RDF data, it is impractical for ordinary users to write SPARQL statements due to the complexity of SPARQL syntax and the lack of priori knowledge of RDF datasets.
%\cite{jagadish2007making, pound2012interpreting,zou2014natural}
Therefore, some efforts have been made to provide easy-to-use interfaces for non-professional users, such as natural language question answering (NL-QA for short) \cite{unger2012template,yahya2012natural,zou2014natural} and keyword search \cite{tran2009top,pound2012interpreting,le2014scalable} over RDF datasets. Ideally, the interfaces take natural language (NL) sentences (e.g. ``which scientist graduate from a university located in USA?'') or keyword queries(e.g. ``scientist graduate from university locate USA'') as end user's input, and retrieve relevant answers. Compared to NL sentences, keywords are more concise and flexible. A complete NL sentence can provide more semantic information than keywords through its syntactic structure. For example, \cite{yahya2012natural,zou2014natural} derive query graph structure by syntactic rules on dependency trees \cite{de2008stanford}, which is unavailable for keywords. Hence keyword search brings more technical challenges, such as disambiguation and query intention understanding. Due to the proliferation of Web search engines, the keyword based information retrieval mechanism enjoys widespread usage, especially in ``search box'' based applications. Therefore, this paper focuses on keyword search over RDF graphs. There are two technical challenges that should be addressed for a desirable keyword search system.  

\textbf{Effectiveness: understanding the query intention \emph{accurately}}. Although keywords are concise and flexible for end users, it is not an easy task for a system to understand the query intention behind that. Generally, there are two obstacles. First, it is the ambiguity of keywords. Given a keyword, we may have multiple ways to interpret the keyword. A system should figure out which interpretation is correct given the context of the keywords. The second obstacle is the ambiguity of query structures. Even if each keyword has been correctly interpreted, how to represent the whole query's intention is also a challenging task.
%It's like that when studying a foreign language, we know each word's meaning but we cannot understand the whole sentence.
A desirable representation of query intention is to interpret the input keywords as a structural query (such as SPARQL) that can be evaluated over the underlying RDF dataset to retrieve the answers that are of interests to users. Therefore, we aim to design an effective interpreting mechanism to translate the input keywords into SPARQL statements.  
	
\textbf{Efficiency: scaling to large graphs \emph{efficiently}}. RDF datasets tend to be very large. For example, Freebase contains about 1.9 billion triples and DBpedia has more than 583 million triples (in our experiments). As an online application over RDF graphs, the keyword search system's efficiency is another criteria. The system's performance consists of two parts: one is to translate the input keywords as SPARQL statements and the other is to evaluate SPARQL. Note that the latter is not the focus of this paper, as it has been studied extensively \cite{zou2014gstore,shi16fast}. We concentrate on building an efficient keyword interpreting mechanism.  

\subsection{Our approach}
To address the effectiveness and efficiency challenges discussed above, we propose a \emph{query graph assembly} (QGA for short) problem to model the keyword search task in this paper. In brief, we firstly match each keyword term into a group of elementary \emph{query graph element} candidates (i.e. entity/class vertices and predicate edges), then assemble these graph elements into a query graph $Q$, which can express users' query intention accurately. 

For the effectiveness issue, our QGA solution integrates the keyword disambiguation and query graph generation into a uniform model (i.e., the Assembly Bipartite Graph model in Definition \ref{def:assemblygraph}) under a single objective function. The uniform model overcomes the error propagation in the separated solution (such as first disambiguating the input keywords and then determining the query structure). 

For the efficiency issue, it is worth noting that the complexity of the QGA problem is \emph{irrelevant to the underlying data graph size}. Although QGA is intractable (we prove the NP-completeness of QGA in Section \ref{sec:hardness}), we figure out the overall search space only depends on the number of keyword terms $l$ and a tunable parameter $k$, i.e., the maximum number of candidate entity/class vertices and predicate edges allowed to match each keyword term. Both $l$ and $k$ are small in practice. Consequently, the time complexity is independent to the scale of RDF graph $G$, which theoretically explains why our approach is much faster than the comparative work over large RDF graphs.
%(see the experimental results in Section \ref{sec:exp}).
%To solve QGA problem, we treat QGA as a constraint-based bipartite graph matching problem. By designing some effective lower bounds, we propose a practical efficient best-first search algorithm with bound-based pruning techniques.

In a nutshell, our contributions are summarized as follows:

\begin{enumerate}
	\item We formulate the keyword search task as a \emph{query graph assembly} problem, and integrate the keyword disambiguation and query graph formulation into a uniform model. It achieves higher accuracy than the widely adopted small-size connected structure criteria, such as the group Steiner tree. 	
	\item We theoretically prove that QGA is NP-complete. To solve that, we propose a constraint-based bipartite graph matching solution, which is a practical efficient algorithm with bound-based pruning techniques. 
	\item We employ graph embedding technique to measure the goodness of query graph $Q$.
%	To our best knowledge, no prior work applies graph embedding model for keyword search tasks.
	\item We conduct extensive experiments on real RDF graphs
%	(DBpedia with 162M triples and Freebase with 596M triples)
	to confirm the the effectiveness and efficiency of our approach.
\end{enumerate}



