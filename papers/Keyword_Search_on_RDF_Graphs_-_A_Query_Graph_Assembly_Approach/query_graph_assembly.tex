\section{QGA: Hardness and Algorithm}
\label{sec:querygraphassembling}
Unfortunately, QGA is proved to be NP-complete in Section \ref{sec:hardness}. To solve that, we transform QGA into a constrained bipartite graph matching problem and design a practical efficient algorithm to find the optimal $Q$.  

\subsection{Hardness Analysis}\label{sec:hardness}

\begin{theorem}
	The query graph assembly problem is NP-complete.
\end{theorem}

\vspace{-0.1in}
\begin{proof}
	The decision version of QGA is defined as follows: 
	Given $n$ vertex sets $\Upsilon=\{V_1, ..., V_n\}$ and $m$ edge sets $\Gamma=\{E_1, ..., E_m\}$ and a threshold $\theta$, QGA is to decide if there exists an assembly query graph $Q$, where it satisfies the two constraints in Definition \ref{def:querygraphassembling} and the total assembly cost $cost(Q) \leq \theta$. Obviously, an instance of QGA can be verified in polynomial time. Thus, QGA belongs to NP class. 

	We construct a polynomial time reduction from 3-SAT (a classical NP-complete problem) to QGA. More specifically, given any instance $I$ of 3-SAT, we can generate an instance $I^{\prime}$ of QGA within polynomial time, where the decision value (TRUE/FALSE) of $I$ is \emph{equivalent} to $I^{\prime}$.
	
	\textbf{\emph{Any instance $I$ of 3-SAT:}}
	Without loss of generality, we define an instance $I$ of 3-SAT as follows: Given a set of $p$ boolean variables $U=\{u_1,u_2,...,u_p\}$ and a set of $q$ 3-clauses $C=\{c_1,c_2,...,c_q\}$ on $U$, The problem is to decide whether there exists a truth assignment for each variable in $U$ that satisfies all clauses in $C$.
	
	\textbf{\emph{Corresponding instance $I^{\prime}$ of QGA:}}
	Given a variable set $U$ and a 3-clause set $C$ (of instance $I$), we build a group of vertex sets $\Upsilon$ and a group of edge sets $\Gamma$ for the instance $I^{\prime}$.  $\Upsilon$ consists of the two parts $\Upsilon_{U}$ and $\Upsilon_{C}$, which are defined as follows:
	
	\begin{enumerate}
	\item For each variable $u_i \in U$, we introduce a vertex set $\{u_i,\overline{u_i}\}$ into $\Upsilon_{U}$. We call $u_i$ and $\overline{u_i}$ as \emph{variable vertices} of $I^{\prime}$. 
	\item For each 3-clause $c_j \in C$, we introduce a vertex set having a single vertex $\{c_j\}$ into $\Upsilon_{C}$. We call $c_j$ as a \emph{clause vertex} of $I^{\prime}$.  
	\end{enumerate}
	where $\Upsilon=\Upsilon_{U} \cup \Upsilon_{C}$.

	We also introduce $q$ disengaged edges into $\Gamma$. Each edge is a singleton set $\{e_j\}$. These $q$ edges can be used to connect any two vertices in $\Upsilon$. We set edge weight $w(e_j)=0$ if and only if $e_j$ connects the clause vertex $c_j$ and a member variable vertex $u_i$ (or $\overline{u_i}$) in 3-clause $c_j$. Otherwise, the edge weights are 1.
	
	The corresponding instance $I^{\prime}$ is defined as follows: Given two groups $\Upsilon$ and $\Gamma$ (explained above), and a threshold $\theta=0$, the problem is to decide whether there exists a graph $Q$, satisfying the two constraints in Definition \ref{def:querygraphassembling}, and $cost(Q)\leq 0$. Since edge weights are no less than 0, hence our goal is to construct $Q$ with $cost(Q)=0$.
	
	\textbf{\emph{Equivalence:}}
	Next, we will show the equivalence between the instance $I$ (of 3-SAT) and the instance $I^{\prime}$ (of QGA), i.e., $I \Leftrightarrow I^{\prime}$.

	Assume that the answer to $I$ is TRUE, which means that we have a truth assignment for each variable $u_i$ so that all 3-clauses $c_j$ are satisfied. According to the truth assignment in $I$, we can construct a graph $Q$ of $I^{\prime}$ as follows: for each clause vertex $c_j$, we connect $c_j$ with variable vertex $u_i$ (or $\overline{u_i}$) if $u_i=1$ (or $\overline{u_i}=1$, i.e, $u_i=0$) and $u_i$ is included in the 3-clause $c_j$. There may exist multiple variable vertices $u_i$  (or $\overline{u_i}$) satisfying the above condition. We connect $c_j$ with arbitrary one of them to form edge $(c_j,u_i)$ (or $(c_j,\overline{u_i})$).
	These edge weights are 0. 
	%	These edge weights are 0, as shown in Figure \ref{fig:3satproof}.
	Thus, we construct a graph $Q$ satisfying the two constraints in Definition \ref{def:querygraphassembling} and $cost(Q)=0$.	It means the answer to $I^{\prime}$ is TRUE, i.e., $I \Rightarrow I^{\prime}$.
	
	Assume the answer to $I^{\prime}$ is TRUE. It means that we can construct a graph $Q$ having the following characters:
	\begin{enumerate}
		\item For $i=1,...,p$, one of variable vertex $\{u_i, \overline{u_i}\}$ is selected; and for $j=1,...,q$, clause vertex $c_j$ is selected; \emph{/*one vertex of each vertex set in $\Upsilon$ is selected*/}
		\item For $j=1,...,q$, each edge $e_j$ is selected; and $e_j$ connects the clause vertex $c_j$ and a variable vertex $u_i$(or $\overline{u_i}$) that corresponds to one of the three member variables of 3-clause $c_j$.  \emph{/*one edge of each edge set in $\Gamma$ is selected, and $cost(Q)=0$*/}
	\end{enumerate} 
	If a variable vertex $u_i$ (or $\overline{u_i}$) is selected, we set $u_i=1$ (or $\overline{u_i}=1$, i.e., $u_i=0$).  
	Since each clause vertex $c_j$ is connected to one selected variable vertex $u_i$ (or $\overline{u_i}$) that is in the 3-clause $c_j$, the corresponding variable $u_i=1$ (or $\overline{u_i}=1$). It means that 3-clause $c_j=1$ as $u_i$ (or $\overline{u_i}$) is included in $c_j$.  Hence, the answer to $I$ is also TRUE, i.e., $I \Leftarrow I^{\prime}$.
	
	In summary, we have reduced 3-SAT to QGA, where the former is a NP-complete problem. Therefore, we have proved that QGA is NP-complete. 

%	\vspace{-0.1in}
%	\textbf{\emph{Reduction Process:}}
%	We construct a polynomial time reduction from 3-SAT (a classical NP-complete problem) to QGA. Let us recall the 3-SAT problem. Given a set of $p$ boolean variables $U=\{u_1,u_2,...,u_p\}$ and a set of $q$ 3-clauses $C=\{c_1,c_2,...,c_q\}$ on $U$, 3-SAT is to decide whether there exists a truth assignment for each variable in $U$ that satisfies all clauses in $C$.
%%	For example, given $U=\{u_1,u_2,u_3,u_4\}$ and $C=\{c_1=u_1  \vee \overline {u_2 }  \vee u_4, c_2= u_2  \vee \overline {u_3 }  \vee \overline {u_4 } \}$, there exists an assignment $\{u_1=1;u_2=1;u_3=0;u_4=1\}$ that satisfies all 3-clauses $c_1$ and $c_2$ in $C$. 
%	
%	 Given a variable set $U$ and a 3-clause set $C$, we build a group of vertex sets $\Upsilon$ and a group of edge sets $\Gamma$ for the QGA problem.  $\Upsilon$ consists of the two parts $\Upsilon_{U}$ and $\Upsilon_{C}$, which are defined as follows:
%	
%	\begin{enumerate}
%		\item For each variable $u_i \in U$, we introduce a vertex set $\{u_i,\overline{u_i}\}$ into $\Upsilon_{U}$. In QGA, we call $u_i$ and $\overline{u_i}$ as \emph{variable vertices}. 
%		\item For each 3-clause $c_j \in C$, we introduce a vertex set having a single vertex $\{c_j\}$ into $\Upsilon_{C}$. In QGA, we call $c_j$ as a \emph{clause vertex}.  
%	\end{enumerate}
%	where $\Upsilon=\Upsilon_{U} \cup \Upsilon_{C}$.
%	
%	Assume that there are $q$ 3-clauses $c_j$ ($j=1,...,q$) in the 3-SAT problem. We introduce $q$ edges into $\Gamma$. Each edge is a singleton set $\{e_j\}$. These $q$ edges can be used to connect any two vertices in $\Upsilon$. We set edge weight $w(e_j)=0$ if and only if $e_j$ connects the clause vertex $c_j$ and a member variable vertex $u_i$ (or $\overline{u_i}$) in 3-clause $c_j$. Otherwise, the edge weights are 1.
%%	For example, there are two 3-clauses $c_1=u_1  \vee \overline {u_2}  \vee u_4 $ and $c_2= u_2  \vee \overline {u_3}  \vee \overline {u_4}$. Only when the edge $e_1$ connects $c_1$ with $u_1$, $\overline {u_2}$ and  $u_4$, and the edge $e_2$ connects $c_2$ with $u_2$, $\overline{u_3}$ and $\overline{u_4}$, the edge weights are 0. Other connections' edge weights are 1. Figure \ref{fig:3satproof} illustrates that. 
%	
%	The reduced QGA instance is described as follows: Given two groups $\Upsilon$ and $\Gamma$ (defined above), and a threshold $\theta=0$, the problem is to decide whether there exists a graph $Q$, which satisfies the two constraints in Definition \ref{def:querygraphassembling}, and $cost(Q)\leq 0$. Since edge weights are no less than 0, thus, our goal is to construct $Q$ with $cost(Q)=0$.
%	
%	Let us prove that the decision of QGA is equivalent to that over 3-SAT. Assume that the answer to QGA is TRUE. It means that we can construct a graph $Q$ having the following characters:
%	\begin{enumerate}
%		\item For $i=1,..,p$, one of variable vertex $\{u_i, \overline{u_i}\}$ is selected;  and for $j=1,...,q$, clause vertex $c_j$ is selected; \emph{/*one vertex of each vertex set in $\Upsilon$ is selected*/}
%		\item For $j=1,...,q$, each edge $e_j$ is selected; and $e_j$ connects the clause vertex $c_j$ and a variable vertex $u_i$(or $\overline{u_i}$) that corresponds to one of the three member variables of 3-clause $c_j$.  \emph{/*one edge of each edge set in $\Gamma$ is selected, and $cost(Q)=0$*/}
%	\end{enumerate} 
%	If a variable vertex $u_i$ (or $\overline{u_i}$) is selected, we set $u_i=1$ (or $\overline{u_i}=1$, i.e., $u_i=0$).  
%	Since each clause vertex $c_j$ is connected to one selected variable vertex $u_i$ (or $\overline{u_i}$) that is in the 3-clause $c_j$, the corresponding variable $u_i=1$ (or $\overline{u_i}=1$). It means that 3-clause $c_j=1$ as $u_i$ (or $\overline{u_i}$) is included in $c_j$.  Therefore, we prove that if the answer to QGA is TRUE then the answer to 3-SAT is also TRUE. 
%	
%%	For example, given two 3-clauses $c_1=u_1  \vee \overline {u_2}  \vee u_4 $ and $c_2= u_2  \vee \overline {u_3}  \vee \overline {u_4}$, we build six vertex sets in Figure \ref{fig:3satproof}. The upper four sets correspond to the variable vertices and the lower two are the clause vertices. Since there are two 3-clauses, we introduce two singleton edge sets in the assembly query graph. Only the solid edges' weight are 0. Assume that we find a QGA solution whose $cost(Q)=0$ (i.e, the answer to QGA is TRUE), as depicted by the red bold solid lines, i.e., the edge connecting $c_1$ and ${u_1}$ and the one connecting $c_2$ and $\overline{u_3}$. Thus, we set variable $u_1=1$ and $\overline{u_3}=1$ (i.e., $u_3=0$). This is a truth assignment satisfying both $c_1$ and $c_2$ no matter what assignment of other variables. It means that it is also true to the 3-SAT instance if we find a solution to the QGA instance. 
%	
%	Let us prove that the answer to 3-SAT is FALSE if the answer to the QGA is FLASE. For the ease of the proof, we prove the corresponding converse negative proposition, i.e, the answer to QGA is TRUE if the answer to 3-SAT is TRUE.  
%	
%	Assume that the answer to 3-SAT is TRUE, which means that we have a truth assignment for each variable $u_i$ so that all 3-clauses $c_j$ are satisfied. According to the truth assignment in 3-SAT, we can construct a graph $Q$ as follows: for each clause vertex $c_j$ in QGA, we connect $c_j$ with variable vertex $u_i$ (or $\overline{u_i}$) if $u_i=1$ (or $\overline{u_i}=1$, i.e, $u_i=0$) and $u_i$ is included in the 3-clause $c_j$. There may exist multiple variable vertices $u_i$  (or $\overline{u_i}$) satisfying the above condition. We connect $c_j$ with one of these variable vertices $u_i$  (or $\overline{u_i}$) to form edge $(c_j,u_i)$ (or $(c_j,\overline{u_i})$).
%	These edge weights are 0. 
%%	These edge weights are 0, as shown in Figure \ref{fig:3satproof}.
%	Thus, we construct a graph $Q$ satisfying the two constraints in Definition \ref{def:querygraphassembling} and $cost(Q)=0$.	
%	
%%	\begin{figure} [h]
%%		\centering
%%		\scalebox{0.80} [0.80]
%%		{
%%			\resizebox{\linewidth}{!}
%%			{
%%				\includegraphics[scale=1.0]{visio_pics/qga_3sat_reduce.pdf}
%%			}
%%		}
%%		\caption{Visualizing the Reduction Process.}
%%		\label{fig:3satproof}
%%		%\vspace{-0.1in}
%%	\end{figure}
%
%	In summary, we have reduced 3-SAT to QGA, while the former is a classical NP-complete problem. Therefore, we have proved that QGA is NP-complete. 
\end{proof}


%\subsection{Algorithm} \label{sec:algorithm}
%Since QGA problem is NP-complete, we aim to design a practical efficient algorithm that can return the exact result. A brute force idea is to enumerate all the possible assembly combinations of the candidate vertices $\Gamma$ and edges $\Upsilon$, check whether each of the combinations is a valid query graph $Q$, and calculate its $cost(Q)$. Then we find the valid $Q$ with minimum $cost(Q)$, as the final result. Suppose $AQ$ consists of $n$ entity/class terms and $m$ relation terms, and each term is matched to at most $k$ candidate vertices (or predicate edges). Then the overall enumeration space is $\left( \begin{array}{l}  n \\  2 \\  \end{array} \right)^m \cdot k^{m+n}$. It is hard to design pruning conditions for such a brute force strategy to reduce its search space. But fortunately, we can transform the QGA problem into a constrained bipartite graph model, then propose a best-first search algorithm with some powerful pruning techniques. We elaborate the model and the algorithm in the following subsections. 


\subsection{Assembly Bipartite Graph Model} \label{sec:general_case}
Since QGA is NP-complete, we transform it to an equivalent bipartite graph model with some constraints. Based on the bipartite graph model, we can design a best-first search algorithm with powerful pruning strategies.

Let us recall the definition of QGA (Definition \ref{def:querygraphassembling}), each of the $n$ entity/class terms is matched to a candidate vertex set $V_i$, and each of the $m$ relation terms is matched to a candidate edge set $E_j$. For example, ``USA'' is matched to $\{$res:USA$\_$Today, res:United$\_$States$\}$, and ``graduate from'' is matched to $\{$dbo:almaMater, dbo:education$\}$. The multiple choices in a candidate vertex/edge set indicate the ambiguity of keywords. If we adopt a pipeline style mechanism to address the keyword disambiguation and the query graph generation separately, we need to select exactly one element from each candidate vertex/edge set in the first phase. In our example, res:United$\_$States is the correct interpretation of ``USA'', and dbo:almaMater should be selected for ``graduate from''. If we simply adopt the string-based matching score \cite{li2011faerie} for keyword disambiguation, the matching score of res:USA$\_$Today may be higher than res:United$\_$States. In this case, if we only select the one with highest matching score, the correct answer will be missed due to the entity linking error. However, a robust solution should be error-tolerant with the ability to construct a correct query graph that is of interest to users even in the presence of noises and errors in the first phase. In our QGA solution, we allow the ambiguity of keywords (i.e., allowing one term matching several candidates) in the first phase, and push down the disambiguation to the query graph assembly step. For example, although the matching score of ``USA'' to res:USA$\_$Today is higher than that to res:United$\_$States, the former's assembly cost is much larger than the latter. Thus, we can still obtain the correct query graph $Q$. We propose the \emph{assembly bipartite graph matching} model to handle the ambiguity of keywords and the ambiguity of query graph structures uniformly. 

\begin{definition}\textbf{ (Assembly Bipartite Graph) }. \label{def:assemblygraph}
	Each entity/class term $t_i^{v}$ corresponds to a set $V_i$ of vertices ($1\leq i \leq n$) and each relation term $t_j^{e}$ corresponds to a set $E_j$ of predicate edges ($1\leq j \leq m$).  
	
	An assembly bipartite graph $\mathbb{B}(V_{L},V_{R},E_{\mathbb{B}})$ is defined as follows:
	
	\begin{enumerate}
		\item Vertex pair set $V_{i_1} \times V_{i_2}=\{(v_{i_1},v_{i_2}) | 1\leq i_1 < i_2 \leq n \wedge v_{i_1} \in V_{i_1}  \wedge v_{i_2} \in V_{i_2}\}$.
		\item $V_{L}=\bigcup\nolimits_{1 \le i_1  < i_2  \le n } {(V_{i_1} \times V_{i_2})} $.
		%\item Edge set $Y_{j}=\{p_j | \alpha+1 \leq j \leq n \wedge p_j \in E_{j}  \}$.
		\item  $V_{R}=\bigcup\nolimits_{1 \le j \le m} {E_j }  $.
		\item there is a crossing edge $e$ between any node $(v_{i_1}, v_{i_2})$ in $V_{L}$ and any node $p_j$ in $V_{R}$ ($1 \le i_1  < i_2  \le n$, $1 \le j \le m$), which is denoted as $e(\langle v_{i_1},v_{i_2}\rangle, p_j)$. Edge weight $w(e)=w(\langle v_{i_1},v_{i_2}\rangle, p_j)$, where $w(\langle v_{i_1},v_{i_2}\rangle, p_j)$ denotes the triple assembly cost.  
	\end{enumerate} 
\end{definition}


\begin{figure} [t]
	\begin{center}
		\vspace{-0.15in}
		\includegraphics[scale=0.55]{visio_pics/assembly_bipartite_graph.pdf}
		%\vspace{-0.1in}
		\caption{An Example of Assembly Bipartite Graph.}
		
		\label{fig:asm_bigraph}
		\vspace{-0.15in}
	\end{center}
\end{figure}

\begin{example} 
Let us recall the running example. Each term's candidate matchings are given in Figure \ref{fig:graph_elements_exp2}, i.e., $V_1=\{$dbo:Scientist$\}$, $V_2=\{$dbo:University$\}$, and $V_3=\{$res:United\_Today, res:United\_States$\}$. Thus, there are three vertex pair sets $V_1 \times V_2$, $V_2 \times V_3$ and $V_1 \times V_3$. In Figure \ref{fig:asm_bigraph}, each vertex pair set is highlighted by a dash circle. There are two predicate edge sets $E_1=\{$dbo:almaMater, dbo:education$\}$ and $E_2=\{$dbo:country, dbo:location$\}$, which are also illustrated in Figure \ref{fig:asm_bigraph} using dash circles. 
\end{example}

It is worth noting that there are some \emph{conflict} relations among the crossing edges in $\mathbb{B}$.  For example, crossing edge $e(\langle$dbo:Scientist, res:USA\_Today$\rangle$, dbo:country) conflicts with $e^{\prime}(\langle$dbo:University, res:United\_States$\rangle$, dbo:almaMater) (in Figure \ref{fig:asm_bigraph}), since the semantic term ``USA'' corresponds to two different entity vertices res:USA\_\\Today and res:United\_States in $e$ and $e^{\prime}$, respectively. In this case, the constraints of QGA (in Definition \ref{def:querygraphassembling}) will be violated if $e$ and $e^{\prime}$ occur in the same matching.
Considering the above example, we formulate the \emph{conflict relation} among crossing edges in $\mathbb{B}$. 

\begin{definition} \textbf{ (Conflict Relation) }.\label{def:conflict}	
	For any two crossing edges $e(\langle v_{i_1},v_{i_2}\rangle, p_j)$ and $e^{\prime}(\langle v_{i_1}^{\prime},v_{i_2}^{\prime}\rangle, p_j^{\prime})$ in an assembly bipartite graph $\mathbb{B}$, we say that $e$ is \emph{conflict} with $e^{\prime}$ if at least one of the following conditions holds:
	
	\begin{enumerate}
		\item $v_{i_1}$ and $v_{i_1}^{\prime}$ (or $v_{i_2}$ and $v_{i_2}^{\prime}$) come from the same vertex set $V_{i_1}$ (or $V_{i_2}$) and  $v_{i_1} \neq v_{i_1}^{\prime}$ (or $v_{i_2} \neq v_{i_2}^{\prime}$);		
		\ /*Two different vertices come from the same vertex set; an entity/class term $t_i^{v}$ cannot map to multiple vertices*/
		\item $p_j$ and $p_j^{\prime}$ come from the same edge set $E_j$ and $p_j \neq p_j^{\prime}$.		
		\ /*Two different predicates come from the same edge set; an relation term $t_j^{e}$ cannot map to multiple predicate edges*/
		\item $(v_{i_1}=v_{i_1}^{\prime} \wedge v_{i_2}=v_{i_2}^{\prime}) \vee (p_j = p_j^{\prime})$ 		
		%/*Two vertex pairs are the same with each other*/
		\ /*$e$ and $e^{\prime}$ share a common endpoint in $V_{L}$ or $V_{R}$; a vertex pair cannot be assigned two different predicate edges and a predicate edge cannot connect two different vertex pairs */
	\end{enumerate}
	
	
\end{definition}

In order to be consistent with the constraints of QGA, we also redefine \emph{matching} as follows.
\begin{definition}\textbf{ (Matching) }\label{def:matchingnew}. Given an assembly bipartite graph $\mathbb{B}(V_{L},V_{R},E_{\mathbb{B}})$, a \emph{matching} of $\mathbb{B}$ is a subset $M$ ($M \subseteq E_{\mathbb{B}}$) of its crossing edges, no two of which are \emph{conflict} with each other.
\end{definition}

\begin{definition}\textbf{ (Matching Cost) }. The \emph{matching cost} of $M$ is $w(M) = \sum\nolimits_{e \in M} {w(e)}$, where $w(e)$ is defined in Definition \ref{def:assemblygraph}(4). 
\end{definition}
It is easy to know that solving QGA problem is equivalent to finding a size-$m$ \emph{matching} over $\mathbb{B}$ with the minimum \emph{matching cost}. A matching edge in $\mathbb{B}$ stands for an assembled edge in $Q$.
%From the assembly bipartite graph model, we design some lower bounds for computing the matching cost, based on which, we propose a best-first search algorithm to find the optimal solution in the following subsection. 

%\vspace{-0.1in}
\subsection{Condensed Bipartite Graph}

\begin{figure} [t]
	\begin{center}
		%\vspace{-0.15in}
		\includegraphics[scale=0.65]{visio_pics/condensed_bipartite_graph.pdf}
		%\vspace{-0.1in}
		\caption{An Example of Condensed Bipartite Graph.}
		\label{fig:con_bigraph}
		   \vspace{-0.2in}
	\end{center}
\end{figure}


According to the condition (2) and (3) in Definition \ref{def:conflict}, each predicate edge set $E_j$ has only one $p_j$ occurring in the \emph{matching} $M$. Thus, we can condense each predicate edge set into one node $E_j$, leading to a \emph{condensed bipartite graph} $\mathbb{B}^{*}(V_{L}^*,V_{R}^*,E_{\mathbb{B}}^*)$, as shown in Figure \ref{fig:con_bigraph}. There is a crossing edge between any node $(v_{i_1},v_{i_2})$ in $V_{L}^*$ and any node $E_j$ in $V_{R}^*$. The edge weight is defined as $w(e) = w(\langle v_{i_1} ,v_{i_2}\rangle ,E_j ) = MIN_{p_j  \in E_j } \{ w(\langle v_{i_1} ,v_{i_2}\rangle,p_j)\}$, where $w(\langle v_{i_1 } ,v_{i_2}\rangle,p_j)$ is defined in Definition \ref{def:assemblygraph}(4). In order to find the size-$m$ matching with the minimum cost in $\mathbb{B}^{*}$, we propose QGA Algorithm (i.e., Algorithm \ref{alg:bfmatch}). 


\subsection{QGA Algorithm}

A search state is denoted as $\{M,Z, cost(M), LB(M)\}$, where $M$ records the current partial matching, i.e., a set of currently selected matching edges, $Z$ records a set of unmatched edges that are not \emph{conflict} with edges in $M$. Obviously, each edge $e \in Z$ can be appended to $M$ to enlarge the current matching. Initially, $M=\phi$, and $Z$ records all crossing edges in the condensed bipartite graph $\mathbb{B}^{*}$ (Line 3 in Algorithm \ref{alg:bfmatch}). $cost(M)$ denotes the current partial matching cost, i.e., $cost(M)= \sum\nolimits_{e \in M} {w(e)}$. $LB(M)$ denotes the lower bound of the current partial matching $M$. We will discuss how to compute the lower bound $LB(M)$ later. All search states are stored in a priority queue $H$ in the non-decreasing order of the lower bound $LB(M)$ (Line 2). Furthermore, we maintain a threshold $\theta$ to be the current minimum matching cost. Initially, $\theta = \infty$. In each iteration, we pop a head state $\{M,Z, cost(M), LB(M)\}$.
We enumerate all unmatched edges $e \in Z$ in non-decreasing order of $w(e)$ to generate subsequent search states. Each $e \in Z$ is moved from $Z$ to $M$ to obtain a new matching $M^{\prime}$ (Line 9). We remove $e$ and all edges in $Z$ that are conflict with $e$ to obtain $Z^{\prime}$ (Line 10). We also update $cost(M^{\prime})$ and $LB(M^{\prime})$ (Lines 11-12). Then we check whether $M^{\prime}$ is a size-$m$ matching over $\mathbb{B}^{*}$(i.e. end state). If so, we update the threshold $\theta$ if $cost(M^{\prime}) < \theta$ and record $M^{\prime}$ as the current optimal matching $M_{opt}$  (Lines 13-16). Otherwise, we push the new state $\{M^{\prime},Z^{\prime}, cost(M^{\prime}), LB(M^{\prime})\}$ into $H$ (Line 18). The algorithm keeps iterating until that the threshold $\theta$ is less than the lower bound of the current head state in $H$ (Line 6) or $H$ is empty. 
\begin{algorithm} 
	\caption{QGA Algorithm} \label{alg:bfmatch}
	\KwIn{Condensed bipartite graph $B^*(V_{L}^*, V_{R}^*, E_B^*)$,
		and conflict relations among $E_B^*$.}
	\KwOut{The optimal assembly query graph $Q$.}
	$M_{opt} := \phi$, $\theta := \infty$ \;
	$H := \phi$ ;\tcp{min-heap, sort by lower bound}
	$H \leftarrow \{M:=\emptyset, Z := E_B^*, cost(M) := 0, LB(M) := 0\}$ \;
	\While{$H$ is not empty}
	{
		$\{M, Z, cost(M), LB(M)\} \leftarrow H.pop$ \;
		\If{$LB(M) >= \theta$}{\textbf{break} \;}
		
		\For{each crossing edge $e \in Z$}
		{
			$M^{\prime} := M \cup \{e\}$; $Z := Z \setminus \{e\}$ \;
			$Z^{\prime} = Z \setminus \{e^\prime | e^\prime \in Z \wedge e^\prime\ conflict\ with\ e\}$ \;
			$cost(M^{\prime}) := cost(M) + w(e)$ \;
			Compute $LB(M^{\prime})$\;
			
			\If{$|M^{\prime}| = m$}
			{
				\If{$cost(M^{\prime}) < \theta$}
				{
					$\theta := cost(M^{\prime})$ \;
					$M_{opt} := M'$ \;
				}       
			}
			\Else
			{
				$H \leftarrow \{M', Z', cost(M^{\prime}), LB(M^{\prime})\}$ \;
			}       
		}
	}
	Build query graph $Q$ according to $M_{opt}$ \;
	\Return $Q$
\end{algorithm}

\vspace{-0.1in}
\subsection{Computing Lower Bound} \label{sec:lower_bound}
Considering a search state $\{M, Z, cost(M), LB(M)\}$, we discuss how to compute $LB(M)$. Let $|M|$ denote the number of edges in the current matching. Since a maximum matching in $B^{*}$ should contain $m$ matching edges (i.e., covering all $E_j$), we need to select the other $(m-|M|)$ no-conflict edges from $Z$, to form a size-$m$ matching. We denote  $\mathcal{M}(Z)$ as the minimum weighted size-$(m-|M|)$ matching of $Z$. Thus, the best result that can be reached from $M$ is $M \cup \mathcal{M}(Z)$. To ensure the correctness of Algorithm \ref{alg:bfmatch}, $LB(M) \le cost(M \cup \mathcal{M}(Z))$ must always be satisfied. A good lower bound should have the following two characters: (1)  $LB(M)$ is as close to $cost(M \cup \mathcal{M}(Z))$ as possible; (2) the computation cost of $LB(M)$ is small. From this intuition, we propose three different lower bounds as follows.

\Paragraph{Naive-LB:}
The naive method to compute $LB(M)$ is to select the top-$(m-|M|)$ unmatched edges $\{e_1,...,e_{m-|M|}\}$ in $Z$ with the minimum weights and compute $Navie$-$LB(M) = cost(M) + \sum\nolimits_{i = 1}^{i = m  - |M|} {w(e_i)}$. In the implementation of Algorithm \ref{alg:bfmatch}, $Z$ is stored by a linked list, and always kept in the non-decreasing order of $w(e)$. Therefore, the complexity of computing Naive-LB is $O(m-|M|)$. Since the top-$(m-|M|)$ unmatched edges in $Z$ may be conflict with each other, Naive-LB is not tight, and has the weakest pruning power comparing with the following two lower bounds.

\Paragraph{KM-LB:}
We ignore the conflict relations among unmatched edges in $Z$, and find the minimum weighted size-$(m-|M|)$ matching $\mathcal{M}_{KM}(Z)$ by KM Algorithm \cite{kuhn1955hungarian} in $O(|Z|^3)$ time. Then we compute $KM$-$LB(M)= cost(M) + cost(\mathcal{M}_{KM}(Z))$. KM-LB is much tighter than Naive-LB, but the computation cost is expensive.

\Paragraph{Greedy-LB:}
Inspired by the matching-based KM-LB, we propose a greedy strategy (Algorithm \ref{alg:greedy_lb}) to find an approximate matching of $Z$ in $O(|Z|)$ time. It has been proved in \cite{preis1999linear} that the result return by Algorithm \ref{alg:greedy_lb} (denote as $\mathcal{M}_{greedy}(Z)$) is a $1/2$-approximation of the optimal matching $\mathcal{M}_{KM}(Z)$. i.e. $cost(\mathcal{M}_{KM}(Z)) \ge \frac{cost(\mathcal{M}_{greedy}(Z))}{2}$. Thus we compute $Greedy$-$LB(M)= cost(M) + \frac{cost(\mathcal{M}_{greedy}(Z))}{2}$. Greedy-LB is considered as the trade-off between Naive-LB and KM-LB, because of its medium tightness and computation cost. Experiment in Section \ref{sec:evaluate_qga_bounds} confirms that Greedy-LB gains the best performance among them.

\begin{algorithm} [t]
	\caption{Greedy-LB Algorithm} \label{alg:greedy_lb}
	\KwIn{Unmatched edge set $Z$.}
	\KwOut{An $1/2$-approximate matching $\mathcal{M}_{greedy}$.}
	$\mathcal{M}_{greedy} := \phi$ \;
	\For{each $e \in Z$ in non-decreasing order of $w(e)$}
	{
		\If{$e$ do not share common vertices with $\mathcal{M}_{greedy}$}
		{
			$\mathcal{M}_{greedy} := \mathcal{M}_{greedy} \cup \{e\}$
		}
		\Return $\mathcal{M}_{greedy}$ \;
	}
\end{algorithm}

\vspace{-0.1in}
\subsection{Time Complexity Analysis} 
In a condensed bipartite graph $\mathbb{B}^{*}(V_{L}^*,V_{R}^*,E_{\mathbb{B}}^*)$, $|V_L^*| \le k^2 \cdot \left( \begin{array}{l}  n \\  2 \\  \end{array} \right)$, because there are $\left( \begin{array}{l}  n \\  2 \\  \end{array} \right)$ vertex pair set, each contains at most $k^2$ vertex pairs, and $V_R^*$ consists of $m$ condensed predicate nodes, i.e., $|V_R^*|=m$. Therefore, the total number of crossing edges is $|E_{\mathbb{B}}^*|=|V_R^*|\times|V_L^*| \le mk^2\left( \begin{array}{l}  n \\  2 \\  \end{array} \right) \le mn^2k^2$. Since a maximum matching in $\mathbb{B}^{*}$ should contain $m$ matching edges, we can find at most $\left( \begin{array}{l}  mn^2k^2 \\  \ \ \ m \\  \end{array} \right) \le (mn^2k^2)^m$ different maximum matchings. Since $n+m \le l$, by replacing $n$ and $m$ by $l$, we get the overall search space $O(k^{2l} \cdot l^{3l})$.


\subsection{Implicit Relation Prediction}
As we know, keywords are more flexible than NL question sentences. In some cases, users may omit some relation terms. For example, users may input ``scientist graduate from university USA'', where the keyword ``locate'' is omitted. In this case, for humans, it is trivial to infer that the user means ``an university located in USA''. Let us recall our QGA approach. If we omit ``locate'' in the running example, there is only one relation term. So, the query graph $Q$ cannot be connected if we use only one predicate edge to connect three vertices. We can patch our solution to connect $Q$ as follows.
%Suppose that the query graph $Q$ generated by QGA Algorithm has $r$ connected components $\mathcal{P}_1$, $\mathcal{P}_2$,...,$\mathcal{P}_r$. In order to connect them, we work as follows:

\begin{definition} \textbf{ (Relation Prediction Graph) }
	Suppose that $Q$ consists of $r$ connected components: $Q=\{\mathcal{P}_1, \mathcal{P}_2, ..., \mathcal{P}_r\}$. A relation prediction graph $P(V_P,E_P)$ is a complete graph and defined as follows:
	\begin{itemize}
		\item $V_P$ consists of $r$ vertices, where each vertex $v_P^i \in V_P$ corresponds to a connected component $\mathcal{P}_i$.
		\item $E_P$ consists of $\frac{r(r-1)}{2}$ labeled weighted edges. For any $(\mathcal{P}_i, \mathcal{P}_j)$, we find the minimum assembly cost triple $e(\langle v_i, v_j \rangle, p)$, where $v_i \in V(\mathcal{P}_i)$, $v_j \in V(\mathcal{P}_j)$, and $p \in \mathcal{U}$. Note that $V(\mathcal{P}_i)$ denotes all vertices in $P_i$, and $\mathcal{U}$ denotes all predicates in RDF graph $G$. Then we add a corresponding edge $e_P(v_P^i,v_P^j)$ into $E_P$, where the weight $w(e_P)=w(\langle v_i, v_j \rangle, p)$, and the label $l(e_P)=(\langle v_i, v_j \rangle, p)$.
	\end{itemize}
\end{definition}
Thus the relation prediction task is modeled as finding a minimum spanning tree $T$ on $P$, which can be solved in linear time. Through the label $(\langle v_i, v_j \rangle, p)$ of the tree edge in $T$, we can know that $v_i, v_j \in V_Q$ should be connected by the predicate edge $p$.


