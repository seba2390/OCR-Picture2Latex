% \input{shrd}
% \usepackage{xr}\externaldocument{supp}

\documentclass[10pt]{article}
\usepackage{times}
\renewcommand{\familydefault}{\rmdefault}
% \renewcommand{\familydefault}{\sfdefault}


%%% New math versions
\DeclareMathVersion{varnormal}
\DeclareMathVersion{varbold}
\newcommand\txmath{\mathversion{normal}}
\newcommand\txboldmath{\mathversion{bold}}
\newcommand\mdmath{\mathversion{varnormal}}
\newcommand\mdboldmath{\mathversion{varbold}}

%%% Math symbol fonts
%%% some examples only
% Math letters from txfonts and mdugm
\SetSymbolFont{letters}{normal}{OML}{txmi}{m}{it}
\SetSymbolFont{letters}{bold}{OML}{txmi}{bx}{it}
\SetSymbolFont{letters}{varnormal}{OML}{mdugm}{m}{it}
\SetSymbolFont{letters}{varbold}{OML}{mdugm}{b}{it}
% Math operators
\SetSymbolFont{operators}{normal}{OT1}{txr}{m}{n}
\SetSymbolFont{operators}{bold}{OT1}{txr}{bx}{n}
\SetSymbolFont{operators}{varnormal}{OT1}{mdugm}{m}{n}
\SetSymbolFont{operators}{varbold}{OT1}{mdugm}{b}{n}
% Math symbols
\SetSymbolFont{symbols}{normal}{OMS}{txsy}{m}{n}
\SetSymbolFont{symbols}{bold}{OMS}{txsy}{bx}{n}
\SetSymbolFont{symbols}{varnormal}{OMS}{mdugm}{m}{n}
\SetSymbolFont{symbols}{varbold}{OMS}{mdugm}{b}{n}
% Large symbols
\SetSymbolFont{largesymbols}{normal}{OMX}{txex}{m}{n}
\SetSymbolFont{largesymbols}{bold}{OMX}{txex}{bx}{n}
\SetSymbolFont{largesymbols}{varnormal}{OMX}{mdugm}{m}{n}
\SetSymbolFont{largesymbols}{varbold}{OMX}{mdugm}{b}{n}

%%% Math alphabets, at most 16 families
%%% some examples only
\SetMathAlphabet{\mathrm}{normal}{OT1}{txr}{m}{n}
\SetMathAlphabet{\mathrm}{bold}{OT1}{txr}{bx}{n}
\SetMathAlphabet{\mathrm}{varnormal}{OT1}{mdugm}{m}{n}
\SetMathAlphabet{\mathrm}{varbold}{OT1}{mdugm}{b}{n}

\SetMathAlphabet{\mathit}{normal}{OT1}{txr}{m}{it}
\SetMathAlphabet{\mathit}{bold}{OT1}{txr}{bx}{it}
\SetMathAlphabet{\mathit}{varnormal}{OT1}{mdugm}{m}{it}
\SetMathAlphabet{\mathit}{varbold}{OT1}{mdugm}{b}{it}


\usepackage{amsmath}
\usepackage{amsthm}\theoremstyle{plain}\newtheorem{remark}{Remark}
\usepackage{mathrsfs}
\usepackage{amssymb}
\usepackage{mathtools,algorithm}
\usepackage{setspace,algpseudocode}
\usepackage{program}
\usepackage{empheq}
\usepackage{subcaption}
\usepackage[paper=a4paper,top=36pt,left=100pt,right=100pt,bottom=50pt,foot=25pt]{geometry}
\usepackage{titlesec}
\usepackage{lineno}
\usepackage{hyperref}
\usepackage{nicefrac}
\usepackage{float}
% \usepackage{subfloat}
\usepackage{upgreek}
\usepackage[dvipsnames]{xcolor}
% \usepackage{graphicx,caption}
\usepackage[numbers,compress]{natbib}
% \usepackage{xr}\externaldocument{supp}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{mdframed}
\usepackage[T1]{fontenc}

% \allowdisplaybreaks


\titleformat{\section}{\normalfont\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont}{\thesubsection}{1em}{}
\titleformat{\subsubsection}{\normalfont\it}{\thesubsubsection}{1em}{}


\renewcommand\appendix{\par
  \setcounter{section}{0}
  \setcounter{subsection}{0}
  \setcounter{figure}{0}
  \setcounter{table}{0}
  \setcounter{equation}{0}
  \renewcommand\thesection{Appendix \Alph{section}}
  \renewcommand\thefigure{\Alph{section}\arabic{figure}}
  \renewcommand\thetable{\Alph{section}\arabic{table}}
  \renewcommand\theequation{\Alph{section}\arabic{equation}}  
}

\newcommand\supp{\par
  \setcounter{section}{0}
  \setcounter{subsection}{0}
  \setcounter{subsubsection}{0}
  \setcounter{figure}{0}
  \setcounter{table}{0}
  \setcounter{equation}{0}  
  \renewcommand\thesection{S\arabic{section}}
  \renewcommand\thefigure{S-\arabic{figure}}
  \renewcommand\thetable{S-\arabic{table}}
  \renewcommand\theequation{S-\arabic{equation}}  
}


\def\lm{\lambda}

\def\src{\text{src}}
\def\FEM{\text{FEM}}
\def\FDM{\text{FDM}}
\def\ppw{\text{ppw}}
\def\min{\text{min}}


% [2023/07/25]
% NOTE: Below are related to the listing environment for presenting code (and algorithms).

\definecolor{cmtcolor}{RGB}{128,128,128}
\definecolor{kwdcolor}{RGB}{180,20,128}
\definecolor{strcolor}{RGB}{0,120,80}

\lstset{breakatwhitespace,
language=C++,
columns=fullflexible,
keepspaces,
breaklines,
tabsize=4, 
showstringspaces=false,
extendedchars=true,
numbers=left,
numberstyle=\tiny,
numbersep=4pt,
%
directivestyle=\color{cyan},
backgroundcolor=\color{white},   % choose the background color
basicstyle=\footnotesize,        % size of fonts used for the code
breaklines=true,                 % automatic line breaking only at whitespace
captionpos=b,                    % sets the caption-position to bottom
commentstyle=\color{cmtcolor},   % comment style
escapechar={`},                  % between two ` are escaped to LaTeX
% escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
keywordstyle=\color{kwdcolor},   % keyword style
stringstyle=\color{strcolor},    % string literal style
}


% \definecolor{nmbcolor}{RGB}{0,120,80} % same as strcolor
\newcommand\digitstyle{\color{kwdcolor2}}
\makeatletter
\newcommand{\ProcessDigit}[1]
{%
  \ifnum\lst@mode=\lst@Pmode\relax%
   {\digitstyle #1}%
  \else
    #1%
  \fi
}
% \makeatother
% \lstset{literate=
%     {0}{{{\ProcessDigit{0}}}}1
%     {1}{{{\ProcessDigit{1}}}}1
%     {2}{{{\ProcessDigit{2}}}}1
%     {3}{{{\ProcessDigit{3}}}}1
%     {4}{{{\ProcessDigit{4}}}}1
%     {5}{{{\ProcessDigit{5}}}}1
%     {6}{{{\ProcessDigit{6}}}}1
%     {7}{{{\ProcessDigit{7}}}}1
%     {8}{{{\ProcessDigit{8}}}}1
%     {9}{{{\ProcessDigit{9}}}}1
%     {<=}{{\(\leq\)}}1,
%     morestring=[b]",
%     morestring=[b]',
%     morecomment=[l]//,
% }


\definecolor{kwdcolor2}{RGB}{20,70,180}
\lstset{
emph={MPI_Sendrecv, main, MPI_Barrier, MPI_Finalize, assert, cudaFree, allocate_memory}, 
emphstyle={\color{kwdcolor2}}
}
% [2023/05/06]
% NOTE: The above defines the color for function names; 
%       class names are left uncolored.


\definecolor{hltcolor}{RGB}{235,120,60}
% [2023/05/06]
% NOTE: Color used for highlighting escaped LaTex text.


\def\ttt#1;{\texttt{#1}} % we can type "\ttt fast;", with `;` delimit the end of the element to be styled

\newcommand{\folderPath}{\string"/dev/null\string"}

\title{\large Compensated sum and delayed update for time dependent wave simulations at half precision}

\author{\small Longfei Gao\thanks{Email address: longfei.gao@anl.gov}
\\ {\it \small Argonne National Laboratory, 9700 S Cass Ave, Lemont, IL 60439} 
}
\date{}


\def\bgnEqn{\begin{equation}}
\def\endEqn{\end{equation}}


\makeatletter\newcommand{\eqrefNolink}[1]{\textup{\tagform@{\ref*{#1}}}}\makeatother


\begin{document}

% \linenumbers

\maketitle


\begin{abstract}
On modern hardware, the speed of memory operation is often the limiting factor for execution time for many scientific applications, particularly for those related to PDE discretizations. % that exploit sparsity. 
%
This motivates us to explore the possibility of operating at half precision to reduce memory footprint and hence utilize the memory bandwidth more effectively.
%
Specifically, we study the viability of half precision simulations for time dependent wave equations in this work. 
%
Potential pitfalls when naively switching to half precision in these simulations are illustrated.
%
We then demonstrate that replacing the standard floating point sum with the compensated sum for solution updates can significantly improve the quality of the simulation results.
%
\end{abstract}
 

\section{Introduction}\label{sec_introduction}
%
In the early days of digital computing, 
there were many activities on the topic of mitigating the round-off errors in floating point arithmetic operations, 
sum in particular (see, e.g., \cite{kahan1965pracniques,moller1965quasi,moller1965note,linz1970accurate,dekker1971floating,neumaier1974rundungsfehleranalyse}), 
largely motivated by the lack of universal support for high precision arithmetic operations in hardware. 
%
Some later interests were motivated by the insufficient accuracy of double precision floating point operations for certain applications (see \cite{bailey2012high} for a collection of scientific applications that benefit from arithmetic operations at higher precision and \cite{shewchuk1997adaptive} for a particular use case in the context of mesh triangulation). 
%
These algorithms received a newer round of interest thanks to the advancement of 
% computing with GPUs, FPGAs, and other 
hardware accelerators (see, e.g., \cite{thall2006extended, goddeke2007performance}).


The gap between processor speed and memory speed has become wider and wider since the 80s. 
%
On modern hardware, the limiting factor for execution time is often memory operations for a large body of scientific applications, particularly for those involving simulations of partial differential equations (PDEs).
%
In such a scenario, reducing memory footprint is critical for achieving efficient simulations.
%
One simple approach to reducing memory footprint is lowering the operating precision, hence reducing the storage and movement requirement per datum.


For the particular application considered here, i.e., time dependent wave simulations, replacing double precision (64 bit) with single precision (32 bit) is common practice and, empirically, often gives satisfactory simulation results without the need of additional correction procedures (see \cite[p.14]{manual2021specfem3d} and \cite{abdelkhalek2009fast,heinecke2019tensor} for some evidence).
%
On the other hand, we will demonstrate with numerical experiments that lowering to half precision (16 bit) without correction will lead to unsatisfactory simulation results. 


We will further illustrate that with a simple fix using a technique often referred to as the Kahan summation, one can restore the simulation results to a satisfactory level.
%
This idea has already been proposed in Gill's 1950 work \cite{gill1951process}, years before the widespread availability of computing machinery capable of floating point arithmetic. 
%
It has also been examined in \cite{linnainmaa1974analysis} in the context of simulations of ordinary differential equations (ODEs).
%
In this work, we examine its applicability in the context of time dependent PDE simulations at half precision.


The remainder of this work is organized as follows. 
%
In section \ref{sec_problem_description}, we briefly outline the underlying physical problem and its numerical discretization used in our numerical experiments.
%
In section \ref{sec_compensated_sum}, we describe the technique of compensated summation, from which we derive the improvements in our half precision simulations.
%
In section \ref{sec_benefits}, we discuss the benefits of half precision simulation on modern hardware, using the problem described in section \ref{sec_problem_description} as a concrete example.
%
Numerical experiments are shown in section \ref{sec_numerical} to illustrate the impact of compensated sum in half precision simulations. 
%
We make a few remarks in section \ref{sec_remarks} and finally, draw our conclusions in section \ref{sec_conclusion}.


\section{Description of the physical problem}\label{sec_problem_description}

To illustrate the concept, we consider a simple 1D wave system defined over interval $(x_L,x_R)$:
%
\begin{linenomath}
\begin{subequations}
\label{1D_wave_equation}
\begin{empheq}[left=\empheqlbrace]{alignat = 2}
\displaystyle \enskip \rho \frac{\partial v}{\partial t} \enskip &= \enskip \displaystyle \! \frac{\partial \sigma}{\partial x} \ + \ s^v \, ; \label{1D_wave_equation_a} \\
\displaystyle \enskip \beta \frac{\partial \sigma}{\partial t} \enskip &= \enskip \displaystyle \! \frac{\partial v}{\partial x}  \ + \ s^\sigma \, . \label{1D_wave_equation_b}
\end{empheq}
\end{subequations}
\end{linenomath}
%
The physical background of this wave system is not significant for the ensuing discussion. 
%
$v$ and $\sigma$ are the sought solution variables. One could understand them as the (particle) velocity and stress of a 1D elastic rod, along which a compressional wave is propagating through. 
%
$\rho$ and $\beta$ are the density and compressibility of the rod, which are given parameters. 
%
$s^v$ and $s^\sigma$ are the (optional) source terms that drive the wave propagation. 
%
Practical applications of this wave system and its higher dimensional extensions can be found in seismology, medical imaging, structural testing, etc.


The wave system \eqref{1D_wave_equation} is associated with a physical energy: 
\begin{equation}
\label{1D_continuous_energy}
\mathscr E \ = \ \frac{1}{2} \int_{x_L}^{x_R} \rho v^2 dx \ + \ \frac{1}{2} \int_{x_L}^{x_R} \beta \sigma^2 dx \, ,
\end{equation}
where the two terms on the right hand side represent the kinetic and potential energy in the system, respectively.


Omitting the source terms in \eqref{1D_wave_equation},
% 
taking the time derivative on both sides of \eqref{1D_continuous_energy}, and substituting in the equations from \eqref{1D_wave_equation}, we arrive at:
\begin{equation}
\label{1D_continuous_energy_derivative}
\frac{d \mathscr E}{d t} \ = \ - \ \sigma(x_L) \cdot v(x_L) \ + \ \sigma(x_R) \cdot v(x_R) \, .
\end{equation} 
In other words, in the absence of source terms, time derivative of the physical energy $\mathscr E$ depends on boundary data only. 
%
If suitable boundary conditions are associated with the boundaries, e.g., the free surface boundary condition $\sigma(x_L) = \sigma(x_R) = 0$, we have $\frac{d \mathscr E}{d t} = 0$, i.e., the physical energy is conservative.


One can devise an energy-conserving semi-discretization of the continuous wave system \eqref{1D_wave_equation}. Details can be found in, e.g., \cite{gao2020simultaneous,gao2022strongly} and the references therein. 
%
The energy-conserving property will be an useful diagnostic tool in this work.
%
Symbolically, such a discretization is represented by the following system:
%
\begin{linenomath}
\begin{subequations}
\label{1D_wave_equation_discretized}
\begin{empheq}[left=\empheqlbrace]{alignat = 2}
\displaystyle \enskip \boldsymbol \rho^V \frac{d V}{d t} 
\enskip &= \enskip \displaystyle 
\mathcal D^\Sigma \Sigma + S^V \, ; \label{1D_wave_equation_discretized_a} \\[0.25ex]
%
\displaystyle \enskip \boldsymbol \beta^\Sigma \frac{d \Sigma}{d t} 
\enskip &= \enskip \displaystyle 
\mathcal D^V V + S^\Sigma \, ,
\label{1D_wave_equation_discretized_b}
\end{empheq}
\end{subequations}
\end{linenomath}
%
where vectors $V$ and $\Sigma$ are the discretizations of solution variables $v$ and $\sigma$, vectors $\boldsymbol \rho^V$ and $\boldsymbol \beta^\Sigma$ are the discretizations of physical parameters $\rho$ and $\beta$, matrices $\mathcal D^\Sigma$ and $\mathcal D^V$ are the discrete versions of the spatial derivative $\frac{\partial}{\partial x}$, vectors $S^V$ and $S^\Sigma$ are the discretizations of the source terms $s^v$ and $s^\sigma$.


The above continuous wave system \eqref{1D_wave_equation}, its energy-conserving discretization \eqref{1D_wave_equation_discretized}, and their higher dimensional extensions will be the testing ground of this work.
%
To carry out the simulation, the time derivative $\frac{d}{dt}$ in \eqref{1D_wave_equation_discretized} also needs to be discretized. 
%
In this work, the staggered leapfrog scheme is chosen for the temporal discretization. 
%
When combined with a staggered spatial discretization, the entire scheme is often referred to as Yee's scheme \cite{yee1966numerical}, which preserves the energy-conserving property of the continuous wave system (see \cite[Appendix A]{gao2022strongly} for more detail). 


The following pseudo algorithm is used to update the solution as the time step advances.
%
\begin{algorithm}[H]
\caption{Time stepping}
\label{algTimeStepping}
\begin{algorithmic}[1]
\State $i_t=0$
\While{$i_t < N_t$}
\State $\hphantom{\hspace{1.35em}}\mathllap{R^V} = \Delta t \cdot \left[\mathcal D^\Sigma \Sigma + S^V_{i_t} \right] \cdot\!\Big/ \ \boldsymbol \rho^V$ 
\Comment{\makebox[12.5em][l]{Calculate addend $R^V$ at $i_t$}}
%
\State $\hphantom{\hspace{1.35em}}\mathllap{V} = V + R^V$ 
\Comment{\makebox[12.5em][l]{Advance $V$ from $i_t-\frac{1}{2}$ to $i_t+\frac{1}{2}$}}
%
\State $\hphantom{\hspace{1.35em}}\mathllap{R^\Sigma} = \Delta t \cdot \left[\mathcal D^V V + S^\Sigma_{i_t + \nicefrac{1}{2}} \right] \cdot\!\Big/ \ \boldsymbol \beta^\Sigma$
\Comment{\makebox[12.5em][l]{Calculate addend $R^\Sigma$ at $i_t+\frac{1}{2}$}}
%
\State $\hphantom{\hspace{1.35em}}\mathllap{\Sigma} = \Sigma + R^\Sigma$ 
\Comment{\makebox[12.5em][l]{Advance $\Sigma$ from $i_t$ to $i_t+1$}}
%
\State $\hphantom{\hspace{0.75em}}\mathllap{i_t}$++ 
\Comment{\makebox[12.5em][l]{Increase the counter}}
%
\EndWhile
\end{algorithmic}
\end{algorithm}

In lines 3 and 5 of Algorithm \ref{algTimeStepping}, the notation $\cdot/$ means component-wise division of two vectors with equal length. 
%
Vectors $R^V$ and $R^\Sigma$ store the addends to be added to the solution vectors at each time step. Their calculation includes evaluation of the spatial derivatives and application of the source terms. 
%
The solution vectors $V$ and $\Sigma$ are updated at lines 4 and 6, which are where the additions take place and will be the focus of this work. 


We emphasize here that $\boldsymbol \rho^V$ and $\boldsymbol \beta^\Sigma$ are fixed throughout the simulation; $V$ and $R$ are updated at each time step; $R^V$ and $R^\Sigma$ are assigned new values at each time step; $S^V_{i_t}$ and $S^\Sigma_{i_t + \nicefrac{1}{2}}$ typically require negligible to zero storage space because the source terms have limited spatial support (e.g., one number per time step for point sources) and can often be evaluated on the fly for synthetic source signals (see Remark \ref{rmk_point_source} for an example).


\section{Summing floating point numbers}\label{sec_compensated_sum}
%
Various techniques have been developed to mitigate the round-off error in floating point summation as surveyed in \cite{higham1993accuracy}. 
%
A class of these techniques are presented in the context of aggregating a set of pre-determined numbers and requires reordering the numbers, which cannot be applied here since our addends ($R^V$ and $R^\Sigma$) are produced at each time step and the updated solution vectors ($V$ and $\Sigma$, i.e., the sums) are used in each time step to produce these addends.


In the following, we recapitulate two techniques that can be applied in our particular context. These two techniques are often attributed to \cite{kahan1965pracniques,moller1965quasi,moller1965note,dekker1971floating,neumaier1974rundungsfehleranalyse}.
%
They use an additional variable to keep track of the bits lost in floating point addition, which are constructed by additional arithmetic operations.


The first technique is presented below in \texttt{C++} syntax.
%
It is sometimes referred to as Kahan's summation technique, compensated summation, or Kahan's trick (as described by the author himself in \cite{kahan1965pracniques}). 

\begin{mdframed}[linewidth=0pt]
\textbf{\texttt{\small fast2sum}}
\newline
\begin{minipage}{\paperwidth}
\begin{lstlisting}[tabsize=4,basicstyle=\ttfamily\scriptsize]
template<typename T>
void fast2sum( T const a , T const b ,
               T &     s , T &     t )
{
      s = a + b;
    T z = s - a;
      t = b - z;
}
\end{lstlisting}
\end{minipage}
%
\end{mdframed}

Given two input numbers \texttt{a} and \texttt{b}, function \texttt{fast2sum} returns two output numbers \texttt{s} and \texttt{t}, where \texttt{s} is the floating point sum of \texttt{a} and \texttt{b}.
%
Provided that $\vert\texttt a\vert\geq\vert\texttt b\vert$, $\texttt t$ will store the difference between $\texttt s$ (i.e., the floating point sum) and the exact sum (i.e., that using infinite operating precision) such that the (exact) sum of $\texttt{s}$ and $\texttt{t}$ is the same as the (exact) sum of \texttt{a} and \texttt{b}. 
%
Intuitively, the lower bits of $\texttt b$ is lost after line 5, \texttt{z} retrieves the higher bits of \texttt{b} that have been added to \texttt{s}, \texttt{t} recovers the lower bits lost in line 5.

Algorithm \textbf{\texttt{\small fast2sum}} does not work when $\vert\texttt a\vert<\vert\texttt b\vert$ because the lower bits in \texttt{a} is lost after line 5 in this case. 
%
One could use an if statement to compare the magnitudes of $\texttt{a}$ and $\texttt{b}$ and swap their roles if $\vert\texttt a\vert<\vert\texttt b\vert$. 
%
However, branching is highly undesirable on modern architecture, particularly when inside small kernels that will be used repeatedly, like function \texttt{fast2sum}.
%
Instead, one can use additional arithmetic operations to cover both cases, which is presented in the following.


\begin{mdframed}[linewidth=0pt]
\textbf{\texttt{slow2sum}}
\newline
\begin{minipage}{\paperwidth}
\begin{lstlisting}[tabsize=4,basicstyle=\ttfamily\scriptsize]
template<typename T>
void slow2sum( T const a , T const b ,
               T &     s , T &     t )
{
	    s =   a + b;
	T p_a =   s - b;
	T p_b =   s - p_a;

	T d_a =   a - p_a;
	T d_b =   b - p_b;

	    t = d_a + d_b;
}
\end{lstlisting}
\end{minipage}
%
\end{mdframed}

We note here that \texttt{z} in \texttt{fast2sum} and \texttt{p\_a}, \texttt{p\_b}, \texttt{d\_a}, \texttt{d\_b} in \texttt{slow2sum} are local variables (in \texttt{C/C++} terminology), which do not cost storage in memory.
%
Function \texttt{slow2sum} uses six arithmetic operations instead of three in \texttt{fast2sum}.
%
However, on modern architecture, the ratio of cycle times for memory operations and floating point operations is often very high. Consequently, there may not be a noticeable difference in speed when switching between these two functions. 
%
The word ``slow'' in \texttt{slow2sum} merely serves as a distinction from \texttt{fast2sum}.
%
% [2023/09/03] NOTE: don't want to call it 2sum because the name starts with a numeral. (In C/C++, numeral cannot start a variable name.)


Integrating \textbf{\texttt{\small fast2sum}} or \textbf{\texttt{\small slow2sum}} to the time stepping algorithm \ref{algTimeStepping} presented in section \ref{sec_problem_description}, we arrive at the following algorithm.

\begin{algorithm}[H]
\caption{Time stepping - compensated sum}
\label{algTimeSteppingComSum}
\begin{algorithmic}[1]
\State $i_t=0$
\While{$i_t < N_t$}
\State $\hphantom{\hspace{1.35em}}\mathrlap{R^V} \quad\enskip\, = \ R^V + \Delta t \cdot \left[\mathcal D^\Sigma \Sigma + S^V_{i_t} \right] \cdot\!\Big/ \ \boldsymbol \rho^V$ 
\Comment{\makebox[12.5em][l]{Calculate addend $R^V$ at $i_t$}}
%
\State $\left(V, R^V\right) \gets V \underset{\texttt{\tiny comp}}{+} R^V$ 
\Comment{\makebox[12.5em][l]{Advance $V$ from $i_t-\frac{1}{2}$ to $i_t+\frac{1}{2}$}}
%
\State $\hphantom{\hspace{1.35em}}\mathrlap{R^\Sigma} \quad\enskip\, = \ R^\Sigma + \Delta t \cdot \left[\mathcal D^V V + S^\Sigma_{i_t + \nicefrac{1}{2}} \right] \cdot\!\Big/ \ \boldsymbol \beta^\Sigma$
\Comment{\makebox[12.5em][l]{Calculate addend $R^\Sigma$ at $i_t+\frac{1}{2}$}}
%
\State $\left(\Sigma, R^\Sigma\right) \gets \Sigma \underset{\texttt{\tiny comp}}{+} R^\Sigma$ 
\Comment{\makebox[12.5em][l]{Advance $\Sigma$ from $i_t$ to $i_t+1$}}
%
\State $\hphantom{\hspace{0.75em}}\mathllap{i_t}$++ 
\Comment{\makebox[12.5em][l]{Increase the counter}}
%
\EndWhile
\end{algorithmic}
\end{algorithm}

Comparing to Algorithm \ref{algTimeStepping}, at lines 4 and 6, we replace the standard floating point sum with one of the compensated sums outlined above with $V$ and $\Sigma$ receiving the floating point sum and $R^V$ and $R^\Sigma$ keeping track of the lost bits. 
%
Moreover, at lines 3 and 5, instead of direct assignment to $R^V$ and $R^\Sigma$, we add the calculated right hand sides into the lost bits from the previous time step.
%
We remark here that the idea of retaining the lost bits and adding them to the next time step has already appeared in Gill's 1950 work \cite[p.~103]{gill1951process}.


\section{Benefits on modern architecture}\label{sec_benefits}
%
On modern hardware, memory speed is often the limiting factor for execution time (see Figure 2.2 of \cite[p.80]{Hennessy2015computer} for a historical trend of the processor-DRAM performance gap), particularly for PDE simulations that exploit sparsity.
%
By reducing the operating precision from single (32 bits) to half (16 bits), the memory footprint, in terms of both storage and transfer, is reduced by 50\%. If we make the assumption that comparing to memory operations, floating point operations are free in terms of both wall-clock time and energy consumption, we could expect a 50\% reduction in operation cost.
%


To make the comparison concrete, when operating at single precision, Algorithm \ref{algTimeStepping} requires $6N$ storage in memory, $2N$ for the solution vectors $V$ and $\Sigma$, $2N$ for the parameters $\boldsymbol \rho^V$ and $\boldsymbol \beta^\Sigma$, and $2N$ for the right hand side vectors $R^V$ and $R^\Sigma$, where $N$ is the storage requirement for a discrete filed
%
defined over the grid at single precision.
%
On the other hand, when operating at half precision, Algorithm \ref{algTimeSteppingComSum} requires only $3N$ storage in memory.


One may argue that in Algorithm \ref{algTimeStepping}, the parameters $\boldsymbol \rho^V$ and $\boldsymbol \beta^\Sigma$ do not have to be stored in single precision, but may be stored in half precision instead and promoted to single precision on the fly when invoked in floating point operations. 
%
This 
%
introduces additional complexity in programming because two operating precisions need to be maintained.
%
Nonetheless, it is a conceivable way of reducing memory footprint. 
%
In this case, the memory storage requirement for Algorithm \ref{algTimeStepping} (at single precision) is $5N$ and the improvement of switching to to Algorithm \ref{algTimeSteppingComSum} (at half precision)
%
is 40\%.


One may further argue that the right hand side vectors $R^V$ and $R^\Sigma$ can be omitted in Algorithm \ref{algTimeStepping} because they can be evaluated on the fly when updating $V$ and $\Sigma$. 
%
In this case, and combined with storing the parameters $\boldsymbol \rho^V$ and $\boldsymbol \beta^\Sigma$ at half precision, the storage requirement for Algorithm \ref{algTimeStepping} becomes $3N$, which is the same as Algorithm \ref{algTimeSteppingComSum} (at half precision).
%
However, this relies on the special structure of the PDE system \eqref{1D_wave_equation} (i.e., the update of $\sigma$ depends on $v$ only and vice versa) and the staggered leapfrog time stepping scheme chosen for Algorithm \ref{algTimeStepping}.
%
Without the special PDE structure or if using a different time stepping scheme (e.g., the standard Runge-Kutta methods), omitting the right hand side vectors $R^V$ and $R^\Sigma$ is generally not feasible because of overwriting.%
\footnotemark
\footnotetext{
Moreover, omitting $R^V$ and $R^\Sigma$ is highly objectionable from the perspective of maintainability. 
%
Effectively, omitting $R^V$ and $R^\Sigma$ means the spatial discretization scheme and temporal discretization scheme are fused into one subroutine. 
%
Supposing a project has 
% potentially 
$\mathbb N_S$ spatial discretization schemes and $\mathbb N_T$ temporal discretization schemes to experiment with and to choose from depending on the circumstance,
%
omitting $R^V$ and $R^\Sigma$ means the implementers need to provide and maintain $\mathbb N_S \times \mathbb N_T$ subroutines for all the possibilities, rather than $\mathbb N_S + \mathbb N_T$ subroutines instead.
% with a modular design. 


Furthermore, in large scale projects, it may very well be two separate teams from different 
parts of the world 
% geographic locations 
who are responsible for the spatial discretization and the temporal discretization, 
% individually, 
which is another aspect that makes implementing and maintaining the fused spatial-temporal discretization schemes challenging in practice.
%
Additionally, for spatial and temporal discretization schemes more complicated than those shown in this work, the complexity will compound in the fused schemes, which will lead to more error-prone code.
}

With the above reasoning, we hope to have convinced the readers that by switching from single precision to half precision, it is reasonable to expect significant reduction in memory footprint for PDE simulations such as the ones considered in this work.
% 
Aside from memory, other potential benefits of switching from single precision to half precision include better cache performance (in terms of hits and misses) due to being able to hold more data items, 
% 
being able to pack more data items into (SIMD) registers to process in tandem, % if supported
%
and, lastly, cheaper floating point operations (which, admittedly, has been deemed insignificant earlier).


\section{Numerical examples}\label{sec_numerical}
%
In this section, we demonstrate numerically that half precision simulations with compensated sum can deliver satisfactory results compared to single and double precision simulations.
%
% The energy-conserving property is used as a diagnostic tool. 

\subsection{1D wave equation}\label{sec_example_1D_configuration}
%
To start, we present some numerical experiments on the 1D wave equation \eqref{1D_wave_equation} to demonstrate the effect of compensated sum for simulations at half precision.
%
These experiments use the emulated half precision provided by the MATLAB package ``chop'' from \cite{higham2019simulating}.


The simulation configuration is outlined in the following. 
%
A homogeneous medium with unit density and wave-speed (i.e., $\rho = 1~\text{kg}/\text{m}^3$ and $c=1~\text{m}/\text{s}$, where $c = \frac{1}{\sqrt{\rho\beta}}$) is considered. 
%
A point source on $\sigma$ is considered, whose temporal profile is specified as the Ricker wavelet with central frequency 5 Hz and time delay 0.25 s (see \cite[p.~684]{gao2019combining} for more detail about the source temporal profile). 
%
The maximal frequency in the source content is counted as 12.5~Hz, which leads to a minimal wavelength of 0.08~m. The length of the simulation domain, i.e., the interval $(x_L, x_R)$, is specified as six times of the minimal wavelength (i.e., 0.48~m).


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.075]{\string"./fig/1\string".png}
%
\caption{Illustration of the 1D staggered grids.}
\label{fig1DGrid}
\end{figure}


Solution variables $\sigma$ and $v$ are discretized on staggered grids, as illustrated in Figure~\ref{fig1DGrid}.
%
The grid spacing ($\Delta x$) is determined by specifying the number of (grid) points per (minimal) wavelength, i.e., $N_\text{ppw}$. 
%
The point source is placed at 1.6~m away from the left boundary $x_L$ on $\sigma$-grid.
%
One receiver is placed at 3.24~m away from the left boundary $x_L$ on $v$-grid. 


The fourth-order staggered grid stencil 
$
[\nicefrac{1}{24}, -\nicefrac{9}{8}, \nicefrac{9}{8}, -\nicefrac{1}{24}]
$
is used for the experiments here. 
%
Periodic boundary condition is considered and imposed by wrapping the stencil around.
%
With these choices on boundary condition, the continuous wave system is energy-conserving, so is the semi-discretization.


\subsubsection{Validating at double precision}\label{sec_1D_double}
%
Below, we first validate the code used for our experiments by comparing the simulation results with three different grid resolutions at $N_\text{ppw}=10$, $N_\text{ppw}=30$, and $N_\text{ppw}=50$ using double precision.
%
The time step length is chosen as $\Delta t = \text{1e-4 s}$ for all three simulations.
%
The recorded signals at the receiver location are shown in Figure~\ref{double_Refinement_V}.
%
The energy evolution are shown in Figure~\ref{double_Refinement_E}, which remains flat after the initial period where the source term takes effect.
%
Agreements between the three simulation results indicate the validity of our simulation code.
%
Segments of the simulation results for a longer time duration (100~s) are included in Supplementary Material \ref{SM_double_additional}.


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/2\string".png}
%
\caption{Recorded signals from simulations using three different grid resolutions.}
\label{double_Refinement_V}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/3\string".png}
%
\caption{Recorded energy from simulations using three different grid resolutions.}
\label{double_Refinement_E}
\end{figure}


\subsubsection{Reducing to single precision}\label{sec_1D_single}
%
Next, we verify our earlier claim that for this type of wave simulations, one can often reduce the operating precision to single and still obtain qualitatively satisfactory results. 
%
We conduct the same simulations as those presented in the previous section, but operating at single precision, emulated using the ``chop'' package.
%
In Figures \ref{comparison_V_single_double_ppw_10} and \ref{comparison_E_single_double_ppw_10}, the recorded signal and energy from single and double precision simulations are compared for the case $N_\text{ppw} = 10$, where we observe qualitatively indistinguishable results from these two sets of simulations.
%
Additional figures and implementation details can be found in Supplementary Material \ref{SM_single_additional}.


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/4\string".png}
%
\caption{Recorded signals from simulations using single and double precisions with $N_\text{ppw}=10$.}
\label{comparison_V_single_double_ppw_10}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/5\string".png}
%
\caption{Recorded energy from simulations using single and double precisions with $N_\text{ppw}=10$.}
\label{comparison_E_single_double_ppw_10}
\end{figure}


\subsubsection{Naively switching to half precision}\label{sec_1D_half_naive}
%
Next, we demonstrate that the fidelity of the simulations is no longer retained if switched to half precision naively. 
%
Almost identical simulations as those in sections \ref{sec_1D_double} and \ref{sec_1D_single} are conducted at half precision for $N_\text{ppw} = 10$, emulated using the ``chop'' package.
%
The only exception is that we use $\Delta t = \text{\rm1.000165939331055e-04 s}$ for the time step length, slightly different from the {\rm 1e-4 s} used in the double and single precision simulations (see Remark \ref{rmk_time_step_length} for the reasoning behind this seemingly odd choice). 


In Figures \ref{comparison_V_half_naive_single_double_ppw_10_seg_0_2}-\ref{comparison_E_half_naive_single_double_ppw_10_seg_0_100}, the recorded signals and energy from half, single, and double precision simulations are compared.
%
We observe that the half precision simulation result deviates increasingly from the single and double precision results as the simulations progress.
%
The energy evolution comparison in Figure \ref{comparison_E_half_naive_single_double_ppw_10_seg_0_100} is the most revealing for this trend. 
%
Additional figures and comments can be found in Supplementary Material \ref{SM_half_naive}.


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/6\string".png}
%
\caption{Recorded signals from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_V_half_naive_single_double_ppw_10_seg_0_2}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/7\string".png}
%
\caption{Recorded signals from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_V_half_naive_single_double_ppw_10_seg_10_12}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/8\string".png}
%
\caption{Recorded signals from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_V_half_naive_single_double_ppw_10_seg_98_100}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/9\string".png}
%
\caption{Recorded energy from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_E_half_naive_single_double_ppw_10_seg_0_100}
\end{figure}


\subsubsection{Switching to half precision with compensated sum}\label{sec_1D_half_compensated}
Below, we demonstrate that with compensated sum, the half precision simulation offers significantly improved results, compared to those from section \ref{sec_1D_half_naive}.
%
The simulation configuration is mostly the same as that from section \ref{sec_1D_half_naive}, with minor tweaks as explained in Supplementary Material \ref{SM_half_compensated_plots}. 
%
In particular, the time step length is adjusted to $\Delta t = \text{\rm9.997558593750000e-05 s}$, following a similar reasoning as outlined in Remark \ref{rmk_time_step_length}. %, but with a slight twist.


In Figures \ref{comparison_V_half_compensated_single_double_ppw_10_seg_0_2}-\ref{comparison_E_half_compensated_single_double_ppw_10_seg_0_100}, the recorded signal and energy evolution are compared to those from the single and double precision simulations.
% 
We observe that signals from the half precision simulations are 
% qualitatively satisfactory and 
visually indistinguishable from the single and double precision simulation results in these plots.
%
Moreover, energy evolution from the half precision simulation also follows the supposed trend (flat) well.%
%
\footnotemark
\footnotetext{
Zoom-in plots for Figures \ref{comparison_V_half_compensated_single_double_ppw_10_seg_0_2}-\ref{comparison_V_half_compensated_single_double_ppw_10_seg_98_100} are included in Supplementary Material \ref{SM_half_compensated_zoom_in} to illustrate the ``staircase'' characteristic of the half precision simulation results.
%
Zoom-in plot of Figure \ref{comparison_E_half_compensated_single_double_ppw_10_seg_0_100} is also included in Supplementary Material \ref{SM_half_compensated_zoom_in} to illustrate the fine scale differences in energy evolution, compared to the single and double precision results.
}
%
For Figures \ref{comparison_V_half_compensated_single_double_ppw_10_seg_0_2}-\ref{comparison_E_half_compensated_single_double_ppw_10_seg_0_100}, 
\textbf{\texttt{\small fast2sum}} is used.%
%
\footnotemark
\footnotetext{
Simulation results using \textbf{\texttt{\scriptsize slow2sum}} can be found in Supplementary Material \ref{SM_half_compensated_slow2sum}.
}
%
Additional figures and comments are included in Supplementary Material \ref{SM_half_compensated}. 


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/10\string".png}
%
\caption{Recorded signals from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_V_half_compensated_single_double_ppw_10_seg_0_2}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/11\string".png}
%
\caption{Recorded signals from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_V_half_compensated_single_double_ppw_10_seg_10_12}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/12\string".png}
%
\caption{Recorded signals from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_V_half_compensated_single_double_ppw_10_seg_98_100}
\end{figure}


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering
%
\centering\includegraphics[scale=0.2]{\string"./fig/13\string".png}
%
\caption{Recorded energy from simulations using half, single, and double precisions with $N_\text{ppw}=10$.}
\label{comparison_E_half_compensated_single_double_ppw_10_seg_0_100}
\end{figure}


\subsection{2D experiments on hardware with genuine half precision support}\label{sec_example_2D}
%
Below, we present numerical experiments for the 2D case using hardware that genuinely support half precision floating point format and operations.
%
The 1D wave system \eqref{1D_wave_equation} is extended to the following 2D elastic wave system

\begin{equation}
\label{2D_elastic_wave_equation}
\left\{
\arraycolsep=2.5pt%\def\arraystretch{0.75}
\begin{array}{rcl}
\displaystyle \frac{\partial v_x}{\partial t} &=& \displaystyle \frac{1}{\rho} \left( \frac{\partial \sigma_{xx}}{\partial x} + \frac{\partial \sigma_{xy}}{\partial y} \right); 
\\[2ex]
\displaystyle \frac{\partial v_y}{\partial t} &=& \displaystyle \frac{1}{\rho} \left( \frac{\partial \sigma_{xy}}{\partial x} + \frac{\partial \sigma_{yy}}{\partial y} \right); 
\\[2ex]
\displaystyle \frac{\partial \sigma_{xx}}{\partial t} &=& \displaystyle \left(\lambda + 2\mu\right) \frac{\partial v_x}{\partial x} + \lambda \frac{\partial v_y}{\partial y} + s^\sigma; 
\\[2ex]
\displaystyle \frac{\partial \sigma_{xy}}{\partial t} &=& \displaystyle \mu \frac{\partial v_y}{\partial x} + \mu \frac{\partial v_x}{\partial y}; 
\\[2ex]
\displaystyle \frac{\partial \sigma_{yy}}{\partial t} &=& \displaystyle \lambda \frac{\partial v_x}{\partial x} + \left(\lambda + 2\mu\right) \frac{\partial v_y}{\partial y} + s^\sigma,
\end{array}
\right.
\end{equation}
where $v_x$ and $v_y$ are the (particle) velocities, $\sigma_{xx}$, $\sigma_{xy}$, and $\sigma_{yy}$ are components of the stress tensor, $\lambda$ and $\mu$ are the (given) Lam\'{e} parameters that, along with density $\rho$, characterize the material where the waves travel through.


For the physical energy associated with \eqref{2D_elastic_wave_equation} and the analysis of its dynamic behavior, the readers are referred to \cite{gao2020simultaneous,gao2019combining}.
%
For the upcoming experiments, periodic boundary condition is considered for the left and right boundaries (i.e., $x$-direction); free surface boundary condition is considered for the top and bottom boundaries (i.e., $y$-direction).
%
With this choice, the physical energy associated with \eqref{2D_elastic_wave_equation} is conservative.
%
For spatial discretization, we use the scheme presented in \cite{gao2020simultaneous}, which preserves the energy-conserving property. 
%
The temporal discretization scheme is the same as that used for the 1D case.


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering\includegraphics[scale=0.2]{\string"./fig/14\string".png}
%
\vspace{-1em}
\caption{Compressional wave-speed.}
\label{model_vp}
\end{figure}


The parameter model is a (sub-sampled) portion of the Marmousi2 model, as illustrated in Figure \ref{model_vp} for the compressional wave-speed.
%
Similar figures illustrating the shear wave-speed and density can be found in Supplementary Material \ref{SM_2D_model}.
%
The model consists of 101 vertical grid points and 401 horizontal grid points. 
%
The minimal (shear) wave-speed is about $1.012$~km/s and the maximal (compressional) wave-speed is about $4.45$~km/s.
%
% for the parameter model used here.


We use the same source specification as in the 1D case and choose $\Delta x = \nicefrac{1}{128}$~km, which lead to $N_\ppw \approx 10$. 
%
For comparison plots shown below, the time step length is chosen as $1\text{e-4~s}$ (before truncation), same as in the 1D case.
%
Comparison plots using larger time steps ($1\text{e-3~s}$) are included in Supplementary Material \ref{SM_2D_signal_larger_dt}.
%
The source is placed on the $\{\sigma_{xx}$ , $\sigma_{yy}\}$ components at $5.5\Delta x$ below the top boundary and $100.5\Delta x$ from the left boundary.
%
The receiver is placed on the $\sigma_{xy}$ component at $5 \Delta x$ below the top boundary and $300 \Delta x$ from the left boundary.

The simulations are performed on NVIDIA A100 GPU, where the type name for (IEEE) half precision float is ``\texttt{\_\_half}'' from header ``\texttt{cuda\_fp16.h}'' for \texttt{C++} code using \texttt{CUDA}.
%
The code is compiled with \texttt{C++17} standard and \texttt{-O3} optimization flag.
%
The machine operates with \texttt{CUDA} version 11.4 at the time when the experiments are conducted.


Recorded signals from half precision (with \textbf{\texttt{\small slow2sum}}), single precision, and double precision simulations are compared in Figures \ref{comparison_V_half_compensated_single_double_ppw_10_seg_0_2_marmousi2}-\ref{comparison_V_half_compensated_single_double_ppw_10_seg_98_100_marmousi2}.
%
We observe satisfactory agreements from these figures in general.
%
Although, minor discrepancies start to creep in for the segment 98-100~s.%
\footnotemark
\footnotetext{
Discrepancies at this interval and magnitude is more of interest for research investigations and less a concern for practical applications since, as illustrated in Supplementary Material \ref{SM_double_additional}, discrepancies resulted from discretization errors are more pronounced than those observed in Figure \ref{comparison_V_half_compensated_single_double_ppw_10_seg_98_100_marmousi2}, and moreover, 1250 periods (100 s) of simulation typically exceeds practical needs.
\label{fnt_oscillations}
}


Similar comparison shown in Supplementary Material \ref{SM_2D_signal_larger_dt} for simulations using larger time step length (1e-3~s) leads to similar observations. 
%
Comparison of energy evolution is shown in Supplementary Material \ref{SM_2D_energy} along with remarks.
%
Simulation results from naively switching to half precision are shown in Supplementary Material \ref{SM_2D_naive}, which are not as satisfactory as those shown in Figures \ref{comparison_V_half_compensated_single_double_ppw_10_seg_0_2_marmousi2}-\ref{comparison_V_half_compensated_single_double_ppw_10_seg_98_100_marmousi2}.


\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering\includegraphics[scale=0.2]{\string"./fig/15\string".png}
\caption{Recorded signals from simulations using half, single, and double precisions.}
\label{comparison_V_half_compensated_single_double_ppw_10_seg_0_2_marmousi2}
\end{figure}
%
\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering\includegraphics[scale=0.2]{\string"./fig/16\string".png}
\caption{Recorded signals from simulations using half, single, and double precisions.}
\label{comparison_V_half_compensated_single_double_ppw_10_seg_10_12_marmousi2}
\end{figure}
%
\begin{figure}[H]
\captionsetup{width=1\textwidth, font=footnotesize,labelfont=footnotesize}
\centering\includegraphics[scale=0.2]{\string"./fig/17\string".png}
\caption{Recorded signals from simulations using half, single, and double precisions.}
\label{comparison_V_half_compensated_single_double_ppw_10_seg_98_100_marmousi2}
\end{figure}


We note here that the code used for the above experiments were originally designed with only double precision capacity in mind, and later adapted for single and half precision simulations by templating the type parameter and replacing the standard floating point sum with compensated sum at the appropriate locations. 
%
For the three simulations performed here, only a single type parameter is changed in the source code (from \texttt{double} to \texttt{single} and then to \texttt{\_\_half}).

However, the adapted code is not well customized for half precision simulations. 
%
Specifically, unnecessary truncations can be avoided when preparing the operators and model parameters, as well as when carrying out the operations. 
%
To give an example, the input model parameters from Marmousi2 were originally provided in single precision. 
%
We did not truncate them to half precision before reading in them in all three simulations. 
%
Moreover, the input model parameters are read in as compressional wave-speed ($c_p$), shear wave-speed ($c_s$), and density ($\rho$), but converted to $\lambda = \rho c_p^2 - 2 \rho c_s^2$, $\mu = \rho c_s^2$, and $\nicefrac{1}{\rho}$ before entering the time stepping loop. 
%
Even if the model parameters can be represented exactly at half precision, truncations may still take place at the these conversions.


We believe that with more effort in implementation and special care to half precision operations in particular, the results shown above may be further improved.
%
On the flip side, the figures above can give practitioners an idea of what kind of outcome can be expected when switching to half precision with little code change.


\section{Remarks}\label{sec_remarks}
%
In this section, we make a few remarks regarding implementation details and related topics.

\begin{remark}[Time step length]\label{rmk_time_step_length}
%
For the simulations in section \ref{sec_1D_half_naive}, we used time step length $\Delta t = \text{\rm1.000165939331055e-4 s}$, which may seem an odd choice to some readers. 
%
This number is slightly larger than the intended {\rm 1e-4}, but can be represented by an IEEE half precision float with bit pattern \texttt{\rm0000 0110 1000 1110}. 
(Another way to represent this number is $1.638671875 \times 2^{-14}$.)


If we instead specify $\Delta t = \text{\rm1e-4 s}$ for all three sets of simulations, this $\Delta t$ will be converted (implicitly) to \text{\rm1.000165939331055e-4 s} for the half precision case.
%
For a {\rm100 s} (i.e., $N_t = \text{\rm 1000000}$) simulation, this would lead to an accumulated difference of approximately {\rm0.01659 s}.
%
For a {\rm12.5 Hz} signal, the corresponding period is {\rm0.08 s}.
%
The above difference is about {\rm20\%} of the period, which would entail a significant phase shift in the comparison plot.


Although there are other ways to address this discrepancy caused by implicit conversion, such as representing $\Delta t$ using two half precision floats, we find the above ``rounding'' approach both simple and practical. 
%
In practice, when the intended $\Delta t$ is at or close to the CFL limit, one needs to be careful with the ``rounding'' (either implicitly or explicitly) so that the CFL condition is not inadvertently violated. 
\end{remark}


\begin{remark}[Point source]\label{rmk_point_source}
%
A point source is considered in this work, whose temporal profile is described by a Ricker wavelet. 
%
The code snippet related to its implementation is shown below in MATLAB notation.
%
As illustrated in the code snippet, calculation of the source amplitude to be imposed at each time step is conducted at double precision.
%
We can afford these operations at double precision because only scalars are involved.
%
Regardless of operating at double or half precision, one register has to be allocated anyway.
%
Moreover, compensated sum can be applied when imposing the source effect (line 8 of the code snippet below) as well. 
%
\begin{mdframed}[linewidth=0pt]
% \textbf{\texttt{Ricker wavelet (MATLAB)}}
% \newline
\vspace{-1em}
\begin{minipage}{\paperwidth}
\begin{lstlisting}[tabsize=4,basicstyle=\ttfamily\scriptsize\rm]
for it = 1:Nt
		`$\cdots$`

    t = (it - 1./2.) * dt - t0;         
    A = (1-2*pi*pi*f*f*t*t)*exp(-pi*pi*f*f*t*t);
    A = chop(A * dt / dx);

    P(i_src) = chop(P(i_src) + A); 

		`$\cdots$`
end
\end{lstlisting}
\end{minipage}
%
\end{mdframed}
%
\end{remark}


\begin{remark}[FMA]
%
Modern hardware can often perform fused multiply-add (FMA) operation with a single rounding. 
%
Its effect on half precision simulations is not studied in this work.
%
\end{remark}


\section{Conclusions}\label{sec_conclusion}
%
We examined the viability of half precision simulations for time dependent wave equations, largely motivated by the gap between processor speed and memory speed on modern hardware.
%
We demonstrated that applying compensated sum to the solution update can significantly improve the fidelity of these half precision simulations.
%
While the idea has already appeared in Gill's 1950 work in the context of ODE calculations, we provided extensive numerical examples in the PDE context.
%
Information provided in this work should be beneficial to practitioners who seek to improve wall-clock time performance or reduce energy consumption by switching to half precision.


\addtolength{\bibsep}{-0.5em}
\renewcommand{\bibfont}{\normalfont\small}
% \bibliographystyle{./bst_base/siam.bst}
\bibliographystyle{./bst_base/abbrv.bst}
\bibliography{./refs.bib}



\newpage
\input{supp}


\end{document}