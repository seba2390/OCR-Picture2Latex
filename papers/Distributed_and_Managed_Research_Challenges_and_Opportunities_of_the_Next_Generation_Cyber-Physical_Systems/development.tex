
\section{Development tools}
\label{sec:development}

Developing code for modern software platforms (e.g. Android or iOS)
cannot be done without sophisticated tool support. This issue is
compounded by the complexity of distributed systems, where not only
code development has to be done, but also complex configuration and
allocation decisions have to be made and implemented.

As discussed above, the platform supports a component model with
complex interaction semantics. Coding for such a component model by
hand is quite difficult and error prone, hence higher-level
abstractions, such as models, are needed. There is a need for a
modeling language specific for the component model that is easy to use
and mitigates accidental complexity. Furthermore, the modeling
language should facilitate the composition of applications from
components. As we are building a distributed system, the models
should also encompass the (static or dynamic) configuration of the
network with computing nodes and communication links. Many
cross-cutting aspects, like resource quotas, fault management
strategies, security labels for secure communications, etc. should
also be represented. Finally, the allocation of applications to computing
nodes and information flows to network links should also be modeled,
either explicitly (to support static allocation) or implicitly (to
support dynamic allocation).

In summary, we envision a wide-spectrum domain-specific modeling
language that covers all of the above areas. General purpose modeling
languages (e.g. UML) or their specializations (e.g. MARTE) solve only
part of the problem, and often in a somewhat cumbersome way,
e.g. using stereotypes. Arguably, a dedicated, platform-specific modeling
language is a better approach.

The development toolchain should be able to support both conventional
(code-oriented) and model-based development of software
components. The first one is needed for general purpose components,
while the second one opens up the opportunity to use the results of
model-based development tools (like Simulink/Stateflow). Tool
integration to ensure semantic interoperability across development
tools is essential.

Finally, the development tools should include tools for checking the
correctness of the modeled applications and analyzing system
properties including schedulability and the ability to compare
alternative deployment strategies.


