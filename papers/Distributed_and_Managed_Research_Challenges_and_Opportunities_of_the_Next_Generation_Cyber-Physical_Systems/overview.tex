% $Id: overview.tex 4010 2013-11-27 07:06:01Z wotte $

%\section{Overview}
%\label{sec:overview}


\input{architecture.tex}


\subsection{Distributed Application Description}
\label{subsec:prob_desc}

A distributed software application is a graph of software components
that are partitioned into processes\footnote{Components hosted within
a process are located within the same memory space} and hosted on
several interconnected computing nodes. Interaction relationships
between the components i.e. the edges can be generally grouped into
kinds: (a) Peer to peer dependencies and (b) Group interactions.

Peer to peer dependencies, are realized using \textbf{Facets} that are
collections of operations (interfaces) provided by a component and
\textbf{Receptacles} that are collections of operation required.
These two ports can be used to implement synchronous and asynchronous
point to point interactions. Generally, a peer to peer dependency
implies an order of deployment between components, i.e. the server
providing the facet should be deployed before the client with the
receptacle.

% Subhav, I'm not sure we really depend on DDS being the driver for the underlying
% pub/sub interaction.  I would make this a bit more general.
The group interactions are always asynchronous in nature and do not
imply ordered deployment. Groups interactions are realized using
\textbf{Publisher} and \textbf{Subscriber} ports, which provide a way
for components to interact in a global data space defined over
\textbf{Topic}s.
This feature is provided using the underlying OMG Data Distribution
Services (DDS) middleware.


\subsection{Deployment Resources}
% Subhav, I don't understand this subsection. Is the computation
% resource needed to do some deployment decision? But the description
% here sounds more like what an application will need.
The deployment and configuration problem is defined over a set of
\emph{deployment resources}. In general, deployment resources are
divided into \emph{computation} and \emph{communication}
resources. Computation resources correspond to hardware facilities
required to execute computation tasks at a given computation
node. These include processing speed (number of instructions per
second), memory size (amount of random access memory required), and
specific hardware required for certain tasks such as sensors, DSP,
etc.  Communication resources on the other hand correspond to
facilities required for interaction between tasks executing on
different computation nodes. This includes communication bandwidth,
available security measures such as encryption etc. Overall, these
resources create a dynamic graph that depends upon the current
connectivity in the cluster of distributed computing nodes.

\subsection{Application Deployment Configuration State}
At any time (t), the status of the distributed application deployed on
the set of distributed resources is called the application deployment
configuration. Compatibility implies that application and platform is
defined with respect to a common resource domain.

% Subhav, it is not clear why this mathematical model is needed. I
% would understand if we were solving an optimization problem. It
% might be worthwhile to mention why this is needed.
Assume that the application is represented as a tuple $A=(C, D,
\sigma, \alpha)$, where,
\begin{enumerate}
\item $C$ is the set of all component instances in the
    application, $type(c)$, is the component instance type. Note that
    there can be more than one instance of the same component in the
    application.
\item $D \subseteq C \times C$ is a peer-to-peer dependency relation
between component, where $(c_i,c_j)\in D$ iff $c_j$ services one or
more requests from $c_i$.
\item $\sigma: C \rightarrow N$ is the virtual node assignment for
each component. $N$ is the set of all computing nodes nominally
available in the cluster. Note that the nominal node assignment only
identifies a virtual node of a particular kind. During deployment this
virtual node can be mapped to any one of the available physical nodes
with same characteristics.
\item $\alpha \subseteq C \times C$ is the collocation relation, where
$(c_i,c_j)\in \alpha$ implies that $c_i$ and $c_j$ are collocated
within the same process.
\end{enumerate}

Thus, the deployment and configuration problem is to initially set up
the system such that all virtual node assignments for an application are
mapped to a concrete node. Nominally, the deployment infrastructure
always maps one virtual node to the same physical node. Then, the
deployment procedure requires instantiating all components, setting up
their connections and then activating them. Failures can occur at any
time, during the setup or after the application has been activated. A
resilient deployment and configuration infrastructure must be able to
detect and isolate the failure and then trigger the redeployment and
reconfiguration of the affected portions of the application.

In this paper we consider the failure modes which result in one of the
nodes in the group to go offline. We do not assume any time constraint
on when this failure mode can appear.


%
%Typically, the deployment procedure always maps
%
%configure the system such that
%
%
%can be divided into two related problems:
%
%\begin{itemize}
%	\item Initial:  Deploy an application $A$ on a given set of  computation Nodes $N$ in the architecture. This procedure can fail if any node $n_i$ becomes unavailable during the deployment. If this happens, the framework must detect this failure and then deploy the application on an equivalent reserve node $n_j$.
%	\item Reconfiguration: Any failures in the application components or the computing nodes after the application has been redeployed should trigger the redeployment and reconfiguration of the affected portions of the application.
%	%summarize the Apres Work
%\end{itemize}
