\section{Enumeration of Maximal Block Palindromes}
In this section, we consider how to enumerate all the maximal block palindromes $\MBP(\T)$.
A brute-force approach based on Theorem~\ref{theorem:largest} would compute the largest block for every possible substring $\T[\bb \ldots \bb + \ell - 1]$
(while suppressing output of non-maximal ones), which takes $\Theta(\sum_{\ell = 1}^{\NN} \ell (\NN - \ell)) = \Theta(\NN^3)$ time.

We propose an optimal solution running in $o(\NN^3)$ time.
\begin{theorem}
  All maximal block palindromes that appear in $\T$ can be enumerated in $O(\NN + \|\MBP(\T)\|)$ time, 
  where $\|\MBP(\T)\|$ is the output size.
\end{theorem}

We actually consider a variant of the problem:
We propose an algorithm to enumerate all the maximal block palindromes of size $\ge 2$,
whose total output size is denoted by $\|\MBP_{\ge 2}(\T)\|$, in optimal $O(\NN + \|\MBP_{\ge 2}(\T)\|)$ time.
That is to say, we can completely ignore maximal block palindromes of size $1$,
which might not be interesting if we focus on palindromic structures in $\T$.
If we want to enumerate $\MBP(\T)$, we can do that by slightly modifying the algorithm.

Our algorithm proceeds in two steps:
(i) enumerate all the pairing unbordered blocks for all center positions in a batch processing, and
(ii) build maximal block palindromes from the enumerated blocks.

In Step (i), we firstly enumerate every pair of occurrences of an unbordered substring in $\T$.
Note that the pair will be a component of a maximal block palindrome, and the total number of enumerated pairs is $O(\|\MBP_{\ge 2}(\T)\|)$.
We preprocess $\T$ in $O(\NN)$ time and space to support LCE queries in constant time.
We also compute, for every character in $\T$, the list storing all the occurrences of the character in increasing order,
all of which can be obtained by sorting the positions $\ii$ of $\T$ with the key $\T[\ii]$ by radix sort in $O(\NN)$ time and space.

Now we focus on an occurrence $\bb$ of $\T[\bb]$,
and identify every pair of occurrences of an unbordered substring such that the left one starts at $\bb$.
Let $\bb < \bb_1 < \bb_2 < \cdots < \bb_k$ be the occurrences of $\T[\bb]$ in $\T[\bb \ldots \NN]$.
We process $\bb_i \in \{\bb_1, \ldots, \bb_k\}$ in increasing order to identify common unbordered substrings
starting at $\bb$ and $\bb_i$ using $\LCE$ queries.
At the first round for $\bb_1$, we see that for any $\ell$ with $1 \le \ell \le \min (\LCE(\bb, \bb_1), \bb_1 - \bb)$,
the common substring of length $\ell$ starting at $\bb$ and $\bb_1$ is unbordered,
and thus, we report each pair of such unbordered substrings.
While processing $\bb_i \in \{\bb_1, \ldots, \bb_k\}$ in increasing order,
we maintain a set $\LL$ of positive integers $\ell$ (by a sorted list of intervals) such that $\T[\bb \ldots \bb + \ell - 1]$ has a border 
caused by the common substrings starting at $\bb$ and $\bb_i$'s processed so far.
We use $\LL$ to efficiently skip $\ell$'s such that $\T[\bb \ldots \bb + \ell - 1]$ has a border in the later rounds.
For example, in the first round, we add the interval $[\bb_1 - \bb + 1 \ldots \bb_1 - \bb + \LCE(\bb, \bb_1)]$ to $\LL$ (which is initially empty)
as, for any $\ell \in [\bb_1 - \bb + 1 \ldots \bb_1 - \bb + \LCE(\bb, \bb_1)]$, $\T[\bb \ldots \bb + \ell - 1]$ has a border 
caused by the common substring starting at $\bb$ and $\bb_1$.
When processing $\bb_i$ for $1 < i \le k$, we see that for any $\ell \in [1 \ldots \min (\LCE(\bb, \bb_i), \bb_i - \bb)] \setminus \LL$,
the common substring of length $\ell$ starting at $\bb$ and $\bb_i$ is unbordered.
Updating $\LL$ can be easily done in $O(1)$ time by adding (merging if necessary) the interval $[\bb_i - \bb + 1 \ldots \bb_i - \bb + \LCE(\bb, \bb_i)]$
to $\LL$ (observe that the new interval is always pushed back to $\LL$ or merged with the last interval of $\LL$
as we process $\{\bb_1, \ldots, \bb_k\}$ in increasing order).
Note that $[1 \ldots \min (\LCE(\bb, \bb_i), \bb_i - \bb)] \setminus \LL$ always contains $1$,
and we can incrementally enumerate its element in constant time per element
because $\LL$ is maintained as a sorted list of intervals.
Thus, the computation cost can be charged to the number of output, i.e., it runs in $O(\NN + \|\MBP_{\ge 2}(\T)\|)$ time in total.

When we find a pair of occurrences $\bb_{l} < \bb_{r}$ of an unbordered substring of length $\ell$,
we list it up as a triple $(\cc, \bb_{r}, \bb_{r} + \ell)$, where $\cc = (\bb_{l} + \bb_{r} + \ell - 1) / 2$ is the center of the pairing blocks.
After listing up all those triples, we sort them using the first and second elements as keys by radix sort,
which can be done in $O(\NN + \|\MBP_{\ge 2}(\T)\|)$ time and space.

Now we are ready to proceed to Step (ii) in which we build the maximal block palindromes from the sorted list of triples computed in Step (i).
For building the maximal block palindromes with center $\cc$,
we scan the sublist of triples having center $\cc$ and connect the pairing blocks whose beginning and ending positions are adjacent
using the information of the second (the beginning position of the block) and third (the ending position of the block plus one) elements of the triples.
We build all the $\cc$-centered maximal block palindromes by extending their blocks outwards simultaneously
with a $0$-initialized array $A$ of length $\NN$.
When we look at a triple $(\cc, \bb_{r}, \bb_{r} + \ell)$,
we write $\bb_{r}$ to $A[\bb_{r} + \ell]$, and connect the block with the block ending at $\bb_{r} - 1$ if such exists
(which can be noticed by the information $A[\bb_{r}] \neq 0$).
Since the block boundaries are not shared due to Lemma~\ref{lem:there-is-no-same-starting-positions-of-factors},
the information written in $A$ can be propagated correctly to extend the blocks.
It runs in time linear to the size of the sublist.
We can also clear $A$ in the same time by scanning the sublist again while writing $0$ to the entries we touched.

Since the initialization cost $O(\NN)$ of $A$ is payed once in the very beginning of Step (ii)
and the other computation cost can be charged to the output size, the total time complexity is $O(\NN + \|\MBP_{\ge 2}(\T)\|)$.

For enumerating $\MBP(\T)$, we modify Step (ii).
While scanning the sublist for center $\cc$,
we can identify all the positions $\ee \ge \cc$ such that $\ee$ is not an ending position of some pairing block,
for which the substring $\T[2 \cc - \ee \ldots \ee]$ is unbordered.
If the unbordered substring cannot be extended outwards by blocks (which can also be checked while scanning the sublist),
it is the maximal block palindrome of size $1$ to output for $\MBP(\T)$.
The algorithm runs in $O(\NN + \|\MBP(\T)\|)$ time in total as the additional cost can be charged to the output size.


