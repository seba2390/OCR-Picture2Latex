% !TEX root = paper.tex
\section{Introduction}
Real life graph networks like communication network or road
network are prone to link or node failure. Thus, algorithms
developed for these networks must be resilient to failure.
For example, the shortest path between two nodes may change
drastically even if a single link fails. So, if the problem
forces us to find shortest paths in the graph, then it should
find the next best shortest path after a link failure. There
are many ways to model this process: one of them is {\em
fault-tolerant graph algorithm}. In this model,  we have to preprocess a graph $G$  and
build a data-structure that can compute a property of the
graph after any $k$ edges/vertices of the graph have failed.
 Note the difference between this model and
{\em dynamic graph model}. In a dynamic graph algorithm,
 we have to {\em maintain} a property of a continuously
changing graph. However,
in the fault tolerant model, we expect the failure to be
repaired readily and
restore our original graph.

In this paper, we study the shortest path problem in the
fault tolerant model. Formally, we are given an undirected
and unweighted graph $G$ and a source
set $S$ of $|S| = \sigma
$ sources. We want to build a data structure which can process
the following query {\sc Q}$(s,t,e):$ find the shortest
distance from $s$ to $t$ avoiding an edge $e$,  where $s
\in S$ and
$t \in V$. Such a data-structure is also called a {\em distance
oracle}.
When there are $n$ sources, Demetrescu et al. \cite{DemetrescuTCR08}
designed an oracle that can find the shortest path between
any two vertices
in $G$ after a single vertex/edge failure in $\tilde O(n^2)$
space and $O(1)$
query time. Recently,
Bil{\`o} et. al. \cite{BiloCGLP17} generalized this result
to any number of sources. They designed a data-structure
of size $\tilde
O(\sigma^{1/2}n^{3/2})$ with the query time of $O(\sqrt{n\sigma})$
for the above problem.

To understand our problem, we should also understand a closely
related problem of finding
{\em fault tolerant subgraph}.
Here, we have to find a subgraph of $G$ such that BFS
tree from $s \in S$ is preserved in the subgraph after any
edge
deletion.  In an unweighted graph, a BFS tree preserves
the shortest path from $s$ to all vertices in $G$.
Parter and Peleg \cite{ParterP13} showed that a subgraph
of
size $O(\sigma^{1/2} n^{3/2})$ is both necessary and sufficient
to
solve the above problem. The above result indicates that
there should
be a better fault-tolerant distance oracle for any value
of $\sigma$.

Inspired by this result,
we generalize the result of \cite{DemetrescuTCR08} to any
number of sources --
by showing that there exists a distance oracle of size $\tilde
O(\sigma^{1/2} n^{3/2})$
which can answer queries in $\tilde O(1)$ time. Note that
our result nearly matches
the space bound achieved by Parter and Peleg\cite{ParterP13}
-- up to poly$\log n$ factors.
We now state the main result of this paper formally:
\begin{theorem}
\label{thm:maintheorem}
  There exists a data-structure of size $\tilde O(\sigma^{1/2}n^{3/2})$
  for multiple source single fault tolerant exact distance
oracle
  that can answer each query in $\tilde O(1)$ time.
\end{theorem}

This generalization turns out to be much more complex than
the result in \cite{DemetrescuTCR08}.
Indeed, the techniques used by Demetrescu et al. \cite{DemetrescuTCR08}
are also used
by us to weed out {\em easy replacement} paths. To take
care of other paths,
we take an approach similar to Parter and Peleg\cite{ParterP13}.
They used the following trick:
if the {\em detour} of replacement paths are {\em disjoint},
then the number of such
paths can be bounded easily by a {\em counting argument}.
The main challenge is
then to show that paths in question are indeed disjoint
-- which is also easy
in their problem. We use a technique similar to above --
however, our paths are not disjoint,
they {may intersect}.  We believe that this technique can
be of independent interest and may be used in solving
closely related fault tolerant subgraph problems.

\iflong
\else
\vspace{-2mm}
\fi
\subsection{Related Work}
Prior to our work, the work related to fault tolerant
distance oracle was limited to two special cases, $\sigma
=1$ or $\sigma = n$.
As stated previously, Demetrescu et al. \cite{DemetrescuTCR08}
designed a single fault
tolerant distance oracle of size $\tilde O(n^2)$ with a
query time of $O(1)$.
The time to build the data-structure is $O(mn^2)$ --  which
was improved to
$O(m n \log n)$ by Bernstein and Karger \cite{BernsteinK09}.
The above result also works for a directed weighted graph.
Pettie and Duan \cite{DuanP09} were able to extend this
result to two vertex faults.
The size and query time of their distance oracle is $\tilde
O(n^2)$ and $\tilde O(1)$
respectively.
If the graph is weighted, then Demetrescu et al. \cite{DemetrescuTCR08}
showed that
there exists a graph in which a single vertex fault tolerant
distance oracle will
take $\Omega(m)$ space.
Recently, Bil{\`o} et. al. \cite{BiloCGLP17} designed the
following data-structure:  for every $S,T \subseteq V$,
a data-structure of size $\tilde O(n \sqrt{|S||T|})$ and
query time $O(\sqrt{|S||T|})$, where the query asks for
the shortest distance from $s \in S$ to $t \in T$ avoiding
any edge. If $|S| = \sigma$ and $|T| = n$, then the size
of their data-structure is $\tilde O(\sigma^{1/2}n^{3/2})$
and the query time is $O(\sqrt{n\sigma})$.%So, the above
%results (which also applies to weighted graph)
%cannot be extended to weighted graph.

The next set of results are not {\em exact} but {\em approximate},
that is, they return
an approximate distance (by a multiplicative {\em stretch}
factor)
between two vertices after an edge/vertex fault. Also, these
oracles work  for a  single source only. Baswana and Khanna
\cite{KhannaB10} showed
that a 3-stretch  single source single fault tolerant distance
oracle of size $\tilde O(n)$ can be built in
$\tilde O(m + n)$ time and a constant query time.
Bil{\`{o}} et. al.\cite{BiloGLP16} improved the above result:
a distance oracle with stretch 2 of size
$O(n)$ and $O(1)$ query time.
In another result, Bil{\`{o}} et. al. \cite{BiloG0P16}
designed a $k$ fault
tolerant distance oracle of size $ \tilde O(kn)$ with a
stretch factor of $(2k+1)$
that can answer queries in $\tilde O(k^2)$ time. The time
required to construct this
data-structure is $ O(kn\alpha(m, n))$, where $\alpha(m,n)$
is the inverse of the Ackermann's function.
If the graph is unweighted,
then Baswana and Khanna\cite{KhannaB10}  showed that a $(1+\epsilon)$-stretch
single source
fault tolerant distance oracle of size $\tilde O(\frac{n}{\epsilon^3})$
can be built in $O(m \sqrt{n/\epsilon})$ time
and  a constant query time.  Bil{\`{o}} et. al \cite{BiloGLP16}
extended this result for
weighted graph by designing a distance oracle with stretch
$(1+\epsilon)$ of size
$O(\frac{n}{\epsilon} \log \frac{1}{\epsilon} )$ and a logarithmic
query time.

There is another line of work, called the {\em replacement
path} problem. In this problem,   we are given a source
$s$ and destination $t$ and for each edge $e$ on the shortest
 $st$ path, we need to find shortest $s$ to $t$ path
avoiding $e$. The problem can be generalized to finding
$k$ shortest $s$ to $t$ path avoiding $e$. The main goal
of this problem is to find all  shortest paths as fast
as possible.
Malik et al. \cite{MalikMG89}  showed that in an undirected
graphs, replacement paths can be computed in
 $O(m + n \log n)$ time. For
 directed, unweighted graphs, Roditty and Zwick \cite{RoddityZ12}
designed an algorithm that  finds all
replacement paths in $O(m
\sqrt n)$ time.
For the $k$-shortest paths problem, Roditty \cite{Roditty07}
presented
an algorithm with an approximation ratio
3/2, and the running time  $O(k(m\sqrt n+n^{3/2}
\log n))$.
 Bernstein \cite{Bernstein10} improved the above result
to get an approximation factor of $(1+\epsilon)$ and running
time $O(km/\epsilon)$.  The same paper also gives an improved
algorithm for the approximate $st$ replacement path algorithm.
See also \cite{GrandoniW12,Williams11,WeimannY10}.



As mentioned previously, a problem closely related to our problem is the fault tolerant subgraph problem. The aim of this problem is to
find a subgraph of $G$ such that BFS
tree from $s \in S$ is preserved in the subgraph after any
edge
deletion.
Parter and Peleg~\cite{ParterP13} designed an algorithm
to compute
single fault tolerant BFS tree with $O(n^{3/2})$ space.
They also showed their result can be easily extended
to multiple source with $O(\sigma^{1/2}n^{3/2})$ space.
Moreover, their upper bounds were complemented by matching
lower bounds for both their results.
This result was later extended to dual fault BFS tree  by
Parter~\cite{Parter15} with $O(n^{5/3})$ space.
Gupta and Khan \cite{GuptaK17} extended the above result
to
multiple sources with $O(\sigma^{1/3} n^{5 /3})$ space.
All the above results are optimal due to a result
by Parter~\cite{Parter15}  which states that a multiple
source $k$
fault tolerant BFS structure requires  $\Omega(\sigma^{\frac{1}{k+1}}n^{2-\frac{1}{k+1}})$
space.
Very recently, Bodwin et. al. \cite{BodwinGPW17} showed
the existence of a $k$ fault tolerant
BFS structure of size $\tilde O(k\sigma^{1/2^k}n^{2-1/2^k})$.

Other related problems include fault-tolerant DFS and fault
tolerant reachability.
Baswana et al.~\cite{BaswanaCCK16} designed an $\tilde{O}(m)$
sized fault tolerant data structure
that reports the DFS tree of an undirected graph after $k$
faults in $\tilde{O}(nk)$ time.
For single source reachability, Baswana et al. \cite{BaswanaCR16}
designed an algorithm
that finds a  fault tolerant reachability subgraph for
$k$ faults using $O(2^k n)$ edges.
\iflong
\else
\vspace{-2mm}
\fi


\iflong

\subsection{Comparison with Previous Technique}
Our technique should be directly compared to the technique
in Bil{\`{o}} et. al.\cite{BiloCGLP17}.
We discuss their work when $|S|=1$ and $|T|=n$, that is
we want a single source
fault tolerant distance oracle. Consider any $st$ path where
$t \in V$.
For the last $\sqrt n \log n$ edges in this $st$ path (edges
from the vertex $t$),
we explicitly store the shortest replacement paths avoiding
these edges.
For the remaining replacement paths, note that the length
of these replacement
paths is always $\ge \sqrt n \log n$. So, we sample a set
$R$ of $O(\sqrt n)$ vertices.
With very high probability, one of our sampled vertices will
lie on the replacement
path (Lemma 1, \cite{BiloCGLP17}).
We can also show that the shortest path from the sampled vertex
to $t$
will never contain the edge avoided by these remaining replacement
paths (Lemma 3, \cite{BiloCGLP17}).
We can store all  shortest paths from $v \in R$ to $t
\in V$ using space $O(n^{3/2})$.

Thus, we have reduced the problem of finding a replacement
paths from $s$ to vertices in $V$,
to finding replacement path from $s$ to vertices in $R$.
This reduction is useful as
there are just $ O(\sqrt n)$ vertices in $R$. Fortunately,
there already exists a
data-structure \cite{DemetrescuTCR08}, say $D$, that can
solve the reduced
problem in $O(n^{3/2})$ space and $O(1)$ query time.

Now the query algorithm in  \cite{BiloCGLP17} is straightforward.
Consider the query $Q(s,t,e)$.
If $e$ is one of  the last $\sqrt n \log n$ edges on $st$
path, then we have already stored
the replacement path.
Else, we know that the replacement path avoiding $e$ must
pass through a vertex in $R$. Unfortunately,
we don't know that vertex. So, we try out all the vertices
in $R$. That is, for each $v \in R$,
we find the shortest path from $s$ to $v$ avoiding $e$ (using
data-structure $D$ in $O(1)$ time)
and add it to shortest $vt$ distance. Thus, we have to return
the minimum of all the computed
shortest paths. This gives us the running time of $|R| =
 O(\sqrt n)$.

 To improve upon the techniques in \cite{BiloCGLP17}, we
use the following
strategy: we also sample $R$ vertices of size $\tilde O(\sqrt
n)$. Instead of looking at all
the vertices in $R$, we concentrate on the vertex of $R$
that lies on the $st$ path, say $v$.
If the replacement path passes through $v$, then we can
 find it in $O(1)$ time using $D$ (as done in \cite{BiloCGLP17}).
The main novel idea of this paper is to show that the number
of replacement paths that do not
pass through $v$ is $O(\sqrt n)$. This helps us in reducing
the running time from $O(\sqrt n)$
to $\tilde O(1)$. Moreover, we show that this technique
can be generalized to any number of sources.
\fi
