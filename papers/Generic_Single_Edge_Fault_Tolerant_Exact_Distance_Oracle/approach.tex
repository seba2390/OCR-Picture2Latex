% !TEX root = paper.tex
\iflong
\else
\vspace{-2mm}
\fi
\section{Our Approach}

\noindent  We will randomly select a set of terminals $\TT$ by sampling
each vertex with probability $\sqrt\frac{\sigma}{n}$. Note
that the size of $\TT$ is $\tilde O(\sqrt {\sigma n})$ with high probability.
For a source $s$ and $t \in V$, let $t_s$ be the last terminal encountered on the $st$ path.
%There is no terminal in the paths $\cup_{s\in S}\ \ t_st$.
%Let us call the this union $\cup_{s\in S}\ \
%t_st$ as the terminal free neighborhood of $t$.
The following lemma is immediate:
\begin{lemma}
\label{lem:lower}
If $|st| \ge c \sqrt{\frac{n}{\sigma}} \log n$ $(c \ge 3)$,
then $|t_st| = \tilde O(\sqrt{\frac{n}{\sigma}})$ with a
very high probability for all $s \in S$ and $t \in V$.
\end{lemma}

\iflong
  \begin{proof}
  Let $E_{s,t}$ be the event  that none of the  last $c \sqrt{\frac{n}{\sigma}} \log n$
  vertices on $st$ path are in $\TT$.  So,
  $\mathsf{P}[E_{st}\ \text{occors} ] = (1 - \sqrt{\frac{\sigma}{n}})^{c \sqrt{\frac{n}{\sigma}}
  \log n} \le \frac{1}{n^c}.$ Using union bound, $\mathsf{P}[ \cup_{s,t} E_{s,t}  ~\text{occors}] \le n \sigma \frac{1}{n^c} \le \frac{1}{n^{c-2}}$.
  Thus, with a very high probability  $|t_st| = \tilde O(\sqrt{\frac{n}{\sigma}})$  for all $s \in S$ and $t \in V$.


  \end{proof}
\fi

Let $G_p$ denote the graph where each edge is perturbed by a weight function that ensures unique shortest paths. Our
$st$ path is the shortest $s$ to $t$ path in $G_p$, let
us denote its  length by $|st|_p$. Note that $G_p$ contains a unique shortest path between any two vertices,
even the ones that avoid an edge -- such a graph has been used before in related problems
\cite{BernsteinK09,ParterP13,HershbergerS01}. We can use $G_p$ even to find all the
replacement paths. However, we want our replacement
paths to have  other nice property, that is,
{\em the length replacement paths(without perturbation) from $s$ to $t$ are different}.
This property is not satisfied by replacement paths in $G_p$. We employ another
simple strategy to find a replacement path. Following \cite{GuptaK17}, we
define preferred replacement paths:

\begin{definition}
A path $P$ is called a \textbf{preferred} replacement path from $s$ to $t$ avoiding $e$ if
(1)  it diverges and merges the $st$ path {\em just once}
(2)  it divergence point from the $st$ path is as close to $s$ as possible
(3)  it is the shortest path in $G_p$ satisfying (1) and (2).
\end{definition}


\noindent The replacement path has to diverge from the $st$ path before $e$. Ideally,
we want a replacement path that diverges from $st$ path as close to $s$ as possible.
This is a crucial feature which will ensure that all  replacement paths from
$s$ to  $t$ have  different lengths. The first condition ensures that we do
not diverge from $st$ path just to get a higher point of divergence. If many shortest paths are diverging from a same vertex, the third condition
is used to break ties. In the ensuing discussion, we will assume that  we are always working with a preferred replacement path.

\begin{comment}
 Fix a vertex $t$. In this paper, we will show
that the query
${\sc Q}(s,t,e)$ (for $s \in S, u \in V$) can be answered
in $\tilde O(1)$ using $\tilde O(\sqrt{\sigma n})$ space.
This immediately implies that we can answer exact queries
in $\tilde O(1)$ time using $\tilde O(\sigma^{1/2} n^{3/2})$
space. In the rest of the paper, we try to find a distance
oracle for a fixed $t$.
\end{comment}

The initial $st$ path is found out by finding the unique shortest path in $G_p$.
Consider the query
${\sc Q}(s,t,e)$. If the failed edge $e$ does not lie on $st$ path, then we can report $|st|$ as the shortest distance from $s$ to $t$ avoiding $e$. To this end, we should be able to check whether $e$ lies in the shortest path from $s$ to $t$. At this point, we will use the property of graph $G_p$. If $e(u,v)$ lies in $st$ path, then we have to check if $u$ and $v$ lie on $st$ path. To this end, we check if $|su|_p + |ut|_p = |st|_p$ and $|sv|_p + |vt|_p = |st|_p$.
If both the above two equations are satisfied then the $st$ path passes through $e$ (as the shortest path from $u$ to $v$ is 1). We can also find whether $u$ or $v$ is closer to  $s$ on $st$ path. Without loss of generality assume that $u$ is closer to $s$ than $v$ on $st$ path.

However, we do not have space to store all these distances. Specifically, the second term on the LHS of  above two equations mandates that we store the distance of every pair of vertices in the graph. This implies that the size of our data structure is
$O(n^2)$ which is not desirable.

To solve the above problem, we observe that if $e$ lies in the  $t_st$ path, then we have just enough space to store this fact. So, given any $e$, we can easily find if $e \in t_st$. If $e \in st_s$, then we know that $|su|_p+|ut_s|_p+|t_st|_p = |st|_p$ and $|sv|_p+|vt_s|_p+|t_st|_p
= |st|_p$. This equality is easier to check with the space at hand. So, we have the following two cases:



\begin{enumerate}[noitemsep,nolistsep]
\item(Near Case) $e$ lies on $t_st$.
\item(Far Case) $e$ lies on $st_s$.
\end{enumerate}

\iflong
\else
\vspace{-2mm}
\fi
\subsection{Handling the Near Case}

For each $e(u,v) \in t_st$, let $P_e$ be the preferred replacement path from $s$ to $t$ avoiding $e$. We put $(e, |P_e|)$ in a balanced binary search tree $\BST(s,t)$ with the key being $e$.  Given any query $\sc{Q}(s,t,e)$, we now need to check if $e$ lies in $\BST(s,t)$. This can be done in $\tilde O(1)$ time and the length of the preferred replacement path  can be reported.
%However, if $u$ does not lie in $\BST_1(t)$, then $u$ may lie in $st_s$ path, that is the far case.

The space required for $\BST(s,t)$ is directly proportional to the size of path $t_st$. By Lemma \ref{lem:lower}, we know that $|t_st| = \tilde O(\sqrt{\frac{n}{\sigma}})$. Thus, the size of $\BST(s,t)\ = \tilde O(\sqrt{\frac{n}{\sigma}})$. This implies that the cumulative size of all the associated binary search tree  is $\cup_{t \in V}\cup_{s \in S} |t_st| = \tilde O( n \sigma \sqrt{\frac{n}{\sigma}}) = \tilde O(\sigma^{1/2} n^{3/2})$.
\iflong
\else
\vspace{-3mm}
\fi
\subsection{Handling the Far Case}

We first need to check if $e \in st_s$. To this end we use the following data-structures.
\begin{itemize}[leftmargin=*,noitemsep,nolistsep]
\item $B_0$: For each pair of vertices $x$ and $y$ where $x
\in (S \cup \TT)$ and $y \in V$, the shortest
path between $x$ and $y$ in $G$ and $G_p$ is stored in $B_0(x,y)$ and $B_0^p(x,y)$ respectively.  The total
size of $B_0$ is $\tilde O((\sigma +\sqrt{n\sigma}) n) = \tilde O(\sigma^{1/2} n^{3/2})$.

%\item $B_1$: For each pair of vertex $v \in V$ and $w \in
%\TT$, the shortest
%path between $v$ and $w$ is stored in $B_1(v,w)$. The total
%size of $B_1$ is $O( \sigma^{1/2} n^
%{3/2})$

\item $B_1$: For each pair of vertices $s \in S$ and $t \in V$, $B_1(s,t)$ contains the
vertex in $\TT$ closest to $t$ on $st$ path, that is $t_s$.  The total size of
$B_1$ is $ O(\sigma n) = \tilde O(\sigma^{1/2}n^{3/2})$.
\end{itemize}

\noindent %The reader can check that the size of these data-structures is $O(\sigma^{1/2} n^{3/2})$.
To check if $e(u,v) \in st_s$, we first find $t_s \leftarrow B_1(s,t)$.
Then we check if $B_0^{p}(s,u) +\ B_0^{p}(u,t_s) +\ B_0^{p}(t_s,t) = B_0^{p}(s,t)$ and $B_0^{p}(s,v) +\ B_0^{p}(v,t_s) +\ B_0^{p}(t_s,t)
= B_0^{p}(s,t)$.
If yes, then $e \in st_s$.
 We subdivide the far case into two more sub-cases:
\begin{enumerate}[noitemsep,nolistsep]
   \item The preferred replacement path  avoiding $e$ passes through $t_s$.

   \item The preferred replacement path avoiding $e$ avoids $t_s$.

\end{enumerate}

\noindent  The first case turns out to be a generalization of techniques
used by Demetrescu et. al.\cite{DemetrescuTCR08}  to solve the all pair distance oracle
under single edge/vertex failure -- we will
use the compact version of this algorithm presented by
Pettie and Duan \cite{DuanP09}. The second case is a {\em new and unexplored}
case. We will show that we
can bound the number of preferred replacement paths in this case to $O(\sqrt{n \sigma})$ for a fixed vertex $t$.
This would imply that the total number of such paths is $O(\sigma^{1/2}n^{3/2})$. We are able to
bound the number of paths even though these paths may intersect with each other --  this
is a new feature of our analysis which is much different from the analysis done by
Parter and Peleg \cite{ParterP13} on a related problem.

Section \ref{sec:passes} deals with the first case. In Section \ref{sec:avoids},
we will apply our new approach to the special case when $\sigma =1$,
or there is a single source. In Section \ref{sec:problem}, we will discuss the
potential problems in extending our approach to multiple sources.
Section \ref{sec:multi1} and \ref{sec:multi2}  extends our approach
to multiple sources and in Section \ref{sec:data} we develop our data-structure
that can answer queries in $\tilde O(1)$ time.
\iflong
\else
To save space, we have omitted proofs in this extended abstract. The concerned reader may read
the proof in the full version of the paper.
\fi
