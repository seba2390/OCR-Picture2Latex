\appendix[Supplementary material]

\newcommand{\mysub}[1]{\subsection{\textbf{#1}}}
\newcommand{\mysubsub}[1]{\subsubsection{#1}}

%\section*{Supplementary material}

% \mysub{Changes based on previous reviews}
% \label{sec:app:reviews}

% \noindent
% This section is intended for readers who have reviewed the
% previous version of this paper, and summarizes the main changes we have
% made based on the feedback from the reviews.

% \mysubsub{Notion of Ballot Secrecy}
% In the previous form of this work, we defined ballot secrecy
% differently. Our earlier definition was based
% on a very strong form of fairness that essentially requires that both $A$ and $B$ should cast a vote.
% Since then, we have deeply reworked our fairness condition and our ballot secrecy notions. Essentially, our fairness
% condition requires that the attacker does not prevent a specific voter to progress to a next phase.
% As explained in~\Cref{sec:frame:ballotsec}, this is less restrictive than using synchronisation barriers as done
% in most of the literature. Our notion of ballot secrecy is now closely related to other existing definitions and
% we consider our notion of fairness itself as a (small) contribution since it plays the role of usual synchronisation barriers
% without its limitations discussed in~\Cref{sec:frame:ballotsec} and in \Cref{sec:back:stateArt}.

% Obviously, those modifications to ballot secrecy 
% have required many improvements on the conditions side as well
% in order to keep our Main Theorem sound whose the proof has been deeply reworked too.

% \mysubsub{Automating the Verification of our Conditions}
% In the earlier draft of this work, the definitions of phase roles, {\em idealised execution for $\vect{n}^v,\vect{n}^\id$}, \etc
% were more complex. Furthermore, no algorithm was presented to compute those objects.

% In this version, phase roles are defined as bijective renaming of the {\em honest execution} that is part of
% the given e-voting protocol. We explain in detail how all necessary objects can be constructed
% in linear-time when describing our algorithm, which allow for verifying all our conditions in
% \Cref{sec:case:verif}. We notably provide a simple heuristic for guessing leaking labels that is
% precise enough to conclude on all our case studies. This justifies our
% time comparison with respect to prior techniques of the time it takes for our technique
% to verify the sufficient conditions,
% since all encodings of the pre-processing can be done in linear-time.

% While it is clear that providing an actual implementation would have
% strengthened our contributions, we believe that it is important
% to base the approach on strong foundations first while making sure everything {\em could be} implemented easily as 
% witnessed by the algorithm we described in \Cref{sec:case:verif}.
% We would also like to point out the fact that eight years passed between the theoretical
% design of the ``swapping technique''~\cite{vote-ifip} (2008) and its actual implementation in ProVerif~\cite{vote-CSF16} (2016).

% \mysubsub{Improved Case Studies}
% In the present version and contrary to the earlier draft,
% we describe two case studies in detail in
% Section~\ref{sec:caseStudies:JCJ} and \ref{sec:caseStudies:LEE}.
% Describing these case studies in detail has enabled us to better explain the
% advantages 
% of using our method compared to other methods.
%  % \mysub{In-Depth Description of one Case Study (TODO)}
% % In a previous form, we only listed our case studies with high-level descriptions. We now fully describe two of them
% % in sections~\ref{sec:caseStudies:JCJ} and \ref{sec:caseStudies:LEE} and exploit this level of precision for recalling advantages of using our method compared to using previous methods.


\section{Model and Definitions}

\mysub{Term algebra}
\label{sec:app:model}
\label{subsec:term}
We now present the term algebra used to model messages
built and manipulated using various cryptographic primitives.
We assume an infinite set $\N$ of \emph{names}, used to represent
keys and nonces; and two infinite and disjoint sets of \emph{variables}
$\X$ and $\W$. Variables in~$\X$ are used to
refer to unknown parts of messages expected by participants,
while variables in~$\W$ (called {\em handles})
are used to store messages learned by the 
attacker.
%
We consider a \emph{signature}~$\Sigma$ (\ie a set of function
symbols with their arity). $\Sigma$ is the union
of two disjoint sets:
the \emph{constructor} and \emph{destructor} symbols, \ie, $\Sigma =
\Sigma_c \cup \Sigma_d$.
%
Given a signature $\mathcal{F}$, and a set of initial data
$\mathsf{A}$, we denote by $\T(\mathcal{F},\mathsf{A})$ the set of terms built
using atoms in $\mathsf{A}$ and function symbols in $\mathcal{F}$.
A {\em constructor term} is a term in $\T(\Sigma_c, \N \cup \X)$.
We denote by $\vars(u)$ the set of variables that occur in a term $u$
and call \emph{messages} the constructor terms that are \emph{ground} (\ie, $\vars(u) = \emptyset$).
Sequences of elements are shown bold (\eg $\vect{x},\vect{n}$).
% We denote by $\vect x$, $\vect n$, $\vect u$ a
% (possibly empty) sequence of variables, names, and terms respectively.
The application of a substitution $\sigma$ to a term $u$ is written
$u\sigma$, and $\dom(\sigma)$ denotes its \emph{domain}.
% {The \emph{positions} of a term are defined as usual.}


\begin{example}
\label{ex:app:signature}
Consider the signature\\[1mm]
\null\hfill
$\begin{array}{rl}
   \Sigma = \{&\sign,\versign,\;\pkv,\; \bl,\;\unbl,\;\com,\\
              &\;\open,\;\langle \, \rangle, \;
              \projl, \; \projr, \; \eq, \;\ok\}.
 \end{array}$
\hfill\null\\[1mm]
The symbols $\sign,\versign,\bl,\unbl,\com$ and $\open$ of
arity 2 represent signature, signature verification, blind signature, unblind, commitment and
commitment opening. Pairing is modelled using $\langle \rangle$ of arity 2, whereas projection
functions are denoted $\projl$ and $\projr$, both of arity 1.
Finally, we consider the symbol $\eq$ of arity 2 to model
equality tests, as well as the constant symbol $\ok$. This signature is
split into two parts:
$
\Sigma_c = \{\sign,\;\pkv,\;\bl,\;\unbl,\com,\;\langle \, \rangle, \;\ok\}$ and
$\Sigma_d = \{\versign,\;\open,\;\projl, \; \projr, \; \eq\}$.
\end{example}


\mysubsub{Equational Theories}
As in the process calculus presented in~\cite{BlanchetAbadiFournetJLAP08}, 
constructor terms are subject to an equational theory
used for
%this has proved very useful
for modelling algebraic properties of cryptographic primitives.
%(see \emph{e.g.}~\cite{CDL05-survey} for a survey).
Formally, we consider a congruence~$\theo$ on $\T(\Sigma_c,\N \cup \X)$,
generated from a set of equations $\E$ over $\T(\Sigma_c,\X)$.
%Thus, $\theo$ is closed  under substitutions and bijective renaming.
We say that a function symbol is {\em free} when it does not occur
in $\E$.
\begin{example}
\label{ex:app:xor}
To reflect the algebraic properties of the blind signature, we may
consider the equational theory generated by the following equations:\\[1mm]
\null\hfill$
\begin{array}{rcl}
\unbl(\sign(\bl(x_m,y),z_k),y) &=& \sign(x_m,z_k)\\
\unbl(\bl(x_m,y),y) &=& x_m. \\
\end{array}$\hfill\null
\end{example}



\mysubsub{Computation relation and rewriting systems}
\label{sec:app:comp}
We can also give a meaning to destructor symbols.
For this, we need a notion of \emph{computation relation}
$\redc : \T(\Sigma,\N)\times\T(\Sigma_c,\N)$ such that
for any term $t$, $(t\redc u\iff t\redc u')$ if, and only if, $u\theo u'$.
While the precise definition of the computation relation is unimportant
for this paper, we describe how it can be obtained from \emph{rewriting systems}.

A rewriting system is a set of rewriting
rules %of the form 
${\gfun(u_1,\ldots, u_n) \to u}$ where $\gfun$ is a
destructor, and $u, u_1, \ldots, u_n \in \T(\Sigma_c,\X)$.
A ground term~$t$ can be rewritten into $t'$ if there is  a
position~$p$ in~$t$ 
and a rewriting rule $\gfun(u_1,\ldots, u_n) \to u$
such that $t|_p = \gfun(v_1,\ldots,v_n)$ and $v_1 =_\E u_1\theta, \ldots, v_n=_\E u_n\theta$ for
some substitution $\theta$, and $t' = t[u\theta]_p$ (\emph{i.e.} $t$
in which the sub-term at position $p$ has been replaced by~$u\theta$).

Moreover, we assume that $u_1\theta,
\ldots, u_n\theta$, and $u\theta$ are messages.
Finally, for some term $t$, we have $t\redc u$ when $u$ is a message such that 
$t\to u$. We write $t\redc$ to denote that there exists some $u$ such
that $t\redc u$, and write
$t\redcb$ otherwise.

\begin{example}
\label{ex:app:rewriting-ap-ap}
%Pursuing Example \ref{ex:signature}, 
The properties of 
symbols in $\Sigma_d$ (see Example~\ref{ex:app:signature})
are reflected through the
following rewriting rules:
\[
\begin{array}{c}
\open(\com(x_m,y),y) \to x_m
\;\;\;\;\;\;
\eq(x,x) \to \ok\\
\versign(\sign(x_m,z_k),\pkv(z_k)) \to x_m\\
\proj_i(\langle x_1,x_2\rangle) \to x_i \;\;\mbox{ for $i \in \{1,2\}$.} 
\end{array}
\]
% \cam{Do we need the below paragraph here? Or maybe reference to some other
% 	paper}
This rewriting system is convergent modulo the equational theory $\E$
given in Example~\ref{ex:app:xor}, and induces a computation relation as described above.
For instance, we have that
$$\open(
  \versign( 
    t,
     \pkv(\mathrm{sk_A})
  ),
  k_c)\redc v
$$
where $t=     \unbl(
        \sign(
           \bl(
              \com(v,k_c),
               k_b
           ),
           \mathrm{sk_A}
        ),
        k_b)
     )$
     % \unbl\Bigl(
     %    \sign\bigl(
     %       \bl\bigl(
     %          \com(v,k_c),
     %           k_b
     %       \bigr),
     %       \mathrm{sk_A}
     %    \bigr),
     %    k_b)
     % \Bigr),
because 
$t\theo\sign(\com(v,k_c),\mathrm{sk_A}).$
\end{example}

\begin{example}
\label{ex:app:rewriting-AND-ap}
We are able to model the $\land$ boolean operators using a destructor
$\AND\in\Sigma_c\cap\Sigma_\pub$ and the following rewriting rule:
$\AND(x,y)\to \ok$.
The induced computational relation satisfies for any terms $t_1,t_2$ that
$\AND(t_1,t_2)\redc \ok$ if, and only if,
$t_1\redc$ and $t_2\redc$.
\end{example}



For modelling purposes, we also split the signature $\Sigma$ into two
parts, namely $\Sigma_\pub$ (public function symbols, known
by the attacker) and $\Sigma_\priv$ (private function symbols).
%We let be all the symbols from our running example be in $\Sigma_\pub$.
An attacker builds his own messages by applying public function symbols to
terms he already knows and that are available through variables
in~$\W$. Formally, a computation done by the attacker is a
\emph{recipe} (noted $R$), \ie, a term in $\T(\Sigma_\pub,\W)$.
%Recipes will be denoted by $R$, $M$, $N$.
% Note that although we do not give the attacker the ability to generate
% fresh names to use in recipes, we obtain essentially the same capability
% by assuming an infinite supply of public constants in
% $\Sigma_c \cap \Sigma_\pub$.

%%
%% Process algebra
%%

\mysub{Process algebra}
\label{subsec:procalg}
%%% START: interesting discussion about sync. barriers
% For some phases, a public deadline is announced allowing all agents to terminate properly
% what they need to do during that phase before the new one starts. Such phases shall be
% modeled using {\em synchronization barriers}. With such barriers, a new phase cannot start
% while any agent is still executing the previous phase.
% Voting phases are often of this kind. We come back to this modeling choice 
% in Section~\ref{sec:condi:tools}.\cam{Reference of ``this modeling
% 	choice'' not completely clear.}
% In the following, we use {\em phase} to refer to {\em synchronization barrriers}.
%%%% END

We assume $\Ch_\pub$ and $\Ch_\priv$ are disjoint sets of public and private channel
names and note $\Ch=\Ch_\pub\cup\Ch_\priv$. % as the set of all channel names.
Protocols are specified using the 
syntax in Figure~\ref{fig:syntax}.

% \lu{\footnotesize
% Concernant sequential replication: dans la litérature, recursive process veut dire $\mathrm{rec}X.P$ avec $X\in P$.
% Et on a une règle d'unfold. Ce n'est pas le comportement que l'on veut ici, sauf si on remplace TOUS les $0$ de $P$ par des $X$
% pour que ``quand on a fini d'exécuter une copie de $P$ par n'importe quel moyen, une nouvelle copie de $P$ apparait.''. Quand je
% googlise ``sequential replication'', je trouve un article TGC'2012 de Lili Xu qui introduit une notion très similaire.
% \normalsize}

 \begin{figure}[t]
   \null\hfill
   $\scalemath{0.8}{
  \begin{array}{rclcl}
    P,Q &:=&  0 & & \mbox{null}\\[0.5mm]
    &\mid & \In(c, x).P && \mbox{input}\\[0.5mm]
    &\mid&\Out(c, u).P &&\mbox{output} \\[0.5mm]
    &\mid& \Let \; x = v \;\In \; P \; \Else \; Q&&
    \mbox{evaluation}\\[0.5mm]
    &\; \mid \; & P \mid Q&&\mbox{parallel}\\[0.5mm]
    &\mid& \new n. P && \mbox{restriction} \\[0.5mm]
    &\mid&  !P && \mbox{replication} \\[0.5mm]
    &\mid&  \phase{i} P && \mbox{phase} \\[0.5mm]
  \end{array} 
  }$\hfill\null\\
  where $c \in \Ch$, $x \in \X$, $n \in \N$, $u \in \T(\Sigma_c, \N
  \cup \X)$, $i\in\mathbb{N}$,
  and $v\in\T(\Sigma, \N\cup\X)$.
  \caption{Syntax of processes}
 \label{fig:app:syntax}
 \end{figure}

Most of the constructions are standard.
The construct  $\Let \; x = v \;\In \;P \; \Else \; Q$
tries to evaluate the term $v$ and in case of success, 
\ie when $v \redc u$ for some message $u$, the process $P$ 
in which $x$ is substituted by~$u$ is executed;
otherwise the process $Q$ is executed.
Note also that the $\Let$ instruction together with the
$\eq$ theory (see Example~\ref{ex:app:rewriting-ap-ap}) can encode the usual
conditional construction.
% Indeed, the process $\Let \;x = \eq(u,v) \;\In
% \; P \; \Else \; Q$  executes~$P$ only if the computation succeeds
% on $\eq(u,v)$, that is only if $u\redc u'$, $v\redc v'$, and $u' \theo v'$ for some
% messages $u'$ and $v'$.
% We note that $\If\;u=v\;\Then\; P\; \Else\; Q$ is such a process.
The replication $!P$ behaves like an infinite parallel composition
$P|P|P|\ldots$.
We shall always deal with guarded processes of the form $\phase{i} P$.
Such a construct $\phase{i} P$ indicates that the process
$P$ may be executed only when the current phase is $i$.
%
% We can't define sync. phase for replicated processes (see ex. below
% so we just define simple 'phases'.
% [ phase1. ! phase2.out(ok) ]
% never can go to phase2 because always a [ ! phase2.out(ok) ]
%
The construct $\nu n.P$ allows to create a new, fresh name $n$.
For a sequence of names $\vect{n}$, we may note $\nu\vect{n}.P$
to denote the sequence of creation of names in $\vect{n}$ followed by $P$.
For brevity, we sometimes omit ``$\Else\;0$''
and null processes at the end of processes.
We write~$\fv(P)$ for %and $\bv(P)$,
the set of \emph{free variables} of~$P$, \ie the set
of variables that are not in the scope of an input or a $\Let$
construct.
A process $P$ is ground if $\fv(P) = \emptyset$.



The operational semantics of processes is given by a labelled transition
system over \emph{configurations} (denoted by $K$) $(\p;\phi;i$)
made of a multiset $\p$ of ground processes,
$i\in\mathbb{N}$ the current phase, and
a {\em frame} $\phi = \{w_1 \refer u_1, \ldots, w_n \refer u_n\}$
(\ie a substitution where $\forall i, w_i\in\W,\ u_i\in\T(\Sigma_c,\N)$).
The frame~$\phi$ represents the messages known to the attacker.
Given a configuration~$K$, $\phi(K)$ denotes its frame.
We often write $P \cup \p$  instead of $\{P\} \cup \p$
and implicitly remove null processes from configurations.
% Sometimes, we consider processes as configurations, in such cases, the corresponding
% frame is~$\emptyset$.

%We first give an example before explaining the transition rules of the system.
\renewcommand{\key}{\mathsf{key}}

\begin{figure}[t]
  \centering $
  \begin{array}[h]{rclr}
    V(\id,v) &=&\phase{1}
                 \new k.\new k'.\Out(c, \langle \pk(\key(\id)); s\rangle). 
              \In(c, x). \\   %&\text{expected: } \sign(e,k_R)\\    
             && \If\, \versign(x,\pk(k_R))=e &\\
             && \Then\, \phase{2} \Out(c,\unbl(x,k')). 
%               &\\  && 
             \In(c, y). \\   %&\text{expected: } \langle \_;M\rangle\\    
             && \If\, y=\langle y_1 ; M\rangle \\
             && \Then\;\Out(c,\pair{y_1}{\pair{M}{k}}) &\\
  \end{array}
  $
  \caption{Voter role of FOO (for some channel $c\in\Ch_\pub$, where
 $M = \com(v,k)$, 
$ e = \bl(M,k')$ and
$s=\sign(e,\key(\id))$)}
  \label{fig:app:foo-role}
\end{figure}


\begin{example}
  \label{ex:app:process}
We use the FOO protocol~\cite{fujioka1992practical}
(modelled as in~\cite{vote-CSF16})
 as a running example.
FOO involves voters and a registrar role.
In the first phase, a voter commits and then blinds its vote and
sends this blinded commit signed with his own signing key $\key(\id)$
to the registrar.
The function symbol $\key(\cdot)$ is a free
private function symbol associating a secret key to each identity.
The registrar is then supposed to blindly sign the committed vote
with his own signing key $k_R\in\Sigma_c\cap\Sigma_\priv$ and sends
this to the voter.
In the voting phase, voters anonymously output their committed
vote signed by the registrar and, on request, anonymously send
the opening for their committed vote.

The process corresponding to a voter session
(depending on some constant
$\id$ and a constant $v$)
is depicted in Figure~\ref{fig:app:foo-role}.
% The first three equations should be understood as syntactic sugar, to write processes in a more compact way.
A configuration corresponding to a voter $A$ ready to vote $v_1$
with an environment knowing the registrar's key is
$K_1=(\{V(A,v_1)\};\{w_R\mapsto k_R\};1)$.
\end{example}
%%
%% Semantics
%%
The operational semantics of a process 
is given by the relation
$\lrstep{\alpha}$
%\lum{note: semantics is closed to the one in Esorcis'16}
defined as the least relation over configurations satisfying the rules
in Figure~\ref{fig:semantics}.
For all constructs, phases are just handed over to continuation processes.
Except for the phases, the rules are quite standard and correspond to the
intuitive meaning of the syntax given in the previous section. 
\toRM{The first rule \textsc{In} % ($\inc$)
allows the attacker to send a message on a public channel as long as it is
the result of a computation done by applying a recipe to
%public function symbols on messages that are in
his current knowledge.
The second rule \textsc{Out} corresponds to the output of a term on a public channel:
the corresponding term is added to the frame
of the current configuration.
% which means that the attacker gains access to it.
The rule \textsc{Com} corresponds to an internal communication on a private channel
that the attacker cannot eavesdrop on nor tamper with.
% The fourth and fifth rules correspond to term evaluation.
% The next three rules allow one to execute a restriction, 
% unfold a replication, and  split a parallel composition.
Finally, the rule \textsc{Phase} allows a process to progress 
to its next phase
and the rule \textsc{Next} allows to drop the current phase and
progress irreversibly to a greater phase.}
%% Proposition:
% Intuitively, when \textsc{Next} is triggered to move to a phase $j$,
% only processes of the form $\phase j Q$ can execute actions. If possible,
% \textsc{Phase} can be used to make processes progress until reaching phase $j$.
% \cam{Can we give intuition how \textsc{Phase} and \textsc{Next} together model
% he right thing?}

The rules \textsc{In,Out,Next} are the only rules that produce observable
actions (\ie, non $\tau$-actions).
\toRM{However, for reasons that will become clear
later on (notably for Definition~\ref{def:honest-trace}),
we make a distinction when a process evolves using $\textsc{Let}$ or
$\textsc{Let-Fail}$.}
%
The relation $\lrstep{\alpha_1 \ldots \alpha_n}$ between
configurations (where~$\alpha_1 \ldots \alpha_n$ is a sequence of actions) 
is defined as the transitive closure of~$\lrstep{\alpha}$. 

% \begin{example}[]
% \label{ex:app:execution}
% Consider the following execution of 
% configuration $K_1$:
% $K_1\sint{\tr_h}(\emptyset;\phi;2)$, where\\[1mm]
% \null
% \hfill
% $
% \begin{array}{rl}
% \tr_h= & \tau.\tau.\Out(c,w_1).\In(c,R).\taut.\tau.\Phase{2}. \\
%        & \Out(c,w_2).\In(c,\pair{C}{w_2}).\taut.\Out(c,w_3)  \\
% \end{array}
% $\hfill
% \null
% and where $C$ is any constant in $\Sigma_c\cap\Sigma_\pub$,
% $R=\sign(\versign(\projr(w_1), \projl(w_1)),w_R)$,
% $\phi=\{
% w_1\mapsto\pair{\pk(k_\id)}{s},
% w_2\mapsto \sign(M,k_R),
% w_3\mapsto \langle n; M; k\rangle
% \}$,
% and, $s,M$ are as specified in \Cref{fig:foo-role}.
% This corresponds to a normal, expected execution of one protocol
% session.
% \end{example}





\mysub{Trace Equivalence}
\label{ap:model:eint}


Continuing Paragraph~\ref{subsec:trace-equiv}, we give the formal definition of static equivalence.

\begin{definition}%[Static equivalence]
A frame $\phi$ is \emph{statically included} in $\phi'$
when $\dom(\phi) = \dom(\phi')$, and
\begin{itemize}
\item for any recipe $R$
  such that $R\phi \redc u$ for some $u$,
 we have that $R\phi'\redc u'$ for some $u'$;
\item for any recipes $R_1,R_2$ such that
  $R_1\phi\redc u$ and $R_2\phi\redc u$ for some message $u$,
  there exists a message $v$ such that $R_1\phi'\redc v$ and
  $R_2\phi'\redc v$.
\end{itemize}
Two frames $\phi$ and $\phi'$ are in \emph{static equivalence},
written $\phi \estat \phi'$, if the two static inclusions hold.
\end{definition}


 \begin{example}
 \label{ex:app:static-ap}
Continuing Example~\ref{ex:eint}, we give the formal witness of statically inequivalence.
Recall that $\phi$ is as in Example~\ref{ex:execution} and
$\phi'=\phi \{v_1\mapsto v_2\}$
\ie the frame one obtains from $\phi$ by replacing the constant
$v_1$ by the constant $v_2$.
If we let $R_o$ be the recipe
$\open(\projr(\projl(w_3)), \projr(\projr(w_3)))$
and $R_1$ be the recipe $v_1$,
one would obtain $R_o\phi\redc v_1$ and $R_1\redc v_1\theo v_1$
while $R_o\phi'\redc v_2$ but $R_1\redc v_1\nottheo v_2$.
 \end{example}


Recall that
$\obs(\tr)$ is defined as the subsequence of $\tr$
obtained by erasing all the $\tau$ actions (\ie $\tau,\taut,\taue$).

\begin{definition}%[Trace equivalence]
  Let $K_1$ and $K_2$ be two configurations.
  We say that $K_1$ is \emph{trace included} in $K_2$,
  written $K_1 \sqsubseteq K_2$, when,
  for any $K_1\sint{\tr}K_1'$
  there exists $K_2\sint{\tr'}K_2'$ such that
  $\obs(\tr) = \obs(\tr')$
  and $\phi(K_1') \estat \phi(K_2')$.
  They are in \emph{trace equivalence}, written $K_1 \eint K_2$, 
  when $K_1 \sqsubseteq K_2$ and $K_2 \sqsubseteq K_1$.
\end{definition}



\mysub{Diff-Equivalence}
\label{ap:model:diff}

The semantics of bi-processes is defined as expected via a relation
that expresses when  and how a bi-configuration may evolve.
A bi-process reduces if, and only if,
both sides of the bi-process 
reduce in the same way triggering the same rule: \eg,
a conditional has to be evaluated in the same way on both sides.
For instance, the {\sc Then} and {\sc Else} rules for the {\sc let}
construct are depicted in \Cref{fig:biproc:sem}.

\begin{figure*}[t]
  \centering
  $  \begin{array}{ll}
    \textsc{Let}&(\phase i \Let \; x = \choice{v_l}{v_r} \; \In \; P \; \Else \; Q\cup \p; \phi; i) \; \lrstep{\taut} \;
                  (\phase i P\{x \mapsto \choice{u_l}{u_r}\} \cup
                  \p; \phi; i)\\
    \multicolumn{2}{r}{\mbox{
    when $v_l\redc u_l$ and $v_r\redc u_r$ for some $u_l,u_r$}}\\%[1mm]
% LET-ELSE
    \textsc{Let-Fail}&(\phase i \Let \; x = \choice{v_l}{v_r} \; \In \; P \; \Else \; Q\cup \p; \phi; i) \; \lrstep{\taue} \;
                       (\phase i Q \cup \p; \phi; i) 
                       \hfill \mbox{when $v_l\redcb$ and $v_r\redcb$}
  \end{array}$
  \caption{Two rules of the semantics for bi-processes}
  \label{fig:biproc:sem}
\end{figure*}

When the two sides of the bi-process reduce in different ways,
the bi-process blocks. The relation $\sint{\tr}_{\mathsf{bi}}$
on bi-processes is therefore defined as for processes.
This leads us to the following notion of diff-equivalence.

\begin{definition}
\label{def:diff-equiv}
A bi-configuration $K_0$ satisfies \emph{diff-equivalence} if for
every bi-configuration
$K = (\p;\phi)$ such that $K_0 \,\sint{\tr}_{\mathsf{bi}}\, K$
for some trace $\tr$, we have that:
\begin{itemize}
\item both sides generate statically equivalent frames:
  $\fst(\phi) \estat \snd(\phi)$;  
\item both sides are able to execute same actions:
  if $\fst(K) \lrstep{\alpha} A_L$ then there exists a
  bi-configuration~$K'$ such that $K \lrstep{\alpha}_{\mathsf{bi}} K'$ and
  $\fst(K') =A_L$ (and similarly for $\snd$).
\end{itemize} 
\end{definition}

% \section{Honest Executions}
% \label{sec:ap:honest-exe}
%   \begin{definition}
%     Let $\th$ be an honest trace (\ie a symbolic trace).
%   \begin{itemize}
%   \item  
%   Any trace $\tr=\th\sigma$ for $\sigma$ a substitution from second-order variables in $\th$ (\ie unknown parts)
%   to recipes is an {\em instantiation of $\th$}.
% \item  Given a trace $\tr$ and a frame $\phi$, we say that $\tr,\phi$ {\em follow a trace} $\tr'$
%   if for some bijection of handles $\rho$, one has $\tr\equiv_\phi (\tr'\rho)$.
% \item  Given a trace $\tr$ and a frame $\phi$, we say that $\tr,\phi$ {\em follow the honest trace}
%   when it follows an instantiation of the honest trace
% \item We say that a voter {\em had an honest interaction} in an execution when
%   there exist role session annotations $s_1,\ldots, s_n$ such that
%   the subtrace made of all actions labelled by this voter or $s_i$ with the resulting frame
%   follow the honest trace.
%   \end{itemize}
% \end{definition}


\mysub{Conditions}
\label{sec:app:conditions}
\begin{example}
\label{ex:app-leaking-phases}
  Consider a voter's role process $V(\id,v)=
\phase 1 \Out(a,\id).\Out(a,v)$
  (other components are unimportant here).
  % where $a$ is an anonymous channel.
  This trivial protocol is an abstraction of a registration phase
  (voter sends its identity) followed by a voting phase (voter sends
  its vote).  We show this does not ensure ballot secrecy.
  Consider the following fair execution:
  $(\S;\emptyset;1)\sint{\tr}(\emptyset;\phi;1)$
  with $\tr=\Out(a,w_\id).\Out(a,w_v).
\Out(a,w_\id').\Out(a,w_v')$
  and $\phi=\{w_\id\mapsto A, w_v\mapsto v_0, w_\id'\mapsto B,w_v'\mapsto v_1\}$.
  This execution has no indistinguishable counterpart in $\S_r$.
  Indeed, because the first message {\em reveals the identity} of the voter, 
  the attacker can make sure that the voter $A$ executes the first output (\ie $w_\id$)
  on the $\S_r$ side as well.
  After the first output $w_\id\mapsto A$, the $\S_r$ side can only output either $B$ or $v_1$
  (because $A$ votes $v_1$ in $\S_r$) but not $v_0$.
  However, because the second message {\em reveals the vote}, the attacker expects a message
  $v_0$ and can test whether $w_v$ equals $v_0$ or not.
  % Indeed, $v_0$ is a public constant so the attacker can test that
  % $w_v\phi\theo v_0$ and will detect if $v_1$ is output instead.
  To summarise, the only executions of $(\S_r;\emptyset;1)$ following the same trace $\tr$
  produce frames that are never statically equivalent to $\phi$.
  Thus, this  protocol does not ensure ballot secrecy because %  The main reason is
  in a single phase (\ie, phase 1), there is one output revealing the identity
  of the voter and one output revealing the voter's vote.
  % and hence the  attacker can link an identity to a vote, thereby
  % breaking ballot secrecy.

  However, the process $V(\id,v)=\phase 1 \Out(a,\id).\ \phase 2 \Out(a,v)$ ensures
  ballot secrecy and does not suffer from the above problem.  
  The attacker cannot force $A$ to execute its first message leaking
  identity and then immediately its second message leaking its vote,
  because doing so would {\em kill} the process $V(B,v_1)$ (which is still in phase 1)
  preventing the whole execution from being fair.
  Thus, the attacker has to trigger all
  possible first-phase actions of $A$ and $B$ before moving to
  the second phase.
%  reflecting deadline in practice.
  After the first phase, we end up with
  the processes $\{\Out(a,v_0), \Out(a,v_1)\}$ on the $\S$ side and
  $\{\Out(a,v_1),\Out(a,v_0)\}$ on the $\S_r$ side, which are indistinguishable.
  % because those two outputs are on the same channel and do not reveal any identity.
  
  Thus,
  in this first iteration, we split
  outputs revealing identity and outputs revealing votes in distinct
  phases. This enables breaking links between identity and vote.
%  (which is the core reason of attacks on ballot secrecy).
\end{example}


\section{Proofs}
\mysub{Proofs of the Main Theorem}
\label{sec:ap:proofs-thm}

\dishoLemma*
\begin{proof}
($\Rightarrow$)
  By fairness, we deduce that, in the given execution after the action $\mathtt{phase}(k)$,
  there are processes annotated $[\id_A,v_i]$ and $[\id_B,v_j]$ both at phase $k$.
  First item of the Dishonest Condition implies that $A$ and $B$ had (disjoint) honest interactions
  in $\tr_0.\mathtt{phase}(k)$ up to phase $k$.
  This allows us to define properly names $\nID{A},\nID{B},\nV{i},\nV{j}$
  and all (disjoint) authorities sessions involved in those two disjoint honest interactions
  (note that names used in authorities starting in phases $k'>k$ can be chosen arbitrarily).
  As a slight abuse of notation, we may omit the vote or the identity from those vectors
  and write for instance $\nID{A}$ to refer to $(\id_A,\nID{A})$.
  Moving backward some $\tau$ actions, one obtains a fair execution 
  \begin{equation}
    \begin{array}{ll}
\displaystyle
((\{
V(\nID{A},\nV{i}),
V(\nID{B},\nV{j})
\}\uplus\;!\,\roles &\\
\phantom{\{ \}}
\biguplus_{A\in\roles_o}
\{A(\nID{A},\nV{i}),
A(\nID{B},\nV{j})\}
;\phi_0;1)\\
\phantom{(}\sint{\tr_0'.\mathtt{phase}(k).\tr_1'}
(\p';\phi;k)&
    \end{array}
\label{eq:lem-cf-init}
\end{equation}
with $\obs(\tr)=\obs(\tr')$ where $\tr'=\tr_0'.\mathtt{phase}(k).\tr_1'$.
We now distinguish two cases whether $\th=\tr^h$ or not to prove that the
latter execution can also be executed starting with roles $A^{\forall}$ instead of $A$.

If $\th=\tr^h$ then there is only one instantiation of the honest trace.
Therefore, voters $A$ and $B$ followed the idealised trace in $\tr_0.\mathtt{phase}(k)$ up to phase $k$.
Therefore, their executions up to the action $\mathtt{phase}(k)$
can be exactly mimicked by executions of processes $A^\forall$ for $A\in\roles_o\cup\{V\}$ with appropriate names.
Indeed, once names $\nID{\id},\nV{i}$ are
fixed, there is only one possible execution (modulo $\theo$) following the trace $\tr^h$ and this
is, by definition of those processes, an execution $A^\forall$ can play.
Moreover, the resulting processes for $A$ and $B$ right after the action $\mathtt{phase}(k)$
are the same when starting with $A(\cdot,\cdot)$ for $A\in\roles_o\cup\{V\}$ or with $A^{\forall}(\cdot,\cdot)$;
they are indeed of the form $V^k_f(\cdot,\cdot)$. Hence, the final sub-trace $\tr_1'$ can equally be executed by roles $A^{\forall}$.
Note also that the resulting frame is $\psi=\phi$ and the resulting trace has same observable actions as $\tr'$.

Otherwise (\ie $\tr^h\neq\th$). We remark that the multiset of processes
at the beginning of Execution~\ref{eq:lem-cf-init} can be reached
from the multiset of processes
$\{S_f(A,v_i),S_f(B,v_j)\} \uplus \;!\,\roles$.
The Execution~\ref{eq:lem-cf-init} can thus be played by the right side of the biprocess
$\biproc^{D}$ (or by a biprocess one can obtain from it by applying a bijection of free public constants).
%
% \footnote{Not exactly because
% $\biproc^D$ considers only one voter process. Recall that currently, this case is useless because we make the assumption that $\th=\tr^h$.
% Two choices here for a future version: (i) either we apply the diff-equivalence of $\biproc^D$
% two times using contexts but we have
% to prove we can do so even though the context shares names (private names in $A_i$) or (i) we add
% $B$ as well in the biprocess and we can thus directly apply the condition.}.
% We can thus extract an execution on the right of $\biproc^D$ equals to the given one up to
% $\tau$ actions.
Applying diff-equivalence of $\biproc^D$ (\ie second item of the Dishonest Condition)
and the fact that diff-equivalence is stable by bijection of free, public constants,
allows us to replace $V$ (resp. role process $A$) by
$V^\forall$ (resp. $A^\forall$) in the latter execution whilst preserving the executability
of the same observable actions (\ie $\obs(\tr')$) and leading to a frame $\psi\estat\phi$.


Next, we remark that thanks to the constraint on phases, putting
$A^i$ in parallel instead of in sequence (as done in $A^\forall$)
allows to complete the same execution.
We can also remove $!\openAllBal$ from the starting multiset whilst preserving
the executability.
We thus get the desired execution with the appropriate multiset of processes at
the beginning.
\smallskip{}

In order to conclude,
we shall prove $\Res(\tr,\phi)=\Res(\tr',\psi)$.
% \lum{This part of the proof is similar to the one of Lemma~\ref{lem:direct}.}
In the case $\th=\tr^h$, it follows from $\psi=\phi$
and the fact that $\tr'$ has same observable actions as $\tr$.
Otherwise, we assume  $\Res(\tr,\phi)\not=\Res(\tr',\psi)$ for the sake of the
contradiction.
We remark that $BB(\tr,\phi)=BB(\tr',\psi)$ follows from 
$\phi\estat\psi$ and $\obs(\tr)=\obs(\tr')$.
Further, there exists an handle $w$ such that $\Out(c_b,w)\in\tr$ (and thus
$\Out(c_b,w)\in\tr'$),
$\Psi_b[w\phi]\redc u$ for some $u$ (and thus $\Psi_b[w\psi]\redc u'$ for some $u'$ since $\phi\estat\psi$ and $\Psi_b$ is a public term),
and $\Extract(w\phi)\redc v_l\in\V\cup\{\bot\}$, $\Extract(w\psi)\redc v_r\in\V\cup\{\bot\}$ with $v_l\neq v_r$. At least on one side,
the extraction does not lead to $\bot$ (otherwise we have $\bot=\bot$).
By symmetry, we assume $\Extract(w\phi)\redc v_l\in\mathcal{V}$.
%%%%%%%
We now consider a straightforward extension of the previously considered execution of the biprocess $\biproc^{D}$
  by adding the trace $\tr^O=\tau.\In(c_u,w).\taut.\Out(c_u,w_e)$. This trace corresponds to the replication of the $\openAllBal$
  process and a usage of one instance of the oracle which tries to extract a vote from the ballot $w$.
  Note that the given execution can be extended
  with this trace on the left (the conditional holds) and because $\biproc^D$ is diff-equivalent, on the right as well.
  We call $\phi_l^O$ (resp. $\phi_r^O$) the resulting frame on the left (resp. on the right).
  By diff-equivalence, it holds that $\phi_l^O\estat\phi_r^O$.
  We remark that $w_e\phi_l\theo v_l$ and
  $w_e\phi_r\theo v_r$. Recall that $v_l$ and $v_r$ are two different public constants not involved in equations
  in $E$. Therefore, $w_e\phi_r\nottheo v_l$.
  Hence the recipe $\eq(w_e, v_l)$ (remind that $v_l$ is a public constant)
  does not fail when applied on the left (\ie on $\phi_l$) but does fail when applied 
  on the right (\ie on $\phi_r$) contradicting $\phi_l^O\estat\phi_r^O$.
  

($\Leftarrow$)
Using the fact that $[\id_A,v_i]$ and $[\id_B,v_j]$ had an honest interaction in $\tr_0'.\mathtt{phase}(k)$ up to phase $k$,
one can show by gluing together phase roles the existence of a similar execution of the form
  \begin{equation}
    \begin{array}{ll}
\displaystyle
((\{
V(\nID{A},\nV{i}),
V(\nID{B},\nV{j})
\}\uplus\;!\,\roles &\\
\phantom{\{ \}}
\biguplus_{A\in\roles_o}
\{A(\nID{A},\nV{i}),
A(\nID{B},\nV{j})\}
;\phi_0;1)\\
\phantom{(}\sint{\tr_0'.\mathtt{phase}(k).\tr_1'}
(\p'';\phi;k).&
    \end{array}
\label{eq:lem-cf-init-other-dir}
\end{equation}

Via a similar proof than the one for $\Rightarrow$,
we make use of the diff-equivalence of $\biproc^D$ to get an execution with real role processes when $A$ and $B$ did not
follow the idealised trace; otherwise, we get the execution with real role processes from the uniqueness of executions following
$\tr^h$. The execution from $(\{V(\id_A,v_i),V(\id_B,v_j)\}\cup\,!\roles;\phi_0;1)$ can then
be obtained by creating appropriate names since they are pairwise distinct.  
\end{proof}


\mainTheorem*
\begin{proof}
% Outline of the proof: cut the given execution of $\S^t$ just before the tally (outputting $res$)
% to get an execution of $\S$.
% Apply Lemma~\ref{lem:cf} to obtain a nicer execution
% where $A$ and $B$ are both executed through the phases sub-parts $V^i$.
% Apply diff-equivalence of $\biproc^I$ to get
% an execution after swapping.
% Apply again Lemma~\ref{lem:cf} to obtain an execution starting with $\S_r$.
% Complete it with the tally outputting $res_r$. Use the tally condition to show that
% $res=res_r$.
Consider a fair execution $(\S;\phi_0;1)\sint{\tr}(\p;\phi;k)$. We shall prove that
there exists a fair execution $(\S_r;\phi_0;1)\sint{\tr'}(\q;\psi;k)$ with
$\obs(\tr)=\obs(\tr')$, $\phi\estat\psi$ and $\Res(\tr,\phi)=\Res(\tr',\psi)$.
We distinguish two cases whether $k=1$ or not.

If $k>1$ then $\tr=\tr_0.\mathtt{phase}(k).\tr_1$ for some
trace $\tr_1$ that does not contain $\mathtt{phase}(\cdot)$ action.
% Since $\th=\tr^h$, we also have that $A$ and $B$ follow the trace $\tr^h$.
We now apply Lemma~\ref{lem:cf} and obtain a fair execution
\begin{equation}
\begin{array}{ll}
(\{
\roles^\id(\nID{A},\nV{0}),
\roles^v(\nID{A},\nV{0}),&\\
\ \ \ \roles^\id(\nID{B},\nV{1}),
\roles^v(\nID{B},\nV{1})
\}\cup\;!\roles;
\phi_0;1)
\sint{\tr'}
(\q;\phi_1;k_f)
\end{array}
\label{t1:before-swap}
\end{equation}
for some $\tr'=\tr_0'.\mathtt{phase}(k).\tr_1'$
where all names in $\nID{A},\nID{B},\nV{0},\nV{1}$ are pairwise distinct names (except identity and vote),
such that $[\id_A,v_0]$ and $[\id_B,v_1]$ have an honest interaction in
$\tr_0'.\mathtt{phase}(k), \phi_1$ up to phase $k$,
$\obs(\tr')=\obs(\tr)$, $\phi\estat\phi_1$
and $\Res(\tr,\phi)=\Res(\tr',\phi_1)$.
We now deduce from 
the diff-equivalence of $\biproc^I$
(\ie the Honest Relations Condition, second item)
and the fact that diff-equivalence is stable by bijection of names,
an execution:
\begin{equation}
\begin{array}{ll}
(\{
\roles^\id(\nID{A},\nV{1}),
\roles^v(\nID{B},\nV{0}),&\\
\ \ \ \roles^\id(\nID{B},\nV{0}),
\roles^v(\nID{A},\nV{1})
\}\cup\;!\roles;
\phi_0;1)
\sint{\tr'}
(\q';\psi';k_f)
\end{array}
\label{t1:after-swap}
\end{equation}
with $\psi\estat\phi_1$.
Remark that in the latter execution,
processes labelled $[\id_A,v_1]$ (resp. $[\id_B,v_0]$) have an honest
interaction in $\tr_0'.\mathtt{phase}(k)$, $\psi'$ up to phase $k$ as well.
This relies on the fact that the honest trace is {\em phase-oblivious}
% \footnote{This is tricky and I've missed it at first:
% in the expected behavior, we need
% input of a id-leaking phase to not depend explicitely on output of a vote-leaking phase (\eg $\th=\Out(c,w).\In(c_\id,w).p_2.\In(a,w)$ would be bad).
% This is now define and required in the honest-relations condition.}
by the Honest Relations Condition.
Thereby, if
(i) a voter follows the honest trace up to phase $k$ for all phases having the same leaking labels isolately, then
(ii) it follows the honest trace up to phase $k$. Property (i) for $A$ and $B$
on Execution~\ref{t1:after-swap} follows from the fact this property holds
in Execution~\ref{t1:before-swap} and is transferred to Execution~\ref{t1:after-swap} by
the diff-equivalence.
For instance, processes
in $\roles^\id(\nID{A},\nV{0})$ and $\roles^v(\nID{B},\nV{1})$ follow the honest trace phase-by-phase
up to phase $k$ in Execution~\ref{t1:before-swap} (because voters $A$ and $B$ follow the honest trace up to phase $k$
in that execution).
By diff-equivalence, $\roles^\id(\nID{A},\nV{1})$ and $\roles^v(\nID{A},\nV{1})$ follow the
honest trace in Execution~\ref{t1:after-swap} up to phase $k$ and thus 
processes labelled $[\id_A,v_1]$ have an honest interaction in Execution~\ref{t1:after-swap} up to phase $k$.
We also have that $[\id_A,v_1]$ casts a ballot, if and only if, $[\id_B,v_0]$ does so. Therefore,
Execution~\ref{t1:after-swap} is fair as well.
By Lemma~\ref{lem:cf}, we deduce the existence of a fair execution
\begin{equation*}
(\S_r;\phi_0;1)\sint{\tr''}(\q'';\psi_1;k_f)
%\label{t1:after-swap-s}
\end{equation*}
such that  $\obs(tr'')=\obs(\tr')$,
$\psi\estat\psi_1$ and
$\Res(\tr',\psi)= \Res(\tr'',\psi_1)$.
\smallskip{}

It remains to show that $\Res(\tr_0,\phi_0)=\Res(\tr'',\psi_0)$.
Since
$\Res(\tr',\psi)=\Res(\tr'',\psi_1)$
and
$\Res(\tr_0,\phi_0)=\Res(\tr',\phi_1)$,
it suffices to show 
$\Res(\tr',\phi_1)=\Res(\tr',\psi)$.
We let $\phi_l=\phi_1$, $\phi_r=\psi$,
$\vect{b}_l=\BB(\tr',\phi_l)$, and,
$\vect{b}_r=\BB(\tr',\phi_r)$.
First, we have that if $\Out(c_b,w_b)$ occurs in $\tr'$ then
$w_b$ induces a valid ballot on the left if, and only if, it induces a valid ballot
on the right. This is because $\phi_l\estat\phi_r$ and $\Psi_b[]$ is a public term (and thus induces a recipe).
Let us first assume that either $\id_A$ or $\id_B$ casts a ballot. In such a case, by fairness, both cast a ballot.
Therefore, there are two handles $w_0,w_1$ corresponding to the honest casting of $[\id_A,v_0]$ (resp. $[\id_A,v_1]$)
and $[\id_B,v_1]$ (resp. $[\id_B,v_0]$)
on the left (resp. on the right). We have that
$\Extract(w_j\phi_l)\redc v_j$
and
$\Extract(w_j\phi_r)\redc v_{1-j}$
for all $j=0..1$.
We can now split the set of valid ballots into ballots $w_0,w_1$ and the others: for $d\in\{l,r\}$,
one has $\vect{b}_d=\{w_0\phi_d,w_1\phi_d\}\uplus\{b_d^1,\ldots,b_d^l\}$
where $b_d^i=w^i\phi_d$
and $\Extract(\{w_0\phi_l,w_1\phi_l\})=
\Extract(\{w_0\phi_r,w_1\phi_r\})=\{v_0,v_1\}^\#$. It remains to show that
$\Extract(\{b_l^1,\ldots,b_l^l\})=
\Extract(\{b_r^1,\ldots,b_r^l\})$.
We actually have that 
$\Extract(b_r^i)=
\Extract(b_r^i)$ for all $1\le i\le l$
as a direct consequence of the Tally Condition.
If neither $A$ nor $B$ cast a ballot then $\Res(\tr',\phi_1)=\Res(\tr',\psi)$
stems from $\Extract(b_r^i)=\Extract(b_r^i)$ for all $1\le i\le l$.

If $k=1$ then no $\mathtt{phase}(\cdot)$ action occurs in $\tr$.
In particular, the phase roles for phase 1 can also perform this execution.
Formally, replacing $\S$ by the following process allows for performing the same execution:
$\biguplus_{A\in\roles_o\cup V}
  \{A^1(\nID{A},\nV{i}),
    A^1(\nID{B},\nV{j})\}\uplus !\roles$.
As a subset of the latter,
$\roles^\id(\nID{A},\nV{1}),
\roles^v(\nID{B},\nV{0}),
\roles^\id(\nID{B},\nV{0}),
\roles^v(\nID{A},\nV{1})
\}\cup\;!\roles$
is also able to perform the given execution.
We conclude by the Honest relation condition.
The proof that $\Res(\cdot)$ is preserved
is a particular case of the previously discussed proof for the
$k>1$ case.
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

\section{Case Studies}
\label{ap:caseStudies}
(Resuming \Cref{sec:case:verif})
\textit{(Syntactical check)}
If (i) the vote $v_i$ does not syntactically occur at all in outputs of id-leaking phases (\ie in $\roles^\id(\nID{i},\nV{i})$)
and (ii) there is no vote-leaking phase before an id-leaking phase in the honest trace $\th$
then the condition is satisfied since item 2 trivially holds then.
%This is the case of JCJ for instance.


We now state that $\biproc^T$ can be used to verify the Tally
Condition.
\begin{restatable}{lemma}{tally}
\label{lem:direct}
  If $\biproc^T$ is diff-equivalent
  then $\biproc$ is diff-equivalent and
  the protocol ensures the Tally Condition.
\end{restatable}
\begin{proof}
  % The outline of the proof is as follows: we first remark that $\biproc$ is diff-equivalent as well, then
  % we use the oracle $\openAllBal$
  % to show that the Tally conditions holds.
  % Finally we conclude by applying
  % Lemma~\ref{lem:interm}.

  Diff-equivalence is stable by removal of processes in the initial multiset.
  Formally, for a biprocess $\biproc$,
  if $\biproc=(\{P\}\cup\q;\phi)$ is diff-equivalent then $(\q;\phi)$ is diff-equivalent.
  This implies that $\biproc$ is diff-equivalent as well.
  Now, let us show that the Tally condition holds.

  % It remains to show that the diff-equivalence of $\biproc^T$ implies the Tally Condition.
  % In that case
  We can actually prove that the diff-equivalence of $\biproc^T$ implies that
  for any execution of $\biproc$, the two executions on both sides yield exactly the same
  tally's outcome (w.r.t.~$\Res(\cdot)$). The proof of this is the same as the proof of
  the Lemma~\ref{lem:cf}  in \Cref{sec:ap:proofs-thm}.
  

 %  \textit{(If $tr_h=\tr^h$).} Then we show that the diff-equivalence of $\biproc^D_r$ implies the Tally
%   Condition. This suffices to conclude since the diff-equivalence of $\biproc^D$ implies the diff-equivalence of
%   $\biproc^D_r$.
% % That would conclude the proof by applying Lemma~\ref{lem:interm}.
%   Consider a trace $\tr$ and an execution of $\biproc$ of that trace that is fair on the left
%   (\ie considering the left part of that execution)
%   leading to the two frames $\phi_l,\phi_r$. Since $\biproc$ is diff-equivalent, we have that
%   $\phi_l\estat\phi_r$.
%   Since the left part of the considered execution is fair, $A$ and $B$ followed the honest trace and cast a ballot.
%   Since $\phi_l\estat\phi_r$ and the two executions on both side followed the same trace, $A$ and $B$ also cast
%   a ballot on the right.
%   % We let $\nID{A},\nV{0}$ (resp. $\nID{B},\nV{1}$)
%   % be the names created for $A$ (resp. for $B$).
%   Let $\ba_A^0$ (resp. $\ba_A^1$) be the ballot cast by $[A,0]$ (resp. $[A,1]$)
%   on the left of the execution under consideration.
%   We define similarly $\ba_B^1$ and $\ba_B^0$.
%   Note that since here we deal with the case $\th=\tr^h$, those ballots match with the ones used
%   in the conditional $\Psi_{\lnot AB}$ in $\openBal$.
%   % \lucca{TODO}
%   % Since $\th=\tr^h$, we have that the ballot actually cast by $A$ on the left (resp. on the right) is
%   % $\ba_A^0$ (resp. $\ba_A^1$). Similarly for $B$.

%   Let $\ba$ be a valid ballot in the BB on the left: $\ba=w_\ba\phi_l$ where $\Out(b,w_\ba)\in\tr$ and $\Psi_b[w_\ba\phi_l]\theo\ok$.
%   Since $\Psi_b$ is public and $\phi_l\estat\phi_r$, we also have that $\ba_r=w_\ba\phi_r$ is a valid ballot
%   in the BB on the right: $\Psi_b[w_\ba\phi_r]\redc$.
%   Indeed, $\Psi_b[w_\ba]$ constitutes a recipe that the attacker can use.
%   We now distinguish two cases.

%   (i) If $\ba\theo\ba_A^0$ or $\ba\theo\ba_B^1$ then the Tally condition is satisfied for this ballot
%   (item 1. of the condition).

%   (ii) Otherwise, $\ba\nottheo\ba_A^0$ and $\ba\nottheo\ba_B^1$ and we shall prove that
%   there exists $v\in\V\cup\{\bot\}$ such that
%   $\Extract(w_\ba\phi_l)\redc v$ and
%   $\Extract(w_\ba\phi_r)\redc v$.
%   % We first remark $w_\ba\phi_r\nottheo\ba_A^1$ and $w_\ba\phi_r\nottheo\ba_B^0$.
%   % Indeed, if $w_A$ is the handle concluding the honest interaction of $A$ on the left, then
%   % $w_A\phi_l\theo\ba_A^0$ and $w_A\phi_r\theo\ba_A^1$. The attacker can thus use the test $w_A =^? w_\ba$ to distinguish
%   % $\phi_l$ from $\phi_r$ in case $w_\ba\phi_l\theo\ba_A^1$ and similarly for $B$.
%   For the sake of the contradiction, we assume that this is not the case. By definition of $\Extract(\cdot)$ this implies
%   that there exists two different $v_l,v_r\in\V\cup\{\bot\}$ such that
%   $\Extract(w_\ba\phi_l)\redc v_l$ and
%   $\Extract(w_\ba\phi_r)\redc v_r$.
%   Recall that $v_l$ and $v_r$ are two different public constants not involved in equations
%   in $E$. Therefore, $w_e\phi_r\nottheo v_l$.
%   One of the $v_i$ must be different from $\bot$.
%   By symmetry, we assume $v_1\in\mathcal{V}$.

%   We now remark that the execution of $\biproc$ under consideration can also be 
%   executed by $\biproc^D$ (or $\biproc^D_r$ for the case (ii)).
%   We now consider a straightforward extension of that latter execution
%   by adding the trace $\tr^O=\tau.\In(c_b,w_\ba).\taut.\taut.\Out(c_u,w_e)$. This trace corresponds to the replication of the $\openAllBal$ (or $\openBal$ for the case (ii))
%   process and a usage of one instance of the oracle which tries to extract a vote from the ballot $w_\ba$.
%   Note that the given execution can be extended
%   with this trace on the left since the conditional of
%   that session of the oracle holds: indeed the underlying ballot is valid
%   and for the case (ii) by definition of $\Psi_{\lnot AB}$ and the fact that
%   $\ba$ is not equal to the ballot of $A$ and $B$.
%   Moreover, since $\biproc^D$ (resp. $\biproc^D_r$)
%   is diff-equivalent, the execution can be extended with
%   $\tr^O$ on the right as well.
%   We call $\phi_l^O$ (resp. $\phi_r^O$) the resulting frame on the left
%   (resp. on the right).
%   By diff-equivalence, it holds that $\phi_l^O\estat\phi_r^O$.
%   We remark that $w_e\phi_l\theo v_l$ and
%   $w_e\phi_r\theo v_r$.
%   Hence the recipe $\eq(w_e, v_l)$ (remind that $v_l$ is a public constant)
%   does not fail when applied on the left but fail when applied on the right contradicting $\phi_l^O\estat\phi_r^O$.
\end{proof}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

\section{Additional explanations on the swapping technique}
\label{sec:ap:swapping}

\mysub{Example of modified protocol using swapping}
\label{sec:app:swapping}
  We consider the voter process from Example~\ref{ex:leaking-phases}; \ie
  $V(\id,v)=\phase 1 \Out(a,\id). \phase 2 \Out(a,v)$.
  We have that\linebreak[4]
  $(\{V(A,\choice{v_1}{v_2}),
V(B,\choice{v_2}{v_2})\};\emptyset;1)$ is
  not diff-equivalent since after the two outputs
  $\Out(a,A)$, $\Out(a,B)$, the resulting multiset of processes is
  $\{\Out(a,\choice{v_1}{v_2}), \Out(a,\choice{v_2}{v_1})\}$ which is
  obviously not diff-equivalent. However, if one is allowed to swap the
  order of the two processes on the right side of that biprocess, he
  would obtain
  $\{\Out(a,\choice{v_1}{v_1}),\linebreak[4] \Out(a,\choice{v_2;v_2})\}$ which is
  diff-equivalent.

\mysub{Restrictions of the swapping technique}
\label{sec:app:swaprestr}

  We here provide support for the claims we made in the introduction about the different problems the swapping approach cannot
  tackle (while our approach can).
%  \begin{enumerate}
    First, it cannot deal with honest roles present in different phases
    (except for the voter role).
      Indeed, such roles would require synchronisation barriers.
      Moreover, because a potentially unbounded number of dishonest
      voters communicate with those authorities, this requires modelling
      an unbounded number of sessions for them.
      However, in the swapping approach, %replication can be combined with sychronization barrier only in a constrained way
      there cannot be a replication underneath a synchronisation
      barrier, which mean we cannot model such roles.\toRM{\footnote{Splitting the role process in two multiple processes
        exchanging data through a private channel during the synchronisation barrier is not an option because
	it does not provide the swapping capability.}}
      We encountered this problem for a simplified variant of JCJ and Belenios:
      we failed to model an unbounded number of sessions of the registrar role
%      (needed if one considers unbounded number of dishonest voters)
      that creates and sends credentials to voters in the registration phase and
      then send encrypted credentials to the bulletin box (so that the latter can
      verify eligibility).
      % \lum{hum, find better example would be nice here}

      
	Second, and similarly, it cannot tackle threat models
	{\em without a
    dishonest voter}, because this would require explicitly modelling an arbitrary number of honest
    voters. Since they are
    present in multiple phases, this would require replication.
    % Second, it cannot tackle threat models where {\em no dishonest voter} is assumed.
    %   Basically for the same reason as above. Indeed, in such a case, arbitrary number of honest voters have to
    %   be explicitely modeled in the system thus requiring a replication.
    %   % But voters are present in multiple phases and a replication is necessary to create unbounded number of voters.
      
      Third, when it comes to leveraging the swapping technique in ProVerif,
      spurious attacks arise
      when the protocol's security also relies on the {\em freshness of some data from previous phases}.
      The problem is that for the
      generated processes,
      ProVerif considers two different sessions of a certain phase
      using the {\em same data} resulting from {\em one single} session of a
      previous phase, as a valid execution.
      The reason is that, for a fixed swap strategy, 
      ProVerif replaces synchronisation barriers of a process $P$
      by private communications exchanging all data the process
      currently knows
      with another process $Q$ with which the swap occurs.
%
      Those new private communications are abstracted by the
      Horn-Clause approximations used by ProVerif:
      an input on a private channel $p$ is not consumed upon use, and can be replayed later on.
      Therefore, % explains that instead of swapping data with a fresh sessions of $Q$, 
      ProVerif also explores the possibility of swapping data with an
      old session of $Q$ whose data has already been swapped before.
      This caused the spurious attacks for JCJ and Belenios (see \Cref{fig:benchmarks}); the credential being the fresh data coming
      from the registration phase and used during the voting phase.
      % A minimal, practical, scenario causing a false attack relying on this problem is depicted in Figure~\ref{fig:problem-freshness}.

      % \begin{figure}[ht]
      %   \centering
      %   % \includegraphics[width=1.1\textwidth]{./img/problemFreshness.png}
      %   \caption{Generic Example}
      %   \label{fig:problem-freshness}
      % \end{figure}
      
    % \item it cannot deal with {\em revote}. This is also because of the constrain on replication's usages.
    %   It is not possible to model an unbounded number of voters sessions since one voter
    %   session features sync. barriers.
      Finally, the swapping technique suffers from an {\em exponential blow up}.
    Indeed, the compiler produces $\Pi_j (n_j!)$ processes where $n_i$
    is the number of processes active at phase $i$ (\eg 3 phases,
    $n_i=3$ lead to 216 processes to verify).  This is unsurprising
    since the compiler has to generate as many processes as possible
    swaps, to guess one that yields security.
    The same problem arises in Tamarin implementing the swapping technique through multisets~\cite{dreier2017beyond}
    since the tool may have to explore all possible shufflings of multisets for each phase.
%  \end{enumerate}

% \input{oldIdeas}
% \input{stateArt}
% \input{generalIdeas}
% \input{completeExample}
% \input{refs}
% \input{oldies}
%\input{graveyard}
