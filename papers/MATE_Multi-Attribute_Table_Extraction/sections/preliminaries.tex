\section{Preliminaries}\label{sec:preliminaries} 
Our approach for enabling multi-attribute joins extends the common inverted index structure.

\textbf{Inverted index.} The inverted index is a structure that maps the content, such as tokens or words, to their containing structures, i.e., tables, rows, and columns~\cite{fernandez2018aurum, abedjan2015dataxformer}. In this work, we extend the index as proposed for the DataXformer system~\cite{abedjan2015dataxformer}: 
\newline
\begin{equation} \label{eq_conventional_inverted_index}
% \vspace{-.2cm}
\small
    v_i \mapsto PL_i = \{ (T_{i1},\ C_{i1},\ R_{i1}),\ (T_{i2},\ C_{i2},\ R_{i2}),\ ... \}.
\end{equation}
% \vspace{-.2cm}
\newline
where, $v_{i}$ is a value and $T_{ij}$, $C_{ij}$, and $R_{ij}$ are the identifiers of the corresponding tables, columns, and rows in the corpus, respectively. This list of triplets is called \textit{Posting List} (PL). We also call every single triplet a PL item.

\textbf{Discussion. } 
Many state-of-the-art systems leverage the inverted index with small alternations~\cite{zhu2019josie,xiao2009top,chaudhuri2006primitive}.
Given a single-attribute join key, the current systems retrieve the PL items for each value in the key column and the number of returned PL items represents the joinability score for each table.
To use the same benefits and optimizations for n-ary joins, we need to generate a multi-attribute inverted index that maps every possible combination of cell values to their location in the tables. For instance, in our running example, we would like to have a PL item that maps the key value of <``Muhammad'', ``Lee'', ``US''> to the rows that contain both of these values at the same time.

One can use a straightforward algorithm that leverages the original inverted index to find the multi-attribute joinable tables. This algorithm obtains the PLs of one single query column first and then verifies whether the values of the remaining query columns appear in the same tables and rows.

As previously discussed, this approach leads to a large number of false positive rows that require a second verification step.
A \textit{false positive row (FP row)} is a row from a candidate table that only contains a subset of join attribute values. For instance, if the search goal is to find joinable tables based on a given 2-column key, candidate rows that are retrieved based on one attribute of the join key and thus only contain one value of the key value combination are considered as FPs and should be excluded from the joinability calculation.
A \textit{false positive table (FP table)} is a candidate table with FP rows that is not among the top-$k$ joinable tables. From here on, we refer to FP rows as FPs unless we explicitly specify the type of FPs.
The FP rate can be up to $1000$ times higher than the actual number of joinable table rows. For each additional row, the discovery system has to compare each value to the composite key values of the input query.

\textit{Example 2.} Going back to our example in Figure~\ref{fig:example}, for the value ``Muhammad'' in the $1^{st}$ row of the query column $q_1$, there are three hits in the $2^{nd}$, $5^{th}$ and $6^{th}$ rows of $T_1$ and column \textit{Vorname}. These rows are highlighted in red. To find the exact matches for the remaining key values ``Lee'' and ``US'' in the second and third query columns ($q_2$ and $q_3$), the system has to check every other value in rows $2$, $5$, and $6$ in Table~$T_1$. Here, \system checks $9$ value matches only for the first key value <``Muhammad'', ``Lee'', ``US''>.
Alternatively, one would have to send two other independent queries against the index to obtain all rows where ``Lee'' and ``US'' occur. 
However, if an oracle could confirm or deny the existence of ``Lee'' and ``US'' with a single operation, the system would only need to check $3$ values.
This optimization would drastically improve the runtime for calculating the joinability score $\jmath$ for multi-attribute keys.
Thus, an index element is required that conveys evidence of whether a particular row contains a given composite key or not. We call this additional element, \textit{super key}. 
%In the next section, we explain our system design and we show how \system generates the \textit{super key}.
