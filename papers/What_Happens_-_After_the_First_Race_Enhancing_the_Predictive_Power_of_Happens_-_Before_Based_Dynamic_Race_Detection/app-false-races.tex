%!TEX root = main.tex

We evaluate existing tools that
use happens-before based race detection to
check if they report false (unschedulable) races.

We use the following program in Figure~\ref{fig:example1} to assess if these
tools guarantee soundness.
The Java source code for this program is in Figure~\ref{simple_java}
and the C source code is in Figure~\ref{simple_c}

\input{programs}

\subsection{\fasttrack}

When run on \fasttrack, the Java program in Fig~\ref{simple_java}, \fasttrack~produces
the following output:

\vspace{0.5cm}
\hrule
{\small
\begin{verbatim}
## 
## =====================================================================
## HappensBefore Error
## 
##          Thread: 2    
##           Blame: Test.y_I
##           Count: 1    (max: 100)
##     Guard State: [(0:0) (1:1)]
##           Class: Test
##           Field: null.Test.y_I
##           Locks: []
##         Prev Op: write-by-thread-1
##      Prev Op CV: [(0:0) (1:1)]
##          Cur Op: read
##       Cur Op CV: [(0:1) (1:0) (2:1)]
##           Stack: Use -stacks to show stacks...
## =====================================================================
## 
## 
## =====================================================================
## HappensBefore Error
## 
##          Thread: 2    
##           Blame: Test.x_I
##           Count: 1    (max: 100)
##     Guard State: [(0:0) (1:1)]
##           Class: Test
##           Field: null.Test.x_I
##           Locks: []
##         Prev Op: read-by-thread-1
##      Prev Op CV: [(0:0) (1:1)]
##          Cur Op: write
##       Cur Op CV: [(0:1) (1:0) (2:1)]
##           Stack: Use -stacks to show stacks...
## =====================================================================
## 
\end{verbatim}
}
\hrule
\vspace{0.5cm}

That is, the flags both the fields \texttt{Test.y} and \texttt{Test/x}.
However, in any execution in \texttt{Test.x} both written and read by different threads,
the read always occurs before the write (with a read on \texttt{y} separating them).

\subsection{ThreadSanitizer}

We run the C program in Fig~\ref{simple_c} on ThreadSanitizer (shipped with LLVM).

\vspace{0.5cm}
\hrule
{\small
\begin{verbatim}
==================
WARNING: ThreadSanitizer: data race (pid=76224)
  Read of size 4 at 0x0001030ba074 by thread T2:
    #0 Thread2(void*) simple_race.cc:13 (a.out:x86_64+0x100000d1e)

  Previous write of size 4 at 0x0001030ba074 by thread T1:
    #0 Thread1(void*) simple_race.cc:8 (a.out:x86_64+0x100000cc9)

  Location is global 'y' at 0x0001030ba074 (a.out+0x000100001074)

  Thread T2 (tid=747232, running) created by main thread at:
    #0 pthread_create <null>:1600736 (libclang_rt.tsan_osx_dynamic.dylib:x86_64h+0x283ed)
    #1 main simple_race.cc:27 (a.out:x86_64+0x100000df3)

  Thread T1 (tid=747231, finished) created by main thread at:
    #0 pthread_create <null>:1600736 (libclang_rt.tsan_osx_dynamic.dylib:x86_64h+0x283ed)
    #1 main simple_race.cc:26 (a.out:x86_64+0x100000dd4)

SUMMARY: ThreadSanitizer: data race simple_race.cc:13 in Thread2(void*)
==================
==================
WARNING: ThreadSanitizer: data race (pid=76224)
  Write of size 4 at 0x0001030ba070 by thread T2:
    #0 Thread2(void*) simple_race.cc:14 (a.out:x86_64+0x100000d3a)

  Previous read of size 4 at 0x0001030ba070 by thread T1:
    #0 Thread1(void*) simple_race.cc:8 (a.out:x86_64+0x100000cae)

  Location is global 'x' at 0x0001030ba070 (a.out+0x000100001070)

  Thread T2 (tid=747232, running) created by main thread at:
    #0 pthread_create <null>:1600736 (libclang_rt.tsan_osx_dynamic.dylib:x86_64h+0x283ed)
    #1 main simple_race.cc:27 (a.out:x86_64+0x100000df3)

  Thread T1 (tid=747231, finished) created by main thread at:
    #0 pthread_create <null>:1600736 (libclang_rt.tsan_osx_dynamic.dylib:x86_64h+0x283ed)
    #1 main simple_race.cc:26 (a.out:x86_64+0x100000dd4)

SUMMARY: ThreadSanitizer: data race simple_race.cc:14 in Thread2(void*)
==================
ThreadSanitizer: reported 2 warnings
\end{verbatim}
}
\hrule
\vspace{0.5cm}

ThreadSanitizer also reports a race on both global locations \texttt{x} and \texttt{y}.

\subsection{Helgrind}

Helgrind is a data race detector integrated with Valgrind.
We analyzed the C program in Fig~\ref{simple_c}.
\vspace{0.5cm}
\hrule
% \vspace{0.5cm}
{\small
\begin{verbatim}
==2403== Helgrind, a thread error detector
==2403== Copyright (C) 2007-2015, and GNU GPL'd, by OpenWorks LLP et al.
==2403== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==2403== Command: ./a.out
==2403== 
==2403== ---Thread-Announcement------------------------------------------
==2403== 
==2403== Thread #3 was created
==2403==    at 0x596F30E: clone (in /usr/lib64/libc-2.17.so)
==2403==    by 0x4E41FD9: do_clone.constprop.4 (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x4E434C8: pthread_create@@GLIBC_2.2.5 (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x4C3064A: pthread_create_WRK (hg_intercepts.c:427)
==2403==    by 0x4C31728: pthread_create@* (hg_intercepts.c:460)
==2403==    by 0x400718: main (simple_race.cc:27)
==2403== 
==2403== ---Thread-Announcement------------------------------------------
==2403== 
==2403== Thread #2 was created
==2403==    at 0x596F30E: clone (in /usr/lib64/libc-2.17.so)
==2403==    by 0x4E41FD9: do_clone.constprop.4 (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x4E434C8: pthread_create@@GLIBC_2.2.5 (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x4C3064A: pthread_create_WRK (hg_intercepts.c:427)
==2403==    by 0x4C31728: pthread_create@* (hg_intercepts.c:460)
==2403==    by 0x4006F9: main (simple_race.cc:26)
==2403== 
==2403== ----------------------------------------------------------------
==2403== 
==2403== Possible data race during read of size 4 at 0x601044 by thread #3
==2403== Locks held: none
==2403==    at 0x4006A3: Thread2(void*) (simple_race.cc:13)
==2403==    by 0x4C3083E: mythread_wrapper (hg_intercepts.c:389)
==2403==    by 0x4E42E24: start_thread (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x596F34C: clone (in /usr/lib64/libc-2.17.so)
==2403== 
==2403== This conflicts with a previous write of size 4 by thread #2
==2403== Locks held: none
==2403==    at 0x40068E: Thread1(void*) (simple_race.cc:8)
==2403==    by 0x4C3083E: mythread_wrapper (hg_intercepts.c:389)
==2403==    by 0x4E42E24: start_thread (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x596F34C: clone (in /usr/lib64/libc-2.17.so)
==2403==  Address 0x601044 is 0 bytes inside data symbol "y"
==2403== 
==2403== ----------------------------------------------------------------
==2403== 
==2403== Possible data race during write of size 4 at 0x601040 by thread #3
==2403== Locks held: none
==2403==    at 0x4006AE: Thread2(void*) (simple_race.cc:14)
==2403==    by 0x4C3083E: mythread_wrapper (hg_intercepts.c:389)
==2403==    by 0x4E42E24: start_thread (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x596F34C: clone (in /usr/lib64/libc-2.17.so)
==2403== 
==2403== This conflicts with a previous read of size 4 by thread #2
==2403== Locks held: none
==2403==    at 0x400685: Thread1(void*) (simple_race.cc:8)
==2403==    by 0x4C3083E: mythread_wrapper (hg_intercepts.c:389)
==2403==    by 0x4E42E24: start_thread (in /usr/lib64/libpthread-2.17.so)
==2403==    by 0x596F34C: clone (in /usr/lib64/libc-2.17.so)
==2403==  Address 0x601040 is 0 bytes inside data symbol "x"
==2403== 
==2403== 
==2403== For counts of detected and suppressed errors, rerun with: -v
==2403== Use --history-level=approx or =none to gain increased speed, at
==2403== the cost of reduced accuracy of conflicting-access information
==2403== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
\end{verbatim}
}

\hrule
\vspace{0.5cm}

Helgrind also incorrectly reports a race on both \texttt{x} and \texttt{y}.

\subsection{DRD}

Valgrind also provides another race detector DRD.
We analyze program in Fig~\ref{simple_c} in DRD:

% \hrule
\vspace{0.5cm}
\hrule
{\small
\begin{verbatim}
==2624== drd, a thread error detector
==2624== Copyright (C) 2006-2015, and GNU GPL'd, by Bart Van Assche.
==2624== Using Valgrind-3.12.0 and LibVEX; rerun with -h for copyright info
==2624== Command: ./a.out
==2624== 
==2624== Thread 3:
==2624== Conflicting load by thread 3 at 0x00601044 size 4
==2624==    at 0x4006A3: Thread2(void*) (simple_race.cc:13)
==2624==    by 0x4C30193: vgDrd_thread_wrapper (drd_pthread_intercepts.c:444)
==2624==    by 0x4E4FE24: start_thread (in /usr/lib64/libpthread-2.17.so)
==2624==    by 0x597C34C: clone (in /usr/lib64/libc-2.17.so)
==2624== Allocation context: BSS section of /home/umathur3/a.out
==2624== Other segment start (thread 2)
==2624==    (thread finished, call stack no longer available)
==2624== Other segment end (thread 2)
==2624==    (thread finished, call stack no longer available)
==2624== 
==2624== Conflicting store by thread 3 at 0x00601040 size 4
==2624==    at 0x4006AE: Thread2(void*) (simple_race.cc:14)
==2624==    by 0x4C30193: vgDrd_thread_wrapper (drd_pthread_intercepts.c:444)
==2624==    by 0x4E4FE24: start_thread (in /usr/lib64/libpthread-2.17.so)
==2624==    by 0x597C34C: clone (in /usr/lib64/libc-2.17.so)
==2624== Allocation context: BSS section of /home/umathur3/a.out
==2624== Other segment start (thread 2)
==2624==    (thread finished, call stack no longer available)
==2624== Other segment end (thread 2)
==2624==    (thread finished, call stack no longer available)
==2624== 
==2624== 
==2624== For counts of detected and suppressed errors, rerun with: -v
==2624== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 18 from 12)
\end{verbatim}
}

\hrule
\vspace{0.5cm}
Again, DRD reports two races, one of which is false.