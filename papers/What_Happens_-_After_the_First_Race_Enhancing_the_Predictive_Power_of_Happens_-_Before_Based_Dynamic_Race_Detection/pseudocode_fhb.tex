\SetKwProg{myalg}{procedure}{}{}

\begin{algorithm*}
\begin{multicols}{2}
\SetKwFunction{facq}{acquire}
\SetKwFunction{frel}{release}
\SetKwFunction{fork}{fork}
\SetKwFunction{join}{join}
\SetKwFunction{read}{read}
\SetKwFunction{wr}{write}
\SetKwFunction{init}{Initialization}

\myalg{\init}{
    \lForEach{$t$}{
    $\Cc_t$ := $\bot[1/t]$
    } 
    \lForEach{$\ell$}{
    $\Ll_\ell$ := $\bot$ % $\lambda t: 0$
    } 
    \For{$x \in \vars{}$}{ 
    $\Rr_x$ := $\bot$; \\% $\lambda t: 0$ ; 
    $\Ww_x$ := $\bot$;  % $\lambda t: 0$ ;
    }
}

\myalg{\facq{$t$, $\ell$}}{ %
    $\Cc_t$ := $\Cc_t \mx \Ll_\ell$ ;
}

\myalg{\frel{$t$, $\ell$}}{
    $\Ll_\ell$ := $\Cc_t$ ; \\
    $\Cc_t(t)$ := $\Cc_t(t) + 1$ ; {\scriptsize \texttt{(* next event *)}}
}

\myalg{\fork{$t$, $u$}}{
    $\Cc_u$ := $\Cc_t[1/u]$ ; \\
    $\Cc_t(t)$ := $\Cc_t(t) + 1$ ; {\scriptsize \texttt{(* next event *)}}
}

\myalg{\join{$t$, $u$}}{
    $\Cc_t$ := $\Cc_t \mx \Cc_u$ ;
}

\myalg{\read{$t$, $x$}}{
    \If{$\neg (\Ww_x \cle \Cc_t)$}{
      declare `\textbf{race with write}';\\
      $\Cc_t$ := $\Cc_t \sqcup \Ww_x$; {\scriptsize \texttt{(* force ordering *)}}\\
    }
    $\Cc_t$ := $\Cc_t \mx \LW_x$; \\
    $\Rr_x(t)$ := $\Cc_t(t)$; \\
}

\myalg{\wr{$t$, $x$}}{
    \If{$\neg (\Rr_x \cle \Cc_t)$}{
      declare `\textbf{race with read}'; \\
      $\Cc_t$ := $\Cc_t \sqcup \Rr_x$; {\scriptsize \texttt{(* force ordering *)}} \\
    }
    \If{$\neg (\Ww_x \cle \Cc_t)$}{
      declare `\textbf{race with write}'; \\
      $\Cc_t$ := $\Cc_t \sqcup \Ww_x$; {\scriptsize \texttt{(* force ordering *)}} \\
    } 
    $\Ww_x(t)$ := $\Cc_t(t)$; \\
}
\end{multicols}
\vspace*{0.25cm}
\caption{\textit{Vector Clock for FHB race detection}}
\label{algo:fhb}
\end{algorithm*}