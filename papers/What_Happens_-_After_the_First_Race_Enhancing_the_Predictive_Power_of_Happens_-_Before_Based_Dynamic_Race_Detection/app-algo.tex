%!TEX root = main.tex

% \subsection{Proofs for Algorithm~\ref{algo:vc}}
% \label{app:algo_update}

We now prove Theorem~\ref{thm:isomorphicVC}, which states the
correctness of Algorithm~\ref{algo:vc}. Before establishing this claim
we would like to introduce some notation and prove some auxiliary
claims. 

Let us fix a trace $\tr$. Recall that for any event $e$, $C_e$ is the
(vector) timestamp assigned by Algorithm~\ref{algo:vc}. Let us denote
by $L_\lk^e$ the value of clock $\Ll_\lk$ just before the event $e$ is
processed. Similarly, let $LW_x^e$ denote the value of clock $\LW_x$
just before $e$ is processed. It is easy to see that the following
invariant is maintained by Algorithm~\ref{algo:vc}.
%
\begin{proposition}
\label{prop:vc-invariant1}
Let $e$ be an arbitrary event of trace $\tr$. Let $e_\lk$ be the last
$\rel(\lk)$-event in $\tr$ before $e$, and let $e_x$ be the last
$\wt(x)$-event in $\tr$ before $e$ (with respect to
$\trord{\tr}$). Note that $e_\lk$ and $e_x$ maybe undefined. Then,
$L_\lk^e = C_{e_\lk}$ and $LW_x^e = C_{e_x}$, where if an event $f$ is
undefined, we take $C_f = \bot$.
\end{proposition}
%
\begin{proof}
The observation follows from the way vector clocks $\Ll_\lk$ and
$\LW_x$ are updated.
\end{proof}

Another invariant that follows from the update rules of
Algorithm~\ref{algo:vc} is the following.
%
\begin{proposition}
\label{prop:vc-invariant2}
Let $e_1$ and $e_2$ be events of thread $t$ such that $e_1 \trord{\tr}
e_2$, i.e., $e_1 \tho{\tr} e_2$. Let $t'$ be any thread such that
$t \neq t'$. Then the following observations hold.
\begin{enumerate}
\item\label{lbl:monotonic} $C_{e_1} \cle C_{e_2}$.
\item\label{lbl:remote-clk-upd} $C_{e_1}(t') = C_{e_2}(t')$ unless
  there is an event $e$ of thread $t$ that is either an $\acq$-event, or
  a $\rd$-event, or a $\join$-event such that $e \neq e_1$ and
  $e_1 \trord{\tr} e \trord{\tr} e_2$.
\item\label{lbl:local-clk-upd} $C_{e_1}(t) = C_{e_2}(t)$ unless there
  is an event $e$ of thread $t$ that is either a $\rel$-event, or a
  $\wt$-event, or a $\fork$-event such that $e \neq e_2$ and
  $e_1 \trord{\tr} e \trord{\tr} e_2$; in this case $C_{e_1}(t) <
  C_{e_2}(t)$.
\end{enumerate}
\end{proposition}
%
\begin{proof}
Follows from the way $\Cc_t$ is updated by Algorithm~\ref{algo:vc}.
\end{proof}

We now prove the main lemma crucial to the correctness of
Algorithm~\ref{algo:vc}, that relates $\shb{}$ to the ordering on
vector clocks.
%
\begin{lemma}
\label{lem:vc-shb}
Let $e = \ev{t,op}$ be an event such that $C_e(t') = k$ for some $t'
\neq t$. Let $e' = \ev{t',op'}$ be the last event such that
$C_{e'}(t') = k$. Then $e' \shb{\tr} e$. 
\end{lemma}
%
\begin{proof}
The result will be proved by induction on the position of $e$ in the
trace $\tr$. Observe that if $e$ is the first event of $\tr$, then
$C_e(t') = 0$ for all $t' \neq t$, no matter what event $e$ is. And
there is no event $e' = \ev{t',op'}$ such that $C_{e'}(t') = 0$. Thus,
the lemma holds vaccuously in the base case.

Let us now consider the inductive step. Define $e_1 = \ev{t,op_1}$ be
the last event in $\tr$ before $e$ (possibly same as $e$) such that
$op_1$ is either $\acq$, $\rd$, or $\join$; if no such $e_1$ exists
then take $e_1$ to be the first event performed by $t$.  Notice, by
our choice of $e_1$ and
Proposition~\ref{prop:vc-invariant2}(\ref{lbl:remote-clk-upd}), for
every $t'' \neq t$, $C_{e_1}(t'') = C_e(t'')$. If $e_1 \neq e$, the
result follows by induction hypothesis on $e_1$. 

Let us assume $e_1 = e$. We need to consider different cases based on
what $e_1$ is.
\begin{itemize}
\item {\bf Case $e = e_1 = \ev{t,\acq(\lk)}$:} Let $f_1$ be the event 
  immediately before $e$ in $\proj{\tr}{t}$ and $f_2$ be the event
  such that $C_{f_2} = L_\lk^e$ (given by
  Proposition~\ref{prop:vc-invariant1}). Note that both $f_1$ and
  $f_2$ may be undefined. Also notice that, for any $t'$, either
  $C_e(t') = 0$, or $C_e(t') = C_{f_1}(t') \neq 0$ (and $f_1$ is
  defined), or $C_e(t') = C_{f_2}(t') \neq 0$ (and $f_2$ is
  defined). If $C_e(t') = 0$ then the lemma follows vaccuously as in
  the base case because there is no event $e' = \ev{t',op'}$ with
  $C_{e'}(t') = 0$. Let us now consider the remaining cases. Let $t_2$
  denote the thread performing $f_2$, if $f_2$ is defined. Consider
  the case when either $C_e(t') = C_{f_1}(t') \neq 0$ or $C_e(t') =
  C_{f_2}(t')$ with $t' \neq t_2$. In this situation, the lemma
  follows using the induction hypothesis on either $f_1$ or $f_2$
  since both $f_1$ and $f_2$ (when defined) are $\shb{\tr} e$. The
  last case to consider is when $t' = t_2$ and $C_e(t') =
  C_{f_2}(t')$. By
  Proposition~\ref{prop:vc-invariant2}(\ref{lbl:local-clk-upd}), $f_2$
  is the last event of $t' = t_2$ whose $t'$th component is
  $k$. Further, by definition $f_2 \shb{\tr} e$, and so the lemma
  holds.
\item {\bf Case $e = e_1 = \ev{t,\rd(x)}$:} Let $f_1$ be the event
  immediately before $e$ in $\proj{\tr}{t}$ and $f_2$ be the event
  such that $C_{f_2} = LW_x^e$ (given by
  Proposition~\ref{prop:vc-invariant1}). Again, both $f_1$ and $f_2$
  may be undefined. Also notice that, for any $t'$, either $C_e(t') =
  0$, or $C_e(t') = C_{f_1}(t') \neq 0$ (and $f_1$ is defined), or
  $C_e(t') = C_{f_2}(t') \neq 0$ (and $f_2$ is defined). If $C_e(t') =
  0$ then the lemma follows vaccuously as in the base case because
  there is no event $e' = \ev{t',op'}$ with $C_{e'}(t') = 0$. Let us
  now consider the remaining cases. Let $t_2$ denote the thread
  performing $f_2$, if $f_2$ is defined. Consider the case when either
  $C_e(t') = C_{f_1}(t') \neq 0$ or $C_e(t') = C_{f_2}(t')$ with
  $t' \neq t_2$. In this situation, the lemma follows using the
  induction hypothesis on either $f_1$ or $f_2$ since both $f_1$ and
  $f_2$ (when defined) are $\shb{\tr} e$. The last case to consider is
  when $t' = t_2$ and $C_e(t') = C_{f_2}(t')$. By
  Proposition~\ref{prop:vc-invariant2}(\ref{lbl:local-clk-upd}), $f_2$
  is the last event of $t' = t_2$ whose $t'$th component is
  $k$. Further, by definition $f_2 \shb{\tr} e$, and so the lemma
  holds.
\item {\bf Case $e = e_1 = \ev{t,\join(t_1)}$:} Let $f_1$ be the event
  immediately before $e$ in $\proj{\tr}{t}$ and $f_2$ be the last
  event of the form $\ev{t_1,op}$. Again, both $f_1$ and $f_2$ may be
  undefined. Also notice that, for any $t'$, either (a) $C_e(t') = 0$,
  or (b) $t_1 = t'$, $C_e(t') = 1$, and $f_2$ is undefined, or (c)
  $C_e(t') = C_{f_1}(t') \neq 0$ and $f_1$ is defined, or (d) $C_e(t')
  = C_{f_2}(t') \neq 0$ and $f_2$ is defined. In cases (a) or (b)
  above, the lemma follows vaccuously as in the base case because
  there is no event $e' = \ev{t',op'}$ with $C_{e'}(t') = k$ (where
  $k$ is either $0$ or $1$ depending on which we case we
  consider). Let us now consider the remaining cases. Let $t_2$ denote
  the thread performing $f_2$, if $f_2$ is defined. Consider the case
  when either $C_e(t') = C_{f_1}(t') \neq 0$ or $C_e(t') =
  C_{f_2}(t')$ with $t' \neq t_2$ (and $f_2$ defined). In this
  situation, the lemma follows using the induction hypothesis on
  either $f_1$ or $f_2$ since both $f_1$ and $f_2$ (when defined) are
  $\shb{\tr} e$. The last case to consider is when $t' = t_2$ and
  $C_e(t') = C_{f_2}(t')$. By definition, $f_2$ is the last event of
  $t' = t_2$ whose $t'$th component is $k$. Further, by definition
  $f_2 \shb{\tr} e$, and so the lemma holds.
\item {\bf Case $e = e_1$ is the first event:} This is the case when 
  the above 3 cases don't hold. So $e = e_1$ is not an $\acq$-event,
  nor a $\rd$-event, nor a $\join$-event. Moreover, since $e$ is the
  first event of thread $t$ and is of the form $\ev{t,op}$, it must be
  the the thread $t$ has not been forked by any thread in $\tr$. Thus,
  for any $t' \neq t$, $C_e(t') = 0$. The lemma, therefore, follows
  vaccuously as in the base case. \qedhere
\end{itemize}
\end{proof}

We are ready to present the proof of Theorem~\ref{thm:isomorphicVC}.

\begin{reptheorem}{thm:isomorphicVC}
For events $e, e' \in \events{\tr}$ such that $e \trord{\tr} e'$,
$C_e \cle C_{e'}$ iff $e \shb{\tr} e'$
\end{reptheorem}

\begin{proof}
Let us first prove the implication from left to right. Consider $e,e'$
such that $e \trord{\tr} e'$. If $e \tho{\tr} e'$ then $e \shb{\tr}
e'$ since $\tho{\tr} \subseteq \shb{\tr}$. On the other hand, if $e$
and $e'$ are not events of the same thread, then this direction of the
theorem follows from Lemma~\ref{lem:vc-shb}.

Let us now prove the implication from right to left. Consider events
such that $e \shb{\tr} e'$. Then, by definition, we have a sequence of
events $e = f_1,f_2,\ldots f_k = e'$ such that for every $i$,
$f_i \trord{\tr} f_{i+1}$ and either (i) $f_i$ and $f_{i+1}$ are both
events of the form $\ev{t,op}$, or (ii) $f_i$ is a $\rel(\lk)$-event
and $f_{i+1}$ is a $\acq(\lk)$-event, or (iii) $f_i$ is a
$\fork(t)$-event and $f_{i+1}$ is an event of the form $\ev{t,op}$, or
(iv) $f_i$ is an event of the form $\ev{t,op}$ and $f_{i+1}$ is a
$\join(t)$-event, or (v) $f_i = \lw{\tr}(f_{i+1})$. In each of these
cases, Algorithm~\ref{algo:vc} ensures that $C_{f_i} \cle
C_{f_{i+1}}$. Thus, we have $C_e \cle C_{e'}$.
\end{proof}

We now prove Theorem~\ref{thm:correct-races}.  We first note some
auxiliary propositions.  Let us denote by $R_x^e$ the value of clock
$\Rr_x$ just before the event $e$ is processed.  Similarly, let
$W_x^e$ denote the value of clock $\Ww_x$ just before $e$ is
processed. It is easy to see that the following invariant is
maintained by Algorithm~\ref{algo:vc}.

\begin{proposition}
\label{prop:vc-invariantrw}
Let $e$ be an arbitrary event of trace $\tr$. Let $e_t^{\rd(x)}$ 
be the last $\ev{t, \rd(x)}$-event in $\tr$ before $e$, 
and let $e_t^{\wt(x)}$ be the last
$\ev{t, \wt(x)}$-event in $\tr$ before $e$ (with respect to
$\trord{\tr}$). 
Note that $e_t^{\rd(x)}$  and $e_t^{\wt(x)}$  maybe undefined. 
Then, $\forall t, R_x(t) = C_{e_t^{\rd(x)}}(t)$ and 
$\forall t, W_x(t) = C_{e_t^{\wt(x)}}(t)$ 
where if an event $f$ is undefined, we take $C_f = \bot$.
\end{proposition}

\begin{proof}
The observation follows from the way vector clocks $\Rr_x$ and
$\Ww_x$ are updated.
\end{proof}

\begin{lemma}
\label{lem:prev_clock}
Let $e_1, e_2 \in \events{\tr}$ performed by threads $t_1$ and $t_2$,
respectively, such that $t_1 \neq t_2$.  Then, $e_1 \shb{\tr} e_2$ iff
$C_{e_1} \cle C_{e_2}[( C_{e_2}(t_2) + 1)/t_2]$.
\end{lemma}

\begin{proof}
Let $c_2 = C_{e_2}(t_2)$.
First suppose that $e_1 \shb{\tr} e_2$.
Then, from Theorem~\ref{thm:isomorphicVC}, we have $C_{e_1} \cle C_{e_2}$
and thus $C_{e_1} \cle C_{e_2}[(c_2+1)/t_2]$.
Next, assume that $C_{e_1} \cle C_{e_2}[(c_2 + 1)/t_2]$.
In particular, $C_{e_1}(t_1) \leq C_{e_2}(t_1)$.
Then by Lemma~\ref{lem:vc-shb}, we have $e_1 \shb{\tr} e_2$
\end{proof}

\begin{reptheorem}{thm:correct-races}
Let $e$ be a read/write event $e \in \events{\tr}$.
Algorithm~\ref{algo:vc} reports a race at $e$
iff there is an event $e' \in \events{\tr}$ such that $(e', e)$
is an $\hb{\tr}$-schedulable race.
\end{reptheorem}

\begin{proof}
% \ucomment{Prove this. You will have to prove that $\Rr_x$ and $\Ww_x$ are maintained correctly.}
% Let $e'$ and $e$ be conflicting events in $\tr$.
% Then by Theorem~\ref{thm:SHBSoundness}, $(e, e')$ is an $\hb{\tr}$-schedulable race
% iff either $\ltho{\tr}(e)$ does not exist or if it exists, then 
% $e' \not\leq_\textsf{SHB}^\tr \ltho{\tr}(e)$.
% 
Let us first consider the case when $\ltho{\tr}(e)$ is not defined.
Then, the value of the clock $\Cc_t = \bot[1/t]$ at line 19, 24 or 26 (depending
upon whether $e$ is a read or a write event).
If the check $\neg(\Ww_x \cle \Cc_t)$ passes, then
there is a $t'$ such that $\Ww_x(t') > \Cc_t$ and thus
the there is an event $e'$ (namely the last write event of $x$ in thread $t'$)
that conflicts with $e$. Thus, $(e', e)$ is a $\hb{\tr}$-schedulable race
by Theorem~\ref{thm:SHBSoundness}.
On the other hand, if the check fails, then
$\Ww_x = \bot[1/t]$ or $\Ww_x = \bot$ and in either case
there is no event that conflicts with $e$.
One can similarly argue that the checks on Lines 24 and 26
are both necessary and sufficient for the case when $e$ is a write event
and $\ltho{\tr}(e)$ is undefined.
% Similarly, for a write event $e$, if one of the checks
% $\neg(\Rr_x \cle \Cc_t)$ or $\neg(\Ww_x \cle \Cc_t)$ passes,
% it means that there is an event $e'$ that conflicts with $e$
% and thus $(e', e)$ is an $\hb{\tr}$-schedulable race.

Next we consider the case when $f = \ltho{\tr}(e)$ is defined.  Now
let $e$ be a read event.  If the check $\neg(\Ww_x \cle \Cc_t)$
passes, then there is a $t'$ such that $\Ww_x(t') > \Cc_t(t')$ and
thus there is an event $e' = \ev{t', \wt(x)}$ such that $C_{e'}(t')
> \Cc_t(t')$ and thus $C_{e'} \not\cle \Cc_t$; note that it must be
the case that $t' \neq t$.  Depending upon whether $f$ is a
read/join/acquire event or a write/fork/release event, the value of
the clock $\Cc_t$ at Line 19 is $\Cc_t = C_f$ or $\Cc_t =
C_f[(C_f(t)+1)/t]$.  In either case, by Lemma~\ref{lem:prev_clock}, we
have that $e' \not\leq_\textsf{SHB}^\tr f$.  On the other hand if,
$\Ww_x \cle \Cc_t$, then $\forall t' \neq t,
C_{e_{t'}^{\wt(x)}}(t') \leq \Cc_t(t')$, where $e_{u}^{\wt(x)}$ is the
last write event of $x$ performed by thread $u$.  This means that for
every event $e'$ such that $e'$ conflicts with, by
Lemma~\ref{lem:prev_clock}, we have $e' \shb{\tr} f$ and thus $(e',
e)$ is not an $\hb{\tr}$-schedulable race.  The argument for the case
when $e$ is a write event is similar.
\end{proof}

We now establish the asymptotic space and time bounds for
Algorithm~\ref{algo:vc}.

\begin{reptheorem}{thm:complexityVC}
For a trace $\tr$ with $n$ events, $T$ threads, $V$ variables, and $L$
locks, Algorithm~\ref{algo:vc} runs in time $O(nT\log n)$ and uses
$O((V+L+T)T\log n)$ space.
\end{reptheorem}

\begin{proof}
Observe that for a trace of length $n$, every component of each of the
vector clocks is bounded by $n$. Thus, each vector clock takes space
$O(T\log n)$, where $T$ is the number of threads. We have a vector
clock for each thread, lock, and variable, which gives us a space
bound of $O((V+T+L)T\log n)$. Notice that to process any event we need
to update constantly many vector clocks. The time to update any single
vector clock can be bounded by its size $O(T\log n)$. Thus, the total
running time is $O(nT\log n)$.
\end{proof}



