%!TEX root = main.tex
In this section, we will fix notation and present some definitions
that will be used in this paper.

\vspace*{0.1in}
\noindent
{\bf Traces.}  We consider concurrent programs under the sequential
consistency model.  Here, an execution, or trace, of a program is
viewed as an interleaving of operations performed by different
threads.  We will use $\tr$, $\tr'$ and $\tr''$ to denote traces.  For
a trace $\tr$, we will use $\threads{\tr}$ to denote the set of
threads in $\tr$. A trace is a sequence of events of the form $e
= \ev{t, op}$, where $t \in \threads{\tr}$, and $op$ can be one of
$\rd(x)$, $\wt(x)$ (read or write to memory location $x$),
$\acq(\lk)$, $\rel(\lk)$ (acquire or release of lock $\lk$) and
$\fork(u)$, $\join(u)$ (fork or join to some thread
$u$)~\footnote{Formally, each event in a trace is assumed to have a
unique event id. Thus, two occurences of a thread performing the same
operation will be considered \emph{different} events. Even though we
will implicitly assume the uniqueness of each event in a trace, to
reduce notational overhead, we do not formally introduce event ids.}.
To keep the presentation simple, we assume that locks are not
reentrant. However, all the results can be extended to the case when
locks are assumed to be reentrant. The set of events in trace $\tr$
will be denoted by $\events{\tr}$.  We will also use $\reads{\tr}(x)$
(resp. $\writes{\tr}(x)$) to denote the set of events that read
(resp. write) to memory location $x$.  Further $\reads{\tr}$
(resp. $\writes{\tr}$) denotes the union of the above sets over all
memory locations $x$. For an event $e \in \reads{\tr}(x)$,
the \emph{last write before} $e$ is the (unique) event
$e' \in \writes{\tr}(x)$ such that $e'$ appears before $e$ in the
trace $\tr$, and there is no event $e'' \in \writes{\tr}(x)$ between
$e'$ and $e$ in $\tr$. The last write before event
$e \in \reads{\tr}(x)$ maybe undefined, if there is no $\wt(x)$-event
before $e$. We denote the last write before $e$ by $\lw{\tr}(e)$. An
event $e = \ev{t_1, op}$ is said to be \emph{an event of thread $t$}
if either $t = t_1$ or
$op \in \{\fork(t), \join(t)\}$. The \emph{projection} of a trace
$\tr$ to a thread $t \in \threads{\tr}$ is the maximal subsequence of
$\tr$ that contains only events of thread $t$, and will be denoted by
$\proj{\tr}{t}$; thus an event $e = \ev{t, \fork(t')}$ (or $e
= \ev{t, \join(t')}$) belongs to both $\proj{\tr}{t}$ and
$\proj{\tr}{t'}$.  For an event $e$ of thread $t$, we denote by
$\ltho{\tr}(e)$ to be the last event $e'$ before $e$ in $\tr$ such
that $e$ and $e'$ are events of the same thread. Again,
$\ltho{\tr}(e)$ may be undefined for an event $e$.  The projection of
$\tr$ to a lock $\lk$, denoted by $\proj{\tr}{\lk}$, is the maximal
subsequence of $\tr$ that contains only acquire and release events of
lock $\lk$.  Traces are assumed to be well formed --- for every lock
$\lk$, $\proj{\tr}{\lk}$ is a prefix of some string belonging to the
regular language
$(\cup_{t \in \threads{\tr}} \ev{t, \acq(\lk)} \cdot \ev{t, \rel(\lk)}
)^*$.

\input{ntrace2b}

\begin{example}
\label{ex:trace-defn}
Let us illustrate the definitions and notations about traces
introduced in the previous paragraph. Consider the trace $\tr_3$ shown
in Fig.~\ref{fig:example3}. As in the introduction, we will refer to
the $i$th event in the trace by $e_i$. For trace $\tr_3$ we have ---
$\events{\tr_3} = \{e_1,e_2,\ldots e_{12}\}$; $\reads{\tr_3}
= \reads{\tr_3}(x) = \{e_7,e_{12}\}$; $\writes{\tr_3}
= \writes{\tr_3}(x) = \{e_2,e_5,e_9,e_{10}\}$. The last write of the
read events is as follows: $\lw{\tr_3}(e_7) = e_5$ and
$\lw{\tr_3}(e_{12}) = e_{10}$. The projection with respect to lock
$\lk$ is $\proj{\tr_3}{\lk} = e_1e_3e_4e_6$. The definition of
projection to a thread is subtle in the presence of forks and
joins. This can be seen by observing that $\proj{\tr_3}{t_4} =
e_8e_9e_{10}e_{11}$; this is because the fork event $e_8$ and the join
event $e_{11}$ are considered to be events of both threads $t_3$ and
$t_4$ by our definition. Finally, we illustrate $\ltho{\tr_3}(\cdot)$
through a few examples --- $\ltho{\tr_3}(e_2) = e_1$,
$\ltho{\tr_3}(e_7)$ is undefined, $\ltho{\tr_3}(e_9) = e_8$, and
$\ltho{\tr_3}(e_{11}) = e_{10}$. The cases of $e_9$ and $e_{11}$ are
the most interesting, and they follow from the fact that both $e_8$
and $e_{11}$ are also considered to be events of $t_4$.
\end{example}

\vspace*{0.1in}
\noindent
{\bf Orders.}  A given trace $\tr$ induces several total and partial
orders.  The total order
$\trord{\tr} \subseteq \events{\tr} \times \events{\tr}$, will be used
to denote the \emph{trace-order} --- $e \trord{\tr} e'$ iff either $e
= e'$ or $e$ appears before $e'$ in the sequence $\tr$.  Similarly,
the \emph{thread-order} is the smallest partial order
$\tho{\tr} \subseteq \events{\tr} \times \events{\tr}$ such that for
all pairs of events $e \trord{\tr} e'$ performed by the same thread,
we have $e \tho{\tr} e'$.
%
\begin{definition}[Happens-Before]
\label{def:hb}
Given trace $\tr$, the happens-before order $\hb{\tr}$ is the smallest
partial order on $\events{\tr}$ such that 
\begin{enumerate}[label=(\alph*)]
\item $\tho{\tr} \subseteq \hb{\tr}$, 
\item for every pair of events $e = \ev{t, \rel(\lk)}$, and,
$e' = \ev{t', \acq(\lk)}$ with
$e \trord{\tr} e'$, we have $e \hb{\tr} e'$
%
% Conditions for fork and join captured by thread order. Hence removed.
%
%\item for every pair of events $e
%= \ev{t,\fork(t')}$ and $e' = (t', op)$, $e \hb{\tr} e'$, and 
%\item for every pair of events $e = \ev{t', op}$ and $e' = \ev{t, \join(t')}$,
%$e \hb{\tr} e'$.
\end{enumerate}
\end{definition}

\begin{example}
\label{ex:hb}
We illustrate the definitions of $\trord{}, \tho{}$, and $\hb{}$ using
trace $\tr_3$ from Fig.~\ref{fig:example3}. Trace order is the
simplest; $e_i \trord{\tr_3} e_j$ iff $i \leq j$. Thread order is also
straightforward in most cases; the interesting cases of
$e_{8} \tho{\tr_3} e_9$ and $e_{10} \tho{\tr_3} e_{11}$ follow from
the fact that $e_8$ and $e_{11}$ are events of both threads $t_3$ and
$t_4$. Finally, let us consider $\hb{\tr_3}$. It is worth observing
that $e_7 \hb{\tr_3} e_9 \hb{\tr_3} e_{10} \hb{tr_3} e_{12}$ simply
because these events are thread ordered due to the fact that $e_8$ and
$e_{11}$ are events of both thread $t_3$ and $t_4$. In addition,
$e_2 \hb{\tr_3} e_5$ because $e_3 \hb{\tr_3} e_4$ by rule (b),
$e_2 \tho{\tr_3} e_3$ and $e_4 \tho{\tr_3} e_5$, and $\hb{\tr_3}$ is
transitive.
\end{example}

\vspace*{0.1in}
\noindent
{\bf Trace Reorderings.} Any trace of a concurrent program represents
one possible interleaving of concurrent events. The notion
of \emph{correct reordering}~\cite{cp2012,wcp2017} of trace $\tr$ identifies
all these other possible interleavings of $\tr$. In other words, if
$\tr'$ is a correct reordering of $\tr$ then any program that produces
$\tr$ may also produce $\tr'$. The definition of correct reordering is
given purely in terms of the trace $\tr$ and is agnostic of the
program that produced it. We give the formal definition below.
% \ucomment{We modify it}
% Correct reorderings have also been called \emph{feasible trace}
% in~\cite{rv2014}.
%
% \begin{definition}[Correct reordering]
% \label{def:correct-reorder}
% A trace $\tr'$ is said to be a correct reordering of
% a trace $\tr$ if
% \begin{enumerate*}[label=(\alph*)]
% %\item $\tr'$ is well formed, i.e., for every lock $\lk$, $\proj{\tr'}{\lk}$ 
% %  is a prefix of some string belonging to the regular language
% %  $(\cup_{t \in \threads{\tr'}} \ev{t, \acq(\lk)} \cdot 
% %  \ev{t, \rel(\lk)})^*$, 
% \item $\forall t \in \threads{\tr'}, \proj{\tr'}{t}$ is a prefix of 
%   $\proj{\tr}{t}$, and
% \item $\forall e \in \reads{\tr'}$, $\lw{\tr'}(e)$ exists iff
%   $\lw{\tr}(e)$ exists.  If it exists, then $\lw{\tr'}(e)
%   = \lw{\tr}(e)$.
% \end{enumerate*}
% \end{definition}
\begin{definition}[Correct reordering]
\label{def:correct-reorder}
A trace $\tr'$ is said to be a correct reordering of
a trace $\tr$ if
\begin{enumerate}[label=(\alph*)]
%\item $\tr'$ is well formed, i.e., for every lock $\lk$, $\proj{\tr'}{\lk}$ 
%  is a prefix of some string belonging to the regular language
%  $(\cup_{t \in \threads{\tr'}} \ev{t, \acq(\lk)} \cdot 
%  \ev{t, \rel(\lk)})^*$, 
\item $\forall t \in \threads{\tr'}, \proj{\tr'}{t}$ is a prefix of 
  $\proj{\tr}{t}$, and
\item for a read event $e = \ev{t, \rd(x)} \in \events{\tr'}$
such that $e$ is not the last event in $\proj{\tr'}{t}$,
$\lw{\tr'}(e)$ exists iff $\lw{\tr}(e)$ exists.  Further, if it
exists, then $\lw{\tr'}(e) = \lw{\tr}(e)$.
% \item \textcolor{green!80!black}{
% Let $e_1 = \ev{t_1, \rd(x)} \in \events{\tr}$
% and $e_2 = \ev{t_2, \wt(x)} \in \events{\tr}$ 
% be read and write events on the same variable $x$
% such that $e_1 \trord{\tr} e_2$.
% If $e_1 \in \events{\tr'}$, $e_2 \in \events{\tr'}$ 
% and $e_1$ is not the last event in $\proj{\tr'}{t_1}$,
% then $e_1 \trord{\tr'} e_2$.
% }
\end{enumerate}
\end{definition}
%
The intuition behind the above definition is the following.  A correct
reordering must preserve lock semantics (ensured by the fact that
$\tr'$ is a trace) and the order of events inside a given thread
(condition (a)).
% \ucomment{Because sequential consistency? Also because that's the best we can guess}.
Condition (b) captures \emph{local determinism}~\cite{rv2014}. 
That is, only the previous events in a given thread determine the next
event of the thread.
Since the underlying program that generated $\tr$ can have
branch events that depend upon the data in shared memory locations,
all reads in $\tr'$, except for the last events in each thread, 
must see the same value as in $\tr$; since our
traces don't record the value written, this can be ensured by
conservatively requiring every read to see the same write event.
If the last event of any thread in $\tr'$ is a read,
we allow that this event may not see the same value (and thus
the same last write event) as in $\tr$.
For example, consider the program and trace given in
Fig.~\ref{fig:example1}. The read event $\rd(y)$ in the conditional in
thread $t_2$ cannot be swapped with the preceding event $\wt(y)$ in
thread $t_1$, because that would result in a different branch being
taken in $t_2$, and the assignment $\texttt{x := 10}$ in $t_2$ will
never be executed. However, this is required only if the read event is
not the last event of the thread in the reordering. If it is the last
event, it does not matter what value is read, because it does not
affect future behavior. 

We note that the definition of correct reordering we have is more general
than in~\cite{wcp2017,cp2012} because of the relaxed assumption about
the last-write events corresponding to read events which are
not followed by any other events in their corresponding threads.
In other words, every correct reordering $\tr'$ of a trace $\tr$
according to the definition in~\cite{cp2012,wcp2017} is also a correct reordering of $\tr$
as per Definition~\ref{def:correct-reorder}, but the converse is not true.
On the other hand, the related notion of \emph{feasible} set of traces~\cite{rv2014}
allows for an even larger set of alternate reorderings that can be inferred
from an observed trace $\tr$ by only enforcing that 
the last-write event $e'$ corresponding to a read event $e$
must write the same value that $e$ reads in $\tr$. 
In particular, $e'$ may not be the same as $\lw{\tr}(e)$.

In addition to correct reorderings, another useful collection of
alternate interleavings of a trace is as follows. Under the assumption
that $\hb{\tr}$ identifies certain causal dependencies between events
of $\tr$, we consider interleavings of $\sigma$ that are consistent
with $\hb{\tr}$.
%
\begin{definition}[$\hb{}$-respecting trace]
\label{def:hb-respecting}
For trace $\tr$, we say trace $\tr'$ respects $\hb{\tr}$ if for any
$e,e' \in \events{\tr}$ such that $e \hb{\tr} e'$ and
$e' \in \events{\tr'}$, we have $e \in \events{\tr'}$ and
$e \trord{\tr'} e'$. 
%\ucomment{Say that $\events{\tr'} \subseteq \events{\tr}$}
\end{definition}
%
Thus, a $\hb{\tr}$-respecting trace is one whose events are downward
closed with respect to $\hb{\tr}$ and in which $\hb{\tr}$-ordered events are not
flipped. We will be using the above notion only when the trace $\tr'$
is a reordering of $\tr$, and hence $\events{\tr'} \subseteq \events{\tr}$.

\begin{example}
\label{ex:reorderings}
We give examples of correct reorderings of $\tr_3$ shown in
Fig.~\ref{fig:example3}. The traces $\rho_1 = e_1e_2e_7$, $\rho_2 =
e_4e_5e_6$, and $\rho_3 = e_1e_2e_3e_4e_5e_7$ are all examples of
correct reorderings of $\tr_3$. Among these, the trace $\rho_2$ is not
$\hb{}$-respecting because it is not $\hb{}$-downward closed ---
events $e_1,e_2,e_3$ are all HB-before $e_4$ and none of them are in
$\rho_2$.
\end{example}

\vspace*{0.1in}
\noindent
{\bf Race.} It is useful to recall the formal definition of a data
race, and to state the soundness guarantees of happens-before. Two
data access events $e = \ev{t_1, \mathsf{a}_1(x)}$ and $e'
= \ev{t_2,\mathsf{a}_2(x)}$ are said to be \emph{conflicting} if
$t_1 \neq t_2$, and at least one among $\mathsf{a}_1$ and
$\mathsf{a}_2$ is a write event. A trace $\tr$ is said to have a race
if it is of the form $\tr = \tr' e e' \tr''$ such that $e$ and $e'$
are conflicting; here $(e,e')$ is either called a race pair or a
race. A concurrent program is said to have a race if it has an
execution that has a race.

The partial order $\hb{\tr}$ is often employed for the purpose of
detecting races by analyzing program executions. In this context, it
is useful to define what we call an HB-race. A pair of conflicting events
$(e,e')$ is said to be an \emph{HB-race} if $e \trord{\tr} e'$ and $e$
and $e'$ are incomparable with respect to $\hb{\tr}$ (i.e., neither
$e \hb{\tr} e'$ nor $e' \hb{\tr} e$). We say an HB-race $(e,e')$ is
the \emph{first HB-race} if for any other HB-race $(f,f') \neq
(e,e')$ in $\tr$, either $e' \stricttrord{\tr} f'$, or $e' = f'$ and
$f \stricttrord{\tr} e$. 
For example, the pair $(e_2, e_3)$ in trace $\tr_1$ from Fig.~\ref{fig:example1} 
is the first HB-race of $\tr_1$.
The soundness guarantee of HB says that if a
trace $\tr$ has an HB-race, then the first HB-race is a valid data
race.
%
\begin{theorem}[Soundness of HB]
\label{thm:hb_sound}
Let $\tr$ be a trace with an HB-race, and let $(e, e')$ be the first
HB-race.  Then, there is a correct reordering $\tr'$ of $\tr$, such
that $\tr' = \tr'' e e'$.
\end{theorem}
%
Instead of sketching the proof of Theorem~\ref{thm:hb_sound}, we will
see that it follows from the main result of this paper, namely,
Theorem~\ref{thm:SHBSoundness}.

\begin{example}
\label{ex:hb-race}
We conclude this section by giving examples of HB-races. Consider
again $\tr_3$ from Fig.~\ref{fig:example3}. Among the different pairs
of conflicting events in $\tr_3$, the HB-races are $(e_2,e_7)$,
$(e_5,e_7)$, $(e_2,e_9)$, $(e_5,e_9)$, $(e_2,e_{10})$, $(e_5,e_{10})$,
$(e_2,e_{12})$, and $(e_5,e_{12})$.
\end{example}

\begin{remark}
% \ucomment{Feel free to edit, as needed.} 
Our model of executions and reorderings assume sequential consistency,
which is a standard model used by most race detection
tools. Executions in a more general memory model, such as 
Total Store Order (TSO),  would also have events that indicate when
 a local write was committed to the global
memory~\cite{HuangTSO16}. In that scenario,
the definition of correct reorderings would be similar, except that
``last write'' would be replaced by ``last observed write'', which
would either be the last committed write or the last write by the same
thread, whichever is later in the trace. The number of correct
reorderings to be considered would increase --- instead of just
considering executions where every write is immediately committed, as
we do here, we would also need to consider reorderings where the write
commits are delayed. However, since our results here are about proving
the existence of a reordered trace where a race is observed, they
carry over to the more general setting. We might miss race pairs that
could be shown to be in race in a weaker memory model, where more
reoderings are permitted, but the races we identify would still be
valid.
\end{remark}
