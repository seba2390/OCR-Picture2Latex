
\section{Problem Formulation}
\label{sec:problem}

\subsection{Definitions and Scope}


\subsubsection{Use-Before-Initialization.} A \acf{UBI} bug refers to the erroneous scenario where a variable \( v \) is accessed or involved in any operation prior to its correct initialization. 
% \yizhuo{"any operation" is not consistent with the definition in UBITect, may need extra explanation later in the evaluation.}
% Assumes \(d(v)\) is the declaration of \(v\), \( u(v) \) is a  use operation of \( v \), and \(i(v)\) initializes \(v\).
Let:

\begin{itemize}
\item 
\(d(v)\) represent the declaration of \(v\).
\item 
\(u(v)\) signify a use operation involving \(v\).
\item 
\(i(v)\) denote the initialization operation of \(v\).
\end{itemize}

if there exists \(d(v)\) and \(u(v)\), then \(v\) is \textit{used before initialization} if:
% \yu{why $\exists v$?}
\begin{equation}
% \nexists i(v) : d(v) < i(v) < u(v)
\exists v : (d(v) < u(v)) \land \neg (\exists i(v) : d(v) < i(v) < u(v))
% \yizhuo{...\neg (\forall i(v) : d(v) < i(v) < u(v))?}
\label{eq:ubi_def}
\end{equation}
where \( < \) indicates a temporal sequence in the program execution. 
% The important characteristic of UBI is that it requires a \textit{use} of a possibly uninitialized variable, which gives us a foundation for our optimization.


\cut{
\subsubsection{\acf{SAR}.} 
A \acf{SAR} of UBI bug is a tuple defined as:
\begin{equation}
\text{SAR} = \langle v, F \rangle
\end{equation}
Where:
\begin{itemize}
    \item \(v\) refers to the uninitialized variable being accessed.
     \item \(F\) specifies the function or context housing the variable \(v\) and its usage \(u(v)\). 
    % \zhiyun{do we mean the function that defines the variable? we should make it clear that we consider only local variables}
\end{itemize}

\cut{
\subsubsection{System Definition} Let \work denote a framework defined as:
\begin{equation}
\work : \text{SAR} \times \text{LLMs} \rightarrow \text{Bug Detection}
\end{equation}
where \work interfaces with SAR and LLMs (e.g., ChatGPT) to systematically identify and reason about UBI bugs from the reports generated by static analysis tools.

The \work is designed to be compatible with bug reports generated by various static analysis tools. In the scope of this paper, our primary focus lies on UBI in C programming languages. To that end, we have chosen UBItect, a state-of-the-art tool specifically developed for detecting UBI bugs.
}

\subsubsection{Framework Definition.}
We define \work as a framework that processes Static Analysis Reports (SAR) to detect bugs:

\begin{equation}
\work(\text{SAR}) \rightarrow \text{Bug Detection}
\end{equation}

Here, \work takes a SAR as input and outputs a bug analysis result. While in principle generalizable to other types of static analysis tools, the prototype of our framework is primarily aligned with UBI detection in the C programming language. 
Specifically, we leverage UBItect which produces the SARs that we want as input to \work.
}

\subsubsection{Postcondition.}

Postconditions encapsulate the expected state or behavior of a system upon the conclusion of a routine~\cite{DBLP:books/ph/Meyer97}. Specifically, they detail the guarantees a routine offers based on its observable outcomes.

For a routine \( R \), consider its set of outcomes as
\(\mathcal{O}\). These outcomes are defined as \textit{updates} to its parameters (and return value) for a path of \(R\). Particularly, \(\mathcal{O}\) does not include
initialization for variables for convenience.
In the study of UBI bug, for a routine \( R \) that can yield a set of outcomes \( \mathcal{O} \), the postcondition \(\mathcal{P}\)
can be defined as:
\begin{equation}
\mathcal{P}_R: \mathcal{S}(R) \rightarrow  \mathcal{O} \times \texttt{must\_init}
\end{equation}
Here, \(\mathcal{S}(R)\) signifies all possible execution paths through the routine \(R\), 
\(\mathcal{O}\) describes all updates of \(R\) on its variables, and
\texttt{must\_init} is a set of variables that must be initialized. 
% Note that only if a variable ends up with the \texttt{must\_init} outcome will it influence the final bug detection result --- a \texttt{must\_init} variable means that its subsequent uses will not lead to UBI, whereas a \texttt{may\_init} will still lead to a subsequent UBI.



\PP{Motivating Example.}
Consider the \texttt{sscanf()} function in our motivating example. 
Based on these return values, the postconditions assure the initialization of certain variables:

\begin{align*}
    \mathcal{P}(path_1) &: \{{ret \mapsto 0}, \texttt{must\_init} \mapsto \emptyset \} \\
    \mathcal{P}(path_2) &: \{{ret \mapsto 1}, \texttt{must\_init} \mapsto \{a\} \} \\
    \mathcal{P}(path_3) &: \{{ret \mapsto 2}, \texttt{must\_init} \mapsto \{a,b\} \} \\
    \mathcal{P}(path_4) &: \{{ret \mapsto 3}, \texttt{must\_init} \mapsto \{a,b,c\} \} \\
    \mathcal{P}(path_5) &: \{{ret \mapsto 4}, \texttt{must\_init} \mapsto \{a,b,c,d\} \} \\
    \mathcal{P}(path_6) &: \{{ret \mapsto 5}, \texttt{must\_init} \mapsto \{a,b,c,d,n\} \} \\
\end{align*}

\noindent
Here, the \(path_1 - path_6\) represent different possible paths in the \texttt{sscanf()} and
each path corresponds with a different postcondition.


For UBI detection, not every associated postcondition is relevant; instead, only the outcomes making the \(u(v)\) reachable are \textit{critical}. The constraints of the use are  \textit{\textbf{post-constraints}} \( \mathcal{C}_{post} \) \cite{path_program_analysis}. The \textit{qualified postcondition}, \( \mathcal{P}_{qual} \), is a subset of \( \mathcal{P} \) refined by \( \mathcal{C}_{post} \):

\[
\mathcal{P}_{qual} = \mathcal{P} |_{\mathcal{C}_{post}}
\]

For the \texttt{sscanf()} case, if the post-constraint is \( \mathcal{C}_{post} = \text{ret} \ge 4 \), the qualified postcondition would be \(\mathcal{P}(path_5) \wedge \mathcal{P}({path_6})\), which ensures that variables \texttt{a, b, c,} and \texttt{d} must be initialized; therefore, all variables used subsequently are initialized, and no UBI happens.

In subsequent discussions, unless otherwise specified, the term \textit{`postcondition'} shall denote \textit{`qualified postcondition'}.


\subsection{Post-Constraint Guided Path Analysis}
\label{subsec:postcondi_work}


When analyzing a routine or function in a path-sensitive manner, the number of paths to explore can grow rapidly. Fortunately, if we have information about what the function is expected to achieve (given by \(\mathcal{C}_{post}\)), we can prune paths that inherently don't meet those expectations. We categorize
two scenarios, \textbf{\textit{direct application}} and \textbf{\textit{outcome conflicts}}, in applying this optimization.
 % these scenarios into:

% \begin{enumerate}
%     \item \textbf{Direct Application}: The \(\mathcal{C}_{post}\) can be directly applied as a path constraint. Paths that inherently contradict this applied constraint can be discarded.
%     \item \textbf{Outcome Conflicts}: Some paths within the function might produce outcomes that contradict the \(\mathcal{C}_{post}\). If such conflicts are detected, these paths can be pruned.
% \end{enumerate}



Let \( R \) be the routine or function under analysis and \( \mathcal{S}(R) \) be its path set. Let \( path \in \mathcal{S}(R) \) refer to a specific path in \( R \). Besides, Each path \(path\) has an associated path constraint \(p\) that dictates its feasibility. These two optimizations can be formed with:

% \begin{enumerate}

\PP{Direct Application.} For direct application, the post-constraint \(\mathcal{C}_{post}\) can be directly applied as a path constraint. 
A \textit{path} can be discarded if:

\begin{equation*}
\neg ( p(path) \land \mathcal{C}_{post}) 
\end{equation*}

This implies that if a \( path \) inherently contradicts the post-constraint, it can be removed from consideration.

\PP{Outcome Conflicts.} Let \( \mathcal{O}(p) \) denote the set of all outcomes or effects produced by path \( p \). A \textit{path} can be pruned if any of its outcomes conflict with the post-constraint:

\[
 \exists o \in \mathcal{O}(path) : \neg (o \land \mathcal{C}_{post})
\]

 This stipulates that if an outcome from \( path \) inherently contradicts the post-constraint, that path can be disregarded in the analysis.

% \end{enumerate}

\PP{Correctness.} The validity of these optimization methods can be proved by contradiction. Consider an instance where one of these paths is executed. If this path conflicts with the $\mathcal{C}_{\text{post}}$, it would render $u(v)$ unreachable. Thus, it becomes evident that such paths can be pruned without sacrificing the correctness of the analysis.

We provide a concrete example of how we perform these optimizations in \S\ref{subsubsec:postcon_rule}.


% With postcondition awareness analysis, the exploration space of paths in
% the function can be effectively reduced and therefore makes the path-sensitive analysis feasible.



% \begin{figure}[t]
% \begin{minted}[xleftmargin=10pt, linenos, fontsize=\footnotesize, escapeinside=@@]{c}
% int caller_function(){
%     int X; // declare of suspicious variable @\(X\)@ 
%     ...
%     ret = init(&X); // initializer of @\(X\)@ 
%     ...
%     if (ret == SOME_CONDI) // a check for postconditition [not required]
%         use(X); // use of @\(X\)@ 
% }
% \end{minted}
% \caption{A typical case of potential UBI bug. For each suspicious variable \(X\), we expect it to 1) have an initializer function that probably initializes  \(X\) and 2) use \(X\). Usually, it includes a check 
% for the
% }
% \label{fig:prob_scope}
% \end{figure}

\cut{
\subsection{Assumptions}
\haonan{need to revise}
Let \(V\) be a variable, \(F\) be a function, and \(C\) be a callee function.

\begin{enumerate}
    \item \(A_1\): We restrict our analysis to patterns where \(V\) is declared in \(F\) and is passed to \(C\) for initialization.
    \item \(A_2\): Initialization of \(V\) in \(C\) can occur with multiple layers of indirection.
    \item \(A_3\): Direct initializations of \(V\) in \(F\) are excluded from the scope.
\end{enumerate}
}



% These patterns are visualized in Figure \ref{fig:}.
\subsection{Conceptual Workflow}
\label{subsec:concept_wf}

Given a bug report containing a suspicious variable \( v \) and its residing function \( F \), the workflow \( \Phi \) is as follows:

\begin{enumerate}
    \item \( \Phi_1(F, v) \rightarrow \{i(v)\} \): Identify potential initializers for \( v \) from the bug report.
    \item \( \Phi_2(F, i(v)) \rightarrow \mathcal{C}_{post} \): Extract the \( \mathcal{C}_{post} \) from the bug report for each \(i(v)\).
    \item \( \Phi_3(F, \{i(v), \mathcal{C}_{post} \}) \rightarrow \text{InitStatus}(v) \): Summarize the initialization status for variable \( v \) after all possible initializers completion (merge multiple initializers). 
    % with respect to their corresponding \( \mathcal{C}_{post} \).
\end{enumerate}


% Figure \ref{fig:wf-case} also illustrates the conceptual workflow with three steps. 
% \yu{do we explain the figure? If not, explain it here}


\noindent
\textbf{Decision Policy.}
% \label{subsec:decicison_policy}
The decision policy \(\Delta\) is defined as: 
% \haonan{actually we also support multiple inits}
\begin{align*}
    \Delta(\text{InitStatus}(v) = \textit{must\_init}) & : \text{non-bug} \\
    \Delta(\text{InitStatus}(v) \neq \textit{must\_init}) & : \text{potential bug}
\end{align*}



% In this policy, we simply consider all non-\textit{must\_init }(or, \textit{may\_init}) to be potential bugs. This may produce false 
% alarms, as UBITect may falsely report non-use variable \(v\)\yu{what do you mean here by mentioning UBITect}. Besides, since we only consider \(F\) and
% ignore \(F\)'s call stack (\eg \(F\)'s caller) and other global memories,
% our method may lack path constraints and only over-approximates the initialization status, which can also result in false positives.
% \yu{A better explain here is to show this policy would keep the sound and would not introduce FN. Then mention a little about possible FP. We should try to  show the benefits of what we do.}

In this policy, we adopt a conservative approach by treating all variables not explicitly marked as \textit{must\_init} as potential vulnerabilities.
% We aim to minimize the introduction of false negatives and maintain soundness to the greatest extent possible. This is one contributing factor to the low occurrence of false negatives in our approach, should they exist. 
And it is worth noting that this policy may introduce some false positives. For example, it might \textit{over-approximate} preconditions.
% \yu{How about this.}



Conceptually, \work will not miss more bugs. The post-constraint guided path optimizations and decision policies are safe.



\subsection{Turns and Conversations in LLMs}
\label{subsec:turn_convo}

% \yu{must we have this sub section?}

We define two key concepts in interacting with LLMs: \textit{turn} and \textit{conversation}.

\squishlist
    \item \textbf{Turn:} A turn encapsulates a singular interaction with the LLM. Formally, it's defined as a tuple, $(p, r)$, where $p$ represents the problem or question, 
    % which in our context might be a code snippet or a query related to postcondition, 
    and $r$ denotes the LLM's response.

    \item \textbf{Conversation:} Leveraging the capabilities of LLMs often necessitates a series of interactions, especially for complex problem-solving. A conversation is an ordered sequence of turns. A conversation comprising $n$ turns can be expressed as $[(p_1, r_1), (p_2, r_2), \ldots , (p_n, r_n)]$.
\squishend

