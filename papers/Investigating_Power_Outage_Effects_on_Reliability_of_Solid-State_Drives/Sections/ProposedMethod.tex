\vspace{-1em}
\section{Proposed Test Platform}
\vspace{-0.6em}
\label{sec:proposed}
In order to analyze the effect of power faults on the reliability of SSDs, we have proposed a test platform which injects real power faults and detects the corresponding failures.
Our proposed platform consists of two parts namely: 1) hardware part and 2) software part. Fig. \ref{fig:overview} depicts an overview of the proposed platform. It can be seen that the hardware part is responsible for injecting physical faults and the software part controls the hardware, sends I/O requests to SSD, and finally detects and analyzes the failures according to the injected faults. In the following, we first elaborate the fault injection mechanism that we have employed in the proposed platform and then present how our platform detects the failures and their sources.
\vspace{-1em}
\subsection{Fault Injection}
\vspace{-0.7em}
\label{sec:fault_injection}
Physical fault injection mechanism is performed by the hardware part of the platform which is controlled by the software part. In the proposed platform, the software part schedules and determines the time instances that a fault will be injected and then sends the commands to the hardware part. The hardware part physically injects the scheduled fault which may occur at any time during an IO operation. In the following we elaborate the details of the software part and hardware part of the proposed platform. 

\begin{figure}
	\centering
	\includegraphics[scale=0.8]{Figures/paltform_overview_ver2.pdf}
	\vspace{-0.5em}
	\caption{Overview of the proposed test platform.}
	\vspace{-2em}
	\label{fig:overview}
\end{figure}
%\vspace{-1em}
\subsubsection{Software-part}
\vspace{-0.7em}
\label{sec:sw}
As depicted in Fig. \ref{fig:overview}, the software part of the proposed platform consists of three major parts, namely: \emph{Scheduler}, \emph{IO Generator}, and \emph{Analyzer}. The details of each parts and how these parts work with each other are as follows:
%\begin{itemize}
	%\item  
	\paragraph{\emph{Scheduler}}
	It determines the random time instances in which power failure will be occurred. It sends \emph{On/Off Commands} to the hardware part which is responsible for physical fault injection. The hardware is programmed to receive the commands from \emph{Scheduler} and cut off the power of SSD at the scheduled time instances.
	%\item
	\paragraph{\emph{IO Generator}}
	It produces random read and write requests as determined by the workload and issues them to the SSD. The requests are named \emph{data packets} including header and data where data is produced randomly (as depicted in Fig. \ref{fig:data_packet}). The parameters of the request such as size, destination address, issue time (i.e., the time instance that the requests is queued in the device), and completion time are kept in the header of \emph{data packets}. 
	The additional information which is required in failure analysis are similarly kept in the header of \emph{data packets} such as three types of checksum including the checksum of data request, checksum before issuing request, and checksum after completion of the request.
	The request size, destination address, and issue time are produced randomly and after completion of the request, we receive acknowledgment (ACK) and completion time of the requests in order to update the header of \emph{data packets}. 
	\begin{figure}[!t]
		\centering
		\includegraphics[scale=0.35]{Figures/data_packet}
		\vspace{-0.5em}
		\caption{Structure of \emph{data packets}.}
		\vspace{-2em}
		\label{fig:data_packet}
	\end{figure}
	%\item 
	\paragraph{\emph{Analyzer}}
	 \emph{Analyzer} is responsible for assessing the correctness of IO operations. For each fault injection, \emph{Analyzer} collects the operations which are marked as \say{\emph{completed}} by the disk through \emph{blktrace} and compares the checksum of data which is written in the disk by checksum of the corresponding \emph{data packet}. \emph{Analyzer} reports a \emph{data loss} when a \say{\emph{completed}} operation has a different checksum by the corresponding \emph{data packet} or previous data in the corresponding address. In addition, \emph{Analyzer} is able to detect the IO errors (i.e., lost data due to unavailability of disk).
	The process of IO tracing and failure detection is elaborated in Section \ref{sec:failure_detection}.
%\end{itemize}
%\vspace{-1em}
\subsubsection{Hardware-part}
\vspace{-0.7em}
\label{sec:hw}
Fig. \ref{fig:hw_schem} depicts the detailed structure of the proposed hardware part. It can be seen that the hardware part of the proposed platform resides in the path of power lines of the SSD and is programmed and controlled by the software part. In addition, the real implementation of the proposed platform is depicted in Fig. \ref{fig:hw1} and Fig. \ref{fig:hw2}.
\begin{figure*}[!t]
	\centering
	\subfloat[]{\includegraphics[width=.4\textwidth]{hardware}%
		\label{fig:hw_schem}}
	\hfil
	\hspace{-.8pt}
	\subfloat[]{\includegraphics[width=.24\textwidth]{11-resize}%
		\label{fig:hw1}}
	\hfil
	\hspace{-.8pt}
	\subfloat[]{\includegraphics[width=.31\textwidth]{HW_lab_1_r-resize}%
		\label{fig:hw2}}
	
	\vspace{-0.5em}
	\caption{Hardware part of the proposed test platform.}
	\vspace{-2em}
	\label{fig:hardware}
\end{figure*}

As depicted in Fig. \ref{fig:hardware}, the proposed platform includes \emph{Host System}, the under test SSDs (or HDDs), an independent PSU, and the \emph{Arduino UNO} board \cite{arduinouno}.
In order to physically switch the power of SSD to ON or OFF state, we have employed an \emph{Arduino UNO} board including a 28-pin \emph{Atmega328} microcontroller \cite{atmega16}.
Through a serial connection, the microcontroller is connected to the \emph{Host System} on which the software part is running on it. The output of the microcontroller (pin 13) is connected to the pin  16 of the ATX controller of the PSU which drives the under test SSD power. Pin 16 of the ATX controller works as an active low pin which cuts off the output power of the PSU by applying a high voltage (+5V) \cite{PSU}.  
The microcontroller is programmed to receive the \emph{On/Off commands} and assign the corresponding value \say{0} and \say{1} to the output pin (pin 13) which controls the ATX‌ controller through pin 16.
%This board connects to the host system through one USB serial port on one side and connctes to the power of SSD on the other side. Thus, through USB serial port the host system commands into the \textit{Arduino} to switch the power of SSD. 

%As shown in Fig.~\ref{platform}(a), the PSU provides the VCC and GND supplies of the \textit{Arduino} from inside the ATX controller. In the PSU, the GND node namely pin 16, can be connected or disconnected casuing the PSU to be in ON or OFF state respectively. Pin 16 of the PSU is connected to pin 13 of the \textit{Arduino}. In the \textit{Arduino} pin 13 is programmed through the USB serial port which is controlled by the host system. Hence, the host system with generating the ``on/off" strings will directly switch the power of SSD. Scheduling of the power faults will be performed within the software part of the test platform in which the fault injector cuts the power of SSD at any time specified by the software. 
Fig. \ref{fig:fall} shows the output voltage of the PSU during discharge phase (i.e., when a power fault is injected) in two conditions: 1) when the PSU does not drive any device (depicted in Fig. \ref{fig:withoutssd}) and 2) when the PSU drives one SSD in the system (depicted in Fig. \ref{fig:withssd}). It can be seen that when the SSD is connected to the system, the discharge phase (i.e., when the voltage drops from 5V to 0V) takes about 900ms while the PSU purely discharges whithin 1400ms. During the discharge phase, the SSD‌ becomes unavailable within the software part in \emph{Host System} when the voltage drops to 4.5V where it takes about 40ms. 

%The voltage of the PSU versus time during cutting off is shown in Fig.~\ref{fall} for when the PSU drives power of the SSD (a) and when the PSU does not drive any devices (b). It can be seen that the discharge time [from vcc (5v) to gnd (0v)] of the PSU in presence of the SSD is about 0.9s while the PSU purely discharges whithin 1.4s. During fall time of the PSU the SSD will be out of access when the voltage drops to 4.5v. Hence, the susceptibility of the SSDs to the power outage is enormous in which when its voltage drops to nine tenth of the supply voltage gets inaccessible. 


In the following, we provide the main prominences of our proposed test platform compared to existing test platforms presented in previous studies. The power fault injection mechanism in the proposed platform is realistic and provides more real failures in SSDs compared to software-based platform presented in \cite{kim2007virtual}. In addition, the proposed test platform drives the power of under test disks with an independent PSU. Such scheme is advantageous from two aspects: First, SSDs experience realistic power failures that happen in systems in data centers. As our experiments reveal, it takes about 900ms for the large size capacitors in the PSU to purely discharge where the SSD turns off in about 40ms (when the input voltage drops to 4.5V).  The state-of-the-art studies such as \cite{tseng2011understanding, zheng2013understanding} cut off the SSDs power by employing high-speed power transistors (the reported delay is in micro seconds order) where the SSDs do not experience the realistic power failures and discharge phase. Second, due to  interior structure of PSU which provides comprehensive drive characteristics, the proposed scheme provides more safe power supplement.
Furthermore, the proposed platform minimizes the probability of short-circuit problems where it would be more common in the transistor-based platforms as presented in \cite{tseng2011understanding, zheng2013understanding}. The last main difference between our proposed platform with other existing platforms is that the injection of power faults is completely controllable by the software part.

 %Providing the power supply of SSDs (or HDDs) with one distinct PSU; This benefits from two aspects, first of all: The power of SSDs cuts off through power supply unit (PSU) which is used for the power of SSDs in operational configured systems, so the results is completely equivalent to what is happened in real. In this case, our experiments in Fig.~\ref{fall}(a) reveals that fall time delay of the power of SSD during power fault testing is about 0.9s. This is while the previous works ~\cite{tseng2011understanding, zheng2013understanding} provide the power of SSDs through high-speed power transistors with the fall time dalay in microsecond order which differs considerably from the real operational conditions of SSDs in systems. second: supplying the power of SSD through PSU is more safe than power transistors which is related to the PSU interior circuits providing better drive characteristics. 3) The power faults can be injected frequently to thousands extent with safe conditions 4) The testing platform is capable of performing the power fault injection for both SSD and HDD; The PSU can supply the power of both SSD and HDD 5) power faults occurences is completely controllable by the software. 

\begin{figure}[!t]
	\centering
		\subfloat[]{\includegraphics[width=.24\textwidth]{fall_withoutssd}%
			\label{fig:withoutssd}}
	\hfil
	\hspace{-.8pt}
	\subfloat[]{\includegraphics[width=.24\textwidth]{fall_withssd}%
		\label{fig:withssd}}
	
	\vspace{-0.5em}
	\caption{The output voltage of the PSU (a) when the PSU does not drive any device and (b) when the PSU drives one SSD.}
	\vspace{-2em}
	\label{fig:fall}
\end{figure}
%It receives the dedicated commands from the software part through a serial UART (RS-232) port. Hardware includes and Atmega16 microcontroller which is responsible for cutting off the power lines. Output of the microcontroller is connected to a circuit including a NMOS transistor which physically cuts the SSD's power lines. Microprocessor is programmed to decode the receiving commands from the software in a specific format. Each command consists of 8 characters like \say{cxxxxpyy} where the first character is considered as a passkey and indicates the power failure command. The commands without 'c' in the first character will be ignored. Four characters after first one (i.e., xxxx), indicate the time instance in which the power failure will be occurred in $\mu s$. The microcontroller waits until that time instance and then cuts the power off. Last two characters after 'p' indicate the recovery time in $ms$ where the microcontroller plugs the SSD on.     

\vspace{-1em}
\subsection{Failure Detection}
\vspace{-0.7em}
\label{sec:failure_detection}
In order to detect data failures of the IO requests, a comprehensive IO tracing mechanism is required in order to discover the online state of the IO requests. To this end, we have employed \emph{blktrace} and \emph{blkparse} toolkits as extreme powerful IO tracing tools which provide wide range of details about IO requests in the device block layer. In addition, we have employed \emph{btt} as a post-processing tool for the output of \emph{blktrace}. We have modified the source code of \emph{btt} and provided a new version of \emph{btt} tool which is able to extract additional information about IO request. In the following we elaborate the details of the modifications that we have performed on \emph{btt} and then show how we can detect IO failures such as IO errors and data failures and their types.

We have modified the source code of \emph{btt} in order to provide \emph{timing information} about IO requests in a standard format where we are able to detect the \emph{complete} and \emph{incomplete} requests. To this end, we have modified the underlying operation of \say{--per-io-dump} switch in \emph{btt} which extracts the trace of individual IO requests. Such modification is advantageous for tracing the large size requests which are divided to more than one request (namely sub-requests) in the device block layer. In addition, we extract the timing information and other parameters such as destination address, request size, and state of the request in the device queue. 
Finally, the data failure detection process starts after receiving the ACK signal of the IO request (i.e., when the request is completed). 
For each request we update two flags namely \emph{completed} and \emph{notApplied}. A request would be marked as \emph{completed} when all its sub-requests are in the complete state. Otherwise the request is marked as \emph{incomplete} (we have set 30 seconds timeout for delayed requests). On the other hand, in the next step, we compare 1) the checksum of original data (i.e., data in \emph{data packet}) with the written data  and also 2) the checksum of the corresponding address prior to issuing the request. In case of inequality in the first comparison and also equality of the second comparison, the value of \emph{notApplied} flag is set to 1, otherwise it would be equal to 0. Based on the values of the flags, we detect the type of failures as follows.
\begin{enumerate}
	\item $completed=1,~notApplied=1$: In such condition, SSD has performed the write operation and the ACK signal is sent to the upper layer while the data is not written in the corresponding address due to power failure. Such failure is called \emph{FWA} as a type of \emph{data failure} or \emph{data loss}. 
	\item $completed=1,~notApplied=0$: In such condition, the request is issued to the SDD and the ACK signal is received by the \emph{Host System}. In this condition, in case of inequality in checksum of the original data and written data, \emph{data failure} or \emph{data loss} is detected. 
	\item $completed=0,~notApplied=1/0$: In such condition, the request is issued to the SDD when it was unavailable by the \emph{Host System}. Such failure is called \emph{IO error}.
	%\item $completed=0,~notApplied=0$: In such condition, \emph{IO error} is detected.
\end{enumerate}

%To this end, we have employed the prototype of $\_\_find\_process\_pid$ function which is defined in $proc.c$ in $global.h$ file of the Linux kernel code. This function is used in $trace\_complete.c$ file in the source code of \emph{btt}. In the last step, we have modified the $display\_io\_trace$ function in $trace\_complete.c$ file in order to detect the IO errors which occur due to disk unavailability (we have set the timeout parameter to 90ms). In order to extract the information about incomplete requests we have modified the  doubly link list employed by \emph{btt} which keeps the list of issued IO requests (i.e., the requests that are not completed). To this end, we have modified $bt\_timeline.c$ code in order to extract the information of incomplete requests in list before they have been removed.

%Finally, the data failure detection process starts after receiving the ACK signal of the IO request (i.e., when the request is completed). In first step, the checksum of data in \emph{Data Packet} is compared to the checksum of written data. In case of inequality, a \say{data failure} or \say{data loss} is detected. In second step, the previous checksum of corresponding address (i.e., the checksum before issuing the request) is compared with the checksum of existing data and in case of  equality, we conclude that the data is not written on the SSD and call such failure as \say{Not Inserted IO}.


%\section{Proposed Test Platform}
%\label{SEC:PROP}
%In order to analyze the effect of power failure on robustness of stored data in the SSD a test platform is required which is able to inject faults and detect the occurred failures. To this end, we have proposed a platform including hardware part and software part. Fig. \ref{fig:overview} shows an overview of the proposed platform. It can be seen that hardware part is responsible for injecting physical faults and the software part controls the hardware and analyzes the failures according to the injected faults. In Section \ref{sec:fault_injection} we elaborate the fault injection mechanism that we have employed in the proposed platform. Section \ref{sec:failure_detection} present how the proposed platform detects the failures due to injected faults.
%
%\subsection{Power Fault Injector Hardware}
%
%\noindent The proposed power fault injector cuts the power of SSDs in a full controllable manner in which delay of power switching is same as what SSDs experience in  any configured systems. 
%Fig.~\ref{platform}(a) shows the power fault injector of the proposed test platform. According to this figure SSD is connected to the host system via SATA connector. Through this connection the host system send the IO requests to the SSD and receive the acknowledgment of the sent data. The power of SSD is provided by one extra power supply unit (PSU) same as existed PSU in the host system to ensure that test operation is equivalent to the configured SSDs located in each desired system. 





