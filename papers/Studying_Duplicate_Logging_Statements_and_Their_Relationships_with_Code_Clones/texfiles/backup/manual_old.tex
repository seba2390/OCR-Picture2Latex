\section{Manually Characterizing Duplicate Logs}
\label{sec:manual}

%\peter{might need to change the motivation based on the new intro}Similar to duplicate code or code clones, having duplicate logs may or may not be a problem~\cite{kapser2006a}. 

In this section, we manually study and characterize duplicate logs with two goals. First, we study duplicate logs and the surrounding code to understand whether duplicate logs are associated to code clones. Also, we manually uncover patterns of duplicate logging code smells that may be an indication of problems and require refactoring. The uncovered patterns of duplicate logging code smells will be utilized in a semi-automated approach to detect more instances of duplicate logging code smell at a large scale in Section~\ref{sec:userstudy}.
Figure~\ref{fig:overall} illustrates the overall process of our study. 

 \begin{figure*}
 \centering
\includegraphics[width=0.85\linewidth]{figures/overallShorten.pdf}
\vspace{-0.3cm}
 \caption{The overall process of our study.}
 \vspace{-0.3cm}
 \label{fig:overall}
 \end{figure*}


% <<<<<<< HEAD
% In this section, we manually study duplicate logs and the surrounding code to understand potential causes (e.g., are they caused by code clones). We also manually uncover patterns of duplicate logging code smells that may be an indication of problems and require refactoring. Figure~\ref{fig:overall} illustrates the overall process of our study. 


% \subsection{Manually Studying Duplicate Logs}

% \phead{Motivation.}
% We have two goals in our manual study. Our first goal is to study whether such duplicate logs are caused by developers copying and pasting the log statements and their surrounding code to different places (i.e., code clones). 
% Prior code clone studies focus on finding whether two pieces of code are syntactically or semantically similar~\cite{roy09}. 
% Although prior code clone studies do not specifically target duplicate logs, one may wonder if duplicate logs reside in cloned code.
% %However, one may wonder if the log messages are the same in two methods, would the code in these two methods be clones of each other. 
% Hence, we want to investigate how many duplicate log sets are in cloned code. A potential way of identifying code clones is to use tools such as CCFinder~\cite{kamiya2002}, but clone detection techniques usually requires setting a certain thresholds~\cite{roy09}. Non-optimal thresholds have significant impacts on the detected clones~\cite{roy09, 7081830}. However, choosing the optimal thresholds is a non-trivial task and the value may differ across systems~
% \cite{nikos_icse_2018}. Therefore, instead of running automated clone detection tools, the first two authors of the paper manually examine the sampled duplicate logs and the surrounding code, to study whether the duplicate logs are related to code clones. 
% =======
\subsection{Manually Studying Duplicate Logs}

\phead{Motivation.}
We have two goals in our manual study. Our first goal is to study whether there is a relationship between duplicate logs and code clones. For example, duplicate logs may be caused by developers copying and pasting the log statements and their surrounding code to different places (i.e., code clones). 
%Prior code clone studies focus on finding whether two pieces of code are syntactically or semantically similar~\cite{roy09}. 
Although prior code clone studies do not specifically target duplicate logs, one may wonder if duplicate logs reside in cloned code.
Hence, we want to investigate how many duplicate log sets are associated with cloned code. A potential way of identifying code clones is to use tools such as CCFinder~\cite{kamiya2002}, but clone detection techniques typically require setting a certain thresholds~\cite{roy09}. Non-optimal thresholds have significant impacts on the detected clones~\cite{roy09, 7081830}. However, choosing the optimal thresholds is a non-trivial task and the value may differ across systems~
\cite{nikos_icse_2018}. 
%\jinqiu{From here to the end of the paragraph, should go to `Approach'}
Therefore, instead of running automated clone detection tools, the first two authors of the paper independently examine the sampled duplicate logs and the surrounding code, to study whether the duplicate logs are related to code clones. 
%>>>>>>> f838390c4a22eb66c321e45065b34eac772fdb4f

Our second goal is to identify duplicate logging code smells. Similar to prior code smell studies~\cite{budgen2003software, fowler1999refactoring}, we define duplicate logging code smells as a {\em ``surface indication that usually corresponds to a deeper problem in the system''}. Most current log-related research focuses on identifying ``where to log''~\cite{Yuan:2010:SED:1736020.1736038, Zhu:2015:LLH:2818754.2818807, kundi_icpe_2018} and ``what to log''~\cite{Yuan:2011:ISD:1950365.1950369, Shang:2014:ULL:2705615.2706065}. Nevertheless, knowing how to help developers refactor logging code and provide the needed supports can help improve various tasks such as debugging and testing~\cite{Shang:2014:ULL:2705615.2706065, Chen:2017:ALT:3103112.3103144}. %Similar to code clones, duplicate logs may or may not be a problem~\cite{kapser2006a}. 
Therefore, we want to manually study duplicate logs and uncover patterns of duplicate logging code smells that may be indications of logging problems that require log refactoring. Since some duplicate logs may not be a problem, uncovering code patterns of duplicate logging code smells help us narrow down the problems and conduct further detailed analysis.% on duplicate logging code smells. 



\phead{Approach.}
%To study the causes of the duplicate logs (e.g., code clone or the logs are the same by coincident), 
We conduct a manual study by randomly sampling a total of 289 sets of duplicate logs (based on 95\% confidence level and 5\% confidence interval~\cite{boslaugh2008statistics}). Since the number of duplicate logs vary significantly across the studied systems, similar to prior studies~\cite{log_pattern_ICSE2017, boslaugh2008statistics}, we use the stratified sampling technique. We calculate the sample size according to the number of duplicate logs in each studied system. As an example, we detected a total of 1,168 sets of duplicate logs (i.e., each set contains two or more logs with the same message) in all the studied systems, and 865 of them are in CloudStack (74\%). Therefore, we sample $74\% * 289 = 213$ sets of duplicate logs from CloudStack. Similarly, we detected 217, 46, and 40 sets from Hadoop, Cassandra, and ElasticSearch, and we sampled 54, 12, and 10 sets, respectively. To uncover patterns of duplicate logging code smells, \peter{explain open coding, how many iteration, describe merger and split}we follow a lightweight open coding-like process to identify the patterns in which the duplicate log belongs~\cite{seaman1999qualitative}. Namely, we first go through the sets of duplicate logs to uncover possible code patterns. %Our first goal is to manually derive the categories of the causes. 
Then, we go through the duplicate logs again and assign them to the corresponding pattern. 

%, where 46 are in Cassandra, 864 are in CloudStack, 217 are in Hadoop, and 40 are in ElasticSearch. Based %Logs are stored as Map structure of which key is the syntactic message, value is a set of all the call-sites of this logging statement. 

%As an example,\zhenhao{We detected totally 1171 sets of duplicate logs in our subject systems, 218 sets were detected from Hadoop which accounts for 18.6\% of the total sets. Thus we will manually study 54 sets in Hadoop.} \zhenhao{ Accordingly, we detected 47, 865, and 41 sets from Cassandra, Cloudstack, and Elasticsearch respectively. Therefore we will sample 12, 213, and 10 sets from each system.} \peter{TODO: Zhenhao, can you fill in the numbers?}\peter{TODO: Zhenhao, add an example on how we calculate this}. \peter{TODO: Zhenhao, say how many we selected from each system} 



\subsection{Studying the Relationship Between Duplicate Logs and Code Clones}%~\jinqiu{Are duplicate logs caused by code clones? or others, it is not clear this section shows results from the title, so is the title of next section} 

% \peter{prior code clones study do not consider log clones (log message or other string constant). One may wonder if they are related }\peter{need to mention they are exact copy or part of the code is exact copy with small modification}
\phead{{\em We find that 40\% of the duplicate logs are not related to code clones.}} We find that, among all the manually studied duplicate logs, 60\% are related to code clone (vary between 59\% to 73\% for the studied systems), whereas 40\% are not related to code clone. We identify if the surrounding code of two duplicate logs is clone if we see syntactic similarities. We use Cohen's kappa~\cite{kappa} to measure the inter-rater agreement between the first two authors of the paper. Any disagreement is discussed until a consensus is reached. %, we discuss until an agreement is reached. 
The value of Cohen's kappa is above 0.9 for all studied systems (i.e., a high-level of agreement~\cite{kappa}). Our finding shows that, although many duplicate logs are related to code clones, there is still a significant number of duplicate logs that are not related to code clones. %related to the methods having similar log messages but different code structure.%~\jinqiu{I don't understand what are `methods having similar log messages'. Revisit} 
\todo{improve the manual}

%\peter{Zhenhao, maybe discuss how many dup logs which are not caused by clones are generic logs/too short logs. We can easily get those logs from the google sheet, and then we only need to count number of words in each group} \zhenhao{For duplicate logs which are not caused by code clone, we find that 16\% (18/111) of them are generic or too short logs}\peter{it is hard to explain what is generic or what is too short. report the number of words is better} \todo{Zhenhao, can you get the new number for me here (mean and median for each system, either C or NC)? I remember you have it in the slide} \zhenhao{Updated those numbers in the comment below. Those short logs were not filtered, can we double-check all the numbers after the first draft, and shape all of them with the same regulation? So far some number are filtered with length<1, some are 2, some are not...} 

% cassandra total 15, 4 not clone (31%), clone is 11 (73%) avg(C): 14.2, avg(NC): 4.3, med(C):14, med(NC):2.5 
% elastic search total 10, 4 not clone (40%), clone is 6 (60%) avg(C):7, avg(NC):4, med(C):5.5, med(NC):3.5
% hadoop total 40, 15 not clone (37.5%), clone is 25 (62.5%) avg(C): 8.2, avg(NC): 5.2, med(C): 8, med(NC):4
% cloud stack total 213, 88 not clone (41%), clone is 125 (59%) avg(C): 11.2, avg(NC):7, med(C):10, med(NC):6
% total 278, total not clone 111, total clone 167
% Those short logs were not filtered, can we double-check all the numbers after the first draft, and shape all of them with the same regulation? 


% \begin{table*}
% \caption{Patterns of duplicate logging code smells 
% and corresponding examples.} %\ahmed{nothing about parallel development or is that showing up as a theme throughout the different challenges?}
% \centering
% %\resizebox{\textwidth}{!} {%
% %\begin{adjustbox}{width=1\textwidth}

% \begin{tabular}{ m{2.5cm}|l}
% \toprule
% \textbf{Name} & \textbf{Example} \\
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \midrule
% %This example is from Cloudstack, com.cloud.api.dispatch.ParamProcessWorker.processParameters
% Inadequate information in catch blocks (IC) & \begin{lstlisting}
% /* log message cannot be used to distinguish which exception occurred */
% catch (final IllegalArgumentException e) {
%     s_logger.error("Error initializing command " + cmd.getCommandName() 
%      + ", field " + field.getName() + " is not accessible.");
%     ... 
% } catch (final IllegalAccessException e) {
%     s_logger.error("Error initializing command " + cmd.getCommandName() 
%      + ", field " + field.getName() + " is not accessible.");
%     ... 
% }
% \end{lstlisting}\\
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \midrule
% %This example is from Cloudstack
% Inconsistent error diagnostic information ({\sf IE}) & \begin{lstlisting}
% public class CreatePortForwardingRuleCmd{
%     ...
%     } catch (NetworkRuleConflictException ex) {
%     s_logger.info("Network rule conflict: " + ex.getMessage());
%     ...
% }
% ------------------------------------------------------------------------
% public class CreateFirewallRuleCmd{
%     ...
%     } catch (NetworkRuleConflictException ex) {
%     s_logger.info("Network rule conflict: ", ex);
%     ...
% }
% \end{lstlisting}\\

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \midrule
% %This example is from Hadoop
% Duplicate log in inheritance ({\sf DI}) & \begin{lstlisting}
% public class PowerShellFencer extends Configured implements FenceMethod {
%     ... /* class-specific implementation for FenceMethod */
%     } catch (InterruptedException ie) {
%       LOG.warn("Interrupted while waiting for fencing command: " + ps1script);
%     ...
% }
% ------------------------------------------------------------------------
% public class ShellCommandFencer extends Configured implements FenceMethod {
%     ... /* class-specific implementation for FenceMethod */
%     } catch (InterruptedException ie) {
%       LOG.warn("Interrupted while waiting for fencing command: " + cmd);
%     ...
% } 
% \end{lstlisting}\\

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \midrule
% %This is from Cassandra, same class: CompactionManager 
% Inconsistent log level ({\sf L}) & \begin{lstlisting}
% /* log levels are different in two very similar methods */
% public AllSSTableOpStatus performCleanup(){
%     ...
%     if (!StorageService.instance.isJoined()){
%         logger.info("Cleanup cannot run before a node has joined the ring");
%         return AllSSTableOpStatus.ABORTED;
%     }
%     ...
% }
% ------------------------------------------------------------------------
% public void forceUserDefinedCleanup(){
%     ...
%     if (!StorageService.instance.isJoined()){
%         logger.error("Cleanup cannot run before a node has joined the ring");
%         return;
%     }
%     ...
% }            
% \end{lstlisting}\\

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \midrule
% %This is from CloudStack
% Log message mismatch ({\sf M}) & \begin{lstlisting}
% public void doScaleUp() {
%     ...
%     s_logger.error("Can not find the groupid " + groupId + " for scaling up");
%     ...
% }
% ------------------------------------------------------------------------
% public void doScaleDown() {
%     ...
%     /* a copy-and-paste error; scaling up is the behavior of the above-mentioned method */
%     s_logger.error("Can not find the groupid " + groupId + " for scaling up");
%     ...
% }
% \end{lstlisting}\\
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% \bottomrule
% \end{tabular}
% %}
% %\end{adjustbox}
% \label{tab:patterns}
% \end{table*}



\begin{table*}
\caption{Patterns of duplicate logging code smells 
and corresponding examples.} %\ahmed{nothing about parallel development or is that showing up as a theme throughout the different challenges?}
\centering
%\resizebox{\textwidth}{!} {%
%\begin{adjustbox}{width=1\textwidth}

\begin{tabular}{m{.2\textwidth} | m{.65\textwidth}  }%{ m{3cm} |l}
\toprule
\textbf{Name} & \textbf{Example} \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\midrule
%This example is from Cloudstack, com.cloud.api.dispatch.ParamProcessWorker.processParameters
Inadequate information in catch blocks (IC) & 
\includegraphics[width=0.65\textwidth]{figures/manual_IC}

\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\midrule
%This example is from Cloudstack
Inconsistent error diagnostic information (IE) & \includegraphics[width=0.65\textwidth]{figures/manual_IE}
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\midrule
%This is from CloudStack
Log message mismatch (LM) & \includegraphics[width=0.65\textwidth]{figures/manual_M}
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\midrule
%This is from Cassandra, same class: CompactionManager 
Inconsistent log level (IL) & \includegraphics[width=0.65\textwidth]{figures/manual_L}
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\midrule
%This example is from Hadoop
Duplicate log in polymorphism (DP) & \includegraphics[width=0.65\textwidth]{figures/manual_DI}
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bottomrule
\end{tabular}
%}
%\end{adjustbox}
\label{tab:patterns}
\end{table*}

\subsection{Manually Uncovering Patterns of Duplicate Logging Code Smells}
%In this subsection, we document the duplicate logging code smells that we uncovered during manual analysis. 
\phead{{\em In total, we uncovered five patterns of duplicate logging code smells.}} Table~\ref{tab:patterns} lists the uncovered patterns of duplicate logging code smells and the corresponding examples. Below, we describe each pattern in detail and discuss its potential problems. Note that these uncovered patterns are indications of potential problems. We use these patterns as a starting point to find more instances of duplicate logging code smells. In Section~\ref{sec:userstudy}, we further conduct a detailed manual analysis on the impact of each pattern by classifying each pattern into sub-categories (i.e., some sub-categories may require refactoring while others may not). 

%The uncovered patterns are our starting point to find more instances of duplicate logging code smells, and so that later we provide a more detailed analysis of impact on each pattern by classifying each pattern into sub-categories (i.e., some sub-categories require refactoring while others do not) in Section~\ref{sec:userstudy}.~\jinqiu{Please check this para.}

\phead{Inadequate information in catch blocks (IC).} Developers usually rely on logs for error diagnostics when exceptions occur~\cite{Yuan:2014:STP:2685048.2685068}. However, we find that sometimes, duplicate logs in the {\em catch} block of different exceptions may cause debugging difficulties since the logs fail to tell which exception occurred. As shown in Table~\ref{tab:patterns}, in the {\em ParamProcessWorker} class in CloudStack, the \em{try} block contains two {\em catch} blocks; however the log messages in these two {\em catch} blocks are identical. Since both the exception message and stack trace are not logged, once one of the two exceptions occurs, developers may encounter difficulties in finding the root causes and determining the occurred exception. %Therefore, developers should either add extra information (e.g., exception type or stack trace) to the log or change the log message to avoid debugging. %On the other hand, if the log messages are different or if the log records stack trace information, developers may use the recorded information to debug the occurred exception. %log messages may not contain sufficient information for developers to debug the occurred exception.  

\phead{Inconsistent error diagnostic information (IE).} We find that sometimes duplicate logs may contain inconsistent error diagnostic information. Namely, the recorded dynamic variables are different (e.g., one log records the stack trace but the other log does not), even though the surrounding code is very similar. As shown in Table~\ref{tab:patterns}, the two classes {\tt\small Create\textbf{PortForwarding}RuleCmd} and {\tt\small Create\textbf{Firewall}RuleCmd} in CloudStack have similar functionality. The two log statements have the same static text message and are in methods with identical names (i.e., {\em create()}, not shown due to space restriction). The two {\em create()} methods have very similar code structure and perform very similar functionalities. The {\em create()} method in {\tt\small Create\textbf{PortForwarding}RuleCmd} is about creating rules for port forwarding and the the method in {\tt\small Create\textbf{Firewall}RuleCmd} is about creating rules for firewalls. However, the two log statements record different information: One records the stack trace information and the other one only records the exception message (i.e., {\em ex.getMessage()}). Due to the similar context of the two log statements, the error diagnostic information that is recorded by the logs may also need to be consistent \peter{not sure if we need to mention this here: }(we reported this problem to developers and it is now fixed as we suggested). %should also be similar. 


%\todo{Zhenhao, can you describe the example? Like if they are very similar class and briefly what these two methods do. We want to argue that, these two methods are very similar, but developers still log differently} \zhenhao{CreatePortForwardingRUleCmd and CreateFirewallRuleCmd. Both of these two logging statements are included in methods create(). The upper example is about creating rule for port forwarding, the under one is about creating rule for firewall. These two logging statements have identical messages and code context, but one logs stack trace with a variable "ex" which was introduced by a developer 4 years ago, the other one just log the exception message "ex.getMessage()" which was introduced 7 years ago. It seems that developer copied it from CreatePortForwardingRuleCmd, and changed the logging statement to log the full stack trace, but didn't change the origin one.} \peter{are you sure about the copying part? If not, we can just not mention it} \zhenhao{Not 100\% sure, because there are many differences between those two methods, only the catch blocks are very very similar.}


%When logging the same message, we find that the logs may sometimes contain inconsistent error diagnostic information (i.e., stack trace). As shown in Table~\ref{tab:patterns}, \peter{TODO: describe the example}



\phead{Log message mismatch (LM).} We find that sometimes after developers copy and paste a piece of code, they may forget to change the log message. As an example, in Table~\ref{tab:patterns}, the method {\em doScaleDown()} is a clone of {\em doScaleUp()} with very similar code structure and minor syntactical differences. However, developers forgot to change the log message in {\em doScaleDown()}, after the code was copied from {\em doScaleUp()} (i.e., both log messages contain {\em scaling up}). The problem causes confusion when developers analyze the logs~\cite{es-issue-forM}. % in the log lines when


%\peter{Zhenhao: which methods are the examples from?} \todo{Zhenhao, can you finish describing the example here?}\zhenhao{The upper example is included in method tryFence(HAServiceTarget target, String argsStr), the under one is included in tryFence(HAServiceTarget target, String cmd). The functions of try statements which manage those catch clauses are identical, only with a difference of variables in the logging statements. The upper example attaches a variable "ps1script" to log message, the under one attaches "cmd" to the log messages, which is also the parameter of it's method. (What can we learn from this example?)}



\phead{Inconsistent log level (IL).} Log levels (e.g., {\em fatal}, {\em error}, {\em info}, {\em debug}, or {\em trace}) allow developers to specify the severity of the log message and to reduce logging overhead when needed (e.g., {\em debug} is usually disabled in production)~\cite{Li2017}. A prior study~\cite{Yuan:2012:CLP:2337223.2337236} shows that log level is frequently modified by developers in order to find the most adequate level. We find that there are duplicate logs that, even though the log messages are exactly the same, %\todo{Zhenhao, can you quickly get the number of words for these logs?} \zhenhao{Now it have the med and avg words for them, should I filter those short ones? and how short should I filter?}\peter{maybe filter out those with only 2 words} \zhenhao{I find that some 2-length ones are meaningful, so for this time I filtered those shorter than 1. The numbers are in the comment below}, 
the log levels are different. 
%We also find that such duplicate logs with inconsistent levels are often {\em not} generic logs (i.e., median length of duplicate logs with inconsistent levels is 6 words). The log message in generic logs could be identical by chance, thus inconsistent log level in generic logs maybe by intent~\jinqiu{Check please.}.%where the log levels might be different by chance. 
As shown in Table~\ref{tab:patterns}, the two methods are both from the class ({\tt\small CompactionManager}) in Cassandra. The two methods have very similar functionality (i.e., both try to perform cleanup after compaction), but we find that the log levels are different in these two methods. %\todo{Zhenhao, for this particular example, was it copied from one method?} \zhenhao{No, look like it's not. The context are so different }
% Link to the L example: https://github.com/apache/cassandra/blob/trunk/src/java/org/apache/cassandra/db/compaction/CompactionManager.java
%avg length of data set in L: 6.6,   med: 6


\phead{Duplicate log in polymorphism (DP).} Classes in object-oriented languages are expected to share similar functionality if they inherent the same parent class or if they implement the same interface (i.e., polymorphism). Since log messages record a higher level abstraction of the program~\cite{Shang:2014:ULL:2705615.2706065}, we find that even though there are no clones among a parent method and its overridden methods, such methods may still contain duplicate logs. %, which have similar functionalities,%the log messages may be the 
% the code in the inherited methods may not necessarily be clone, but the log messages may be the same due to the methods having similar functionalities. 
%Due to the similarity, we find that developers may put the same log messages in the sibling classes or in the parent class. 
%\peter{log message record a higher level abstraction of the log. in the particular situation of DI, the code may not necessarily clone, but the log message should be similar. This opens a door for refactoring}
Such duplicate logs may cause maintenance overhead. For example, when developers update one log message, he/she may forget to update the log message in all the other sibling classes. Inconsistent log messages may cause problems during log analysis~\cite{mehran_emse_2018, HADOOP-4190}. %or may even cause incorrect test analysis results\peter{some citations?}. 
As shown in Table~\ref{tab:patterns}, the two classes ({\tt\small PowerShellFencer} and {\tt\small ShellCommandFencer}) in Hadoop share similar behaviours, and both classes extend the same parent class and implement the same interface. The log lines in both classes have the identical message in the inherited method. However, as systems evolve, developers may not always remember to change the log lines in both methods, which may cause problems during system debugging, understanding, and analysis.  

\hypobox{We find that 40\% of the duplicate logs are not related to code clones. We also uncover five patterns of duplicate logging code smells based on our manual study on a statistical sample of duplicate logs.}

\begin{comment}
\subsubsection{Duplicate Log Patterns} 
\peter{for the patterns of duplicate logs, each of them, we should say, whether logging library should have some new mechanism to support these patterns, instead of developers use duplicate logs to hack these.}
Below, we discuss three general duplicate log patterns we observe that are added intentionally by developers. \peter{I only have two right now, can you think of another one, or you think two is enough?}

%https://github.com/apache/hadoop/blob/f67237cbe7bc48a1b9088e990800b37529f1db2a/hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/Client.java


\phead{Inconsistent log levels in different control flow ({\tt IC}).} 
\peter{maybe see which one makes more sense}
\zhenhao{all of them make sense I think, maybe the third one is better?}
\begin{lstlisting}
if (currRetries < maxRetries) {
    if(LOG.isDebugEnabled()) {
        LOG.debug("Exception encountered while connecting to "
                    + "the server : " + ex);
    }
    ...
} else {
    LOG.warn("Exception encountered while connecting to "
                + "the server : " + ex);
}              
\end{lstlisting}

\begin{lstlisting}
if (e instanceof ClusterBlockException) {
    if (logger.isTraceEnabled()) {
        logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e);
    }
} else {
        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e);
}
\end{lstlisting}

\begin{lstlisting}
switch (threshold) {
    case WARN:
        if (logger.isWarnEnabled()) 
            logger.warn(SLOW_GC_LOG_MESSAGE, ...);
            break;
    case INFO:
        if (logger.isInfoEnabled())
            logger.info(SLOW_GC_LOG_MESSAGE, ...);
            break;
     ...
}
\end{lstlisting}

\phead{Duplicate logs in inheritance ({\tt DI}).} We find that there may exist duplicate logs in classes that share the same superclass. Listing~\ref{code:di} shows an example of {\tt DI} in CloudStack. We observe that since developers often provide similar log messages to the same children classes, sometimes there may exist duplicate logs. \peter{may need to improve this}Moreover, due to the differences in the implementation, information such as log levels may also differ. For example, in {\tt NfsSecondaryStorageResource}, the operation can only happen inside service VM (as indicated by the developer's comment), so the log level is set to {\tt warn}. On the other hand, the same log message is set to {\tt info} in {\tt ConsoleProxyResource}.  %, and such duplicate logs may even have  
%com.cloud.agent.resource.consoleproxy.ConsoleProxyResource.configure,org.apache.cloudstack.storage.resource.NfsSecondaryStorageResource.configure
\begin{lstlisting}[caption={An example of duplicate log pattern in inheritance ({\tt DI}) in CloudStack.} \label{code:di}]
public class ConsoleProxyResource extends ServerResourceBase{
    ...
	@Override
    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {
        _localgw = (String)params.get("localgw");
        _eth1mask = (String)params.get("eth1mask");
        _eth1ip = (String)params.get("eth1ip");
        if (_eth1ip != null) {
            params.put("private.network.device", "eth1");
        } else {
            s_logger.info("eth1ip parameter has not been configured, assuming that we are not inside a system vm");
        } 
        .../* class-specific implementation */
    }
}

public class NfsSecondaryStorageResource extends ServerResourceBase{
    ...
	@Override
    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {
        _eth1ip = (String)params.get("eth1ip");
        _eth1mask = (String)params.get("eth1mask");
        if (_eth1ip != null) { // can only happen inside service vm
            params.put("private.network.device", "eth1");
        } else {
            s_logger.warn("eth1ip parameter has not been configured, assuming that we are not inside a system vm");
        }
        .../* class-specific implementation */
    }
}   

\end{lstlisting}


%https://github.com/apache/hadoop/blob/6ba9587d370fbf39c129c08c00ebbb894ccc1389/hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/datanode/fsdataset/ReplicaInputStreams.java
% Could not get file descriptor for inputstream of class

\subsubsection{Duplicate Log Anti-patterns}
During our manual study process, we also observe a number of anti-patterns that are associated with duplicate logs. Such anti-patterns may be an indicator of a logging problem. Below, we document three duplicate log anti-patterns that we observed.

\phead{Log message mismatches ({\tt M}).} We find that developers may forget to change the class/method name in the log message after copying the code to another place. As shown in Listing~\ref{code:m}, the correct log message in {\tt tryVirtualLock()} should be ``{\em cannot virtual lock because...}''. However, because the code was copied from {\tt tryMlockall()}, the message was incorrect. The problem was detected by our anti-pattern detector (Section~\ref{sec:detection}) and was reported and fixed by ElasticSearch developers~\cite{elasticsearch_m}. 

\begin{lstlisting}[caption={An example of log message mismatch anti-pattern ({\tt M}) in ElasticSearch. The problem was reported and fixed~\cite{elasticsearch_m}.} \label{code:m}]
static void tryMlockall() {
    if (!JNA_AVAILABLE) {
        logger.warn("cannot mlockall because JNA is not available");
        return;
    }
    JNANatives.tryMlockall();
}

static void tryVirtualLock() {
    if (!JNA_AVAILABLE) { /* a copy-and-paste error */
        logger.warn("cannot mlockall because JNA is not available");
        return;
    }
    JNANatives.tryVirtualLock();
}
\end{lstlisting}


\phead{Inconsistent error diagnostician information ({\tt IE}).} 
\peter{need to find another example. This one might not be a problem}
\begin{lstlisting}[caption={Inconsistent error diagnostician information ({\tt IE}) in Cassandra.} \label{code:di}]
public class StreamReader{
...
	@Override
    public SSTableMultiWriter read(DataInputPlus inputPlus) throws IOException {
...
        catch (Throwable e)
        {
            Object partitionKey = deserializer != null ? deserializer.partitionKey() : "";
            logger.warn("[Stream {}] Error while reading partition {} from stream on ks='{}' and table='{}'.",
                        session.planId(), partitionKey, cfs.keyspace.getName(), cfs.getTableName(), e);
            if (writer != null)
            {
                writer.abort(e);
            }
            throw Throwables.propagate(e);
        }
    }
...    
}

public class CompressedStreamReader extends StreamReader{
...

     public void rewriteOVFFile(final String origOvfFilePath, final String newOvfFilePath, final String diskName) {
...
catch (Throwable e)
        {
            Object partitionKey = deserializer != null ? deserializer.partitionKey() : "";
            logger.warn("[Stream {}] Error while reading partition {} from stream on ks='{}' and table='{}'.",
                        session.planId(), partitionKey, cfs.keyspace.getName(), cfs.getTableName());
            if (writer != null)
            {
                writer.abort(e);
            }
            if (extractIOExceptionCause(e).isPresent())
                throw e;
            throw Throwables.propagate(e);
        }
    }
...
}   

\end{lstlisting}

\phead{Inconsistent log level ({\tt L}).} \zhenhao{maybe L should not be considered as an anti-pattern} In some cases, we find that two logs in very similar code may have different log level. As shown in Listing~\ref{code:l}, the two methods are clones of each other (Type II clone), but the log levels are inconsistent (one is error and one is debug).  

\begin{lstlisting}[caption={An example of inconsistent log level anti-pattern ({\tt L}) in CloudStack.} \label{code:l}]
actually, I think this is not a problem...need to find anther example
public class SimulatorInvestigator extends AdapterBase{
    ...
    @Override
	public Status isAgentAlive(Host agent) {
    	... // code clone
    	catch (Exception e) {
        	s_logger.debug("Failed to send command to host: " + neighbor.getId()); /* debug log */
    	}
		...    
	}
	...
}

public class Ovm3Investigator extends AdapterBase{
	...
	@Override 
	public Status isAgentAlive(Host agent) {
    	... // code clone
    	catch (Exception e) {
            LOGGER.error("Failed to send command to host: " + neighbor.getId(), e); /* error log */
    	}
    	...
	}
	...
}
\end{lstlisting}



%We release our manual study result %For each individual studied system, the percentage of duplicate logs that are caused by clones vary between \peter{might need to count if those not caused by clones are shorter?}
\end{comment}







