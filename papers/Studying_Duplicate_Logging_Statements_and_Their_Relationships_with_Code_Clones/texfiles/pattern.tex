\section{Patterns of Duplicate Logging Code Smells}
\label{sec:manual}


In this section, we conduct a manual study to investigate duplicate logging statements. Note that duplicate logging statements may not necessarily be a problem. Hence, our goal is to uncover patterns of potential code smells that may be associated with duplicate logging statements (i.e., {\em duplicate logging code smells}). % and discuss other duplicate logging statements that may not be a problem. 
Similar to prior code smell studies, we consider duplicate logging code smells as a {\em ``surface indication that usually corresponds to a deeper problem in the system''}~\cite{budgen2003software, fowler1999refactoring}. Such duplicate logging code smells may be indications of logging problems that require fixes.
%In this section, we conduct a manual study to uncover patterns of potential code smells that may be associated with duplicate logging statements (i.e., {\em duplicate logging code smells}). Similar to prior code smell studies, we consider duplicate logging code smells as a {\em ``surface indication that usually corresponds to a deeper problem in the system''}~\cite{budgen2003software, fowler1999refactoring}. Such duplicate logging code smells may be indications of logging problems that require fixes.

We categorize each duplicate logging code smell instance as either problematic (i.e., require fixes) or justifiable (i.e., do not require fixes), by understanding the surrounding code.
Not every duplicate logging code smell is problematic. Intuitively, one needs to consider the code context to decide whether a code smell instance is problematic and requires fixes. As shown in prior studies~\cite{Zhu:2015:LLH:2818754.2818807, Fu:2014:DLE:2591062.2591175, Li2018}, logging decisions, such as log messages and log levels, are often associated with the structure and semantics of the surrounding code.
In addition to the manual analysis by the authors, we also ask for developers' feedback regarding both the problematic and justifiable cases.
%Hence, we categorize code smell instances as problematic or justifiable through both our manual analysis on surrounding code and also communications with developers.
By providing a more detailed understanding of code smells, we may better assist developers to improve logging practices and inspire future research.




\phead{Manual study process.} We conduct a manual study by analyzing all the duplicate logging statements in the five studied systems. In total, we studied 1,371 sets of duplicate logging statements (more than 4K logging statements in total; each set contains two or more logging statements with the same static message). Specifically, we examine the four following criteria when studying the code snippets: 1) the generated log messages record incorrect information (i.e., the recorded method name is different from the method where the log message is generated), 2) the recorded information cannot be used to distinguish the occurred errors (e.g., to distinguish different exception types), 3) there are inconsistencies in terms of log levels or the recorded debugging information, and 4) the duplicated log message may need to be updated to ensure consistency (i.e., maintenance of logs).


\noindent The process of our manual study involves five phases:

%\vspace{-0.1cm}
%\begin{itemize}\itemsep 0em
{\em Phase I}: The first two authors manually studied 301 randomly sampled (based on 95\% confidence level and 5\% confidence interval~\cite{boslaugh2008statistics}) sets of duplicate logging statements and the surrounding code to derive an initial list of duplicate logging code smell patterns. All disagreements were discussed until a consensus was reached.

%The authors studied all of the static messages, log levels, and surrounding code/comments to derive the patterns.
{\em Phase II}: The first two authors {\em independently} categorized {\em all} of the 1,371 sets of duplicate logging statements to the derived patterns in Phase I. We did not find any new patterns in this phase. The results of this phase have a Cohen’s kappa of 0.811, which is a substantial-level of agreement~\cite{kappa}.

{\em Phase III}: The first two authors discussed the categorization results obtained in Phase II. All disagreements were discussed until a consensus was reached.

{\em Phase IV}: The first two authors further studied all logging code smell instances that belong to each pattern to identify justifiable cases that may not need fixes. The instances that do not belong to the category of justifiable are considered potentially problematic and may require fixes.

{\em Phase V}: We verified both the problematic and justifiable instances of logging code smells with developers by creating pull requests, sending emails, or posting our findings on developers’ forums (e.g., Stack Overflow). We reported every instance that we believe to be problematic (i.e., require fixes), and reported a number of instances for each justifiable category.



\begin{table}
\caption{Patterns of duplicate logging code smells
and corresponding examples.}
\vspace{-0.2cm}
\centering
\resizebox{\columnwidth}{!} {%
%\begin{adjustbox}{width=1\textwidth}
\scalebox{1}{
\begin{tabular}{m{0.04\textwidth} | m{.60\textwidth}  }%{ m{3cm} |l}
\toprule
\textbf{Pattern} & \textbf{Example} \\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\midrule
%This example is from Cloudstack, com.cloud.api.dispatch.ParamProcessWorker.processParameters
IC &
\includegraphics[width=0.60\textwidth]{figures/manual_IC}

\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\midrule
%This example is from Cloudstack
IE & \includegraphics[width=0.60\textwidth]{figures/manual_IE}
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\midrule
%This is from CloudStack
LM & \includegraphics[width=0.60\textwidth]{figures/manual_M}
\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\midrule
%This is from Cassandra, same class: CompactionManager
IL & \includegraphics[width=0.60\textwidth]{figures/manual_L}
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\midrule
%This example is from Hadoop
DP & \includegraphics[width=0.60\textwidth]{figures/manual_DI}
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bottomrule
\end{tabular}}
%\vspace{-0.3cm}
}
%\end{adjustbox}
\vspace{-0.3cm}
\label{tab:patterns}
\end{table}

\begin{table}
    \caption{Number of problematic instances ({\sf Prob.}) verified by our manual study and developers' feedback, number of instances of technical debt ({\sf Tech.}), and total number of instances (Total) including non-problematic instances.\label{tab:manual}}
	\vspace{-0.3cm}
    \centering
    %\resizebox{\columnwidth}{!} {
    \tabcolsep=1pt
    \begin{tabular}{lcc|cc|cc|cc|cc}

        \toprule
        & \multicolumn{2}{c|}{\textbf{IC}} & \multicolumn{2}{c|}{\textbf{IE}} & \multicolumn{2}{c|}{\textbf{LM}} & \multicolumn{2}{c|}{\textbf{IL }} & \multicolumn{2}{c}{\textbf{DP}}\\
        & Prob.  & Total & Prob. &Total& Prob.  &Total& Prob. &Total& Tech.  &Total\\
        \midrule
        \textbf{Cassandra}     & 1  & 1 & 0  & 1 & 0  & 0 & 0 & 3 & 2  & 2 \\
        \textbf{CloudStack}    & 8  & 8 & 4  & 14 & 27  & 27 & 0 & 47 & 107 & 107 \\
        \textbf{Elasticsearch} & 1  & 1 & 0  & 5 & 1  & 1 & 0 & 9 & 3  & 3 \\
        \textbf{Flink}        & 0  & 0 & 2  & 5 & 4  & 4 & 0 & 14 & 24  & 24 \\
        \textbf{Hadoop}        & 5  & 5 & 0  & 0 & 9  & 9 & 0 & 17 & 27  & 27 \\

        \midrule
        \textbf{Total}         & 15  & 15 & 6 & 25 & 41  & 41 & 0  & 90 & 163\tnote{1}  & 163 \\


        \bottomrule
    \end{tabular}

	\vspace{-0.6cm}

    %}
\end{table}



\phead{Results.} In total, we uncovered five patterns of duplicate logging code smells. Table~\ref{tab:patterns} lists the uncovered code smell patterns and the corresponding examples. Table~\ref{tab:manual} shows the number of problematic code smell instances for each pattern that we manually found.
Below, we discuss each pattern according to the following template:


\begin{LaTeXdescription}
  \item[{\em Description:}] A description of the pattern of duplicate logging code smell.
  \item[{\em Example:}] An example of the pattern.
  \item[{\em Code smell instances:}] Discussions on the manually-uncovered code smell instances. We also discuss the justifiable cases if we found any.
  \item[{\em Developers' feedback:}] A summary of developers' feedback on both the problematic and justifiable cases.

\end{LaTeXdescription}



\phead{Pattern 1: Inadequate information in catch blocks (IC).}

\noindent{\bf {\em Description. }}Developers usually rely on logs for error diagnostics when exceptions occur~\cite{Yuan:2014:STP:2685048.2685068}. However, we find that sometimes, duplicate logging statements in different {\em catch} blocks of the same {\em try} block may cause debugging difficulties since the logs fail to tell which exception occurred.

\noindent{\bf {\em Example. }}As shown in Table~\ref{tab:patterns}, in the {\tt\small ParamProcessWorker} class in CloudStack, the {\em try} block contains two {\em catch} blocks; however, the log messages in these two {\em catch} blocks are identical. Since both the exception message and stack trace are not logged, once one of the two exceptions occurs, developers may encounter difficulties in finding the root causes and determining the occurred exception.

\noindent{\bf {\em Code smell instances. }}After examining all the instances of IC, we find that all of them are potentially problematic and require fixes. For all the instances of IC, none of the exception type, exception message, and stack trace are logged. %In other words, developers may not be able to identify what the occurred exception is when analyzing the logs, since the log messages are the same and there is insufficient error diagnostic information (e.g., no stack trace nor exception message) being recorded by the logging statements.

\noindent{\bf {\em Developers' feedback. }}We reported all the problematic instances of IC (15 instances), and all of them are fixed by adding more error diagnostic information (e.g., stack trace) into the logging statements. %  All the pull requests were accepted by developers and the fixes were integrated to the studied systems. 
Developers agree that IC will cause confusion and insufficient information in the logs, which may increase the difficulties of error diagnostics.

\phead{Pattern 2: Inconsistent error-diagnostic information (IE).}
\noindent{\bf {\em Description. }}We find that sometimes duplicate logging statements for recording exceptions may contain inconsistent error-diagnostic information (e.g., one logging statement records the stack trace and the other does not), even though the surrounding code is similar. %Namely, the recorded dynamic variables are different (e.g., one log records the stack trace but the other log does not), .

\noindent{\bf {\em Example. }}As shown in Table~\ref{tab:patterns}, the two classes in CloudStack: {\tt\small Create\textbf{PortForwarding}RuleCmd} and {\tt\small Create\textbf{Firewall}RuleCmd} have similar functionalities. The two logging statements have the same static text message and are in methods with identical names (i.e., {\em create()}, not shown due to space restriction). %The two {\em create()} methods are very similar to each other in terms of code structure.
The {\em create()} method in {\tt\small Create\textbf{PortForwarding}RuleCmd} is about creating rules for port forwarding, and the method in {\tt\small Create\textbf{Firewall}RuleCmd} is about creating rules for firewalls. These two methods have very similar code structure and business logic. However, the two logging statements record different information: One records the stack trace information and the other one only records the exception message (i.e., {\em ex.getMessage()}). Since the two logging statements have similar context, the error-diagnostic information recorded by the logs may need to be consistent for the ease of debugging. We reported this example, which is now fixed to have consistent error-diagnostic information.

\noindent{\bf {\em Code smell instances. }} We find 25 instances of IE (Table~\ref{tab:manual}), and six of them are considered problematic in our manual study. %(all pull requests are accepted by developers).
From the remaining instances of IE, we find three justifiable cases that may not require fixes.

{\em \underline{Justifiable case IE.1:} Duplicate logging statements record general and specific exceptions}.
For 11/25 instances of IE, we find that the duplicate logging statements are in the {\em catch} blocks of different types of exception. In particular, one duplicate logging statement is in the {\em catch} block of a generic exception (i.e., the {\tt\small Exception} class in Java) and the other one is in the {\em catch} block of a more specific exception (e.g., application-specific exceptions such as {\tt\small CloudRuntimeException}). In all of the 11 cases, we find that one log would record the stack trace for \texttt{\small Exception}, and the duplicate log would only record the type of the occurred exception (e.g., by calling {\em e.getMessage()}) for a more specific exception. The rationale may be that generic exceptions, once occurred, are often not expected by developers~\cite{Yuan:2014:STP:2685048.2685068}, so it is important that developers record more error-diagnostic information.

{\em \underline{Justifiable case IE.2:} Duplicate logging statements are in the same catch block for debugging purposes}.
For 6/25 instances of IE, the duplicate logging statements are {\em in the same} {\em catch} block and developers' intention is to use a duplicate logging statement at {\em debug} level to record rich error-diagnostic information such as stack trace (and the log level of the other logging statement could be {\em error}). The extra logging statements at {\em debug} level help developers debug the occurred exception and reduce logging overhead in production~\cite{Li2017} (i.e., logging statements at debug level are turned off). %In particular, the duplicate log at the {\em debug} level records additional information (e.g., stack trace) that helps developers debug the occurred exception and reduces logging overhead in production~\cite{Li2017}.

{\em \underline{Justifiable case IE.3:} Having separate error-handling classes}. For 2/25 instances, we find that the error-diagnostic information is handled by creating an object of an error-handling class. As an example from CloudStack:

\begin{lstlisting}
public final class LibvirtCreateCommandWrapper {
    ...
        } catch (final CloudRuntimeException e) {
            s_logger.debug("Failed to create volume: " + e.toString());
            return new CreateAnswerErrorHandler(command, e);
        }
    ...
}

public class KVMStorageProcessor {
    ...
        } catch (final CloudRuntimeException e) {
            s_logger.debug("Failed to create volume: ", e);
            return new CopyCmdAnswerErrorHandler(e.toString());
        }
    ...

}
\end{lstlisting}
In this example, extra logging is added by using error-handling classes (i.e., {\tt\small CreateAnswerErrorHandler} and {\tt\small CopyCmdAnswerErrorHandler}) to complement the logging statements. As a consequence, the {\em actual} logged information is consistent in these two methods: One method records {\em e.toString()} in the logging statement and records the exception variable {\em e} through an error-handling class; the other method records {\em e} in the logging statement and records {\em e.toString()} through an error-handling class.

\noindent{\bf {\em Developers' feedback. }} We reported all the six instances of IE that we consider problematic to developers, all of which are fixed. Moreover, we ask developers whether our conjecture was correct for each of the justifiable cases of IE. Developers confirmed our observation on the justifiable cases. They agreed that those cases are not problematic thus do not require fixes. 
%We received positive feedback that confirms our manual analysis on the justifiable cases.



\phead{Pattern 3: Log message mismatch (LM).}

\noindent{\bf {\em Description. }}Sometimes after developers copy and paste a piece of code to another method or class, they may forget to change the log message. This results in having duplicate logging statements that record inaccurate system behaviors.



%resulting in duplicate logging statements in different code locations.

\noindent{\bf {\em Example. }} As an example, in Table~\ref{tab:patterns}, the method {\em doScaleDown()} is a code clone of {\em doScaleUp()} with very similar code structure and minor syntactical differences. However, developers forgot to change the log message in {\em doScaleDown()}, after the code was copied from {\em doScaleUp()} (i.e., both log messages contain {\em scaling up}). Such instances of LM may cause confusion when developers analyze the logs.

\noindent{\bf {\em Code smell instances. }} We find that there are 41 instances of LM that are caused by copying-and-pasting the logging statement to new locations without proper modifications. For all the 41 instances, the log message contains words of incorrect class or method name that may cause confusion when analyzing logs.

\noindent{\bf {\em Developers' feedback. }} Developers agree that the log messages in LM should be changed in order to correctly record the execution behavior (i.e., update the copy-and-pasted log message to contain the correct class/method name). We reported all the 41 instances of LM that we found and all of them are fixed. %through pull requests, and all of the reported instances are now fixed.




\phead{Pattern 4: Inconsistent log level (IL).}
%76 instances in total among the 4 systems.

\noindent{\bf {\em Description. }}Log levels (e.g., {\em fatal}, {\em error}, {\em info}, {\em debug}, or {\em trace}) allow developers to specify the verbosity of the log message and to reduce logging overhead when needed% (e.g., {\em debug} is usually disabled in production)
~\cite{Li2017}. A prior study~\cite{Yuan:2012:CLP:2337223.2337236} shows developers frequently modify log levels to find the most adequate level. We find that there are duplicate logging statements that, even though the log messages are exactly the same, the log levels are different.

\noindent{\bf {\em Example. }} In the IL example shown in Table~\ref{tab:patterns}, the two methods, which are from the same class {\tt\small CompactionManager}, have very similar functionality (i.e., both try to perform cleanup after compaction), but different log levels. %we find that the log levels are different in these two methods.

\noindent{\bf {\em Code smell instances. }} We find three justifiable cases in IL that may be developers' intended behavior. We do not find problematic instances of IL after communicating with developers -- Developers think the problematic instances identified by our manual analysis may not be problems.

{\em \underline{Justifiable case IL.1:} Duplicate logging statements are in the catch blocks of different types of exception}. Similar to what we observed in IE, we find that for 9/90 instances, the log level for a more generic exception is usually more severe (e.g., {\em error} level for the generic Java {\tt\small Exception} and {\em info} level for an application-specific exception). Generic exceptions might be unexpected to developers~\cite{Yuan:2014:STP:2685048.2685068}, so developers may use a higher log level (e.g., {\em error}) to record exception messages.

{\em \underline{Justifiable case IL.2:} Duplicate logging statements are in different branches of the same method}. There are 42/90 instances belong to this case. Below is an example from Elasticsearch, where a set of duplicate logging statements occur in the same method but in different branches.
\begin{lstlisting}
   if (lifecycle.stoppedOrClosed()) {
        logger.trace("failed to send ping transport message", e);
   } else {
        logger.warn("failed to send ping transport message", e);
   }
\end{lstlisting}
In this case, developers already know the desired log level and intend to use different log levels due to the difference in execution (i.e., in the if-else block). %Note that the condition may also be a log level guard (e.g., {\tt if (LOGGER.isDebugEnabled()}) or a {\tt switch} statement.

{\em \underline{Justifiable case IL.3:} Duplicate logging statements are followed by error-handling code}. There are 19/90 instances that are observed to have such characteristics: In a set of duplicate logging statements, some statements have log levels of higher verbosity, and others have log levels of lower verbosity. However, the duplicate logging statement with lower verbosity log level is followed by additional error handling code (e.g., {\em throw a new Exception(e);}). Therefore, the error is handled elsewhere (i.e., the exception is re-thrown), and may be recorded at a higher-verbosity log level.


\noindent{\bf {\em Developers' feedback. }} In all the instances of IL that we found, developers think that IL may not be a problem. In particular, developers agreed with our analysis on the justifiable cases. However, developers think the problematic instances of IL from our manual analysis may also not be problems. We concluded the following two types of feedback from developers on the ``suspect'' instances of IL (i.e., 20 problematic ones from our manual analysis out of the 90 instances of IL).
The first type of developers' feedback argues the importance of semantics and usage scenario of logging in deciding the log level. A prior study~\cite{Yuan:2012:CLP:2337223.2337236} suggests that logging statements that appear in syntactically similar code, but with inconsistent log levels, are likely problematic. However, based on the developers' feedback that we received, IL still may not be a concern, even if the duplicate logging statements reside in very similar code. A developer indicated that ``conditions and messages are important but the {\it context} is even more important''. As an example, both of the two methods may display messages to users. One method may be displaying the message to {\em local} users with a {\em debug} logging statement to record failure messages. The other method may be displaying the message to {\em remote} users with an {\em error} logging statement to record failure messages (problems related to remote procedure calls may be {\em more severe} in distributed systems). Hence, even if the code is syntactically similar, the log level has a reason to be different due to the different semantics and purposes of the code (i.e., referred to as different {\it contexts} in developers' responses). Our findings show that future studies should consider both the syntactic structure and semantics of the code when suggesting log levels.

The second type of developers' feedback acknowledges the inconsistency. However, developers are reluctant to fix such inconsistencies since developers do not view them as concerns.
For example, we reported the instance of IL in Table~\ref{tab:patterns} to developers. A developer replied:
\noindent ``I think it should probably be an {\it ERROR} level, and I missed it in the review (could make an argument either way, I do not feel strongly that it should be {\it ERROR} level vs {\it INFO} level.'' %, but it should be consistent).''
Our opinions (i.e., from us and prior studies~\cite{Yuan:2012:CLP:2337223.2337236, Li2017}) differ from that of developers' regarding whether such inconsistencies are problematic.
On one hand, whether an instance of IL is problematic or not can be subjective. This shows the importance of including perspectives from multiple parties (e.g., user studies or interviews) in future studies of software logging practice.
On the other hand, the discrepancy also indicates the need of establishing a guidance for logging practice and further even enforcing such standard. In short, none of the IL instances that we manually identified are problematic based on developers' feedback. 



\phead{Pattern 5: Duplicate logging statements in polymorphism (DP).}

\noindent{\bf {\em Description. }}Classes in object-oriented languages are expected to share similar functionality if they inherit the same parent class or if they implement the same interface (i.e., polymorphism). Since log messages record a higher level abstraction of the program~\cite{Shang:2014:ULL:2705615.2706065}, we find that even though there are no clones among a parent method and its overridden methods, such methods may still contain duplicate logging statements. Such duplicate logging statements may cause maintenance overhead. For example, when developers update one log message, they may forget to update the log message in all the other sibling classes. Inconsistent log messages may cause problems during log analysis~\cite{mehran_emse_2018, HADOOP-4190, logzip, loghub}.

\noindent{\bf {\em Example. }} In Table~\ref{tab:patterns}, the two classes ({\tt\small PowerShellFencer} and {\tt\small ShellCommandFencer}) in Hadoop both extend the same parent class, implement the same interface, and share similar behaviors. The inherited methods in the two classes have identical log message. However, as the system evolves, developers may not always remember to keep the log messages consistent, which may cause problems during system debugging, understanding, and analysis.

\noindent{\bf {\em Code smell instances. }} We find that all the 163 instances of DP are potentially problematic that may be fixed by refactoring. In most of the instances, the parent class is an abstract class, and the duplicate logging statements exist in the overridden methods of the subclasses. We also find that in most cases, the overridden methods in the subclasses are very similar with minor differences (e.g., to provide some specialized functionality), which may be the reason that developers use duplicate logging statements.

\noindent{\bf {\em Developers' feedback. }} Developers agree that DP is associated with logging code smells and specific refactoring techniques are needed. %From the feedback that we received, developers generally agree that DP is related to logging code smells.
One developer comments that:

\noindent {\em ``You want to care about the logging part of your code base in the same way as you do for business-logic code (one can argue it is part of it), so salute DRY (do-not-repeat-yourself).''}


Based on developers' feedback, DP is viewed more as technical debts~\cite{Kruchten:2012:TDM:2412381.2412847}, while resolving DP often requires systematic refactoring. 
However, to the best of our knowledge, current Java logging frameworks, such as SLF4J and Log4j 2, do not support the use of polymorphism in logging statements. Thus, we find that developers are more reluctant to fix DP. The way to resolve DP is to ensure that the log message of the parent class can be reused by the subclasses, e.g., storing the log message in a static constant variable. We received similar suggestions from developers on how to refactor DP, such as {\it ``adding a method in the parent class that generates the error text for that case:  logger.error(notAccessible( field.getName()));}'', or {\it ``creat[ing] your own Exception classes and put message details in them''.} We find that without supports from logging frameworks, even though developers acknowledged the issue of DP, they do not want to {\em manually} fix the code smells. Similar to some code smells studied in prior research~\cite{Johnson:2013:WDS:2486788.2486877, Silva:2016:WWR:2950290.2950305}, developers may be reluctant to fix DP due to additional maintenance overheads but limited supports (i.e., need to manually fix hundreds of DP instances). Therefore, we did not report all the instances of DP and refer to the instances of DP as technical debts, instead of problematic instances, in the rest of the paper.  In short, logging frameworks should provide better support to developers in creating log ``templates'' that can be reused in different places in the code.  % that exceeds the benefits



\phead{Discussions on duplicate logging statements that do not belong to one of the uncovered smells.} In this paper, we focus on studying the problematic patterns of duplicate logging statements. However, we do not consider all duplicate logging statements as bad logging practice. For other duplicate logging statements that do not belong to the identified smells, we did not find evidence that they may cause confusion when analyzing logs. In most of the cases, the log message may be similar by coincidence (e.g., the log messages are used to record a certain type of exception message and stack trace). In some cases, we found that developers intentionally write duplicate logging statements with comments explaining the reasons. For example, some developers mentioned in the comment that the code snippet is copied from another class, and said the code should be refactored in the future. In some other cases, developers described the intention of the two duplicate logging statements. Although the static messages are identical, the comments are different, which shows that duplicate logging statements could have different intentions in different places. In such cases, duplicate logging statements may assist machine-learning based approaches to suggest where-to-log.


\rqboxc{We manually uncovered five patterns of duplicate logging code smells. % and six justifiable cases where the code smell instances may not need fixes. 
In total, our manual study helped developers fix 62 problematic duplicate logging code smells in the studied systems.}
\vspace{-0.2cm}




