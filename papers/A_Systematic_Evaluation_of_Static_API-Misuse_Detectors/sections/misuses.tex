%!TEX root = ../paper.tex

\section{Background and Terminology}
\label{sec:definitions}

An \emph{API usage} (\textit{usage}, for short) is a piece of code that uses a given API to accomplish some task.
It is a combination of basic~\textit{program elements}, such as method calls, exception handling, or arithmetic operations.
The combination of such elements in an API usage is subject to constraints, which depend on the nature of the API.
We call such constraints \emph{usage constraints}.
For example, two methods may need to be called in a specific order, division may not be used with a divisor of zero, and a file resource needs to be released along all execution paths.
When a usage violates one or more such constraints, we call it a \emph{misuse}, otherwise a \emph{correct usage}. 

The detection of API misuses may be approached through \emph{static analyses} of source code or binaries and through \emph{dynamic analyses}, i.e., runtime monitoring or analysis of runtime data, such as traces or logs.
In either case, the detection requires either specifications of correct API usage to find violations of or specifications of misuses to find instances of.
Such specifications may be \emph{crafted manually} by experts or \emph{inferred automatically} by algorithms.
Automatic specification inference (or \textit{mining}) may, again, be approached both \emph{statically}, e.g., based on code samples or documentation, and \emph{dynamically}, e.g., based on traces or logs.

Since manually crafting and maintaining specifications is costly, in this work, we focus on automated detectors.
We call such tools \emph{API-misuse detectors}.
In the literature, we find \emph{static misuse detectors}, which statically mine specifications and detect misuses through static analysis, e.g., \cite{WZL07,NNP+09,MM13};
\emph{dynamic misuse detectors}, which dynamically mine specifications and detect misuses through dynamic analysis, e.g., \cite{PG12,LZLJMSR14};
and \emph{hybrid misuse detectors}, which, for example, combine dynamic specification mining with static detection~\cite{PJAG12}.
In this work, we focus on static API-misuse detectors.
 
Static API-misuse detection is often achieved through detecting \emph{deviant code}~\cite{ECHC+01,LZ05,L07,WZL07,RGJ07,NNP+09,AX09,TX09,TX09b,WZ11,MM13,NPVN16}.
The key idea is that mistakes violate constraints that the code should adhere to and that, given sufficiently many examples of correct usage, such violations appear as \emph{anomalies}. 
We call a usage that appears frequently in programs a \emph{pattern}.
The identification of mistakes through the detection of deviant code assumes that patterns correspond to correct usages (specifications) and anomalies with respect to these patterns are, consequently, misuses.
Such an approach can detect mistakes in the usage of popular libraries~\cite{ECHC+01,LZ05,WZL07,NNP+09,WZ11,MM13}.

In our previous work~\cite{ANNN+16}, we collected a dataset of Java API misuses by reviewing bug reports of \checkNum{21 real-world projects} and surveying developers about API misuses.
We call this dataset \MUBench.
It contains \checkNum{90 misuses}, \checkNum{73 misuses} from the real-world projects and \checkNum{17} from the survey (see \autoref{tab:datasets}, Row 1).
For each real-world misuse, the dataset identifies the \emph{project} where the misuse is, the \emph{project version} that contains the misuse, and the commit that fixed the misuse.
For the other misuses, \MUBench provides hand-crafted misuse examples and their fixes.

\begin{table}[tb]
  \centering
  \input{sections/table-datasets}
  \label{tab:datasets}
\end{table}



\section{The API-Misuse Classification (\MUC)} % (fold)
\label{sec:api_misuses}

In this section, we introduce the  \emph{API-Misuse Classification} (\MUC), our taxonomy for API misuses.
We derive \MUC from the misuse examples in the \MUBench dataset.
In \autoref{sec:misuse-detectors-related-work}, we use \MUC to qualitatively compare the capabilities of existing API-misuse detectors.
In \autoref{sec:results}, we use \MUC to define our expectations on the detectors' performance.
Before presenting the classification itself, we briefly~discuss existing related classifications to motivate the need for \MUC.

\subsection{Motivation for \MUC}
%% Classifications

IEEE has a standard for classifying software defects~\cite{IEEE10}, which served as the basis for IBMâ€™s \aName{Orthogonal Defect Classification} (ODC)~\cite{CBCHMRW92}.
The ODC uses the defect type as one of the aspects from which to classify defects.
The defect type is composed of a conceptual program element, such as a function, check, assignment, documentation, or algorithm, and a violation type, i.e., either \emph{missing} or \emph{incorrect}.
%
More recently, Beller~\etal~\cite{BBMZ16} presented the \aName{General Defect Classification} (GCD), a remote ODC-descendant, tailored to compare the capabilities of automated static-analysis tools.
%
Both classifications capture the entire domain of all types of software defects.
To compare the capabilities of API-misuse detectors, we need a more fine-grained differentiation of a subset of the categories in both of them.

Past work presented empirical studies and taxonomies of API-usage directives~\cite{DH09,METM12}.
Many of these directives can be thought of as usage constraints in our terminology and their violations, consequently, as misuses.
Other directives, however, do not formulate constraints.
Examples are directives that explicitly allow \code{null} to be passed as a parameter and directives that inform about alternative ways to achieve a behaviour (possibly with different trade-offs).
Therefore, we cannot directly convert a taxonomy of usage directives into a taxonomy of misuses.
Instead, to consider the directives that can be viewed as usage constraints, we extend \MUBench~\cite{ANNN+16} by hand-crafted examples of misuses violating them, which we derive from examples in the studies.
This gives us \checkNum{10 additional misuses}, resulting in a total of \checkNum{100 misuses} that we use for \MUC and our experiments (see \autoref{tab:datasets}, Row 2).
For simplicity, we subsequently refer to this extended dataset as \MUBench.

%In the \MUBench data paper~\cite{ANNN+16}, we provided a basic API-misuse classification.
%However, in this work, we want to provide a more comprehensive and detailed classification to enable us to compare existing misuse detectors.
%In addition to the original \MUBench misuses, we consider the findings of two empirical studies on API usage directives~\cite{DH09,METM12}.
%Many of the directives those studies identify can be thought of as usage constraints in our terminology and their violation, consequently, as misuses.
%The studies report directives corresponding to all violations in \MUBench and a few more.~\sn{doesn't that make it sound like we could have just used these directives since they correspond to exactly what we have plus more?}
%To make \MUBench more comprehensive, we add hand-crafted examples of misuses violating these additional directives, which we derive from the examples in the studies.



\subsection{The Classification}

We developed \MUC using a variation of Grounded Theory~\cite{GS67}:
Following our notion of API misuses as API usages with one or more violations of usage constraints, the first author of this work went through all the misuses in \MUBench and came up with labels for the characteristics of the respective violations, until each misuse was tagged with at least on label.
Subsequently, all authors iteratively revisited the labelled misuses to unify semantically equivalent labels and group related labels, until we had a consistent taxonomy.
In the end, we had two dimensions whose intersection describes all violations in \MUBench:
the type of the involved API-usage element and the type of the violation.
Consequently, we define a \emph{violation} as a pair of a violation type and an API-usage element.

An \textit{API-usage element} is a program element that appears in API usages.
The following elements are involved in the misuses in \MUBench:
\emph{method calls}, \emph{conditions}, \emph{iterations}, and \emph{exception handling}.
Note that we consider primitive operators, such as arithmetic operators, as methods.
For conditions, we further distinguish \emph{\code{null} checks}, \emph{value or state conditions}, \emph{synchronization conditions}, and \emph{context conditions}, because of their distinct properties.

The \textit{violation type} describes how a usage violates a given usage constraint with respect to a given usage element.
In \MUBench, we find \checkNum{two} violation types: {\em missing} and {\em redundant}.
Violations of the missing type come from constraints that mandate the presence of a usage element.
They generally cause program errors.
An example of such a violation is a ``missing method call.''
Violations of the redundant type come from constraints that mandate the absence of a usage element or declare the presence of a usage element unnecessary.
Note that in either case the repetition of an element may have undesired effects, such as errors or decreased performance.
An example of such a redundant violation is a ``redundant method call.''

\autoref{tab:muc} shows a summary of \MUC.
The numbers in the cells show how many misuses in \MUBench have a respective violation.
Note that a single misuse may have multiple violations; thus, the individual cells in the table sum up to more than \checkNum{100}.
The table shows that missing method calls, \code{null} checks, and value or state conditions are the most prevalent violations.
Redundant calls and missing exception handling are less frequent, but still prevalent, while we have only few examples of the other violations.

We now discuss the different violation categories shown in \autoref{tab:muc}, grouped by the API-usage element involved.

\begin{table}
  \centering
  \caption{The Misuse Classification (\MUC), with the number of misuses with a particular violation in \MUBench.}
    \input{sections/table-muc}
  \label{tab:muc}
\end{table}


\subsubsection*{Method Calls}

Method calls are the most prominent elements of API usages, as they are the primary means of communication between client code and the API.

One violation category is \emph{missing method calls}, which occur if a usage does not call a certain method that is mandated by the API usage constraints.
For example, if a usage does not call \code{validate()} on a \code{JFrame} after adding elements to it, which is required for the change to become visible.

The other case is \emph{redundant method calls}, which occur if a usage calls a certain method that is restricted by the API usage constraints.
For example, if a usage calls \code{remove()} on a list that is currently being iterated over, which causes an exception in the subsequent iteration.
% or when \code{finalize()} is called on an \code{Object}, which should never be done from any user-defined code.


\subsubsection*{Conditions}

Client code often needs to ensure conditions for valid communication to an API, in order to adhere to the API's usage constraints.
There are often alternative ways to ensure such conditions.
For example, to ensure that a collection is not empty one may check \code{isEmpty()}, check its \code{size()}, or add an element to it.
Note that checks, in particular, are also a means for the client code to vary usages depending on program inputs.

One violation category is \emph{missing conditions}, which occur if a usage does not ensure certain conditions that are mandated by the API usage constraints.
One case is \emph{missing null checks}, e.g., if a usage fails to ensure that a receiver or a parameter of a call is not \code{null}.
Another case is \emph{missing value or state conditions}, e.g., if a usage fails to ensure that a \code{Map} contains a certain key before using the key to access the \code{Map}.
In multi-threaded environments, \emph{missing synchronization conditions} may occur, e.g., if a usage does not obtain a lock before updating a \code{HashMap} that is accessed from multiple threads~\cite{METM12}.
Finally, \emph{missing context conditions} may also occur, e.g., if a usage fails to ensure that GUI components in \aName{Swing} are updated on the Event Dispatching Thread (EDT)~\cite{DH09}.
% and \code{Logger.setParent()} should not be called from application code~\cite{METM12}.

The other case is \emph{redundant conditions}, where a condition prevents a necessary part of a usage, e.g., a method call, from being executed along certain execution paths or is simply redundant.
One case is \emph{redundant \code{null} checks}, e.g., if the usage checks nullness only after a method has been invoked on the respective object.
Another case is \emph{redundant value or state conditions}, e.g., if the usage checks \code{isEmpty} on a collection that's guaranteed to contain an element.
In multi-thread environments, \emph{redundant synchronization conditions} may occur, e.g., if the usage requests a lock that it already holds, which may cause a deadlock.
Finally, \emph{redundant context conditions} may also occur, e.g., if a \aName{JUnit} assertion is executed on another thread, where its failing cannot be captured by the \aName{JUnit} framework.


\subsubsection*{Iteration}

Iteration is another means of interacting with APIs, used, in particular, with collections and IO streams.
It takes the form of loops and recursive methods.
Note that respective usage constraints are about (not) repeating (part of) a usage, rather than about the condition that controls the execution.
%~\mm{The Iteration category doesn't feels right to me. Aren't the two examples given rather instances of other misusages? The first one could be seen as "check before wait" and the loop is simply a way to ensure this constraint, while the second one can be seen as a superflous call ...
% Where do they come from? And, given that there are only two, does it make sense to get rid of them altogether?}
% \hn{``check before wait'' would over-simplify the usage where wait() is kept being called until the condition is no longer satisfied. The second one cannot be classified as a redundant call be cause the call must be there. } 

One violation category is \emph{missing iterations}, which occur if a usage does not repeatedly check a condition that the API usage constraints mandate must be checked again after executing part of the usage.
For example, the Java documentation states that a call to \code{wait()} on an object should always happen in a loop that checks the condition the code waits for, because \code{wait()} could return before the condition is satisfied, in which case the usage should continue to wait.
%Note that even if the code ensures the correct condition, say, with an \code{if}, the iteration constraint is still violated since the check and, depending on its outcome, the invocation of \code{wait()} are not repeated.\hn{The last sentence is not needed and could confuse readers. The previous sentence already says ``should always happen in a loop''}

The other case is \emph{redundant iterations}, which occur if part of a usage is reiterated that the API usage constraints mandate may be executed not more than once or that is simply redundant.
For example, a \code{Cipher} instance might be reused in a loop to encrypt a collection of values, but its initialization through calling \code{init()} must happen exactly once, i.e., before the loop.
Note that in this situation, the required call is present in the respective code exactly once, as required, but its inclusion in an iteration causes a violation.


\subsubsection*{Exception Handling}

Exceptions are a way for APIs to communicate errors to client code.
The handling of different errors often depends on the specific~API.

One violation category is \emph{missing exception handling}, which occurs if a usage does not take actions to recover from a possible error, as mandated by the API usage constraints.
For example, when initializing a \code{Cipher} with an externally provided cryptographic key, one should handle \code{InvalidKey\-Exception}.
Another example is resources that need to be closed after use, also in case of an exception.
Such guarantees are often implemented by a \code{finally} block, but also using the try-with-resources construct or even respective handling in multiple \code{catch} blocks.

The other case is \emph{redundant exception handling}, which occurs if a usage intercepts exceptions that should not be caught or handled explicitly.
For example, catching \code{Throwable} when executing a command in an application might suppress a \code{CancellationException}, preventing the user from cancelling the execution.
