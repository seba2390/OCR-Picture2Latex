% !TEX root = ../DPIM.tex
% !TEX spellcheck = en-US

In this paper, we have shown that it is possible to obtain a model of the untyped \lam-calculus based on a kind of computational machines that operate exclusively on ``addresses'', without any reference to some basic data-type.
The result only depends on the assumption that every machine has a unique address (and \emph{vice versa} every address identifies a machine) and is completely independent from the specific nature of the addresses themselves.

A natural question that can be raised is whether \am s can be seen as a representation of Combinatory Logic's operational semantics in disguise, since their instructions essentially incorporate the contents of the rewriting rules of the basic combinators. To correct this simplistic point of view, observe that the address table map is an arbitrary bijection, whence there are uncountably many possible choices. In particular, address table maps may have arbitrary computational complexity. On the contrary, the operational semantics is constrained to work with the subterms of the current term, i.e.\ it uses a very ``narrow'' address table map. We plan to investigate in future works what possibilities arise from the extra degree of freedom given by the arbitrary nature of this map.

We would like to explore whether the theory of the \lam-model $\cS$ defined in Section~\ref{sec:consistency} depends on the specific nature of the bijection $\Lookup(\cdot) : \Addrs \to\cM$. As discussed in Remark~\ref{rem:forever}, certain ATMs display some peculiarities, since they may create infinite chains of references morally representing infinitary objects. In fact, given an ATM $\#(-)$ and an  injection $f:\nat\to\Addrs$, a simple application of Hilbert's Hotel allows to define a new ATM $\#'(-)$ where machines $(\mM^f_n)_{n\in\nat}$ satisfying $\mM^f_n = \tuple{f(n),\varepsilon,[\Lookup'(\mM^f_{n+1})]}$ exist.
%For cardinality reasons, not all machines of this kind exist, as one would need a set of addresses having the size of the continuum.
However, these machines are not \lam-definable, whence they should simply constitute non-definable ``junk'' from the model-theoretic perspective. Therefore, we conjecture that $\Th{\cS}$ is actually independent from the choice of the lookup function $\Lookup(\cdot)$.
In case of a positive answer, it would be interesting to provide a complete characterization of the associated \lam-theory.

In Section~\ref{sec:consistency} we have shown that $\Th{\cS}$ is neither extensional nor sensible. This is due to the fact that we kept our construction tight: at each step --- from applicative structure, to combinatory algebra, and finally to \lam-model --- we added the minimal quotient resolving the issue. In order to obtain an extensional model, it would be sufficient to replace the rule $\extrule$ with a form of extensionality non-restricted to machines that become stuck once executed. Similarly, a sensible model can be obtained by collapsing all the addresses of those machines exhibiting a non-terminating behaviour when executed on a number of indeterminates large enough.
These quotients are not difficult to define, but the non-trivial problem becomes to prove that the resulting \lam-model is non-trivial. This is left for further works.

A different line of research, more in the direction of functional programming, is to expand the computational capabilities of \am s by adding simple data-types and the associated basic operations. In fact, although data-types are unnecessary to achieve Turing-completeness, they are desirable to perform arithmetical operations and conditionals.
Preliminary investigations~\cite{IntrigilaMM21} show that extending \am s with numerals, conditional branching, natural numbers basic arithmetic instructions opens the way for representing Plotkin's {\tt PCF}~\cite{Plotkin77}. These investigations show the precise simulation existing between \am 's head reduction and the corresponding evaluation strategy defined on {\tt PCF} extended with explicit substitutions~\cite{LevyM99}. % chktex 32
We will check if results of this kind extend to the call-by-value untyped setting. To begin with, we plan to study whether \am s can be used to represent the crumbling abstract machines from~\cite{AccattoliCGC19}.

%A step in a different direction would be to extend addressing machine with an ``internal state'', taking only a finite number of values and depending on the states of the machines in its ``neighborhood''. The idea is to develop a kind of ``cellular automata'' model and study the interaction between the machines and their asymptotic behavior.


To perform some tests on \am s, we have implemented the formalism both in functional and imperative style. Even if the sources remain for internal use only, some technical choices deserve a discussion. Although not explicitly required by the  definition, any implementation must rely on a computable association between \am s and the corresponding addresses. To implement such a bijection, one could try to use as addresses the actual pointers to the structures representing the machines, but the referenced data might change without affecting the address.
A naive solution consists in defining an association list $\ell$ of type $\Addrs \times \cM$ and an incremental approach. The list $\ell$ is initialized as the empty-list. When a new machine $\mM$ is created, one checks whether $\mM$ belongs to $\pi_2(\ell)$: in the affirmative case there is nothing to do as the machine is already known; otherwise, a new address $a$ is generated and the pair $(a,\mM)$ is added to the list $\ell$. This guarantees that an address uniquely identifies a machine and that, when an address is used, the corresponding machine has already been introduced. For a more optimized solution one should employ the hash-consing technique, allowing to implement the same concept in a more efficient way.
\smallskip

\paragraph{Acknowledgements} This work is partly supported by ANR Project PPS, ANR-19-CE48-0014. We would like to thank Henk Barendregt for interesting discussions concerning the problem of finding a model of \lam-calculus based on recursive functions, as well as the role of the $(\omega)$-rule. % chktex 8
We are grateful to the anonymous reviewers for the careful reading and insightful suggestions.
We also thank Nicolas M\"unnik for his comments on the paper.
