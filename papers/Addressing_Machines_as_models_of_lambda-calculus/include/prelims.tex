% !TEX root = ../DPIM.tex
% !TEX spellcheck = en-US

We present some notions that will be useful in the rest of the article.

\subsection{The Lambda Calculus --- Its Syntax}\label{subsec:lamcal}

For the \lam-calculus we mainly follow Barendregt's first book~\cite{Bare}.
We consider fixed a countable set $\Var$ of \emph{variables} denoted by $x,y,z,\dots$
\begin{defi}
The set $\Lam$ of \emph{\lam-terms} over $\Var$ is generated by the following simplified\footnote{
This basically means that parentheses are left implicit.} grammar (for $x\in\Var$):
\begin{equation}\tag{$\Lambda$}
M,N,P,Q \eqbnf\ x\mid \lam x.M\mid MN
\end{equation}
\end{defi}
We assume that application is left-associative and has a higher precedence than \lam-abstraction. Therefore $\lam x.\lam y.\lam z.xyz$ stands for $(\lam x.(\lam y.(\lam z.(xy)z)))$.
Moreover, we often write $\lam x_1\dots x_n.M$ for $\lam x_1\dots \lam x_n.M$.

\begin{defi} Let $M\in\Lam$.
\begin{enumerate}[(i)]
\item The set $\FV{M}$ of \emph{free variables} of $M$ is defined by induction:
\[
	\begin{array}{lll}
	\FV{x} &=& \set{x},\\
	\FV{\lam x.P} &=& \FV{P} -\set{x},\\
	\FV{PQ} &=&\FV{P}\cup\FV{Q}.\\
	\end{array}
\]
\item We say that $M$ is \emph{closed}, or \emph{a combinator}, whenever $\FV{M} = \emptyset$.
\item We let $\Lamo = \set{ M\in\Lam \st \FV{M} = \emptyset}$ be the set of all combinators.
\end{enumerate}
\end{defi}

\noindent
 The variables occurring in $M$ that are not free are called ``bound''.
From now on, \lam-terms are considered modulo \emph{$\alpha$-conversion}, namely, up to the renaming of bound variables (see~\cite[\S2.1]{Bare}).
\begin{nota} Concerning specific combinators we let:
\[
	\begin{array}{lcll}
	\comb{I}&=&\lam x.x,&\textrm{identity,}\\
	\comb{1}&=&\lam xy.xy,&\textrm{an $\eta$-expansion of the identity,}\\
	\comb{K}&=&\lam xy.x,&\textrm{first projection,}\\
	\comb{F}&=&\lam xy.y,&\textrm{second projection,}\\
	\comb{S}&=&\lam xyz.xz(yz),&\textrm{$S$-combinator from Combinatory Logic,}\\
	\comb{\Delta}&=&\lam x.xx,&\textrm{self-application,}\\
	\Om&=&\comb{\Delta\Delta},&\textrm{paradigmatic looping combinator,}\\
	\comb{Y}&=&\lam f.(\lam x.f(xx))(\lam x.f(xx)),&\textrm{Curry's fixed point combinator.}\\
	\end{array}
\]
\end{nota}
The \lam-calculus is given by the set $\Lam$ endowed with reduction relations that turn it into a higher-order term rewriting system.

We say that a relation $\rel{R}\subseteq\Lam^2$ is \emph{compatible} if it is compatible w.r.t.\ application and \lam-abstraction. This means that, for $M,N,P\in\Lam$, if $M \rel{\,R\,} N$ holds then also $MP \rel{\,R\,} NP$, $PM \rel{\,R\,}PN$ and $\lam x.M \rel{\,R\,} \lam x.N$ hold.

\begin{defi} Define the following reduction relations.
\bsub
\item The \emph{$\beta$-reduction} $\to_\beta$ is the least compatible relation closed under the rule
\begin{equation}\tag{$\beta$}
	(\lam x.M)N\to M\subst{x}{N}
\end{equation}
where $M\subst{x}{N}$ denotes the \lam-term obtained by substituting $N$ for all free occurrences of $x$ in $M$, subject to the usual proviso about renaming bound variables in $M$ to avoid capture of free variables in $N$.
\item Similarly, the \emph{$\eta$-reduction} $\to_\eta$ is the least compatible relation closed under the rule
\begin{equation}\tag{$\eta$}
	\lam x.Mx \to M, \textrm{ if }x\notin\FV{M}.
\end{equation}
\item Moreover, we define $\to_\be\ =\ \to_\beta\cup\to_\eta$.
\item
	The relations $\to_\beta,\to_\eta$ and $\to_\be$ respectively generate the notions of \emph{multi-step reduction}  $\msto,\msto[\eta],\msto[\beta\eta]$ (resp.\ \emph{conversion} $=_\beta,=_\eta,=_\be$) by taking the reflexive and transitive (and symmetric) closure.
\esub
\end{defi}

\begin{thm}[Church-Rosser]
The reduction relation $\msto[\beta(\eta)]$ is confluent:
\[
M\msto[\beta(\eta)] M_1 \und M\msto[\beta(\eta)]M_2\imp \exists N\in\Lam\,.\,
M_1\msto[\beta(\eta)] N \invredd[\beta(\eta)]M_2
\]
\end{thm}
The \lam-terms are classified into solvable and unsolvable, depending on their capability of interaction with the environment.
\begin{defi}
A \lam-term $M$ is called \emph{solvable} if $(\lam\vec x.M)\vec P =_\beta \comb{I}$ for some $\vec x$ and $\vec P\in\Lam$. Otherwise $M$ is called \emph{unsolvable}.
\end{defi}
We say that a \lam-term $M$ \emph{has a head normal form} (\emph{hnf}) if it reduces to a \lam-term of shape $\lambda x_{1}\ldots x_{n}.yM_{1}\cdots M_{k}$ for some $n,k\ge 0$.
As shown by Wadsworth in~\cite{Wadsworth76}, a \lam-term $M$ is solvable if and only if $M$ has a head normal form.
The typical examples of unsolvable \lam-terms are $\Om, \lam x.\Om$ and $\comb{YI}$.

\subsection{Lambda theories and lambda models}

Conservative extensions of $\beta$-conversion are known as ``\lam-theories'' and have been extensively studied in the literature, see e.g.~\cite{Bare,LusinS04,IntrigilaMP19,IntrigilaS17,ManzonettoPSS19}.

\begin{defi}\
\bsub
\item A \emph{\lam-theory} $\cT$ is any congruence on $\Lam^2$ including $\beta$-conversion $=_\beta$.
\item A \lam-theory $\cT$ is called:
\begin{itemize}
\item \emph{consistent}, if $\cT$ does not equate all \lam-terms;
\item \emph{inconsistent}, if $\cT$ is not consistent;
\item \emph{extensional}, if $\cT$ contains the $\eta$-conversion $=_\eta$ as well;
\item \emph{sensible}, if $\cT$ is consistent and equates all unsolvable \lam-terms;
\item \emph{semi-sensible}, if $\cT$ does not equate a solvable and an unsolvable.
\end{itemize}
\esub
We write $\cT\vdash M = N$, or simply $M =_\cT N$, whenever $(M,N)\in\cT$.
\end{defi}

The set of all \lam-theories, ordered by inclusion, forms a quite rich complete lattice.
We denote by $\blam$ (resp.\ $\blame$) the smallest (resp.\ extensional) \lam-theory.
Both $\blam$ and $\blame$ are consistent, semi-sensible but not sensible.
A \lam-theory can be introduced syntactically, or semantically as the theory of a model. The model theory of \lam-calculus is largely based on the notion of combinatory algebras, and its variations (see, e.g.,~\cite{Koymans82,Selinger02,Meyer82,HindleyLS72} and~\cite[Ch.~5]{Bare}).

\begin{defi}\
\bsub
\item An \emph{applicative structure} is given by $\cA = (A,\cdot\,)$ where $A$ is a set and $(\cdot)$ is a binary operation on $A$ called \emph{application}.
We represent application as juxtaposition and we assume it is left-associative, e.g., $abc = (a\cdot b)\cdot c$.
An equivalence $\simeq$ on $\cA$ is a \emph{congruence} if it is compatible w.r.t.\ application:
\[
	a \simeq a' \und b\simeq b'\imp ab\simeq a'b'
\]

\item
A \emph{combinatory algebra} $\cC = (C, \cdot, \ssk, \sss)$ is an applicative structure for a signature with two constants $\ssk,\sss$, such that $\ssk\neq\sss$ and  ($\forall x,y,z\in C$):
\[
\ssk xy=x, \textrm{ and }\sss xyz=xz(yz).
\]
We say that $\cC$ is \emph{extensional} if the following holds:
\[
	\forall x. \forall y.(\forall z .(xz = yz) \Rightarrow x = y)
\]
\item Given a combinatory algebra $\cC$ and a congruence $\simeq$ on $(C,\cdot\,)$, define:
\[
	\cC_\simeq = (C/_\simeq,\bullet_\simeq,\ssk_\simeq,\sss_\simeq)
\]
where
\[
	\begin{array}{rcl}
	{[}a{]}_\simeq\bullet_\simeq [b]_\simeq &=& [a\cdot b]_\simeq,\\ % chktex 9
	\ssk_\simeq &=& [\ssk]_\simeq\\
	\sss_\simeq &=& [\sss]_\simeq.\\
	\end{array}
\]
It is easy to check that if $\ssk\not\simeq\sss$ then $\cC_\simeq$ is a combinatory algebra.
\esub
\end{defi}

\noindent
We call $\ssk$ and $\sss$ the \emph{basic combinators}; the derived combinators $\ssi$ and $\sso$ are defined by $\ssi= \sss\ssk\ssk$ and $\sso= \sss(\ssk\ssi)$.
It is not difficult to verify that every combinatory algebra satisfies the identities $\ssi x=x$ and $\sso xy=xy$.

It is well-known that combinatory algebras are models of combinatory logic. A \lam-term $M$ can be interpreted in any combinatory algebra $\cC$ by first translating $M$ into a term $X$ of combinatory logic, written $(M)_\CL = X$, and then interpreting the latter in $\cC$. However, there might be $\beta$-convertible \lam-terms $M,N$ that are interpreted as distinguished elements of~$\cC$. For this reason, not all combinatory algebras are actually models of \lam-calculus.

The axioms of an elementary subclass of combinatory algebras, called \emph{$\lambda$-models}, were expressly chosen to make coherent the definition of interpretation of $\lambda$-terms (see~\cite[Def.~5.2.1]{Bare}).
The \emph{Meyer-Scott axiom} is the most important axiom in the definition of a $\lambda$-model.
In the first-order language of combinatory algebras it becomes:
\[
\forall x. \forall y\,.\,(\forall z\,.\, (xz = yz) \Rightarrow \sso x = \sso y).
\]
The combinator $\sso$ becomes an inner choice operator, that makes coherent the interpretation of an abstraction $\lambda$-term.

\subsection{Syntactic \lam-models}

The definition of a \lam-model is difficult to handle in practice because the five Curry's axioms~\cite[Thm.~5.2.5]{Bare} are complicated to verify by hand.
To prove that a certain combinatory algebra is actually a \lam-model, it is preferable to exploit Hindley's (equivalent) notion of a syntactic \lam-model. See, e.g.,~\cite{Koymans82}.

The definition of syntactic \lam-model in~\cite{Koymans82} is general enough to interpret \lam-terms possibly containing constants $\cons{a}$ representing elements $a$ of a set $A$.
We follow that tradition and denote by $\Lam(A)$ the set of all \lam-terms possibly containing constants from $A$, and we call them \emph{$\lam A$-terms}. For instance, given $a\in A$, we have $M =\comb{I}(\lam x.x\cons a)\cons b\in\Lam(A)$.
All notions, notations and results from Subsection~\ref{subsec:lamcal} extend to $\lam A$-terms without any problem.
In particular, substitution is extended by setting $\cons a\subst{x}{N} = \cons a$, for all $a \in A$ and $N\in\Lam(A)$.
As an example, the $\lam A$-term $M$ above reduces as follows: $M \to_\beta (\lam x.x\cons a)\cons b\to_\beta \cons b\cons a\in\Lam(A)$.
Observe that substitutions of variables by constants always permute, namely $M\subst{x}{\cons a}\subst{y}{\cons b} = M\subst{y}{\cons b}\subst{x}{\cons a}$, for all $a,b\in A$.


Given a set $A$, a \emph{valuation in $A$} is any map $\rho : \Var\to A$. We write $\Val A$ for the set of all valuations in $A$. Given $\rho\in\Val A$ and $a\in A$, define:
\[
	(\rho\repl{x}{a})(y) = \begin{cases}
	a,&\textrm{if }x=y,\\
	\rho(y),&\textrm{otherwise}.
	\end{cases}
\]

\begin{defi}\label{def:syntmod}
A \emph{syntactic \lam-model} is a tuple $\cS = (A,\cdot,\Int{-}{-})$ such that $(A,\cdot)$ is an applicative structure and the \emph{interpretation function}
\[
	\Int{-}{-} : \Lam(A)\times \Val{A}\to A
\]
satisfies
\bsub
\item\label{def:syntmod1}
	$\Int{x}{\rho} = \rho(x)$, for all $x\in\Var$;
\item\label{def:syntmod2}
	$\Int{\cons a}{\rho} = a$, for all $a\in A$;
\item\label{def:syntmod3}
	$\Int{PQ}{\rho} = \Int{P}{\rho}\cdot \Int{Q}{\rho}$;
\item\label{def:syntmod4}
	$\Int{\lam x.P}{\rho}\cdot a = \Int{P}{\rho\repl{x}{a}}$, for all $a\in A$;
\item\label{def:syntmod5}
	$\forall x\in\FV{M}\,.\, \rho(x) = \rho'(x) \imp \Int{M}{\rho} = \Int{M}{\rho'}$;
\item\label{def:syntmod6}
	$\forall a\in A\,.\, \Int{M}{\rho\repl{x}{a}} = \Int{N}{\rho\repl{x}{a}} \imp \Int{\lam x.M}{\rho} = \Int{\lam x.N}{\rho}$.
\esub

\noindent
If $M\in\Lamo$, then $\Int{M}{\rho}$ is independent from the valuation $\rho$ and we simply write $\Int{M}{}$.

We write $\cS \models M = N$ if and only if $\forall \rho\in\Val A\,.\, \Int{M}{\rho} = \Int{N}{\rho}$ holds.
It is easy to check that $\blam\vdash M = N$ entails $\cS\models M = N$.
\end{defi}

The \emph{\lam-theory induced by $\cS$} is defined as follows:
\[
	\Th{\cS} = \set{ M = N \st \cS\models M = N}.
\]
The precise correspondence between \lam-models and syntactic \lam-models is described in~\cite{Bare}, Theorem~5.3.6. For our purposes, it is enough to know that if $\cS$ is a syntactic \lam-model then $\cC_\cS = (A,\cdot,\Int{\comb{K}}{},\Int{\comb{S}}{})$ is a \lam-model. We say that $\cS$ is \emph{extensional} whenever $\cC_\cS$ is extensional as a combinatory algebra.
This holds iff $\Th{\cS}$ is extensional iff $\cS \models \comb{I} = \comb{1}$.
