\section{Implementation}
\label{sec-impl}
We implement and evaluate \sys on production servers that emulate pool latency. Pond artifacts are open-sourced at \url{https://github.com/vtess/Pond}.

\myparagraph{System software}
This implementation comprises three parts.
First, we emulate a single-socket system with a CXL pool on a two-socket server by disabling all cores in one socket, while keeping its memory accessible from the other socket. This memory mimics the pool.

Second, we change \azure's hypervisor to instantiate arbitrary \cvn topologies.
We extend the API between the control plane and the host to pass the desired \cvn topology to the hypervisor.

Third, we implement support in \azure's hypervisor for the telemetry required for training \sys's models.
We extend each virtual core's metadata with a copy of its core-PMU state and transfer this state when it gets scheduled on different physical cores.
\sys samples core-PMU counters once per second, which takes 1ms.
%Specifically, the hypervisor copies the virtual hardware counter state to physical core registers when the virtual core is scheduled.
%When the virtual core is descheduled, we save the hardware register state in the virtual core struct.
We enable access bit scanning in hypervisor page tables.
%The overhead of A/D bit scanning and its impact on guest application-level metrics significantly reduces as we increase the interval between resetting the bits.
We scan and reset access bits every 30 minutes, which takes 10s.

\myparagraph{Distributed control plane}
We train our prediction models by aggregating daily telemetry into a central database.
The latency insensitivity model uses a simple random forest (RandomForest) from Scikit-learn~\cite{pedregosa2011scikit} to classify whether a
workload exceeds the \pdm.
The model uses a set of 200 hardware counters as supported by current Intel processors.
The untouched memory model uses a gradient boosted regression model (GBM) from LightGBM~\cite{ke2017lightgbm} and makes a quantile regression prediction with a configurable target percentile.
After exporting to ONNX~\cite{onnx}, the prototype adds the prediction (the size of \cvn) on the VM request path using a custom inference serving system similar to~\cite{olston2017tensorflow,crankshaw2017clipper,microsoft_trace_analysis}.
\azure's VM scheduler incorporates \cvn requests and pool memory as an additional dimension into its bin packing, similar to other cluster schedulers~\cite{hadary2020protean,burns2016borg,delimitrou2013paragon,delimitrou2015tarcil,schwarzkopf2013omega,verma2015large}.


