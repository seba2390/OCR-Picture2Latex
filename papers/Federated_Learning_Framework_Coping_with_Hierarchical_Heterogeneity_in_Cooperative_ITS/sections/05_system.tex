

\section{System Framework}
\label{sec:system}



We divide the C-ITS into three layers: traffic agent layer, roadside unit layer, and cloud layer (Fig.~\ref{fig:sys}). We first consider a pre-trained process, where raw data are collected by automotive OEMs internal test vehicles the in traffic agent layer. A DNN model is trained in a centralized fashion based on the data managed in the cloud layer. Since the amount of the collected data is not sufficient for training, the pre-trained DNN model is sent to a public traffic cloud, which can orchestrate federated learning for model enhancements in public C-ITS.



The cloud shares the pre-trained DNN model with all connected RSUs in the roadside unit layer. This pre-trained DNN model is taken as the initial global and roadside FL model and forwarded to the traffic agents by the RSUs. Once the traffic agents in the traffic agent layer receive the duplicated model via V2I communication, the training process is run based on the cached datasets. The data labeling can be achieved by digital twin services via V2N communication~\cite{Cress2021_ITSReview}. 



According to the specific federated learning orchestration, the traffic agents train the DNN model several epochs and share it back to their connected RSUs. Then RSUs aggregate the models from the selected partition of agents and update the roadside FL model. Before uploading the model to the cloud, the local aggregation in the roadside unit layer can be implemented a few times, as the model exchange between the roadside unit and traffic agent layers using sidelink communication is considered to be faster than up- and downlink. The roadside unit layer can be regarded as the first aggregation layer. After a necessary pre-aggregation, the roadside FL models from all RSUs are sent to the cloud via I2N communication and aggregated globally. The cloud layer is then the second aggregation layer. The new global FL model is sent back to all RSUs, where the old roadside and global FL models in the roadside unit layer are replaced.

To address the heterogeneity problems in C-ITS as analyzed in the previous Section~\ref{sec:problem_formulation}, we employ the method defined in~(\ref{Eq:HtHFed}) for federated optimization in hierarchical systems and propose a \emph{Federated Learning Framework Coping with Hierarchical Heterogeneity} ({\myHFed}). The pseudo-code for traffic agents, RSUs and the traffic cloud are given in Algorithm~\ref{alg:agent},~\ref{alg:rsu} and~\ref{alg:cloud}, respectively. By designing parameters in the traffic agent and RSU layers, our {\myHFed} system can be deployed as a general framework for other federated learning methods with respect to (\ref{Eq:prox-hfl}) : \emph{(i)} $\mu_{k,l}\,=\,0$ and $L\,=\,1$ correspond to the idea of \emph{FedAvg}~\cite{pmlr-v54-mcmahan17a}; \emph{(ii)} $\mu_{k,l}\,>\,0$ and $L\,=\,1$ are equivalent to \emph{FedProx}~\cite{li2020federated}; \emph{(iii)} $\mu_{k,l}\,=\,0$ and $L\,>\,1$ match \emph{HierFAVG}~\cite{9148862}. Furthermore, the trade-off between stability and accuracy can be tuned by designing all parameters for traffic agents at different RSUs in {\myHFed}. This will be evaluated in Sec.~\ref{sec:evaluation}.

\begin{algorithm}[t]%Consider splitting the algo into server and client parts or use another template.
 \caption{\raggedright Traffic agent $i$ connecting RSU $k$ in {\myHFed}}
 \label{alg:agent}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \newcommand{\algorithmicbreak}{\textbf{break}}
 \newcommand{\BREAK}{\STATE \algorithmicbreak}
 
 \REQUIRE {$\eta$, $\mathcal{M}_{i,k}$, $E$, digital twin data}
 \ENSURE  {$w_{i,k}$}
    \STATE receive $w_k$ and $w$ from RSU $k$
    \STATE generate labels from digital twin data
    \FOR{each epoch $\tau$ = 1,...,E}
        \STATE $w_{i,k} \gets \eta\nabla \mathcal{L}^*_{\mathcal{M}_{i,k}}(w_{i,k};w_{k};w)$ based on Equation (\ref{Eq:HtHFed})
    \ENDFOR
    \STATE send $w_{i,k}$ to RSU $k$
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[t]%Consider splitting the algo into server and client parts or use another template.
 \caption{\raggedright RSU $k$ in {\myHFed}}
 \label{alg:rsu}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \newcommand{\algorithmicbreak}{\textbf{break}}
 \newcommand{\BREAK}{\STATE \algorithmicbreak}
 \REQUIRE {$LAR$}
 \ENSURE  {$w_{i,k}$}
     \FOR{each local round}
        \STATE download $w$ from cloud
        \STATE generate $\mathcal{P}_k^t$ based on orchestration
        \FOR{each clients $i \in \mathcal{P}_k^t$}
            \STATE send $w$ and $w_k$ to client $i$
            \STATE receive $w_{i,k}$ from client $i$
        \ENDFOR
        \STATE $w_k \gets \sum_{i\in{\mathcal{P}_k^t}} \frac{n_{i,k}}{n_k}{w_k}$
       \ENDFOR 
    \STATE upload $w_{k}$ to cloud
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[t]%Consider splitting the algo into server and client parts or use another template.
 %\ContinuedFloat %Rui: commented to fix the index problem
 \caption{\raggedright Cloud in {\myHFed}}
 \label{alg:cloud}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \newcommand{\algorithmicbreak}{\textbf{break}}
 \newcommand{\BREAK}{\STATE \algorithmicbreak}
 \REQUIRE {initial $w$ from a private cloud}
 \ENSURE  {$w$}
     \FOR{each global round}
        \FOR{each RSU $k$}
            \STATE send $w$ to RSU $k$
            \STATE receive $w_k$ from RSU $k$
        \ENDFOR 
     \STATE $w \gets \sum_k \frac{n_k}{n}{w_k}$
     \ENDFOR 
\end{algorithmic}
\end{algorithm}

















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{comment}


The data acquired by traffic agents is trained locally. Only the model weights are disseminated in the vehicular networks. 


various models are shared among the C-ITS components, i.e., the traffic agents, the roadside units and the traffic cloud. Additionally, we consider a primary model trained in the cloud, which is typically operated by an automotive OEM. This OEM cloud  processes the data from a number of test vehicles. The pre-trained model will be sent to the traffic cloud and improved there by the 2-layer hierarchical federated learning system. Once the pre-trained model is received by traffic cloud, it is regarded as a global model and shared with all connected RSUs. RSUs are able to forward the global model as a roadside model to all connected vehicles by means of direct RSU-vehicle communication. 

Thanks to the high defined sensors at RSUs, the highly accurate perception is achieved and can be set for 3D digital twin services, which can be taken as labels for supervised federated learning implementation. The connected vehicles subscribing the digital twin services and further train the roadside model based on their local data that acquired by on-board sensors. After several epochs, the model in each vehicles has been updated to vehicle model. According to the requests from RSUs, the vehicle models are uploaded to the corresponding RSUs and aggregated as a new RSU model there. Meanwhile, the traffic cloud can also request all connected RSUs for uploading the RSU models. All RSU models are further aggregated in traffic cloud and the global model is then updated. After sufficient communication rounds between RSUs and vehicles as well as between the traffic cloud and RSUs, the pre-trained OEM model is enhanced with broad data from public traffic.

Depending on the different methods in the system framework, the shared information in the vehicular networks can be different. One typical approach in the implementation of federated learning is FedAvg. The vehicles run the SGD locally and upload their vehicle models to RSU after specific epochs. The federated learning ochestrator in the connected RSU selects those models and weighted average the parameters in accord with the training data load in each vehicle. As a hierarchical system, the pre-aggregated models in RSUs are averaged again in the traffic cloud. The final global model takes all 

The 2-layer-Federated Averaging (2-layer-FedAvg) framework allows all connected traffic agents further to train the model that is received by means of direct communication with RSUs. The updated models are selected and averaged at RSU according to a pre-defined parameter $f_1$, which is the aggregation frequency at RSUs. Each RSU sends requests to all connected traffic agents for model collection every $\frac{1}{f_1}$~seconds, then shares the averaged model to them. The traffic agents replaced their local model with this averaged model and further train it with their local data. Similarly, the traffic cloud requests all connected RSUs to transfer their current models for centralized FedAvg with the frequency $f_2$ (usually $f_2 < f_1$). The models from all RSUs are averaged at cloud and shared back to RSUs, which can be forwarded to the traffic agents periodically. When the federated learning needs to be stopped, the stopping signal is sent to all traffic agents over RSUs by traffic cloud. The pseudo-code for traffic agents, RSUs and the traffic cloud are given in Algorithm~\ref{alg:agent},~\ref{alg:rsu} and~\ref{alg:cloud}



\begin{algorithm}[t]%Consider splitting the algo into server and client parts or use another template.
 \caption{\raggedright Heterogeneity-Tolerated HFL Framework} 
 \label{alg:2-layer-FedProx}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \newcommand{\algorithmicbreak}{\textbf{break}}
 \newcommand{\BREAK}{\STATE \algorithmicbreak}
 
 \REQUIRE {$w^0$, $\eta$, $\mathcal{G}$, $f_1$, $f_2$, $t_{end}$, $\mathcal{U}$}
 \ENSURE  {$w^{end}$}
    \\ \textit{Traffic agent $i$ connecting to RSU $k$}:
    \WHILE{Stopping learning not received}
        \IF{$w_{k}$ and $w$ is received}
            \STATE $w_{i,k} \gets w^t$
        \ELSE
            \STATE $w_{i,k} \gets \eta\nabla \mathcal{L^*_{\mathcal{U}}}(w_{i,k};w_{k};w)$ based on Equation (\ref{Eq:HtHFed})
        \ENDIF
    \ENDWHILE
    \STATE send $w_{i,k}$ to RSU
    \\ \textit{RSU $k$ connecting to traffic cloud}:
    \WHILE{Stopping learning not received}
        \IF{$w$ is received}
            \STATE $w_{k} \gets w$
        \ENDIF
        \IF{$t > t_0 + \frac{1}{f_1}$}
            \STATE $t_0 \gets t$
            \STATE Sends request and receives the $w_{i,k}^t$ from connected agents %Change into math symbol
            \STATE $w_{k} \gets\sum_{i=1}^{I} w_{i,k}$
            \STATE Sends $w_{k}$ to traffic agents
        \ENDIF
    \ENDWHILE
    \\ \textit{Traffic cloud}:
    \WHILE{$t < t_0 + \frac{1}{f_2}$}
        \STATE $t_0 \gets t$
        \STATE Sends request and receives the $w_{k}$ from RSUs
        \STATE $w \gets\sum_{k=1}^{K} w_{k}$
        \STATE Sends $w$ to RSU
        \IF{$t > t_{end}$}
            \RETURN $w^{end} \gets w$ 
            \STATE Sends request to RSUs for stopping learning 
            \BREAK
        \ENDIF
    \ENDWHILE
    
 \end{algorithmic}
 \end{algorithm}
 
 
 
\begin{algorithm}[t]%Consider splitting the algo into server and client parts or use another template.
 \caption{\raggedright Traffic Agent $i$ in {\myHFed} framework} 
 \label{alg:agent}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \newcommand{\algorithmicbreak}{\textbf{break}}
 \newcommand{\BREAK}{\STATE \algorithmicbreak}
 
 \REQUIRE {$w_k^{t_0}$, $\eta$, $\mathcal{U}$}
 \ENSURE  {$w_{i,k}$}
    \WHILE{Termination is not received}
        \IF{$w$ is received}
            \STATE $w \gets w$
        \ENDIF
        \IF{$w_{k}$ is received}
            \STATE $w_{k} \gets w_{k}$
            \STATE $w_{i,k} \gets w^{i,k}$
        \ENDIF
        \STATE $w_{i,k} \gets \eta\nabla \mathcal{L^*_{\mathcal{U}}}(w_{i,k};w_{k};w)$ based on Equation (\ref{Eq:HtHFed})
        \IF{Reqest for uploading is received}
            \STATE Sends $w_{i,k}$ to RSU
        \ENDIF
    \ENDWHILE
    
 \end{algorithmic}
 \end{algorithm}
 
 
 
 
 \begin{algorithm}[t]%Consider splitting the algo into server and client parts or use another template.
 \caption{\raggedright RSU $k$ in {\myHFed} Framework} 
 \label{alg:rsu}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \newcommand{\algorithmicbreak}{\textbf{break}}
 \newcommand{\BREAK}{\STATE \algorithmicbreak}
 
 \REQUIRE {$w^{t_0}$ $\mathcal{G}$, $f_1$}
 \ENSURE  {$w_{k}$}
    \WHILE{Termination is not received}
        \IF{$w$ is received}
            \STATE $w_{k} \gets w$
        \ENDIF
        \IF{$t > t_0 + \frac{1}{f_1}$}
            \STATE $t_0 \gets t$
            \STATE Sends request to connected agents for uploading %Change into math symbol
            \STATE Receives $w_{i,k}^t$ from connected agents
            \STATE $w_{k} \gets\sum_{i=1}^{I} w_{i,k}$
            \STATE Sends $w_{k}$ to traffic agents
        \ENDIF
         \IF{Reqest for uploading is received}
            \STATE Sends $w_{k}$ to cloud
        \ENDIF
    \ENDWHILE
    
 \end{algorithmic}
 \end{algorithm}
 
  \begin{algorithm}[t]%Consider splitting the algo into server and client parts or use another template.
 \caption{\raggedright The Traffic Cloud in H2Fed Framework} 
 \label{alg:cloud}
 \begin{algorithmic}[1]
 \renewcommand{\algorithmicrequire}{\textbf{Input:}}
 \renewcommand{\algorithmicensure}{\textbf{Output:}}
 \newcommand{\algorithmicbreak}{\textbf{break}}
 \newcommand{\BREAK}{\STATE \algorithmicbreak}
 
 \REQUIRE {$w^{t_0}$, $\mathcal{G}$, $f_2$, $t_{end}$}
 \ENSURE  {$w^{t_{end}}$}
    \WHILE{$t < t_0 + \frac{1}{f_2}$}
        \STATE $t_0 \gets t$
        \STATE Sends request to connected RSUs for uploading 
        \STATE Receives $w_{k}$ from connected RSUs
        \STATE $w \gets\sum_{k=1}^{K} w_{k}$
        \STATE Sends $w^t$ to RSU
        \IF{$t > t_{end}$}
            \RETURN $w^{t_{end}} \gets w$ 
            \STATE Sends Termination to RSUs
            \BREAK
        \ENDIF
    \ENDWHILE
    
 \end{algorithmic}
 \end{algorithm}
 
\end{comment}