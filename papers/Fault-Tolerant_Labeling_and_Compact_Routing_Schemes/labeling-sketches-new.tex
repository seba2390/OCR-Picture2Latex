\subsection{Connectivity Labels Based on Graph Sketches}\label{sec:ftconn-sketch}
In this section, we show the following:
\begin{theorem}
For every undirected $n$-vertex graph $G=(V,E)$, a positive integer $f$, there is a randomized $f$-FT connectivity labels $\FTConnLabel_{G}: V \cup E \to \{0,1\}^{\ell}$ of length $\ell=O(\log^3 n)$ bits. The decoding time of the scheme is $\widetilde{O}(f)$, and the computation time for assigning the labels is $\widetilde{O}(m+n)$.
\end{theorem}
%\begin{theorem}
%For every undirected $n$-vertex graph $G=(V,E)$ and a spanning tree $T \subseteq G$, a positive integer $f$, there is a randomized $f$-FT connectivity labels $\FTConnLabel_{G,T}: V \cup E \to \{0,1\}^{\ell}$ of length $\ell=O(\log^3 n)$ bits. The decoding time of the scheme is $\widetilde{O}(f)$, and the time for assigning the labels is $\widetilde{O}(m+n)$.
%\mtodo{added decoding and labeling time.}
%\end{theorem}
In Section \ref{sec:label-alg}, we present the labeling algorithm which assigns labels based on the notion of graph sketches. In Section \ref{sec:dec-alg} we present the decoding algorithm that given the label information determines if $s$ and $t$ are connected in $G \setminus F$. When the graph $G$ is clear from the context, we may omit it and simply write $\FTConnLabel$. 



\subsubsection{The Labeling Algorithm}\label{sec:label-alg}
Given a connected graph $G$, let $T$ be an arbitrary rooted spanning tree in $G$ that is used throughout this section. In our future applications of this labeling scheme (e.g., routing), both the graph $G$ and the tree $T \subseteq G$ will be given as input to the labeling algorithm. In the latter case, we denote the output labels by $\FTConnLabel_{G,T}$. Throughout, all vertices have unique ids $\ID(v)$ between $\{1,\ldots,n \}$.  

\paragraph{Extended Edge Identifiers.} In our algorithm it is important to distinguish between an identifier of a single edge to the bitwise XOR of several edges. For this purpose, we define for each edge $e$ an extended edge identifier $\EID_T(e)$ that allows distinguishing between these cases, and serves as the identifier of the edge.
%We define for each edge $e$ an 
The extended edge identifier $\EID_T(e)$ consists of a (randomized) unique distinguishing identifier $\UID(e)$, as well as additional tree related information that facilitates the decoding procedure. The computation of $\UID(e)$ is based on the notion of $\epsilon$-\emph{bias} sets \cite{naor1993small}. The construction is randomized and guarantees that, w.h.p., the XOR of the $\UID$ part of each given subset of edges $S \subseteq E$, for $|S|\geq 2$, is not a legal $\UID$ identifier of any edge.
%The algorithm will be able to detect whether a given $O(\log n)$ bits corresponding to an $\XOR(S)$ is a legal ID (in which case, $S$ contains a single edge) or not, w.h.p.
Let $\XOR(S)$ be the bitwise XOR of the extended identifiers of edges in $S$, i.e., $\XOR(S)=\oplus_{e \in S} \EID_T(e)$. In addition, let $\XOR_U(S)=\oplus_{e \in S} \UID(e)$. Missing proofs are deferred to Appendix \ref{sec:miss-proof}.

\begin{lemma}[Modification of Lemma 2.4 in \cite{GhaffariP16}]
\label{cl:epsbias}
There is an algorithm that creates a collection $\mathcal{I}=\{\UID(e_1), \ldots, \UID(e_{M})\}$ of $M=\binom{n}{2}$ random identifiers for all possible edges $(u,v)$, each of $O(\log n)$-bits using a seed $\mathcal{S}_{ID}$ of $O(\log^2 n)$ bits. These identifiers are such that for each subset $E' \subseteq E$, where $|E'|\neq 1$, we have $\Pr[\XOR_U(E') \in \mathcal{I}] \leq 1/n^{10}$. In addition, given the identifiers $\ID(u), \ID(v)$ of the edge $e=(u,v)$ endpoints, and the seed $\mathcal{S}_{ID}$, one can determine $\UID(e)$ in $\widetilde{O}(1)$ time.
\end{lemma}
\def\APPENDUNIQUEID{
\begin{proof}[Proof of Lemma \ref{cl:epsbias}]
The lemma is proved in \cite{GhaffariP16}, the only part that is not discussed there is the time to determine $\UID(e)$ that follows from \cite{naor1993small}. 
By Theorem 3.1 of \cite{naor1993small}, given the seed $\mathcal{S}_{ID}$ and the edge identifier $e_j=(\ID(u), \ID(v))$, determining the $i^{th}$ bit of $\UID(e_{j})$ can be done in $O(\log n)$ time. Thus, determining all $O(\log n)$ bits, takes $O(\log^2 n)$ time. 
\end{proof}
}%\APPENDUNIQUEID
For every vertex $v \in G$, let $\LCALabel_T(v)$ be the ancestor label of $v$ computed for the given tree $T$ using Lemma \ref{anc_labels}. The extended identifier $\EID_T(e)$ is given by
\begin{equation}\label{eq:extend-ID}
\EID_T(e)=[\UID(e), \ID(u), \ID(v), \LCALabel_T(u), \LCALabel_T(v)]~.
\end{equation}
The identifiers of $\ID(u), \ID(v)$ are used in order to verify the validity of the unique identifier $\UID(e)$.  
When the tree $T$ is clear from the context, we might omit it and simply write $\EID(e)$. As we will see, the labeling scheme will store the seed $\mathcal{S}_{ID}$ as part of the labels of the tree edges. 

%\paragraph{Graph Sketches.} \mtodo{this would probably be removed from here, if we stay if the current overview.}
%Graph sketches are a powerful tool to identify outgoing edges \cite{kapron2013dynamic,ahn2012analyzing}. We start by illustrating the intuition behind them. For a vertex $v$, let $\bSketch(v)$ be the bitwise XOR of all the extended IDs of edges adjacent to $v$. \mertodo{It seems that we do not use the notation $\bSketch(v)$ later on, so we might want to omit it.} 
%That is, $\bSketch(v)=\XOR(E(v,G))$ where $E(v,G)$ are the edges incident to $v$ in $G$. 
%If we take a subset of vertices $S$, and define  $\bSketch(S) = \oplus_{v \in S} \bSketch(v)$, we can see that all edges that have both endpoints in $S$ are cancelled, and we are left with the XOR of the extended identifiers of the outgoing edges from $S$. If there is only one such edge, we get its extended id. In the case there are more outgoing edges, we can use sampling to identify one outgoing edge. We next formalize this idea and show how to use it in our labels. 

\paragraph{Fault-Tolerant Labels via Graph Sketches.} 
Graph sketches are a tool to identify outgoing edges. We start by providing an intuition for them. Say that $S$ is a connected component, and that there are $2^j$ edges outgoing from $S$. If we sample all edges in the graph with probability $1/2^j$, there is a constant probability that exactly one outgoing edge from $S$ is sampled, and our goal is to find it using local information stored at the vertices of $S$. This information is the \emph{sketch}. 
The sketch of each vertex stores the bitwise XOR of sampled edges adjacent to it. Now looking at the XOR of all the sketches of vertices of $S$ allows to detect an outgoing edge. This holds as any sampled edge that has both endpoints in $S$ gets cancelled out, and we are left with the XOR of sampled edges outgoing from $S$. If there is exactly one outgoing edge, we find it. To increase the success probability we can repeat the process $O(\log{n})$ times. We define sets of vertices $E_{i,j}$, where for $i \in \{1, \ldots, c \log n\}$, the set $E_{i,j}$ is obtained by sampling each edge with probability $2^{-j}$. Since we repeat the process $O(\log{n})$ times for each $j$, then w.h.p we can use the sketches to identify outgoing edge from any component. To use this approach in our context, it is crucial to be able to simulate the sampling process using a small random seed. To do this, we follow \cite{DuanConnectivityArxiv16,DuanConnectivitySODA17} and use pairwise independent hash functions to decide whether to include edges in sampled sets.
%The graph sketches are based on random sub-sampling of the graph edges with logarithmic number of scales, i.e., with probability of $2^{-j}$ for every $j \in [0,\log m]$. For our purposes and similarly to \cite{DuanConnectivityArxiv16,DuanConnectivitySODA17}, we use pairwise independent hash functions to decide whether to include edges in sampled sets. 
We choose $L=c\log n$ 
pairwise independent hash functions $h_1, \ldots, h_{L}:\{0,1\}^{\Theta(\log n)} \to \{0, \ldots, 2^{\log m}-1\}$, %\mtodo{why is the domain of the hash function strings of $2\log{n}$ bits? Shouldn't it be some $O(\log{n})$ that depends on the size of extended identifiers?} \mertodo{Yes, of course, it should depend on the number of bits in the extended identifiers. I changed it now.} 
and for each $i \in \{1, \ldots, L\}$ and $j \in [0,\log m]$, define the edge set 
$$E_{i,j} =\{ e \in E ~\mid~ h_i(e) \in [0,2^{\log m-j})\}~.$$ 
Each of these hash functions can be defined using a random seed of logarithmic length \cite{TCS-010}. Thus, a 
random seed $\mathcal{S}_h$ of length $O(L \log n)$ can be used to determine the collection of all these $L$ functions. As observed in \cite{DuanConnectivityArxiv16,GibbKKT15}, pairwise independence is sufficient to guarantee that for any set $E' \subset E$ and any $i$, there exists an index $j$, such that with constant probability $\XOR(E' \cap E_{i,j})$ is the name (extended identifier) of one edge in $E'$, for a proof see Lemma 5.2 in  \cite{GibbKKT15}.
\begin{lemma}\label{lem:hitting-pairwise}
For any edge set $E'$ and any $i$, with constant probability there exists a $j$ satisfying that $|E' \cap E_{i,j}|=1$.
\end{lemma}


We also need to be able to tell that a bit string of $\XOR(E' \cap E_{i,j})$ is a legal edge ID or not. Here we exploit the extended ids. See Appendix \ref{sec:miss-proof} for a proof.
%\mertodo{For now, moving proofs to appendix, later on consider mentioning it in an analysis section.}
\begin{lemma} \label{lemma_unique}
Given the seed $\mathcal{S}_{ID}$, one can determine in $\widetilde{O}(1)$ time if $\XOR(E' \cap E_{i,j})$ corresponds to a single edge ID in $G$ or not, w.h.p.
\end{lemma}
\def\APPENDLEMMUNIQUE{
\begin{proof}[Proof of Lemma \ref{lemma_unique}]
Let $X=\XOR(E' \cap E_{i,j})$. Letting $E''=E' \cap E_{i,j}$, then $X$ can be written as the concatenation of $\XOR_1(E'')$ and $\XOR_2(E'')$, where $\XOR_1(E'')=\XOR_U(E'')$ is the bit-wise XOR of the unique identifiers $\UID(e)$ for $e \in E''$ and $\XOR_2(E'')$ is the bit-wise XOR of the remaining information in the extended identifiers of $E''$.  We now show how using the seed and $\XOR_2(E'')$, one can test the validity of $\XOR_1(E'')$.
The algorithm detects the case that $|E''| \geq 2$ as follows. First, in the case that $E''$ is a single edge, $\XOR_2(E'')$ should contain legal ids $\ID(u),\ID(v)$. If this is not the case, it follows that $|E''| \neq 1$. If $\XOR_2(E'')$ contains legal ids $\ID(u),\ID(v)$, we use them and the seed $\mathcal{S}_{ID}$ to determine $\UID(e)$ for $e = (u,v)$, and we check if $\XOR_1(E'')=\ID_1(e)$. We have two options, either $E'' = \{e\}$ is the single edge $e$, in which case $\XOR_U(E'')=\UID(e) \in \mathcal{I}$, and the verification succeeds. Otherwise $|E''| \geq 2$, in which case, from Lemma \ref{cl:epsbias}, $\Pr[\XOR_U(E'') \in \mathcal{I}] \leq 1/n^{10}$, hence w.h.p $\XOR_U(E'') \neq \UID(e) \in \mathcal{I}$ and we identify that $|E''| \geq 2$.
%To show that the algorithm detects the case that $|E''|\geq 2$, we should show that w.h.p. 
%$$h(u_1,v_1) \oplus h(u_2,v_2) \neq h(u_1 \oplus u_2, v_1 \oplus v_2)$$ \mtodo{is it enough to show it for 2? I think that if we know what are the %original ids (say the set $\{1,...,n\}$), we can get a simpler proof using Lemma 2.9, I'm not sure if we want this assumption.}
%where $h(u,v)$ is $\ID_1(e)$ for $e=(u,v)$. TBD.
\end{proof}
}%\APPENDLEMMUNIQUE

For each vertex $v$ and indices $i,j$, let $E_{i,j}(v)$ be the edges incident to $v$ in $E_{i,j}$. 
The $i^{th}$ \emph{basic sketch unit} of each vertex $v$ is then given by:
\begin{equation}
\label{eq:vsketch}
\Sketch_{G,i}(v)=[\XOR(E_{i,0}(v)),\ldots,\XOR(E_{i,\log m}(v))].
\end{equation}
The sketch of each vertex $v$ is defined by a concatenation of $L=\Theta(\log n)$ basic sketch units: 
$$\Sketch_G(v)=[\Sketch_{G,1}(v),\Sketch_{G,2}(v), \ldots\Sketch_{G,L}(v)]~.$$ 
For every subset of vertices $S$, let 
$\Sketch_G(S)=\oplus_{v \in S}\Sketch_G(v).$ When the graph $G$ is clear from the context, we may omit it and write $\Sketch_{i}(v)$ and $\Sketch(v)$. 

We are now ready to define the fault-tolerant connectivity labels of vertices and edges. 
The label of each vertex $u$ is given by:
\begin{equation}\label{eq:conn-vertex}
\FTConnLabel_{G,T}(u)=\langle \LCALabel_T(u), \ID(u) \rangle~,
\end{equation}
where $\LCALabel_T(u)$ is the ancestry label of $u$ with respect to the tree $T$. 
For every $u \in V(T)$, let $T_u$ be the subtree rooted at $u$.  The label $\FTConnLabel_{G,T}(e)$ of each \emph{edge} $e=(u,v)$ is given by:
%\textbf{MP: Suggestion: we may want to have distinct labels for tree edges and non-tree edges, as below. This facilitate the notation for the routing scheme}
\begin{equation*}
    \FTConnLabel_{G,T}(e)=
    \begin{cases}
      \langle \EID_T(e), \Sketch(V(T_u)), \Sketch(V(T_v)), \Sketch(V), \mathcal{S}_{ID}, \mathcal{S}_h\rangle ,& \mbox{~for~} e \in T \\
     \langle \EID_T(e) \rangle,& \mbox{~Otherwise}.
    \end{cases}
\end{equation*}

%\paragraph{Analysis of the Labeling Algorithm.}
We complete this subsection by bounding the label size and computation time of the labeling algorithm. For proofs see Appendix \ref{sec:miss-proof}. 
\begin{claim}\label{cl:label-length}
The label length is $O(\log^3 n)$ bits.
\end{claim}
\def\APPENDLABELCONSISE{
\begin{proof}[Proof of Claim \ref{cl:label-length}]
The label size is dominated by the sketching information $\Sketch(V(T_u))$, which is made of a concatenation of the bitwise XOR of $O(\log n)$ basic sketch units $\Sketch_i(u)$. By Eq. (\ref{eq:vsketch}), each unit has $O(\log^2 n)$ bits, and thus overall, the label has $O(\log^3 n)$ bits.
\end{proof}
}%\APPENDLABELCONSISE

We show that assigning the labels takes  $\widetilde{O}(m+n)$ time.
\begin{claim}\label{cl:time-conn-labelsketch}
The time complexity of the labeling algorithm is $\widetilde{O}(m+n).$
\end{claim}
\def\APPENDCONNLABELSKETCH{
\begin{proof}[Proof of Claim \ref{cl:time-conn-labelsketch}]
To compute the labels of vertices we assign ids to vertices in $O(n)$ time, and compute ancestry labels in $O(n)$ time using Lemma \ref{anc_labels}. To compute the extended identifiers $\EID_T(e)$, we also choose the random seed $\mathcal{S}_{ID}$ and compute $\UID(e)$ using Lemma \ref{cl:epsbias}, this takes $\widetilde{O}(1)$ time per edge, and $\widetilde{O}(m)$ time for all edges. Lastly, we should compute the sketch values $\Sketch(V(T_u))$. For this, first, we choose the random seed $\mathcal{S}_h$, and compute the values $\Sketch_G(v)$. For this, we should identify for each vertex the adjacent edges in $E_{i,j}$. For each edge we can identify the sets it belongs to in $\widetilde{O}(1)$ time using Fact \ref{fc:pairwise}. This allows us computing the sketch values of all vertices in $\widetilde{O}(m+n)$ time. We can then compute the values $\Sketch(V(T_u))$ by scanning the tree in $\widetilde{O}(n)$ time.   
\end{proof}
}%\APPENDCONNLABELSKETCH
Finally, the subsequent decoding algorithm will be based on the following useful property of the graph sketches, stored by our labels. 
\begin{lemma}\label{lem:sketch-property}
For any subset $S$, given one basic sketch unit $\Sketch_i(S)$ and the seed $\mathcal{S}_{ID}$ one can compute, with constant probability, an outgoing edge $E(S, V \setminus S)$ if such exists. The complexity is $\widetilde{O}(1)$ time.
\end{lemma}
\def\APPENDSKETCHPROP{
\begin{proof}[Proof of Lemma \ref{lem:sketch-property}]
The proof follows from Lemma \ref{lem:hitting-pairwise}. Note that by definition of the sketch values $\Sketch_i(S)=\oplus_{v \in S}\Sketch_i(v)=[\XOR(E_{i,0}(S)),\ldots,\XOR(E_{i,\log m}(S))],$ where $E_{i,j}(S)$ are the outgoing edges from $S$ in $E_{i,j}$ (edges that have both endpoints in $S$ are cancelled out by the XOR operation). Let $E'$ be all the outgoing edges from $S$. From Lemma \ref{lem:hitting-pairwise}, with constant probability there exists a $j$ such that $|E' \cap E_{i,j}|=1$. In this case, $\XOR(E_{i,j}(S))$ corresponds to an extended id of a single outgoing edge from $S$. We can check if this happens in $\widetilde{O}(1)$ time using Lemma \ref{lemma_unique}.   
\end{proof}
}%\APPENDSKETCHPROP



\subsubsection{The Decoding Algorithm} \label{sec:dec-alg}
We next describe the decoding algorithm where given a triplet $s,t, F \in V \times V \times E^f$ along with their labels, it determines whether $s$ and $t$ are connected in $G\setminus F$, w.h.p. 
The decoding algorithm has four key steps: The first step identifies the at most $f+1$ components $\mathcal{C}_0=\{C_1,\ldots, C_\ell\}$ of $T \setminus F$, as well as the components of $s$ and $t$ in $\mathcal{C}_0$. The second step uses the label information to compute the sketch value $\Sketch(C_i)$ of each component $C_i \in \mathcal{C}_0$. The third step modifies this sketch information into $\Sketch_{G \setminus F}(C_i)$, by subtracting the information related to the faulty edges. The forth and final step uses the sketch information in order to simulate $L=O(\log n)$ steps of the Boruvka algorithm. At the end of these steps, the decoding algorithm identifies the connected components of both $s$ and $t$ in $G \setminus F$. In the case where $s$ and $t$ are indeed connected in $G \setminus F$, the algorithm also outputs a succinct representation of an $s$-$t$ path in $G \setminus F$. This extra information would be used later on by our compact routing scheme. We next describe these steps in details. 

\paragraph{Step 1: Identification of the connected components $\mathcal{C}_0$ in $T \setminus F$.} 
Let $F_T=F \cap T$ be the faulty tree edges and let $F_{NT}=F \setminus F_T$ be the faulty non-tree edges. Let $Q=\{s,t\} \cup V(F_T)$.  Each component $C_i$ of $T \setminus F$ will be identified by the maximum vertex ID in $C_i \cap V(F_T)$. Note that in the case where $F_T=\emptyset$, $T \setminus F=T$ and thus $s$ and $t$ are connected iff $s,t \in V(T)$.  From now on, we therefore assume that $F_T \neq \emptyset$. 

We next show that although we do not have full information about the tree $T$ and the vertices of each connected component, the ancestry labels of $V(F_T)$ give us enough information to identify the connected components of $T \setminus F$. Additionally, given an ancestry label of a vertex $u$, we can identify the connected component of $u$. To obtain this, it is helpful to look at the \emph{component tree} that is obtained by contracting each connected component of $T \setminus F$ to one vertex, as follows. Let $\ell = |F_T|+1.$ The component tree $T_C = (\mathcal{C}_0, E_C)$ is a tree of $\ell$ vertices representing the connected components in $T \setminus F$, and $|F_T|=\ell-1$ edges corresponding to the edges of $F_T$. There is an edge $(C_i,C_j) \in E_C$ iff there is an edge $(u,v) \in F_T$ where $u \in C_i, v \in C_j$. See Figure \ref{componentTreePic} for an illustration.  


\setlength{\intextsep}{0pt}
\begin{figure}[h]
\centering
\setlength{\abovecaptionskip}{-2pt}
\setlength{\belowcaptionskip}{6pt}
\includegraphics[scale=0.55]{componentTree.pdf}
 \caption{Illustration of the component tree where $F=\{e_1,e_2,e_3,e_4\}$. Each connected component of $T \setminus F$ is contracted to one vertex on the right.}
\label{componentTreePic}
\end{figure}

We can construct the tree $T_C$ using the ancestry labels of the edges $F_T$.  For this, for each edge $e \in F_T$ we just need to identify the set of edges from $F_T$ above $e$ in $T$. Moreover, for a given vertex $v$, its connected component is exactly determined by the set of edges in $F_T$ above it in $T$, which can again be identified using the ancestry labels of $v \cup V(F_T)$. In particular, we can identify the connected components of $s$ and $t$. The component tree can be constructed in $O(f^2)$ time by checking for any pair of edges $e,e' \in F_T$, if $e$ is above $e'$ in the tree. We next show a faster algorithm taking only $\widetilde{O}(f)$ time by exploiting properties of the ancestry labels. Moreover, we show that the component of each vertex can be identified in $O(\log{f})$ time.

\begin{claim} \label{claim_component_tree}
The component tree can be constructed in $O(f \log{f})$ time. Additionally, given $\LCALabel_T(v)$, we can identify the connected component of $v$ in $T \setminus F$ in $O(\log{f})$ time.
\end{claim}

\begin{proof}
Our algorithm uses ancestry labels based on DFS from \cite{kannan1992implicat}. In this scheme, the label of each vertex $v$ is composed of two numbers $(DFS_1(v),DFS_2(v))$ that represent the first and last times a DFS scan of the tree visits $v$. A vertex $u$ is an ancestor of a vertex $v$ iff the interval $(DFS_1(u),DFS_2(u))$ contains the interval $(DFS_1(v),DFS_2(v))$. To build the component tree, we sort the labels of $V(F_T)$, as described next. First, for each component $C \in T \setminus F$, we use the highest vertex in the component to represent the component. For the highest component, this is the root $r$. For any other component, we have that the highest vertex of the component, $v$, is in $V(F_T)$. This holds as the edge connecting $v$ to its parent $p(v)$ is necessarily in $F_T$ (otherwise, $v$ is not the highest vertex in its component), see Figure \ref{componentTreePic} for illustration. Hence, for any edge $(v,p(v)) \in F_T$, we have that the vertex $v$ represents one component (we can identify which of the vertices is the parent using the ancestry labels). Hence, we have $|F_T|+1$ vertices $v_i$ representing the components $C_i$ of the component tree, and we also know the ancestry labels $(DFS_1(v_i),DFS_2(v_i))$ of all vertices $v_i$, except $r$. For $r$ we can use the label $(1,M)$ where $M$ is a number greater than all values $DFS_2(v_i)$ of other vertices. We next use these labels to determine the structure of the component tree.
For this, we create for each vertex $v_i$ two tuples: $(DFS_1(v_i),v_i,1),(DFS_2(v_i),v_i,2)$, and we sort the $2(|F_T|+1)$ tuples according to their first coordinate. This takes $O(f \log{f})$ time. We next scan the sorted list, and when we reach the tuple $(DFS_1(v_i),v_i,1)$, we identify the parent of $v_i$ in the component tree, as follows. The first tuple is $(1,r,1)$ and $r$ is set to be the root of the component tree. For a vertex $v_i \neq r$, we identify its parent when we reach $(DFS_1(v_i),v_i,1)$. Let $(DFS_b(u),u,b)$ be the last tuple before $(DFS_1(v_i),v_i,1)$ in the sorted order. If $b=1$, then $u$ is the parent of $v_i$ in the component tree. If $b=2$, let $w$ be the parent of $u$ in the component tree, then $w$ is also the parent of $v$ in the component tree. Additionally, $w$ was already computed as $(DFS_1(u),u,1)$ appears before $(DFS_1(v_i),v_i,1)$. Hence, we can find the parent of $v$ in $O(1)$ time using the tuple before it. Scanning the list takes $O(f)$ time, and after it we know for each component its parent in the component tree, which gives the complete structure of the tree. We next prove the correctness of the algorithm.  

We first discuss the case that $b=1$. Here $(DFS_1(u),u,1)$ is the last tuple before $(DFS_1(v_i),v_i,1)$. This means that $u$ is necessarily an ancestor of $v$, because the entry $(DFS_1(v_i),v_i,1)$ is between the entries $(DFS_1(u),u,1)$ and $(DFS_2(u),u,2)$, and the DFS scan traverses exactly the subtree of $u$ in the time interval $(DFS_1(u),DFS_2(u))$, implying that $v_i$ is a child of $u$. Moreover, this is the closest ancestor to $v_i$ among the vertices $\{v_1,v_2,...,v_{\ell}\} \setminus \{v_i\}$, as the DFS scan traverses the ancestors of $v_i$ from the highest to the lowest. It follows that $u$ represents the closest component $C$ above $v_i$ in the component tree, as needed.  

We next discuss the case that $b=2$. Here $(DFS_2(u),u,2)$ is the last tuple before $(DFS_1(v_i),v_i,1)$. Note that now $u$ is not an ancestor of $v_i$, as the DFS scan finished scanning the subtree of $u$ before reaching $v_i$, but we claim that $u$ and $v_i$ have the same parent in the component tree. For this, we show they have exactly the same ancestors in the set $\{v_1,v_2,...,v_{\ell}\} \setminus \{u,v_i\}.$ For any ancestor $w\neq u$ of $u$, we have that $DFS_1(w) < DFS_1(u) < DFS_2(u) < DFS_2(w)$. As $(DFS_1(v_i),v_i,1)$ is the first tuple after $(DFS_2(u),u,2)$, it must hold that $DFS_1(w) < DFS_1(v_i) <  DFS_2(w)$, implying that $v_i$ is a child of $w$ as needed. Similarly, any ancestor $w \neq v_i$ of $v_i$ is also an ancestor of $u$, as we have $DFS_1(w) < DFS_2(u) < DFS_1(v_i) < DFS_2(v_i) < DFS_2(w)$.
Hence, the parent of $u$ in the component tree is also the parent of $v_i$ in the component tree, as needed.  
 
Lastly, we show that using similar ideas we can also identify the component of a vertex $v$ in $T \setminus F$. We create for $v$ the tuple, $(DFS_1(v),v,1)$, and use binary search to find the last tuple smaller or equal to it in the sorted list we computed before, denote it by $(DFS_b(u),u,b)$. 
If $b=1$ then $v$ is in the component of $u$, and else it is in the component of the parent of $u$ (that was computed before). The complexity of the binary search is $O(\log{f})$, we next prove correctness. 
One special case is that $v$ is a root of one of the components in the component tree. In this case, the entry $(DFS_b(u),u,b)$ we find is equal to $(DFS_1(v),v,1)$, and $u=v$ is indeed the component of $v$. Otherwise, $v$ is an internal vertex in its component, and the root of the component is the closest ancestor to $v$ in $\{v_1,...,v_{\ell}\}$.
If $b=1$, then as shown before, $u$ is the closest ancestor to $v$ in the component tree, as needed. If $b=2$, then as shown before, $u$ is not an ancestor of $v$, but has exactly the same ancestors in the component tree. Hence, the root $w$ of the component above $u$ is the root of the component of $v$, as needed.    
\end{proof} 


\paragraph{Step 2: Computing the sketch values of each component $\mathcal{C}_0$ in $G$.} 
For each component $C_j \in \mathcal{C}_0$ the algorithm computes $\Sketch_G(C_j)$ using the sketch information of the vertices in $V(F_T)$.  The basic observation here is the following. Given $S' \subset S$ and $\Sketch(S), \Sketch(S')$, it holds that $\Sketch(S \setminus S')=\Sketch(S) ~\oplus~ \Sketch(S')$. To compute the sketch values, first, we define for each component a temporary value $\Sketch'_G(C_j)$ as follows. Let $v_j$ be the highest vertex (closest to the root in $T$) in the component $C_j$. For the component of the root $r$, this is $r$. For any other component $C_j$, let $(C_j,p(C_j))$ be the edge connecting $C_j$ to its parent in the component tree. This edge corresponds to an edge $(v_j,p(v_j)) \in F_T$, where $v$ is the highest vertex in $C_j$. We define $\Sketch'_G(C_j) = \Sketch_G(V(T_{v_j}))$. % where $V_{v_j}=V(T_{v_j})$ (the vertices in the subtree of $v_j$ in $T$). 
Since $(v_j,p(v_j)) \in F_T$, the sketch information $\Sketch'_G(C_j)$ can be obtained from the label of the tree edge $(v_j,p(v_j))$. We also know the temporary sketch value of the component of $r$, as $\Sketch_G(V_{r})=\Sketch_G(V)$ is part of the labels of all tree edges (and we assume that $F_T \neq \emptyset$). We next use the temporary sketch values to compute the sketch values of components using the following claim.

\begin{claim}
Let $C_j$ be a component in $T \setminus F$. If $C_j$ is a leaf in the component tree, we have $\Sketch_G(C_j) = \Sketch'_G(C_j).$ Otherwise, let $D=\{D_1,...,D_t\}$ be the children of $C_j$ in the component tree and let $\Sketch'(D)=\oplus_{1 \leq i \leq t} \Sketch'_G(D_i)$, then $\Sketch_G(C_j) = \Sketch'_G(C_j) \oplus \Sketch'(D).$ 
\end{claim}

\begin{proof}
It holds that $\Sketch_G(C_j) = \oplus_{v \in C_j} \Sketch_G(v)$. By definition, $\Sketch'_G(C_j)=\Sketch_G(V(T_{v_j})) = \oplus_{v \in V(T_{v_j})} \Sketch_G(v)$ is the XOR of sketches of all vertices in the subtree of $v_j$. As $v_j$ is the highest vertex in $C_j$, if $C_j$ is a leaf component in the component tree, then the vertices in $C_j$ are exactly the vertices in $T_{v_j}$, and the claim follows. Otherwise, the vertices in $C_j$ are all vertices in $T_{v_j}$ that are not contained in any component below $C_j$. Hence, to compute the value $\Sketch_G(C_j)$, we should subtract from $\Sketch_G(V(T_{v_j}))$ the sketch values of vertices in components below $C_j$. Let $D_1,\ldots,D_t$ be the children of $C_j$ in the component tree, and let $u_1,\ldots,u_t$ be the highest vertices in the components $D_1,\ldots,D_t$, respectively. Any vertex that is in some component below $C_j$ is in exactly one of the subtrees $T_{u_1},\ldots,T_{u_t}$. Hence the sketch value of vertices in components below $C_j$ equals $\oplus_{1 \leq i \leq t} \Sketch_G(V(T_{u_i}))= \oplus_{1 \leq i \leq t} \Sketch'_G(D_i)=\Sketch'(D)$. To conclude, we get $\Sketch_G(C_j)=\Sketch_G(V(T_{v_j})) \oplus \Sketch'(D)=\Sketch'_G(C_j) \oplus \Sketch'_G(D)$, as needed.
\end{proof}

To conclude, from the values $\Sketch'_G(C_j)$, we can easily compute the values $\Sketch_G(C_j)$. The complexity is $\widetilde{O}(f)$, as for each component, the sketch $\Sketch'(C_j)$ participates in two computations, and we have at most $O(f)$ components and the sketches have poly-logarithmic size.


\paragraph{Step 3: Computing the sketch values of each component $\mathcal{C}_0$ in $G \setminus F$.} 
For each faulty edge $e \in F$ (both tree and non-tree edges), our goal is to subtract the sketch information of $e$ from the corresponding components of the endpoint of $e$. The step does not require the label information of the edges, and it would be sufficient to know only the seed $\mathcal{S}_h$ that determines the sampling of edges into the sketches, and the extended identifier of the failing edges. Since $F_T \neq \emptyset$, the algorithm holds the seed $\mathcal{S}_h$ (from the label of an edge $e \in F_T$), and it has the extended identifiers of all edges in $F$ as part of their labels. 

Using the extended identifier of the faulty edge $e=(u,v)$, one can determine in $O(\log{f})$ time the components in $\mathcal{C}_0$ to which its endpoints belong, from Claim \ref{claim_component_tree}. Using the identifier $\EID(e)$ and the seed $\mathcal{S}_h$, one can determine all the indices of the sketch to which the edge $e$ was sampled in $\widetilde{O}(1)$ time using Fact \ref{fc:pairwise}. %\mtodo{what is the complexity of this? MP: It should be $\widetilde{O}(1)$ using Fact \ref{fc:pairwise}.}
Letting $C_u, C_v$ be the components of $u$ and $v$ in $T \setminus F$, respectively. If $C_u \neq C_v$, then the values $\Sketch_G(C_u),\Sketch_G(C_v)$ are updated by XORing them with the matrix that contains the extended identifier $\EID(e)$ in the relevant positions. The complexity is poly-logarithmic, as the matrix has poly-logarithmic size. In the case that $C_u=C_v$, as $e$ is an internal edge in the component, it is not part of $\Sketch_G(C_u)$, and there is no need to update the value. Overall, doing the computation for all edges in $F$ takes $\widetilde{O}(f)$ time.
From that point on, all sketches of the components $\mathcal{C}_0$ can be treated as sketches that have been computed in $G \setminus F$.  


\paragraph{Step 4: Simulating the Boruvka algorithm.} Finally, our goal is to determine the identifiers of the maximal connected components of $s$ and $t$ of $G \setminus F$. The input to this step is the identifiers of the components $\mathcal{C}_0=\{C_{1}, \ldots, C_k\}$ in $T \setminus F$, along with their sketch information in $G \setminus F$. While the algorithm does not have information on the vertices of each component, it knows the component identifier of each vertex in $Q$. 

The algorithm consists of $L=O(\log n)$ phases of the Boruvka algorithm. Each phase $i \in \{1,\ldots, L\}$ will be given as input a partitioning $\mathcal{C}_i=\{C_{i,1}, \ldots, C_{i,k_i}\}$ of (not necessarily maximal) connected components in $G \setminus F$.
These components are identified by an $O(\log n)$ bit identifier, where for each vertex in $Q$, the algorithm receives its unique component identifier in  $\mathcal{C}_i$. In addition, the algorithm receives the sketch information of the components $\mathcal{C}_i$ in $G \setminus F$. The output of the phase is a partitioning $\mathcal{C}_{i+1}$, along with their sketch information in $G \setminus F$ and the identifiers of the components for each vertex in $U$. A component $C_{i,j} \in \mathcal{C}_i$ is \emph{growable} if it has at least one non-faulty outgoing edge to a vertex in $V \setminus C_{i,j}$. That is, the component is growable if it is strictly contained in some maximal connected component in $G \setminus F$. Letting $N_i$ denote the number of growable components in $\mathcal{C}_i$, the output partitioning $\mathcal{C}_{i+1}$ of the $i^{th}$ step guarantees that $N_{i+1}\leq N_i /2$ w.h.p. To obtain outgoings edges from the growable components in $\mathcal{C}_i$, the algorithm uses the $i^{th}$ basic-unit sketch $\Sketch_i(C_{i,j})$ of each $C_{i,j} \in \mathcal{C}_i$. By Lemma \ref{lem:sketch-property}, from every growable component in $\mathcal{C}_i$, we get one outgoing edge $e'=(x,y)$ with constant probability. Using the extended edge identifier of $e'$ the algorithm can also detect the component $C_{i,j'}$ to which the second endpoint, say $y$, of $e'$ belongs using Claim \ref{claim_component_tree}. %Specifically, this is done using the ancestry label of the detected edge $e'$. 
That label allows us to compute the component of $y$ in the initial partitioning $T \setminus F$, i.e., the component $C_{0,q}$ of $y$ in $\mathcal{C}_0$. Thus $y$ belongs to the unique component $C_{i,j'} \in \mathcal{C}_i$ that contains 
$C_{0,q}$. 


%The algorithm uses the sketch information to compute at least one outgoing edge from each growable component $C_{i,j}$. This is done using the $i^{th}$ block of $K'=O(\log n)$ sketches $\{\Sketch_{(i-1)K+\ell}(C_{i,j}), \ell \in \{1,\ldots, K'\}\}$ to compute an outgoing edge. \mtodo{check indexes, $K$ or $K'$?}

As noted in prior works \cite{ahn2012analyzing,kapron2013dynamic,DuanConnectivityArxiv16}, it is important to use fresh randomness (i.e., independent sketch information) in each of the Boruvka phases. The reason is that the cut query, namely, asking for a cut edge between $S$ and $V \setminus S$, should not be correlated with the randomness of the sketches. Note that indeed the components of $\mathcal{C}_i$ are correlated with the randomness of the first $(i-1)$ basic sketch units of the vertices. Thus, in phase $i$ the algorithm uses the $i^{th}$ basic sketch units of the vertices (which are independent of the other sketch units) to determine the outgoing edges of the components in $\mathcal{C}_i$.

%\begin{claim}\label{cl:balg}
%Given a sketch $\Sketch_i(C_{i,j})$ of a growable compo
%W.h.p given the set of sketches $\{\Sketch_{(i-1)K+\ell}(C_{i,j}), \ell \in \{1,\ldots, K'\}\}$, one can determine an outgoing edge $e=(u,v) \in C_{i,j} \times (V\setminus C_{i,j})$ in time $\widetilde{O}(1)$ if such an edge exists. In addition, one can also compute the component $C_{i,j'}$ such that $v \in C_{i,j'}$ in $\widetilde{O}(1)$ time. 
%\end{claim}
%\begin{proof}
%
%\end{proof}
%By Cl. \ref{cl:balg}, w.h.p. the algorithm computes an outgoing edge from each of the components which leads to a merging of the components. 

The algorithm then computes the updated sketches of the merged components. This is done by XORing over the sketches of the components in $\mathcal{C}_i$ that got merged into a single component in 
$\mathcal{C}_{i+1}$. In expectation, the number of growable components is reduced by factor $2$ in each phase. Thus after $O(\log n)$ phases, the expected number of growable components is at most $1/n^5$, and using Markov inequality, we conclude that w.h.p there are no growable components. The final partitioning $\mathcal{C}_L$ corresponds w.h.p to the maximal connected components in $G \setminus F$. The pair $s$ and $t$ are connected in $G \setminus F$ only if the components $C_s,C_t$ of $s,t$ respectively in $T \setminus F$ are connected in the final component decomposition.
We next show that the complexity of the algorithm is $\widetilde{O}(f)$. This is also the decoding time of the whole algorithm, as all steps take $\widetilde{O}(f)$ time, as discussed above. 

\begin{claim}\label{cl:complexity-step-four}
The complexity of step 4 is $\widetilde{O}(f)$.
\end{claim}

\begin{proof}%[Proof of Claim \ref{cl:complexity-step-four}]
The algorithm has $O(\log{n})$ phases, where in each phase the following is computed. First, given the sketch values of the current components we identify outgoing edges from the components. This takes $\widetilde{O}(1)$ time per component from Lemma \ref{lem:sketch-property}, and $\widetilde{O}(f)$ time for all components, as we have at most $f+1$ components. Next, for each outgoing edge we identify the components it connects using its ancestry labels, this takes $\widetilde{O}(1)$ time per edge using Claim \ref{claim_component_tree}. Then, we merge components accordingly and compute the sketch values of the new components by XORing the sketch values of merged components. Overall this takes $\widetilde{O}(f)$ time, as we have at most $O(f)$ merges. In more detail, we can use a union-find data structure to implement the merges, where every time we merge components we compute the sketch value of the new component. We also maintain for each original component in $T \setminus F$ its current component in phase $i$, this allows us to learn the current components connected by an outgoing edge $e$. This information can be maintained as follows. Let $C$ be a component in $T \setminus F$, and assume we know the component $C_{i,j}$ it belongs to at the beginning of phase $i$. After the merges of phase $i$, $C_{i,j}$ joins some component $C_{i+1,j'}$ of phase $i+1$. We can use the find operation to identify the id of the new component. Overall, we have $O(f)$ merges and $O(f)$ find operations to identify for each component $C \in T \setminus F$, the corresponding component $C_{i+1,j'}$ it belongs to, hence the complexity is bounded by $\widetilde{O}(f)$. 
\end{proof}

%For simplicity assume first that there is only one failing edge $e=(u,v)$ in $T$. W.l.o.g assume that $v$ is the parent of $u$ in the tree (this can be checked using the LCA labels). The forest $T \setminus \{e\}$ has two components given by $V_u$ and $\bar{V}_u=V \setminus V_u$. The sketch value $\Sketch(V_u)$ and $\Sketch(\bar{V}_u)$ are explicitly stored in the label of $u$ (which is part of $\FTConnLabel(e)$). To update these sketches into sketches in $G \setminus F$ we do as follows. First we cancel the effect of the edge $e$ by using the information stored in $\FTConnLabel(e)$. That is, we add $ID(e)$ to every entry in the sketch $\Sketch(V_u)$ and $\Sketch(\bar{V}_u)$ in which it appears. The cancellation of inter-cluster edges $e' \in F$ is performed in the same manner. 
%
%\begin{description}
%\item add information of LCA to the labels, so that we can detect the LCA label of the edge.
%\item bound the time in which we can tell that the XOR is not a legal edge.
%\end{description}
Finally, we show that the decoding algorithm can be slightly modified to output a compressed encoding of an $s$-$t$ path in $G \setminus F$, using $O(f\log n)$ bits. This encoding is represented by an $s$-$t$ path $\widehat{P}$ that has two type of edges, appearing in an alternate manner on  $\widehat{P}$: $G$-edges and edges $e'=(u,v)$ such that the $u$-$v$ tree path is intact in $T \setminus F$. See Figure \ref{fig:succ-paths}. 
\begin{lemma}\label{lem:useful-recovery-edges}
Consider a triplet $s,t,F$ such that $s$ and $t$ are connected in $G \setminus F$. 
The decoding algorithm can also output a set of at most $f$ recovery edges $R$ such $(T \setminus F) \cup R$ is a spanning tree. In addition, it outputs a labeled $s$-$t$ path $\widehat{P}$ of length $O(f)$ that provides a succinct description of the $s$-$t$ path. The edges of $\widehat{P}$ are labeled by $0$ and $1$, where $0$-labeled edges correspond to $G$-edges and $1$-labeled edges $e=(x,y)$ correspond to $x$-$y$ paths in $T \setminus F$. 
\end{lemma}
\begin{proof}
Let $C_s, C_t$ be the components of $s$ and $t$ in the initial partitioning $\mathcal{C}_0$. In Step $4$ of the decoding algorithm, the Boruvka algorithm is simulated up to the point that $C_s$ and $C_t$ are connected. Therefore, the algorithm has computed a path $P$ that connects the components $C_s$ and $C_t$. Each vertex on that path corresponds to a component in $\mathcal{C}_0$, and each edge corresponds to an outgoing edge (discovered using the sketch information). Since $\mathcal{C}_0$ has at most $f+1$ components, $|P|\leq f+1$. 
Each such edge $e' \in P$ corresponds to an edge in $G$. Let $e_1=(x_1,y_1),\ldots, e_k=(x_k,y_k)$ be the $G$-edges corresponding to the edges of $P$ ordered from $C_s$ to $C_t$. Letting $y_0=s$ and $x_{k+1}=t$, we get that 
$y_i$ and $x_{i+1}$ belong to the same component in $\mathcal{C}_0$, for every $i \in \{0,\ldots, k\}$. 
The labeled path is given by $\widehat{P}=[s, x_1,y_1, x_2, y_2, \ldots y_k,t]$ where the edges $(y_i,x_{i+1})$ are labeled $1$ and the edges $(x_{i}, y_i)$ are labeled $0$. Each $0$-labeled edge is a real edge in $G$, and each $1$-labeled edge $(x_{i}, y_i)$ corresponds to a tree path $\pi(x_i, y_i)$ in $T \setminus F$. 
\end{proof}


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.40]{suc-path.pdf}
\caption{\sf Shown is a tree $T$ with faulty edges $e_1,\ldots, e_4$. The $s$-$t$ path in $G \setminus F$ is represented by the path $\widehat{P}=[s,v_1]\circ (v_1,v_2) \circ [v_2,v_3] \circ (v_3,r) \circ [r,v_4] \circ (v_4, v_5) \circ [v_5,t]$. The recovery edges $(v_1,v_2), (v_3,r)$ and $(v_4, v_5)$ are shown in dashed lines.  \label{fig:succ-paths}
}
\end{center}
\end{figure}