\section{Compact Routing Schemes}
In this section, we explain how to use our FT-distance labels to provide compact and low stretch routing schemes. This is the first scheme to provide an almost tight tradeoff between the space and the multiplicative stretch, for a constant number of faults $f=O(1)$.  Throughout this section, tree routing operations are performed by using the tree routing scheme of Thorup and Zwick \cite{thorup2001compact}.
\begin{fact}\label{fc:route-trees}[Routing on Trees]\cite{thorup2001compact}
For every $n$-vertex tree $T$, there exists a routing scheme that assigns each vertex $v \in V(T)$ a label $L_T(v)$ of $(1+o(1))\log n$ bits. Given the label of a source vertex
and the label of a destination, it is possible to compute, in constant time, the port number of the edge from the source that heads in the direction of the destination.
\end{fact}

\textbf{MP: check if needed.} \mtodo{I've added a discussion of the port information later.}
In our routing scheme, each vertex $u$ is required to compute the port number of the next-hop towards the target destination. Towards that goal, we modify the FT-distance labels of Sec. \ref{sec:ft-distance}, by adding the port information to the extended identifier of the edges. That is, the extended identifier of each edge $e=(u,v)$ is augmented with a third field containing the port number of $v$ w.r.t $u$ and vice-versa. To avoid cumbersome notation, we still refer to this port-augmented FT-distance label of $u$ by $\FTDistLabel(u)$. 

%Let $\mathcal{T}=\bigcup_{i=1}^{K}\TreeCover_i$ be the collection of tree covers with $K=O(\log (nW))$ scales of distances. We call an edge $(u,v)$ a \emph{tree edge} if it appears on at least one of trees in $\mathcal{T}$. Our routing schemes will be based on assigning labeling information for the tree edges. For a non-tree edge, it will be sufficient to obtain the extended ID of the edge that contains $O(\log n)$ bits. As we will see, these IDs would not be stored explicitly in the routing tables.  
%
%For every $i \in [1,K]$ for $K=\lceil \log(nW) \rceil$, let Let $H_i$ be set of heavy edges in $G$ of weight at least $2^i$, and define the $i^{th}$ tree-cover by $\TreeCover_i=\TreeCover(G\setminus H_i,\omega, 2^i,2k)$. 
%Let $\mathcal{T}=\bigcup \TreeCover_i$, and denote the tree edges by $E_T=\bigcup_{T_{i,j} \in \TreeCover_i} E(T_{i,j})$. Note that by Def. \ref{def:tree-cover}, $|E_T|=O(k n^{1+1/(2k)} \log(nW))$. 
%

\mtodo{Added the part from here. This adds port and tree routing information to the ids, and adapts Lemma \ref{lem:useful-recovery-edges} (finding succinct path description) to the context of routing.}

%\mtext{
We slightly modify the connectivity label of the edges and vertices by augmenting them with routing information. 
Specifically, we define the vertex identifier $\ID_T(u)=[\ID(u), L_T(u)]$ where $L_T(u)$ is taken from Fact \ref{fc:route-trees}. We then slightly modify the 
the connectivity label of Eq. (\ref{{eq:conn-node}}) by defining 
$$\FTConnLabel_{G,T}(u)=\langle \LCALabel_T(u), \ID_T(u) \rangle~.$$
In addition, we also augment the extended identifier of an edge Eq. (\ref{eq:extend-ID}) with port information and tree routing information, by having:
$$\EID(e)=[\UID(e), \ID(u), \ID(v), \LCALabel_T(u), \LCALabel_T(v), \port(u,v), \port(v,u), L_T(u), L_T(v)]~,$$
where $\port(u,v)$ is the port number of the edge $(u,v)$ for $u$. 
%
%
%We next discuss a variant of Lemma \ref{lem:useful-recovery-edges} that is useful in the context of routing. 
%We use the following notation. For a vertex $v$, and a tree $T$ where $v \in T$, let $ID_T(v)=(\LCALabel(v),L_T(v))$, where $\LCALabel_T(v)$ is the ancestry label of $v$ in the tree $T$. For an edge $e=(u,v)$ where $u,v \in T$, we define the extended identifier $ID_T(e)$ as follows. $ID_T(e)$ is defined as in Section \ref{sec:ftconn-sketch}, but we also add to it port information and tree routing information. 
%
%
%
%First, we add to the extended identifier $ID_T(e)$ the port number of $v$ w.r.t $u$ and vice-versa. In addition, we add to $ID_T(e)$ the tree routing labels $L_T(u),L_T(v)$ from Fact \ref{fc:route-trees}. Note that the size of the ids is still $O(\log{n})$. 
Throughout this section, when applying the connectivity labels from Section \ref{sec:ftconn-sketch} on a graph $G$ with spanning tree $T$, we use these labels and extended identifiers to support routing.
%First, to support routing, when we apply the connectivity labels from Section \ref{sec:ftconn-sketch} on a graph $G$ with spanning tree $T$, we add to the identifiers $ID(e)$ port information and tree routing information. For each edge $e=(u,v)$, we add to the extended identifier $ID(e)$ the port number of $v$ w.r.t $u$ and vice-versa. In addition, we add to $ID(e)$ the tree routing labels $L_T(u),L_T(v)$ from Fact \ref{fc:route-trees}. Note that the size of the ids is still $O(\log{n})$. We also add to the connectivity label of a vertex $v$, its tree routing label $L_T(v)$. 
We later apply the connectivity labels with respect to the different trees of the tree cover as discussed in Section \ref{sec:ft-distance}. 
Let $T_{i,j} \in \TreeCover_i$, recall that $G_{i,j}=G[V(T_{i,j})]$ and that $\mathcal{T}=\bigcup_{i=1}^K \TreeCover_i$ for $K=O(\log (nW))$. 
%Recall that for a vertex $t$, the graph $G_{i,i^*(t)}$ contains the $2^i$ ball of $t$ in $G$, where $ T_{i,i^*(t)}$ is the corresponding tree from the tree cover that spans $G_{i,i^*(t)}$. We denote $G_i = G_{i,i^*(t)}, T_i = T_{i,i^*(t)}$. Using Lemma \ref{lem:useful-recovery-edges} ,we have the following.

\begin{lemma}\label{lem:succint_path_routing}
Consider a triplet $s,t,F$ such that $s,t,F \in G_{i,j}$. 
Given $ID_{T_{i,j}}(s),ID_{T_{i,j}}(t)$ and the connectivity labels $\{\FTConnLabel_{G_{i,j},T_{i,j}}(e)\}_{e \in F}$, we can determine w.h.p if $s$ and $t$ are connected in $G_{i,j} \setminus F$. If they are connected, we can output a labeled $s$-$t$ path $\widehat{P}$ of length $O(f)$ that provides a succinct description of the $s$-$t$ path in $G_{i,j} \setminus F$. The edges of $\widehat{P}$ are labeled by $0$ and $1$, where $0$-labeled edges correspond to $G_{i,j}$-edges and $1$-labeled edges $e=(x,y)$ correspond to $x$-$y$ paths in $T_{i,j} \setminus F$. For each $G_{i,j}$-edge, the succinct path description has the port information of the edge, and for each $x-y$ path, the description has the tree routing labels $L_{T_{i,j}}(x),L_{T_{i,j}}(y)$.
The length of the $s$-$t$ path encoded by $\widehat{P}$ is bounded by $(4k-1)(f+1)\cdot 2^i$. 
\end{lemma}

\mtodo{For the proof I use the fact that the decoding algorithm only uses the ancestry labels of $s,t$, we should probably add some remark on the topic also on the labels section.}

\begin{proof}
The proof follows the proof of Lemma \ref{lem:useful-recovery-edges}. To see this, first note that the decoding algorithm from Section \ref{sec:ftconn-sketch} mostly uses the connectivity labels of the faulty edges $F$, and it needs only the labels $\LCALabel(s),\LCALabel(t)$ of $s$ and $t$, to detect the connected components of $s$ and $t$ in $T_{i,j} \setminus F$. \mtodo{do we want to edit this there? at least have some remark} 
Hence, using $ID_{T_{i,j}}(s),ID_{T_{i,j}}(t)$ and the connectivity labels $\{\FTConnLabel_{G_{i,j},T_{i,j}}(e)\}_{e \in F}$, we can first check if $s$ and $t$ are connected in $G_{i,j} \setminus F$ using the decoding algorithm of Section \ref{sec:ftconn-sketch}. If they are connected, then from Lemma \ref{lem:useful-recovery-edges}, we get a succinct description of the $s$-$t$ path in $G_{i,j} \setminus F$. We next show that the algorithm indeed has the relevant port and tree routing information. For this note that all the vertices in the path $\widehat{P}$ obtained by Lemma \ref{lem:useful-recovery-edges} are either $s$ and $t$ or endpoints of the $f$ recovery edges found in the algorithm. The ids $ID_{T_{i,j}}(s),ID_{T_{i,j}}(t)$ of $s$ and $t$ have their tree routing information, and when the algorithm finds a recovery edge, it learns about its extended id $ID_{T_{i,j}}(e)$ that has the port information and tree routing information of its endpoints. Any $G_{i,j}$-edge in $\widehat{P}$ is a recovery edge, hence the algorithm has its port information, and for any $x$-$y$ path in $T_{i,j} \setminus F$, the algorithm has the tree routing labels $L_{T_{i,j}}(x),L_{T_{i,j}}(y)$, as needed.
The stretch analysis follows the stretch analysis in Section \ref{sec:ft-distance}. It is based on the fact that $\widehat{P}$ has as most $f+1$ subpaths in $T_{i,j} \setminus F$, each of length at most $(4k-2)2^i$, and at most $f$ recovery edges of weight at most $2^i$.
\end{proof}
%}







\subsection{Forbidden Set Routing (Faulty Edges are Known)}\label{sec:routing-known}
We start by describing the routing scheme in the forbidden set setting, where the faulty edges $F$ are known to the source vertex $s$. We show the following.

\begin{theorem}\label{thm:routing-known}[Forbidden-Set Routing]
For every integers $k,f$, there exists an $f$-sensitive compact routing scheme that given a message $M$ at the source vertex $s$, a label of the destination $t$, and labels of at most $f$ forbidden edges $F$ (known to $s$), routes $M$ from $s$ to $t$ in a distributed manner over a path of length at most $(8k-2)(f+1)\cdot \dist_{G \setminus F}(s,t)$. The table size of each vertex is bounded by $\widetilde{O}(n^{1/k} \log{(nW)})$. The header size of the messages is bounded by $\widetilde{O}(f)$ bits. The labels of vertices and edges have size $\widetilde{O}(n^{1/k} \log{(nW)})$.
\end{theorem}

\mtodo{I edited a bit the proof so it's more similar to the next section and uses Lemma \ref{lem:succint_path_routing}. The routing tables here still use the distance labels. Also, added a bit more details on the routing process.}

\begin{proof}
The algorithm is based on the distance labels from Section \ref{sec:ft-distance}. Recall that the distance labels are based on applying fault tolerant connectivity labels on different graphs $G_{i,j}$, we use the connectivity labels from Section \ref{sec:ftconn-sketch}.
The routing table of each vertex $u$ consists of its distance label and the tree routing labels from Fact \ref{fc:route-trees} for every tree $T_{i,j} \in \mathcal{T}$ containing $u$. That is,
$$R_{route}(u)=\FTDistLabel(u) \cup \{ \langle L_{T_{i,j}}(u), (i,j) \rangle ~\mid~ i \in [1,K], j \in \{1,\ldots, |\TreeCover_{i}|\}, u \in T_{i,j}\}~.$$
Since each vertex $u$ participates in $O(k n^{1/k} \log(n W))$ trees of $\mathcal{T}$, and since the distance labels are of size $O(k n^{1/k} \log(n W) \cdot \log^3{n})$, the table $R_{route}(u)$ has $O(k n^{1/k} \log(n W) \cdot \log^3{n})$ bits.
The label of a vertex $u$ is just $R_{route}(u)$, and the label of an edge $e$ is $\FTDistLabel(e)$. The labels have size $O(k n^{1/k} \log(n W) \cdot \log^3{n})$. \mtodo{we can have shorter labels for vertices as in the next section (but then we need to "open the box" of the distance labels), as the labels of edges are anyway large I'm not sure if we want to do it in this section.}

\mtext{
In the routing algorithm, the vertex $s$ is given the label $R_{route}(t)$ of $t$, and the labels $\{\FTDistLabel(e)\}_{e \in F}$, and it needs to route a message to $t$ in the graph $G \setminus F$. First, from the distance labels of $s,t$ and $F$, $s$ can check using the algorithm from Section \ref{sec:ft-distance} if $s$ and $t$ are connected in $G \setminus F$, and if so get a succinct description of a path between them. In more detail, recall that the algorithm from Section \ref{sec:ft-distance} works in $K$ phases, where in phase $i$ it checks if $s$ and $t$ are connected in the graph $G_{i,i^*(s)} \setminus F$ that contains the $2^i$-ball around $s$. Let $i$ be the first iteration where $s$ and $t$ are connected in $G_{i,i^*(s)} \setminus F$ according to the algorithm, and denote $G_i = G_{i,i^*(s)},T_i = T_{i,i^*(s)}$, and let $F_i = F \cap G_i$. The algorithm can also give a succinct description of an $s$-$t$ path in $G_i \setminus F_i$ following Lemma \ref{lem:succint_path_routing}. For this, note that we indeed have all the required information. The distance labels of edges in $F$ in particular contain the labels $\{\FTConnLabel_{G_i,T_i}(e)\}_{e \in F_i}$, and we can also tell which edges of $F$ are in $G_i$ from the labels. Also, the labels of $s,t$ contain the information $ID_{T_i}(s),ID_{T_i}(t)$ if they are both in $T_i$ (otherwise, they are not connected in level $i$).

The path $\widehat{P}$ as described in Lemma \ref{lem:succint_path_routing} is composed of $O(f)$ parts, where segment $(x,y)$ in the path corresponds either to an edge in $G_i$ or to a tree path in $T_i \setminus F$, it also has the relevant port and tree routing information. Our goal is to route a message according to this path. For this we add to the header of the message the description of $\widehat{P}$, the indexes $(i,i^*(s))$ of the tree we explore and an index $1 \leq q \leq 2f+1$ that represents the segment of $\widehat{P}$ we currently explore, initially $q=1$. Overall, the header size is $\widetilde{O}(f)$. To route a message according to the path, we work as follows. The header specifies the current segment in $\widehat{P}$. If the current segment corresponds to an edge $(x,y) \in G$, then $x$ uses the port information to route the message to $y$ and increases the index $q$. Otherwise, the current segment represents a tree path $(x,y) \in T_i$ and a vertex $u$ in this path uses its routing label in $T_i$ and the routing label of $y$ in $T_i$ (that is part of the header) to route the message towards $y$. When the message reaches $y$, it increases the index $q$. This completes the description of the routing process. The length of the path described is at most $(8k-2)(f+1)\cdot \dist_{G\setminus F}(s,t)$, as shown in Section  \ref{sec:ft-distance}. } 
%Given the labels $\{\FTDistLabel(w), w \in \{s,t\} \cup F\}$, the decoding algorithm of Lemma \ref{lem:approx-dist-recovery} computes a succinct description of an $s$-$t$ path in $G \setminus F$ of length $(8k-2)(f+1)\cdot \dist_{G\setminus F}(s,t)$. This description is given by a path $\widehat{P}$ augmented with the index $(i,j)$, such that every non-$G$ edge $e'=(u,v)$ of $\widehat{P}$ corresponds to a $u$-$v$ path in $T_{i,j}\setminus F$. Our routing scheme augments each vertex $v$ on $\widehat{P}$ with its tree label $L_{T_{i,j}}(v)$ from Fact \ref{fc:route-trees}. Overall, this information is encoded in $O(f\log^2 n)$ \mtodo{why $\log^2 n$?} bits which are attached to the header of the message. As each $G$-edge on $\widehat{P}$ is augmented with the port information, and each non-$G$ edge $(u,v)$ is augmented with the tree labels of $u,v$ in $T_{i,j}$, the vertices have the required information to route the message along the $s$-$t$ path encoded by $\widehat{P}$. 
\end{proof}

%We therefore have:
%\begin{enumerate}[noitemsep]
%\item }.
%\item Every non-$G$ edge $e=(u,v)$ corresponds to a tree path $T \in \bigcup_i\TreeCover_i$
%\item The 
%\end{enumerate}


\subsection{Fault Tolerant Routing (Faulty Edges are Unknown)}\label{sec:route-unknown}
We now consider the more involved setting where the set of failed edges $F$ are unknown to $s$. In this case, an edge $(u,v) \in F$ is detected only when the message arrives, during the routing procedure, to one of the endpoints of $e$. Note that the routing scheme should, by definition, be prepared to any set of faulty edges $F$. However, the space bound of our scheme is required to be bounded by $\widetilde{O}(f n^{1+1/k})$, which is possibly much smaller than the number of graph edges $m$. This in particular implies that we cannot store the FT-distance labels of all the graph edges. Nevertheless, we show that it is sufficient to explicitly store the labeling information for the tree edges in $\mathcal{T}$. The required information for the failed non-tree edges would be revealed throughout the process, by applying the decoding algorithm of Lemma \ref{lem:succint_path_routing}.
Our routing scheme eventually routes the message along the $s$-$t$ path encoded by the FT-distance labels of $s,t$ and $F$. However, since the labels of $F$ are unknown in advance, the routing scheme will detect these edges in a trail and error fashion which induces to an extra factor of $f$ in the final multiplicative stretch. This extra $f$ factor is also shown to be essential, in the end of the section.
We proceed by describing the routing tables.  
%A routing scheme consists of a two phases algorithm. In the preprocessing phase, each vertex $v$ is assigned
%a routing table $R(v)$ and a label $L(v)$. In the routing phase, a vertex $u$ gets a message with a short header
%$H(M)$ and with a destination label $L(v)$, and based on its own routing table $R(u)$, the destination label $L(v)$
%and the header $H(M)$, it decides to which neighbor $w$ to forward the message. It can also add information to the header of the message. The key objective is to minimize the individual size of each label $L(u)$, routing tables $R(u)$ and the message header $H(M)$. 

\remove{
\paragraph{The routing tables.} For ease of presentation, we first describe a solution with a multiplicative stretch of $O(kf^2)$, and \emph{global} space of $\widetilde{O}(f K \cdot n^{1+1/k})$, \mtodo{should it be $n^{1+2/k}$?} but the individual tables of some of the vertices might be of linear space. 
Recall that $\mathcal{T}=\bigcup_i^{K} \TreeCover_i$, for $K=O(\log (nW))$ is a collection of tree covers in all $K=\lceil \log (nW) \rceil$ distance scales, see Eq. (\ref{eq:TC-i}). For every vertex $u$, let $\deg_T(u)=\sum_{T_{i,j} \in \mathcal{T}}\deg(u,T_{i,j})$ be the sum of degrees of $u$ in the collection of trees  $\mathcal{T}$.
The algorithm computes each vertex $u$ a table of $\widetilde{O}(f \cdot \deg_T(u) \cdot n^{1/k})$ bits.
Since the total number of tree edges in $\mathcal{T}$ is bounded by $\widetilde{O}(K \cdot n^{1+1/k})$, this provides a global space bound of $\widetilde{O}(fK \cdot n^{1+2/k})$ bits. We later on improve the space of each table to $\widetilde{O}(fK \cdot n^{2/k})$ bits. \mtodo{maybe extra $k,K$ are needed in some places.}

The routing process has at most $f+1$ phases, and each phase uses an independent set of randomized FT-distance labels. Therefore, the preprocessing algorithm employs $f$ \mtodo{$f$ or $f+1$?} independent applications of the $(f,(8k-2)(f+1))$ FT-distance labels scheme. Denote the output labels obtained by the $i^{th}$ application by $\FTDistLabel_i(w)$ for every $w \in V(G)\cup E(G)$. Let $E_T=\bigcup_{T_{i,j} \in \mathcal{T}} E(T_{i,j})$ be the collection of tree edges. The \emph{routing label} \mtodo{maybe we want to have shorter labels, and have this information only in the routing tables?} of each $w \in V\cup E_T$ is given by 
$$L_{route}(w)=\{\FTDistLabel_1(w),\ldots, \FTDistLabel_{f+1}(w)\}~.$$ 
The routing label $L_{route}(e)$ of a non-tree edge $e \in E \setminus E_T$ is simply the extended identifier of $e$. For each vertex $u$, the routing table $R_{route}(u)$ consists of the following:
\begin{enumerate}%[noitemsep]
\item Tree labels $L_{T_{i,j}}(u)$ for every tree $T_{i,j}$ in $\mathcal{T}$ that contains $u$ (from Fact \ref{fc:route-trees}). These labels are augmented with their corresponding tree index $(i,j)$.
\item The routing labels $L_{route}(u)$ and $\{L_{route}(e=(u,v)) ~\mid~ e \in T_{i,j}, T_{i,j} \in \mathcal{T}\}$.
\end{enumerate}
The header information initially contains the succinct path information\footnote{\textbf{MP: This is not essential, we can always make the header contain the labels of the currently detected faults.}} obtained by the decoding algorithm of the FT-distance labeling when given the labels $L_{route}$ of $s$ and $t$. \mtodo{do we want to have $f$ paths? Or only one of them that is relevant for the current phase}  As we will see, throughout the routing procedure, the header information will be augmented with the labels of the currently detected faulty edges. 
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{The routing tables.} For ease of presentation, we first describe a solution with a multiplicative stretch of $O(kf^2)$, and \emph{global} space of $\widetilde{O}(f K \cdot n^{1+1/k})$, but the individual tables of some of the vertices might be large. We later on improve the space of each table to $\widetilde{O}(fK \cdot n^{1/k})$ bits.

Recall that $\mathcal{T}=\bigcup_i^{K} \TreeCover_i$, for $K=O(\log (nW))$ is a collection of tree covers in all $K=\lceil \log (nW) \rceil$ distance scales, see Eq. (\ref{eq:TC-i}). For every vertex $v$, let $\deg_T(v)=\sum_{T_{i,j} \in \mathcal{T}}\deg(u,T_{i,j})$ be the sum of degrees of $u$ in the collection of trees  $\mathcal{T}$. Recall that $G_{i,j}=G[V(T_{i,j})]$.
\mtext{For the routing we apply the FT-connectivity labels on the graphs $G_{i,j}$, similarly to Section \ref{sec:ft-distance}.
The routing process uses $f$ independent applications of randomized FT-connectivity labels from Section \ref{sec:ftconn-sketch}, applied on each one of the graphs $G_{i,j}$. \mtodo{There is some delicate issue here. In my understanding we do want to have the extended ids fixed in different applications, and only change the randomness of sketches, as I try to explain here.} In more detail, when we apply the labeling scheme on the graph $G_{i,j}$ with spanning tree $T_{i,j}$, we use $f$ independent random seeds $\mathcal{S}_h$ to determine the randomness of the sketches. However, the seed $\mathcal{S}_{ID}$ used to determine the extended ids of edges in $G_{i,j}$ is fixed in the $f$ applications, hence the ids are fixed and we only use fresh randomness to compute the sketch information. This process is done independently on each one of the graphs $G_{i,j}$. }  
Denote the output labels obtained by the ${\ell}^{th}$ application of the scheme on the graph $G_{i,j}$ by $\FTConnLabel^{\ell}_{G_{i,j},T_{i,j}}(w)$ for every $w \in V(G_{i,j})\cup E(G_{i,j})$, and we denote by $$\FTConnLabel_{G_{i,j},T_{i,j}}(w)=(\FTConnLabel^1_{G_{i,j},T_{i,j}}(w),...,\FTConnLabel^f_{G_{i,j},T_{i,j}}(w)).$$
Since in each application the labels are of size $O(\log^3{n})$, the total size of each label is $O(f \log^3{n})$. \mtext{Recall that for a non-tree edge $e \in G_{i,j}$, we have that  $\FTConnLabel^{\ell}_{G_{i,j},T_{i,j}}(e)=\ID_{T_{i,j}}(e)$. This label does not depend on the sketch information, and hence is the same in all $f$ applications, we will exploit this later in the algorithm.}

\mtodo{I changed a bit the definition of routing tables and labels. The labels currently are of polylog size (no extra $f$ or $n^{1/k}$).}
\mtext{
The routing table $R_{route}(v)$ of a vertex $v$ has the following information for any tree $T_{i,j}$ such that $v \in T_{i,j}$:
\begin{enumerate}
\item The values $(ID_{T_{i,j}}(v),i,j)$.
\item The connectivity labels $\FTConnLabel_{G_{i,j},T_{i,j}}(e)$ for any tree edge $e \in T_{i,j}$ adjacent to $v$. 
\end{enumerate}

Since the connectivity labels are of size $\widetilde{O}(f)$, and since $v$ appears in $\deg_T(v)$ trees, the size of the table is $\widetilde{O}(f \deg_T(v)).$ Since the total number of tree edges in $\mathcal{T}$ is bounded by $\widetilde{O}(K \cdot n^{1+1/k})$, this provides a global space bound of $\widetilde{O}(fK \cdot n^{1+1/k})$ bits.

Recall that for a vertex $v$ and index $1 \leq i \leq K$, we denote by $i^*(v)$ an index such that the $2^i$-ball around $v$ is contained in $T_{i,i^*(v)}$.
The routing label $L_{route}(v)$ of $v$ has the id of $v$ in the trees $T_{i,i^*(v)}$.
$$L_{route}(v) = \{(i^*(v),ID_{T_{i,i^*(v)}}(v)) | i \in [1,K]\}$$

The size of the label is $O(K\log{n})=O(\log{n} \log{nW})$.}

\mtodo{In the routing algorithm the main difference is that we have log iterations for the different trees, in each tree the algorithm is similar to before.}

\paragraph{The routing algorithm.} \mtext{In the routing algorithm, the source vertex $s$ gets the routing label $L_{route}(t)$ of the destination $t$ and its goal is to find a graph $G_{i,j}$ such that $s$ and $t$ are connected in $G_{i,j} \setminus F$, and use it for routing. As the set $F$ is not known in advance, the algorithm works in $K= O(\log{nW})$ iterations, where in iteration $i$ it tries to route a message in $G_{i,i^*(t)}$. If $s$ and $t$ are connected in $G_{i,i^*(t)} \setminus F$ the algorithm succeeds, and otherwise we proceed to the next iteration. 
We next describe the algorithm for one iteration $i$, we denote $G_i = G_{i,i^*(t)}, T_i = T_{i,i^*(t)}$. Note that $s$ learns the index $i^*(t)$ from the label of $t$, and it can check if $s \in T_i$ using its routing table. If $s \not \in T_i$, we proceed to the next iteration.}

If $s \in T_i$, the routing procedure for iteration $i$ has at most $f+1$ phases. Each phase will start at the source vertex $s$. We will maintain the following invariant in the beginning of each phase $\ell \in \{1,\ldots, f+1\}$: (i) the algorithm has already detected a subset of $\ell-1$ faulty edges $F_\ell \subseteq F$, and (ii) the header contains the labels $\FTConnLabel_{G_i,T_i}(e)$ of all the edges $e \in F_\ell$. Each phase $\ell \leq f+1$ will terminate either at the destination vertex $t$, or at the source vertex $s$. In addition, w.h.p., if $s$ and $t$ are connected in $G_i \setminus F$, phase $f+1$ will terminate at $t$. The invariant holds vacuously for phase $1$.

We now describe the $\ell^{th}$ phase of the routing procedure given the invariant. The source vertex $s$ considers the $\ell^{th}$ copy of the FT-connectivity labels, $\FTConnLabel^{\ell}_{G_i,T_i}(e)$ for every $e \in F_\ell$. 
Using the connectivity labels, that are part of the header, and the ids $ID_{T_i}(s),ID_{T_i}(t)$ that are part of the routing table of $s$ and routing label of $t$, the algorithm first checks if $s$ and $t$ are connected in $G_i \setminus F_\ell$ using Lemma \ref{lem:succint_path_routing}. If the answer is no, the algorithm moves to the next iteration $i+1$.
Otherwise, by applying the decoding algorithm of Lemma \ref{lem:succint_path_routing}, it computes the succinct path $\widehat{P}_\ell$. The path $\widehat{P}_\ell$ encodes an $s$-$t$ path in $G_i \setminus F_\ell$, that includes the relevant port and tree routing information of its vertices. The header of the message $H_\ell$ then contains 
$$H_\ell=\langle \widehat{P}_\ell, i, i^*(t), \{\FTConnLabel_{G_i,T_i}(e)\}_{e \in F_{\ell}}, q \rangle~,$$ where $q = O(f)$ is an index indicating the current segment of $\widehat{P}_\ell$ we explore. \mertodo{$H_\ell$ should contain $\FTConnLabel^{\ell}_{G_i,T_i}(e)$, right?}


\mtext{The size of the header is $\widetilde{O}(f^2)$, as the description of the path has size $\widetilde{O}(f)$, and additionally we have at most $f$ faulty edges with labels of size $\widetilde{O}(f)$.} \mtodo{in some sense we don't really need to have all this $O(f^2)$ information on the header at once because it's enough that $s$ learns in each phase on one of the labels and then stores it locally, but this I guess doesn't work with the formal definition of routing.}
Let $P_\ell$ be the $G$-path encoded by the path $\mathcal{P}_\ell$. The algorithm then routes the message along $P_\ell$ in the same manner as in Sec. \ref{sec:routing-known}. In the case where $P_{\ell}\cap F=\emptyset$, the phase successfully terminates at the destination vertex $t$. From now on, we consider the case that $P_{\ell}$ contains at least one faulty edge. 

Let $e=(u,v)$ be the first edge (closest to $s$) on the path $P_\ell$ that belongs to $F$. Since $P_\ell \cap F_\ell=\emptyset$, it holds that $e \in F \setminus F_\ell$. Without loss of generality, assume that $u$ is closer to $s$ on $P_\ell$. Thus the faulty edge $e$ is detected upon arriving to the vertex $u$. 
In the case where $e$ is a \emph{non-tree edge}, then it must be a $G$-edge on $\widehat{P}_\ell$. Since this path has the ids $ID_{T_i}(e)$ of its $G$-edges, and since the connectivity label of a non-tree edge $e$ is $ID_{T_i}(e)$ in all the $f$ applications of the scheme on $G_i$, $u$ can add $\FTConnLabel_{G_i,T_i}(e)$ to the header of the message. \mtodo{here we use the fact that the extended ids are the same in all $f$ phases (of the same tree)} Assume now that $e$ is a tree edge in $T_i$. The vertex $u$ then adds the label $\FTConnLabel_{G_i,T_i}(e)$ to the header of the message, as $e$ is a tree edge adjacent to $u$ it has this information in its routing table. Finally, it marks the header with the sign $R$, indicating that the message should now be routed in the reverse direction, until arriving $s$ again. This completes the description of phase $\ell$. It is easy to see that the invariant is maintained. If $s$ and $t$ are connected in $G_i \setminus F$, after at most $f$ phases all faulty edges are detected. In the last phase, the path computed based on the labeling information is free from faulty edges, and the routing is completed (in the same manner as in Sec. \ref{sec:routing-known}) at the destination $t$. We next bound the multiplicative stretch of the routing.

%The routing procedure has at most $f+1$ phases. Each phase will start at the source vertex $s$. We will maintain the following invariant in the beginning of each phase $\ell \in \{1,\ldots, f+1\}$: (i) the algorithm has already detected a subset of $\ell-1$ faulty edges $F_\ell \subseteq F$, and (ii) the header contains the labels $L_{route}(e)$ of all the edges $e \in F_\ell$. \mtodo{what happens with edges that are non-tree edges in some of the trees and tree edges in some later trees? Not sure that we learn the relevant information about it, maybe need to find it again?} Each phase $\ell \leq f$ will terminate either at the destination vertex $t$, or at the source vertex $s$. In addition, w.h.p., phase $f+1$ will terminate at $t$. \mtodo{if there is a path to $t$?}  The invariant holds vacuously for phase $1$. 

%We now describe the $\ell^{th}$ phase of the routing procedure given the invariant. The source vertex $s$ considers the $\ell^{th}$ copy of the FT-distance labels, $\FTDistLabel_\ell(w)$ for every $w \in \{s,t\} \cup F_\ell$. 
%By applying the decoding algorithm of Lemma \ref{lem:approx-dist-recovery}, it computes the succinct path $\widehat{P}_\ell$ along with a tree index $(i_\ell,j_\ell)$. The path $\widehat{P}_\ell$ encodes an $s$-$t$ path in $G[V(T_{(i_\ell,j_\ell)})] \setminus F_\ell$.  As in the previous section, the source $s$ augments this path with the tree labels (of Fact \ref{fc:route-trees}) of the vertices on $\mathcal{P}$. The header of the message $H_\ell$ then contains 
%$$H_\ell=\langle \widehat{P}_\ell, (i_\ell,j_\ell), \bigcup_{v \in \widehat{P}_\ell} L_{T_{i_\ell,j_\ell}}(v) \rangle~.$$
%Let $P_\ell$ be the $G$-path encoded by the path $\mathcal{P}_\ell$. The algorithm then routes the message along $P_\ell$ in the same manner as in %Sec. \ref{sec:routing-known}. In the case where $P_{\ell}\cap F=\emptyset$, the phase successfully terminates at the destination vertex $t$. From now on, we consider the case that $P_{\ell}$ contains at least one faulty edge. 

%Let $e=(u,v)$ be the first edge (closest to $s$) on the path $P_\ell$ that belongs to $F$. Since $P_\ell \cap F_\ell=\emptyset$, it holds that $e \in F \setminus F_\ell$. Without loss of generality, assume that $u$ is closer to $s$ on $P_\ell$. Thus the faulty edge $e$ is detected upon arriving to the vertex $u$. 
%In the case where $e$ is a \emph{non-tree edge}, then it must be a $G$-edge on $\widehat{P}_\ell$. Since this path is augmented with the extended ID of its $G$-edges, $u$ can add the extended ID of $e$ to the header of the message.  Assume now that $e$ is a tree edge, i.e., $e \in E_T$.  Specifically, by Lemma \ref{lem:approx-dist-recovery}, $e$ is an edge in the tree $T_{i_\ell,j_\ell}$. The vertex $u$ then adds the label $L_{route}(e)$ \mtodo{if we add the complete label, it makes the headers large} to the header of the message. Finally, it marks the header with the sign $R$, indicating that the message should now be routed in the reverse direction, until arriving $s$ again.  This completes the description of phase $\ell$. It is easy to see that the invariant is maintained, and thus after at most $f$ phases all faulty edges are detected. In the latter case, the path computed based on the labeling information is free from faulty edges, and the routing is completed (in the same manner as in Sec. \ref{sec:routing-known}) at the destination $t$. We next bound the multiplicative stretch of the routing.

\mtodo{updated the stretch analysis.}

\mtext{
\begin{claim}\label{cl:route-length}
Fix a set of faulty edges $F$, and let $s,t$ be vertices that are connected in $G \setminus F$. Then, the message is routed from $s$ to $t$ within $32k (f+1)^2 \cdot \dist_{G \setminus F}(s,t)$ steps, w.h.p.
\end{claim}
\begin{proof}
First note that since each phase and each graph $G_{i}$ uses an independent set of FT-connectivity labels, then in each iteration and each phase the decoding algorithm succeeds w.h.p. and outputs an $s$-$t$ path $\widehat{P}_\ell$ if exists. 

Assume that $\dist_{G \setminus F}(s,t) \in (2^{i-1},2^i]$. Then, $s$ and $t$ are connected in $G_i \setminus F$, as $T_i = T_{i,i^*(t)}$ contains the $2^i$-ball around $t$. We show that the algorithm terminates at $t$ in iteration $i$ or before it, and that in any iteration $j \leq i$, the routing algorithm traverses a path of length at most $2(4k-1)(f+1)^2 \cdot 2^j$.

Let $j \leq i$. In the $\ell$'th phase of iteration $j$, the algorithm first checks if $s$ and $t$ are connected in $G_j \setminus F_{\ell}$, where $F_{\ell}$ is the set of currently detected faults. If the answer is no, the algorithm proceeds to the next iteration. Otherwise, it tries to route a message from $s$ to $t$ on the path encoded by $\widehat{P}_{\ell}$. The length of the path is bounded by $(4k-1)(f+1)\cdot 2^j$ from Lemma \ref{lem:succint_path_routing}. The algorithm either succeeds, or finds a faulty edge on the way in which case it returns to $s$ by traversing the same path on the reverse direction. Overall, the algorithm traverses a path of length at most $2(4k-1)(f+1)\cdot 2^j$, in this phase. In all $f+1$ phases of iteration $j$, the length of the path explored is at most $2(4k-1)(f+1)^2 \cdot 2^j$. Summing over all iterations $j \leq i$, the stretch is bounded by $$\sum_{j=1}^{i} 2(4k-1)(f+1)^2 \cdot 2^j = 2(4k-1)(f+1)^2 \sum_{j=1}^i 2^j \leq 2^{i+2} (4k-1)(f+1)^2 \leq 32k (f+1)^2 \dist_{G \setminus F}(s,t).$$ The last inequality uses the fact that $2^{i-1} \leq \dist_{G \setminus F}(s,t).$ 

In the $i$'th iteration, since $s$ and $t$ are connected in $G_i \setminus F$, then for any $F_{\ell} \subseteq F$, $s$ and $t$ are connected in $G_i \setminus F_{\ell}$, hence the algorithm always finds a path $\widehat{P}_{\ell}$. Hence, it either succeeds in routing the message to $t$ in one of the phases (or one of the previous iterations), or learns about all the failures $F$. In the latter case, in phase $f+1$ it learns about a failure-free path $\widehat{P}_{f+1}$, and the routing terminates at $t$. This completes the proof.
\end{proof}
}

\remove{
\begin{claim}\label{cl:route-length}
Fix a set of faulty edges $F$. Then, the message is routed from $s$ to $t$ within $(16k-4)(f+1) f\cdot \dist_{G \setminus F}(s,t)$ steps, w.h.p.
\end{claim}
\begin{proof}
First note that since each phase and each graph $G_{i}$ uses an independent set of FT-connectivity labels, w.h.p., the decoding algorithm of phase $\ell$ applied on the label set $\{\FTDistLabel(w), w \in \{s,t\} \cup F_\ell\}$ succeeds w.h.p. and outputs an $s$-$t$ path $\widehat{P}_\ell$. 

Let $P_{\ell}$ be the $s$-$t$ path in $G \setminus F_\ell$ encoded by $\widehat{P}_\ell$. By Lemma \ref{lem:approx-dist-recovery}, the length of $P_\ell$ is bounded by $(8k-2)(f+1)\cdot \dist_{G \setminus F_\ell}(s,t)$. Since in phase $\ell$ the message is routed along a (possibly) partial path $P_\ell$ and back to $s$, we have $2|P_\ell|$ routing hops \mtodo{change to capture weighted graphs?} in that phase. Overall, we have at most $2\sum_{i=1} |P_\ell|$ routing hops. Since 
$F_\ell \subseteq F$ for every $\ell$, it holds that $\dist_{G \setminus F_\ell}(s,t)\leq \dist_{G \setminus F}(s,t)$, and consequently $(16k-4)(f+1) f \cdot \dist_{G \setminus F}(s,t)$ routing steps over all. The claim follows. 
\end{proof}
}

To conclude, we have the following.

\begin{theorem}
For every integers $k,f$, there exists an $f$-sensitive compact routing scheme that given a message $M$ the source vertex $s$ and a label $L_{route}(t)$ of the destination $t$, in the presence of at most $f$ faulty edges $F$ (unknown to $s$) routes $M$ from $s$ to $t$ in a distributed manner over a path of length at most $32k (f+1)^2\cdot \dist_{G \setminus F}(s,t)$. 
The global table size is $\widetilde{O}(f \cdot n^{1+1/k} \log{(nW)})$.
The header size of the messages is bounded by $\widetilde{O}(f^2)$ bits, and the label size of vertices is $O(\log{(nW)} \log{n})$. 
\end{theorem}


 %$R_{T}(u)$ for every $T \in \TreeCover_i$ for $i \in \{1,\ldots, \log (nW)\}$. In addition, $u$ stores the $(f,k)$ FT-approximate labels of $u$ and each of its incident edges in $\mathcal{T}$. Let $\dist_{G \setminus F}(s,t) \in (2^i, 2^{i+1}]$ and let $T_{i,j}$ be a tree in $\TreeCover_i$ containing both $s$ and $t$.  Initially the scheme attempts to route the message from $s$ to $t$ using the edges of $T_{i,j}$ alone. Note that indeed all vertices on $T_{i,j}$ contain the routing table $R_{T_{i,j}}$. If none of the faulty edges are on $T_{i,j}$, then we are done as the depth of $T_{i,j}$ is at most $(2k-1) 2^{i+1}$. Now, assume otherwise and let $e_1=(x_1,y_1)$ be the first edge on the $s$-$t$ path on $T_{i,j}$ that belongs to $F$. W.l.o.g. assume that $x_1$ is the vertex that appears first on the $\pi(s,t,T_{i,j})$ path. Since $e_1$ is in $T_{i,j}$ the vertex $x_1$ contains the FT-connectivity label of the edge $e_1$ in $G_{i,j}$. 
%
%Using Lemma \ref{lem:useful-recovery-edges}, the vertex $x_1$ which holds the labels $\FTConnLabel(s), \FTConnLabel(t)$ and $\FTConnLabel(e_1)$ can compute the recovery edge $q_1=(a_1,b_1)$ such that $(T_{i,j} \setminus e_1)\cup \{q_1\}$ is a tree that restores the connectivity of $s$ and $t$ (if possible).  The vertex $x_1$ then adds to the header of the message the identity of $e_1$, the recovery edge $q_1$ and the connectivity label $\FTConnLabel_{G_{i,j}}(e_1)$. The message is then forward to $a_1$ over the tree $T_{i,j}$. If the tree path from $x_1$ to $a_1$ in $T_{i,j}$ does not contain any edge from $F$, then we proceed to routing the message along the recovery edge $q_1$. Otherwise, another faulty edge $e_2=(x_2,y_2) \in F$ is detected. The endpoint $x_2$ then holds the FT-connectivity label of $e_2$, namely, $\FTConnLabel_{G_{i,j}}(e_2)$, and in addition from the header of the message and the label of $t$ is has $\FTConnLabel_{G_{i,j}}(w)$ for $w \in \{e_1,s,t\}$. Thus, it can compute the recovery edges $q'_1$ and $q'_2$. The names of the recovery edges as well as the FT-connectivity label of $e_2$ are added to the header of the message. Note that throughout the process the recovery edges provided at some point are turned out to be faulty as well. In the latter case, we will use the fact that the decoding algorithm of 
%the FT-connectivity scheme only needs the edge labels of $F \cap T_{i,j}$ and the identifiers of the remaining edges in $F \setminus T_{i,j}$.
%This process continues until all the faulty edges are revealed. In this case, at some point, some vertex $w$ holds the FT-connectivity labels of all the faulty edges in $T_{i,j}$ as well as the labels of $s$ and $t$. This allows $w$ to compute the of recovery edges $Q$ that restores the $s$-$t$ connectivity on $T_{i,j}\setminus F$. In addition, the decoding algorithm also outputs a succinct path description that describes the ordering of the $Q$ edges on the tree path in $(T_{i,j}\setminus F) \cup Q$. 


\mtodo{I didn't change the next section, as some of the definitions of routing tables/labels changed, there are probably also changes here.}

\paragraph{Improving the size of the routing tables.} 
So far, we have described a routing scheme that consumes a total space of $\widetilde{O}(f\cdot n^{1+1/k}\log (nW))$ bits, and multiplicative stretch %\footnote{Alternatively, by scaling this can be written as space of $\widetilde{O}(f\cdot n^{1+2/k}\log (nW))$ bits and stretch of $32(f+1)^2 k$.} 
$32(f+1)^2 k$. We now explain the required modifications needed to providing routing tables with $\widetilde{O}(f^2\cdot n^{1/k})$ bits per vertex. The most space consuming information for a vertex $u$ is the connectivity labeling
information of the edges incident to $u$ in each of the trees $T_{i,j} \in \mathcal{T}$. As the degree of $u$ in some of the trees might be $\Theta(n)$, it leads to tables of linear size. To reduce the space of the individual tables, we apply a load balancing idea which distributes the labeling information incident to \emph{high}-degree vertices among their neighbors. 

Instead of storing the labeling information of $e=(u,v)$ at the routing tables of $u$ and $v$, we define 
for every tree $T \in \mathcal{T}$ and an edge $e=(u,v) \in T$, a subset $\Gamma_T(e)$ of vertices that store the connectivity labeling information of $e$ in $T$. We will make sure that the information on some vertex in $\Gamma_T(e)$ can be easily extracted in the routing procedure, and that each vertex stores the information for a small number of edges in each tree. Consider an edge $e=(u,v)$ in a tree $T$, and assume, without loss of generality, that $u$ is the parent of $v$ in the tree $T$. In the case where $\deg(u,T)\leq f+1$, we simply let $\Gamma_T(e)=\{u,v\}$. That is, the label of $e$ is stored by both endpoints of $e$ (as before). The interesting case is where $\deg(u,T)\geq f+2$, in which case, $u$ might not be able to store the label of $e$, and will assist its other children as follows.  Let $Child(u,T)=[v_1,\ldots, v_\ell]$ be the lexicographically ordered list of the children of $u$ in $T$.  The algorithm partitions $Child(u,T)$ into consecutive blocks of size $f+1$ (the last block might have $2f+1$ vertices). Letting $[v_{q,1}, \ldots, v_{q,f+1}] \subseteq Child(u,T)$ be the block containing $v$, define
$$\Gamma_T(e)=\{v_{q,1}, \ldots, v_{q,f+1}\}~.$$
Note that in particular, $v \in \Gamma_T(e)$. Thus, the label of $e$ is stored by $v$ and $\ell \in [f,2f-1]$ additional children on $u$ in $T$. 

We then modify the tree labels from Fact \ref{fc:route-trees} to contain the port information of $\Gamma_T(e)$. 
To do that, we re-define the identifier of an edge $e$ to include the port information of $\Gamma_T(e)$. Thus, the identifier of an edge has $O(f\log n)$ bits. Using Fact \ref{fc:route-trees}, we then have tree labels of $O(f\log n)$ such that given the labels of $u$ and $t$, the algorithm can compute the port information $\Gamma_T(e)$ where $e$ is the edge incident to $u$ on the $u$-$t$ tree path in $T$. We have:
\begin{claim}\label{cl:tree-label-port}


\end{claim}

In addition, we modify the routing tables of each vertex $v$, so that its includes the connectivity labels $\FTConnLabel_{G_{i,j},T_{i,j}}(e)$ for any tree edge $e \in T_{i,j}$ such that $v \in \Gamma_{T_{i,j}}(e)$ for every tree $T_{i,j} \in \mathcal{T}$. This should be compared with the solution of the previous subsection, where $v$'s table contained the information for all its incident edges in $T_{i,j}$. We therefore have:
\begin{claim}\label{cl:route-balance-table}
The size of each routing table $R_{route}(v)$ is bounded by $\widetilde{O}(f K n^{1/k})$ bits.
\end{claim}
\begin{proof}
For every tree $T_{i,j}$ containing $v$, $v$ stores that connectivity label of $\widetilde{O}(f)$ bits of all edges in the set $E(v,T_{i,j})=\{e \in T_{i,j} ~\mid~ v \Gamma_{T_{i,j}}(e)\}$. Note that $|E(v,T_{i,j})|\leq f$ as each vertex stores the label of its parent in the tree, $O(f)$ child edges, and $O(f)$ child edges of its parent in the tree. Since each $v$ participates in $\widetilde{O}(K n^{1/k})$ trees, overall its routing table has $\widetilde{O}(f K n^{1/k})$ bits, as required. 
\end{proof}

It remains to explain the required modifications for the routing procedure. Upon arriving to a vertex $u$ incident to a faulty \emph{tree} edge $e=(u,v)$ the procedure is as follows. The interesting case is where $e$ is a tree edge in some path $\pi(x,y,T_{i,j})$ where $(x,y)$ is an edge in the succinct path $\widehat{P}$ indicated on the header of the message. 
In this case, the tree routing algorithm applied at $u$ is given the tree labels $L_{T_{i,j}}(u)$ and $L_{T_{i,j}}(y)$ and output the port information of $\Gamma_{T_{i,j}}(e)$ for the edge $e=(u,v)$ that lies on the tree path $\pi(u,y, T_{i,j})$. Since there are at most $f$ edge faults, and $\Gamma_{T_{i,j}}(e)$ contains information on at least $f+1$ ports of $u$'s neighbors that contain the label of $e$, the vertex $u$ can access a non-faulty neighbor, say $w$, that has the label information of $e$. That vertex can then add the labeling information of $e$ to the header of the message, and the routing algorithm proceeds as before. 



%%First, we slightly modify the routing labels by applying  $f+1$ independent applications of the $(f,2k)$ FT-distance labeling scheme. That is, we increase the stretch parameter by a factor of $2$ to yield more succinct-distance labels with label size of $\widetilde{O}(n^{1/(2k)}\log(nW))$ bits. As before, we denote the output label obtained by the $i^{th}$ application of the $(f,2k)$ FT-distance labeling scheme by $\FTDistLabel_i(w)$ for every $w \in V(G)\cup E_T$. 
%%We have that $L_{route}(w)=\{\FTDistLabel_1(w),\ldots, \FTDistLabel_{f+1}(w)\}$  has $\widetilde{O}(f n^{1/(2k)}\log (nW))$ bits, for every $w \in V\cup E_T$. The label of a non-tree edge is given by its extended edge identifier, as before. 
%The routing labels are unchanged, and the routing tables are modified as follows. For every tree $T_{i,j}\in \mathcal{T}$ containing $u$ the algorithm computes a table $R_{route,i,j}(u)$ defined as follows. Let $v$ be the parent of $u$ and let $N_{i,j}(v)=[v_1,\ldots, v_\ell]$ be the lexicographically ordered list of the children of $v$ in $T_{i,j}$. 
%The table $R_{route,i,j}(u)$ contains the labels $L_{route}(u)$, $L_{route}((u,v))$, and the edge labels connecting $u$ to its (lexicographically) first $f+1$ children in $T_{i,j}$. In the case where $u$ has at least $f+1$ brothers, i.e., $\ell \geq f+1$, the algorithm stores in $R_{route,i,j}(u)$ the labels of at most $2f$ edges connecting a subset of its brothers to the parent $v$.  The goal of this step is to provide a load balancing over the labels of the edges incident to the parent $v$. To determine this edge set, the list $N_{i,j}(v)$ is partitioned into consecutive blocks of size $f+1$ (the last block might have $2f+1$ vertices). The vertices of the $k$'th block in $N_{i,j}(u)$ will store the $L_{route}(e)$ labels of all the child edges of that block. Letting 
%$[v_{q,1}, \ldots, v_{q,f+1}]$ be the block containing $u$, then $u$ stores the labels $L_{route}(e')$ for every $e' \in \{ (v_{q,1},v), \ldots, (v_{q,f+1},v)\}$. Note that the block size is set to be at least $f+1$, to guarantee that at least one child edge in each block is non-faulty. Overall, $R_{route}(u)=\bigcup_{T_{i,j} \in \mathcal{T} ~\mid~ u \in T_{i,j}} R_{route,i,j}(u)$. 
%%Consider a tree $T_{i,j} \in \mathcal{T}$ and a vertex $u \in T_{i,j}$ with at least $f+1$ children in $T_{i,j}$. The labels $L_{route}(e)$ of its child edges $e$\footnote{I.e., edges connecting $u$ to its children in $T_{i,j}$.} are distributed among the children of $u$ in $T_{i,j}$ as follows. 
%%Let $N_{i,j}(u)=\{v_1,\ldots, v_\ell\}$ be an ordered list of $u$'s children in the tree $T_{i,j}$. The algorithm partitions the neighbor set $N_{i,j}(u)$ into consecutive blocks of size $f+1$ (the last block might have $2f+1$ vertices). The vertices of the $k$'th block in $N_{i,j}(u)$ will store the $L_{route}(e)$ labels of all the child edges of that block. That is, letting $v_{k,1}, \ldots, v_{k,f+1}$ be the vertices of the $k^{th}$ block, then each $v_{k,\ell}$ stores in its routing table the labels $L_{G,f}(e)$ for $e \in \{ (u,v_{k,1}), \ldots, (u,v_{k,f+1})\}$. The block size is set to be at least $f+1$ in order to make sure that at least one child edge in each block is non-faulty. This is done for every tree $T_{i,j} \in \mathcal{T}$. 
%
%The routing algorithm is also slightly modified. Upon arriving to a vertex $v$ incident to a faulty \emph{tree} edge $e=(u,v)$ the procedure is as follows. Let $T_{i,j}$ be the tree on which $e$ belongs. 
%The index of this tree is specified as part of the succinct path $\widehat{P}$ indicated on the header of the message. Then, if $v$ explicitly stores $L_{route}(e)$ the algorithm works as before. That is, $v$ adds this label to the header, and routes the message back to $s$. Otherwise, $v$ has at least $f+1$ children ($u$ is one of them), and it can locally compute the block of (at least) $f+1$ children to which $u$ belongs. It will then route the message to one of the children of that block (at least one of them is connected to $v$ by a non-faulty edge). That child can then add the labeling information of $e$ to the header of the message, and the message will be routed back to $s$. This completes the description of the modified routing scheme.
We now bound the size of each routing table. 
\begin{claim}
The routing table of each vertex has $\widetilde{O}(f^2 n^{2/k} \log (nW))$ bits.
\end{claim}
\begin{proof}
Each vertex appears in $O(k n^{1/k} \log (nW))$ trees in $\mathcal{T}$. For each such tree, it might store the routing labels of at $O(f)$ edges. Since each label $L_{route}(e)$ has $\widetilde{O}(f n^{1/k} \log (nW))$ bits, over all it stores $\widetilde{O}(f^2 \cdot n^{2/k}\log (nW))$ bits. 
\end{proof}
%The routing procedure is slightly adapted as follows. A vertex $u$ uses the FT-approximate distance labels of its incident edge $e$ only in the case where the routing algorithm asked to send message on $e$ but $e \in F$. In such a case, $u$ routes the message to one of its neighbors in $w$'s block which holds the label of the faulty edge $e$. Note that since $u$ might not know the other faulty edges incident to it, it might approach each of its neighbors in the block of $w$. Since the block has size of $f+1$, at least one of these neighbors should have an non-faulty edge to $u$. 
%
%Since our scheme is based on $(f,8fk)$ FT-approximate distance labels, the stretch is increased by a factor of $2$ compared to the stretch bound of Claim \ref{cl:route-length}. 

\mtodo{how is the stretch affected from the process?}

We have:
\begin{theorem}\label{thm:routing-unknown}[Fault-Tolerant Routing]
For every integers $k,f$, there exists an $f$-sensitive compact routing scheme that given a message $M$ at the source vertex $s$ and a destination $t$, in the presence of at most $f$ faulty edges $F$ (unknown to $s$) routes $M$ from $s$ to $t$ in a distributed manner over a path of length at most $32k f^2\cdot \dist_{G \setminus F}(s,t)$. The table size of each vertex is $\widetilde{O}(f^2 \cdot n^{1/k} \log(nW))$. The header size of the messages is bounded by $\widetilde{O}(f^2)$ bits. 
\end{theorem}

\paragraph{Lower Bound.} Finally, we show that the price of not knowing the set of faulty edges $F$ in advance might indeed incur a multiplicative stretch of $\Omega(f)$. 

\begin{theorem}[Stretch Lower-Bound for FT-Routing]\label{thm:lb-routing}
Any FT-routing randomized scheme resilient to $f$ faults induces an expected stretch of $\Omega(f)$ regardless of the size of the routing tables and labels. In particular, this holds even if each routing table contains a complete information on the graph. 
\end{theorem}
\begin{proof}
Consider a graph that consists of $f+1$ vertex disjoint $s$-$t$ paths, each of length $L=\Theta(n/f)$. The last edge of each of the paths, except for one, is faulty. Assume that the non-faulty path is chosen uniformly at random. Since the routing scheme is oblivious to the faulty edges, it can discover a faulty edge only upon sending the message to one of the edge endpoints. The expected length of the routing is given by:
$$\frac{L}{f+1} +2L \cdot \left(1-\frac{1}{f+1} \right)\cdot \frac{1}{f} + \ldots+ \left(f+1\right)L\cdot \prod_{i=0}^{f-1} \left(1-\frac{1}{f+1-i}\right)=\Omega(f L)~.$$ 
Since the $s$-$t$ shortest path under these faults is $L$, the proof follows. See Fig. \ref{fig:LB-stretch} for an illustration.
\end{proof}


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.40]{lb.pdf}
\caption{\sf Illustration for a stretch lower bound for any FT-routing schemes. The $s$-$t$ pair are connected by $f+1$ vertex disjoint paths. Since the faulty-edge is the last edge of the path, the routing requires $\Omega(L)$ steps to discover a single faulty edge. As the non-faulty path is chosen uniformly at random, in expectation, the routing requires $\Omega(fL)$ steps.  \label{fig:LB-stretch}
}
\end{center}
\end{figure}

%\begin{description}
%\item add the entire label of an edge to the ID of the edge
%\item for the routing scheme have f copies, one per number of current knowledge of faulty edges
%\item in the label of $s$ for every scale $i$ keep the index of the tree that contains the entire $2^i$ ball of $s$. 
%\end{description}