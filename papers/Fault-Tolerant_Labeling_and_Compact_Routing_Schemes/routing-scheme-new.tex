\section{Compact Routing Schemes}
In this section, we explain how to use our FT distance labels to provide compact and low stretch routing schemes. This is the first scheme to provide an almost tight tradeoff between the space and the multiplicative stretch, for a constant number of faults $f=O(1)$.  Throughout this section, tree routing operations are performed by using the tree routing scheme of Thorup and Zwick \cite{thorup2001compact}.
\begin{fact}\label{fc:route-trees}[Routing on Trees]\cite{thorup2001compact}
For every $n$-vertex tree $T$, there exists a routing scheme that assigns each vertex $v \in V(T)$ a label $L_T(v)$ of $(1+o(1))\log n$ bits. Given the label of a source vertex
and the label of a destination, it is possible to compute, in constant time, the port number of the edge from the source that heads in the direction of the destination.
\end{fact}

%\textbf{MP: check if needed.} \mtodo{I've added a discussion of the port information later.}
%In our routing scheme, each vertex $u$ is required to compute the port number of the next-hop towards the target destination. Towards that goal, we modify the FT-distance labels of Sec. \ref{sec:ft-distance}, by adding the port information to the extended identifier of the edges. That is, the extended identifier of each edge $e=(u,v)$ is augmented with a third field containing the port number of $v$ w.r.t $u$ and vice-versa. To avoid cumbersome notation, we still refer to this port-augmented FT-distance label of $u$ by $\FTDistLabel(u)$. 

%Let $\mathcal{T}=\bigcup_{i=1}^{K}\TreeCover_i$ be the collection of tree covers with $K=O(\log (nW))$ scales of distances. We call an edge $(u,v)$ a \emph{tree edge} if it appears on at least one of trees in $\mathcal{T}$. Our routing schemes will be based on assigning labeling information for the tree edges. For a non-tree edge, it will be sufficient to obtain the extended ID of the edge that contains $O(\log n)$ bits. As we will see, these IDs would not be stored explicitly in the routing tables.  
%
%For every $i \in [1,K]$ for $K=\lceil \log(nW) \rceil$, let Let $H_i$ be set of heavy edges in $G$ of weight at least $2^i$, and define the $i^{th}$ tree-cover by $\TreeCover_i=\TreeCover(G\setminus H_i,\omega, 2^i,2k)$. 
%Let $\mathcal{T}=\bigcup \TreeCover_i$, and denote the tree edges by $E_T=\bigcup_{T_{i,j} \in \TreeCover_i} E(T_{i,j})$. Note that by Def. \ref{def:tree-cover}, $|E_T|=O(k n^{1+1/(2k)} \log(nW))$. 
%%
%
%\mtodo{Added the part from here. This adds port and tree routing information to the ids, and adapts Lemma \ref{lem:useful-recovery-edges} (finding succinct path description) to the context of routing.}

%\mtext{
We slightly modify the connectivity label of the edges and vertices by augmenting them with routing information. 
First, we augment the extended identifier of an edge (see Eq. (\ref{eq:extend-ID})) with port information and tree routing information, by having:
\begin{equation}\label{eq:edge-extended-routing}
\EID_T(e)=[\UID(e), \ID(u), \ID(v), \LCALabel_T(u), \LCALabel_T(v), \port(u,v), \port(v,u), L_T(u), L_T(v)]~,
\end{equation}
where $\port(u,v)$ is the port number of the edge $(u,v)$ for $u$, and the labels $L_T(u), L_T(v)$ are the tree routing labels taken from Fact \ref{fc:route-trees}. 
We then slightly modify the connectivity label of Eq. (\ref{eq:conn-vertex}) to include also the tree label $L_T(u)$from Fact \ref{fc:route-trees}, by defining 
\begin{equation}\label{eq:conn-vertex-label-routing}
\FTConnLabel_{G,T}(u)=\langle \LCALabel_T(u), \ID(u), L_T(u)\rangle~.
\end{equation}

%
%
%We next discuss a variant of Lemma \ref{lem:useful-recovery-edges} that is useful in the context of routing. 
%We use the following notation. For a vertex $v$, and a tree $T$ where $v \in T$, let $ID_T(v)=(\LCALabel(v),L_T(v))$, where $\LCALabel_T(v)$ is the ancestry label of $v$ in the tree $T$. For an edge $e=(u,v)$ where $u,v \in T$, we define the extended identifier $ID_T(e)$ as follows. $ID_T(e)$ is defined as in Section \ref{sec:ftconn-sketch}, but we also add to it port information and tree routing information. 
%
%
%
%First, we add to the extended identifier $ID_T(e)$ the port number of $v$ w.r.t $u$ and vice-versa. In addition, we add to $ID_T(e)$ the tree routing labels $L_T(u),L_T(v)$ from Fact \ref{fc:route-trees}. Note that the size of the ids is still $O(\log{n})$. 
Throughout this section, when applying the connectivity labels from Section \ref{sec:ftconn-sketch} on a graph $G$ with a spanning tree $T$, we use these modified extended identifiers and labels. This will also be the basis for the application of the distance labels of Section \ref{sec:ft-distance}. 
%First, to support routing, when we apply the connectivity labels from Section \ref{sec:ftconn-sketch} on a graph $G$ with spanning tree $T$, we add to the identifiers $ID(e)$ port information and tree routing information. For each edge $e=(u,v)$, we add to the extended identifier $ID(e)$ the port number of $v$ w.r.t $u$ and vice-versa. In addition, we add to $ID(e)$ the tree routing labels $L_T(u),L_T(v)$ from Fact \ref{fc:route-trees}. Note that the size of the ids is still $O(\log{n})$. We also add to the connectivity label of a vertex $v$, its tree routing label $L_T(v)$. 
Similarly to the distance labels of Section \ref{sec:ft-distance}, we will apply the connectivity labels with respect to the different trees of the tree cover as discussed in Section \ref{sec:ft-distance}. 
Let $T_{i,j} \in \TreeCover_i$, recall that $G_{i,j}=G[V(T_{i,j})]$ and that $\mathcal{T}=\bigcup_{i=1}^K \TreeCover_i$ for $K=O(\log (nW))$. 
%Recall that for a vertex $t$, the graph $G_{i,i^*(t)}$ contains the $2^i$ ball of $t$ in $G$, where $ T_{i,i^*(t)}$ is the corresponding tree from the tree cover that spans $G_{i,i^*(t)}$. We denote $G_i = G_{i,i^*(t)}, T_i = T_{i,i^*(t)}$. Using Lemma \ref{lem:useful-recovery-edges} ,we have the following.

\begin{lemma}\label{lem:succint_path_routing}
Consider a triplet $s,t,F$ such that $s,t,F \in G_{i,j}$. \\
Given the connectivity labels $\{\FTConnLabel_{G_{i,j},T_{i,j}}(w)\}_{w \in F \cup \{s,t\}}$, we can determine w.h.p if $s$ and $t$ are connected in $G_{i,j} \setminus F$. If they are connected, we can output a labeled $s$-$t$ path $\widehat{P}$ of length $O(f)$ that provides a succinct description of the $s$-$t$ path in $G_{i,j} \setminus F$. The edges of $\widehat{P}$ are labeled by $0$ and $1$, where $0$-labeled edges correspond to $G_{i,j}$-edges and $1$-labeled edges $e=(x,y)$ correspond to $x$-$y$ paths in $T_{i,j} \setminus F$. For each $G_{i,j}$-edge, the succinct path description has the port information of the edge, and for each $x-y$ path, the description has the tree routing labels $L_{T_{i,j}}(x),L_{T_{i,j}}(y)$.
The length of the $s$-$t$ path encoded by $\widehat{P}$ is bounded by $(4k-1)(|F|+1)\cdot 2^i$. 
\end{lemma}

\begin{proof}
The proof follows the proof of Lemma \ref{lem:useful-recovery-edges}.
Using $\{\FTConnLabel_{G_{i,j},T_{i,j}}(w)\}_{w \in F \cup \{s,t\}}$, the decoding algorithm of Section \ref{sec:ftconn-sketch} determines if $s$ and $t$ are connected in $G_{i,j} \setminus F$. If they are connected, then from Lemma \ref{lem:useful-recovery-edges}, we get a succinct description of the $s$-$t$ path in $G_{i,j} \setminus F$. We next show that the algorithm indeed has the relevant port and tree routing information. For this note that all the vertices in the path $\widehat{P}$ obtained by Lemma \ref{lem:useful-recovery-edges} are either $s$ and $t$ or endpoints of the $|F|$ recovery edges found in the algorithm. The labels of $s$ and $t$ contain the tree routing information $L_{T_{i,j}}(s)$ and $L_{T_{i,j}}(t)$, and when the algorithm finds a recovery edge, it learns about its extended id $\EID_{T_{i,j}}(e)$ that has the port information and tree routing information of its endpoints. Any $G_{i,j}$-edge in $\widehat{P}$ is a recovery edge, hence the algorithm has its port information, and for any $x$-$y$ path in $T_{i,j} \setminus F$, the algorithm has the tree routing labels $L_{T_{i,j}}(x),L_{T_{i,j}}(y)$, as needed.
The stretch analysis follows the stretch analysis in Section \ref{sec:ft-distance}. It is based on the fact that $\widehat{P}$ has as most $|F|+1$ subpaths in $T_{i,j} \setminus F$, each of length at most $(4k-2)2^i$, and at most $|F|$ recovery edges of weight at most $2^i$.
\end{proof}
%}







\subsection{Forbidden Set Routing (Faulty Edges are Known)}\label{sec:routing-known}
We start by describing the routing scheme in the forbidden set setting, where the faulty edges $F$ are known to the source vertex $s$. We show the following.

\begin{theorem}\label{thm:routing-known}[Forbidden-Set Routing]
For every integers $k,f$, there exists an $f$-sensitive compact routing scheme that given a message $M$ at the source vertex $s$, a label of the destination $t$, and labels of at most $f$ forbidden edges $F$ (known to $s$), routes $M$ from $s$ to $t$ in a distributed manner over a path of length at most $(8k-2)(|F|+1)\cdot \dist_{G \setminus F}(s,t)$. The table size of each vertex is bounded by $\widetilde{O}(n^{1/k} \log{(nW)})$. The header size of the messages is bounded by $\widetilde{O}(f)$ bits. The labels of vertices and edges have size $\widetilde{O}(n^{1/k} \log(nW))$.
\end{theorem}

\begin{proof}
The algorithm is based on the distance labels from Section \ref{sec:ft-distance} using the slightly modified connectivity labels (augmented with port and tree roting information). Recall that the distance labels are based on applying fault-tolerant connectivity labels on different graphs $G_{i,j}$, we use the slightly modified connectivity labels and the corresponding distance labels. 
The routing table of each vertex $u$ consists of its distance label $\FTDistLabel(u)$. The label of an edge $e$ is $\FTDistLabel(e)$. Each distance label has $\widetilde{O}(n^{1/k} \log(n W))$ bits. 

%\mtext{
In the routing algorithm, the vertex $s$ is given the label $\FTDistLabel(t)$, and the labels $\{\FTDistLabel(e)\}_{e \in F}$, and it needs to route a message to $t$ in the graph $G \setminus F$. 
%First, from the distance labels of $s,t$ and $F$, $s$ can check using the algorithm from Section \ref{sec:ft-distance} if $s$ and $t$ are connected in $G \setminus F$, and if so get a succinct description of a path between them.
Recall that the algorithm from Section \ref{sec:ft-distance} works in $K$ phases, where in phase $i$ it checks if $s$ and $t$ are connected in the graph $G_{i,i^*(s)} \setminus F$ that contains the $2^i$-ball around $s$. Let $i$ be the first iteration where $s$ and $t$ are connected in $G_{i,i^*(s)} \setminus F$ according to the algorithm, and denote $G_i = G_{i,i^*(s)},T_i = T_{i,i^*(s)}$, and let $F_i = F \cap G_i$. The algorithm can also give a succinct description of an $s$-$t$ path in $G_i \setminus F_i$ following Lemma \ref{lem:succint_path_routing}. For this, note that we indeed have all the required information. The distance labels of edges in $F$ in particular contain the labels $\{\FTConnLabel_{G_i,T_i}(e)\}_{e \in F_i}$, and we can also tell which edges of $F$ are in $G_i$ from the labels. Also, the labels of $s,t$ contain the information $\ID_{T_i}(s),\ID_{T_i}(t)$ if they are both in $T_i$ (otherwise, they are not connected in level $i$).

The path $\widehat{P}$ as described in Lemma \ref{lem:succint_path_routing} is composed of $O(|F|)$ parts, where segment $(x,y)$ in the path corresponds either to an edge in $G_i$ or to a tree path in $T_i \setminus F$, it also has the relevant port and tree routing information. Our goal is to route a message according to this path. For this we add to the header of the message the description of $\widehat{P}$, the indexes $(i,i^*(s))$ of the tree we explore and an index $1 \leq q \leq 2|F|+1$ that represents the segment of $\widehat{P}$ we currently explore, initially $q=1$. Overall, the header size is $\widetilde{O}(f)$. To route a message according to the path, we work as follows. The header specifies the current segment in $\widehat{P}$. If the current segment corresponds to an edge $(x,y) \in G$, then $x$ uses the port information to route the message to $y$ and increases the index $q$. Otherwise, the current segment represents a tree path $(x,y) \in T_i$ and a vertex $u$ in this path uses its routing label in $T_i$ and the routing label of $y$ in $T_i$ (that is part of the header) to route the message towards $y$. When the message reaches $y$, it increases the index $q$. This completes the description of the routing process. The length of the path described is at most $(8k-2)(|F|+1)\cdot \dist_{G\setminus F}(s,t)$, as shown in Section  \ref{sec:ft-distance}. 
%}
%Given the labels $\{\FTDistLabel(w), w \in \{s,t\} \cup F\}$, the decoding algorithm of Lemma \ref{lem:approx-dist-recovery} computes a succinct description of an $s$-$t$ path in $G \setminus F$ of length $(8k-2)(f+1)\cdot \dist_{G\setminus F}(s,t)$. This description is given by a path $\widehat{P}$ augmented with the index $(i,j)$, such that every non-$G$ edge $e'=(u,v)$ of $\widehat{P}$ corresponds to a $u$-$v$ path in $T_{i,j}\setminus F$. Our routing scheme augments each vertex $v$ on $\widehat{P}$ with its tree label $L_{T_{i,j}}(v)$ from Fact \ref{fc:route-trees}. Overall, this information is encoded in $O(f\log^2 n)$ \mtodo{why $\log^2 n$?} bits which are attached to the header of the message. As each $G$-edge on $\widehat{P}$ is augmented with the port information, and each non-$G$ edge $(u,v)$ is augmented with the tree labels of $u,v$ in $T_{i,j}$, the vertices have the required information to route the message along the $s$-$t$ path encoded by $\widehat{P}$. 
\end{proof}

%We therefore have:
%\begin{enumerate}[noitemsep]
%\item }.
%\item Every non-$G$ edge $e=(u,v)$ corresponds to a tree path $T \in \bigcup_i\TreeCover_i$
%\item The 
%\end{enumerate}


\subsection{Fault-Tolerant Routing (Faulty Edges are Unknown)}\label{sec:route-unknown}
We now consider the more involved setting where the set of failed edges $F$ are unknown to $s$. In this case, an edge $(u,v) \in F$ is detected only when the message arrives, during the routing procedure, to one of the endpoints of $e$. Note that the routing scheme should, by definition, be prepared to any set of faulty edges $F$. However, the space bound of our scheme is required to be bounded by $\widetilde{O}(f n^{1+1/k})$, which is possibly much smaller than the number of graph edges $m$. This in particular implies that we cannot store the FT distance labels of all the graph edges. Nevertheless, we show that it is sufficient to explicitly store the labeling information for the tree edges in $\mathcal{T}=\bigcup_{i=1}^K \TreeCover_i$. The required information for the failed non-tree edges would be revealed throughout the process, by applying the decoding algorithm of Lemma \ref{lem:succint_path_routing}.
Our routing scheme eventually routes the message along the $s$-$t$ path encoded by the FT distance labels of $s,t$ and $F$. However, since the labels of $F$ are unknown in advance, the routing scheme will detect these edges in a trail and error fashion which induces an extra factor of $f$ in the final multiplicative stretch. This extra $f$ factor is also shown to be essential, in the end of the section.
We proceed by describing the routing tables.  
%A routing scheme consists of a two phases algorithm. In the preprocessing phase, each vertex $v$ is assigned
%a routing table $R(v)$ and a label $L(v)$. In the routing phase, a vertex $u$ gets a message with a short header
%$H(M)$ and with a destination label $L(v)$, and based on its own routing table $R(u)$, the destination label $L(v)$
%and the header $H(M)$, it decides to which neighbor $w$ to forward the message. It can also add information to the header of the message. The key objective is to minimize the individual size of each label $L(u)$, routing tables $R(u)$ and the message header $H(M)$. 
%
%\remove{
%\paragraph{The routing tables.} For ease of presentation, we first describe a solution with a multiplicative stretch of $O(kf^2)$, and \emph{global} space of $\widetilde{O}(f K \cdot n^{1+1/k})$, \mtodo{should it be $n^{1+2/k}$?} but the individual tables of some of the vertices might be of linear space. 
%Recall that $\mathcal{T}=\bigcup_i^{K} \TreeCover_i$, for $K=O(\log (nW))$ is a collection of tree covers in all $K=\lceil \log (nW) \rceil$ distance scales, see Eq. (\ref{eq:TC-i}). For every vertex $u$, let $\deg_{\mathcal{T}(u)=\sum_{T_{i,j} \in \mathcal{T}}\deg(u,T_{i,j})$ be the sum of degrees of $u$ in the collection of trees  $\mathcal{T}$.
%The algorithm computes each vertex $u$ a table of $\widetilde{O}(f \cdot \deg_T(u) \cdot n^{1/k})$ bits.
%Since the total number of tree edges in $\mathcal{T}$ is bounded by $\widetilde{O}(K \cdot n^{1+1/k})$, this provides a global space bound of $\widetilde{O}(fK \cdot n^{1+2/k})$ bits. We later on improve the space of each table to $\widetilde{O}(fK \cdot n^{2/k})$ bits. \mtodo{maybe extra $k,K$ are needed in some places.}
%
%The algorithm has at most $K$ phases for each distance scale $2^i$ for $i \in \{1,\ldots, K\}$. 
%Each phase is applied on the tree $T_{i,i^*(t)}$ and has at most $f+1$ iterations. Each iteration uses a 
 %an independent set of randomized FT-distance labels. 
%
%
%The routing process has at most $f+1$ phases, and each phase uses an independent set of randomized FT-distance labels. Therefore, the preprocessing algorithm employs $f$ \mtodo{$f$ or $f+1$?} independent applications of the $(f,(8k-2)(f+1))$ FT-distance labels scheme. Denote the output labels obtained by the $i^{th}$ application by $\FTDistLabel_i(w)$ for every $w \in V(G)\cup E(G)$. Let $E_T=\bigcup_{T_{i,j} \in \mathcal{T}} E(T_{i,j})$ be the collection of tree edges. The \emph{routing label} \mtodo{maybe we want to have shorter labels, and have this information only in the routing tables?} of each $w \in V\cup E_T$ is given by 
%$$L_{route}(w)=\{\FTDistLabel_1(w),\ldots, \FTDistLabel_{f+1}(w)\}~.$$ 
%The routing label $L_{route}(e)$ of a non-tree edge $e \in E \setminus E_T$ is simply the extended identifier of $e$. For each vertex $u$, the routing table $R_{route}(u)$ consists of the following:
%\begin{enumerate}%[noitemsep]
%\item Tree labels $L_{T_{i,j}}(u)$ for every tree $T_{i,j}$ in $\mathcal{T}$ that contains $u$ (from Fact \ref{fc:route-trees}). These labels are augmented with their corresponding tree index $(i,j)$.
%\item The routing labels $L_{route}(u)$ and $\{L_{route}(e=(u,v)) ~\mid~ e \in T_{i,j}, T_{i,j} \in \mathcal{T}\}$.
%\end{enumerate}
%The header information initially contains the succinct path information\footnote{\textbf{MP: This is not essential, we can always make the header contain the labels of the currently detected faults.}} obtained by the decoding algorithm of the FT-distance labeling when given the labels $L_{route}$ of $s$ and $t$. \mtodo{do we want to have $f$ paths? Or only one of them that is relevant for the current phase}  As we will see, throughout the routing procedure, the header information will be augmented with the labels of the currently detected faulty edges. 
%}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{The routing labels and tables.} For ease of presentation, we first describe a solution with a multiplicative stretch of $O(kf^2)$, and \emph{global} space of $\widetilde{O}(f K \cdot n^{1+1/k})$, but the individual tables of some of the vertices might be large. We later on improve the space of each table to $\widetilde{O}(f^3 K \cdot n^{1/k})$ bits.

Recall that $\mathcal{T}=\bigcup_i^{K} \TreeCover_i$, for $K=O(\log (nW))$ is a collection of tree covers in all $K=\lceil \log (nW) \rceil$ distance scales, see Eq. (\ref{eq:TC-i}). For every vertex $v$, let $\deg_{\mathcal{T}}(v)=\sum_{T_{i,j} \in \mathcal{T}}\deg(u,T_{i,j})$ be the sum of degrees of $u$ in the collection of trees  $\mathcal{T}$. Recall that $G_{i,j}=G[V(T_{i,j})]$.
For the routing we apply the FT connectivity labels on the graphs $G_{i,j}$, similarly to Section \ref{sec:ft-distance}. 
\\ \\
\noindent \textbf{Routing labels.} The routing process uses at most $f'=f+1$ independent applications of randomized FT connectivity labels from Section 
\ref{sec:ftconn-sketch}, applied on each one of the graphs $G_{i,j}$. 
In more details, when we apply the labeling scheme on the graph $G_{i,j}$ with spanning tree $T_{i,j}$, we use $f'$ independent random seeds $\mathcal{S}_h$ to determine the randomness of the sketches. 
However, the seed $\mathcal{S}_{ID}$ used to determine the extended ids of edges in $G_{i,j}$ is fixed in the $f'$ applications, hence the extended identifiers of the edges (see Eq. (\ref{eq:extend-ID})) are fixed in all the $f'$ applications, and we only use fresh randomness to compute the sketch information using $f'$ independent seeds $\mathcal{S}^1_h,\ldots, \mathcal{S}^{f'}_h$. 
This process is done independently on each one of the graphs $G_{i,j}$. 

Denote the output connectivity labels obtained by the ${\ell}^{th}$ application of the scheme (using $\mathcal{S}^\ell_h$) on the graph $G_{i,j}$ by $\FTConnLabel^{\ell}_{G_{i,j},T_{i,j}}(w)$ for every $w \in E(G_{i,j})\cup V(G_{i,j})$. For every edge $e \in G_{i,j}$, define its $T_{i,j}$ routing label by
\begin{equation}\label{eq:route-edge-label}
    L_{route,i,j}(e)=
    \begin{cases}
      (\FTConnLabel^1_{G_{i,j},T_{i,j}}(e),\ldots,\FTConnLabel^{f'}_{G_{i,j},T_{i,j}}(e)),& \mbox{~for~} e \in T_{i,j} \\
     \EID_{T_{i,j}}(e),& e \in G_{i,j}\setminus E(T_{i,j})~.
    \end{cases}
\end{equation}
Every $L_{route,i,j}(e)$ label has $O(f \log^3 n)$ bits. 
%Overall, for every edge $e$, the routing label is defined by $L_{route}(e)=\{\langle L_{route,i,j}(e), i,j \rangle ~\mid~ e \in G_{i,j}\}$.\mtodo{I don't think that we use this definition later} Since in each application the labels are of size $O(\log^3{n})$, the total size of each routing label $L_{route}(e)$ \mtodo{here I think it should have the indexes $i,j$, otherwise the size is much larger.} is $O(f \log^3 n)$. 
In our routing algorithms, the $T_{i,j}$ routing labels of the discovered faulty edges will be added to the header for the message in order to guide the routing process. 
We now turn to define the routing labels of vertices. Recall that for a vertex $v$ and index $1 \leq i \leq K$, we denote by $i^*(v)$ an index such that the $2^i$-ball around $v$ is contained in $G_{i,i^*(v)}$.
The routing label $L_{route}(v)$ of $v$ 
For every \emph{vertex} $v$, the routing label of $v$ is given by
\begin{equation}\label{eq:Label-route-vertex}
L_{route}(v) = \{(i^*(v), \FTConnLabel^1_{G_{i,i^*(v)},T_{i,i^*(v)}}(v) | i \in [1,K]\}~.
\end{equation}


Note that by definition, the connectivity labels of the \emph{vertices} are the same in all $f'$ applications of the labeling algorithm, and therefore it is sufficient to include only one of these copies in the label. The size of the label is $O(K\log{n})=O(\log{n} \log{nW})$.
%Note for a non-tree edge $e \in G_{i,j}$, we have that $\FTConnLabel^{\ell}_{G_{i,j},T_{i,j}}(e)=\EID_{T_{i,j}}(e)$, 
%and thus the label $\FTConnLabel^{\ell}_{G_{i,j},T_{i,j}}(e)$ is the same for every $\ell \in \{1,\ldots, f\}$. 
%We will exploit this later in the routing algorithm.
%\remove{
%The routing table $R_{route}(v)$ of a vertex $v$ has the following information for any tree $T_{i,j}$ such that $v \in T_{i,j}$:
%\begin{enumerate}
%\item $\FTConnLabel_{G_{i,j},T_{i,j}}(v)$ \mertodo{Before it was written $(\ID_{T_{i,j}}(v),i,j)$.}
%\item The connectivity labels $\FTConnLabel_{G_{i,j},T_{i,j}}(e)$ for any tree edge $e \in T_{i,j}$ \emph{adjacent} to $v$. 
%\end{enumerate}
%This information is augmented with the tree index $(i,j)$. 
%
%
%\mertodo{Alternatively, we can write:
%The routing table $R_{route}(v)$ of a vertex $v$ has the following information for every tree 
%$T_{i,j}$ such that $v \in T_{i,j}$:
%\begin{equation}\label{eq:route-table-ij}
%R_{route,i,j}(v)=\{\FTConnLabel_{G_{i,j},T_{i,j}}(w), w \in \{v\} \cup E(v,T_{i,j})\}~,
%\end{equation}
%where $E(v,T_{i,j})$ is the set of edges incident to $v$ in the tree $T_{i,j}$. 
%The final routing table is given by $R_{route}(v)=\{R_{route,i,j}(v), (i,j) ~\mid~ T_{i,j} \in \mathcal{T}, v\in T_{i,j}\}$. }
%}
\\ \\
\noindent \textbf{Routing tables.} The routing table $R_{route}(v)$ of a vertex $v$ has the following information for every tree 
$T_{i,j}$ such that $v \in T_{i,j}$:
\begin{equation}\label{eq:route-table-ij}
R_{route,i,j}(v)=\{L_{route,i,j}(e), e \in E(v,T_{i,j})\} \cup \{\FTConnLabel^1_{G_{i,j},T_{i,j}}(v)\}~,
\end{equation}
%\begin{equation}\label{eq:route-table-ij}
%R_{route,i,j}(v)=\{L_{route,i,j}(w), w \in \{v\} \cup E(v,T_{i,j})\}~,
%\end{equation}
%\begin{equation}\label{eq:route-table-ij}
%R_{route,i,j}(v)=\{\FTConnLabel_{G_{i,j},T_{i,j}}(w), w \in \{v\} \cup E(v,T_{i,j})\}~,
%\end{equation}
where $E(v,T_{i,j})$ is the set of edges incident to $v$ in the tree $T_{i,j}$. 
The final routing table is given by $R_{route}(v)=\{R_{route,i,j}(v), (i,j) ~\mid~ T_{i,j} \in \mathcal{T}, v\in T_{i,j}\}$.

Since the connectivity labels are of size $\widetilde{O}(f)$, and as each $v$ appears in $\deg_{\mathcal{T}}(v)$ trees, the size of the table is $\widetilde{O}(f \deg_{\mathcal{T}}(v)).$ Since the total number of tree edges in $\mathcal{T}$ is bounded by $\widetilde{O}(K \cdot n^{1+1/k})$, this provides a global space bound of $\widetilde{O}(fK \cdot n^{1+1/k})$ bits.

%Recall that for a vertex $v$ and index $1 \leq i \leq K$, we denote by $i^*(v)$ an index such that the $2^i$-ball around $v$ is contained in $G_{i,i^*(v)}$.
%The routing \emph{label} $L_{route}(v)$ of $v$ has the id of $v$ in the trees $T_{i,i^*(v)}$.
%\begin{equation}\label{eq:Label-route-vertex}
%L_{route}(v) = \{(i^*(v),\ID_{T_{i,i^*(v)}}(v)) | i \in [1,K]\}~.
%\end{equation}
%\mertodo{Shouldn't it be as below? We should maybe mention that the connectivity label of a vertex is deterministic.} \mtodo{the problem is that the connectivity labels have extra $f$ term in the size (that is not really needed for vertices), we can consider changing the definition of connectivity labels for vertices. Also working directly with ids is currently not enough, as we need the tree routing information.}

\paragraph{The routing algorithm.} In the routing algorithm, the source vertex $s$ initially gets the routing label $L_{route}(t)$ (Eq. (\ref{eq:Label-route-vertex})) of the destination $t$ and its own routing table, $R_{route}(s)$, and its goal is to find the smallest radius graph $G_{i,j}$ such that $s$ and $t$ are connected in $G_{i,j} \setminus F$, and use it for routing. 
As the set $F$ is \emph{not} known in advance, the algorithm works in $K= O(\log{nW})$ phases, where in phase $i$ it tries to route a message in the graph $G_{i,i^*(t)}$ (which contains the entire $2^i$-radius ball of $t$). If $s$ and $t$ are connected in $G_{i,i^*(t)} \setminus F$ the algorithm succeeds, and otherwise we proceed to the next phase, corresponding to the distance scale of $2^{i+1}$. 
We next describe the algorithm for a single phase $i$, we denote $G_i = G_{i,i^*(t)}, T_i = T_{i,i^*(t)}$. Note that $s$ can deduce the index $i^*(t)$ from the routing label of $t$, and it can check if $s \in T_i$ using its routing table. If $s \not \in T_i$, we proceed to the next phase.

If $s \in T_i$, the routing procedure for phase $i$ has at most $|F|+1$ iterations. We maintain the following invariant in the beginning of each iteration $\ell \in \{1,\ldots, |F|+1\}$: (i) the iteration starts at vertex $s$, (ii) the algorithm has already detected a subset of $\ell-1$ faulty edges $F_\ell \subseteq F$, and (iii) the header contains the labels $\FTConnLabel_{G_i,T_i}(e)$ of all the edges $e \in F_\ell$. Each iteration $\ell \leq |F|+1$ terminates either at the destination vertex $t$, or at the source vertex $s$. In addition, w.h.p., if $s$ and $t$ are connected in $G_i \setminus F$, iteration $|F|+1$ terminates at $t$. The invariant holds vacuously for iteration $1$.

We now describe the $\ell^{th}$ iteration (of the $i^{th}$ phase) of the routing procedure given the invariant. The source vertex $s$ considers the $\ell^{th}$ copy of the FT connectivity labels, $\FTConnLabel^{\ell}_{G_i,T_i}(e)$ for every $e\in F_\ell$. 
Using the routing labels of the edges, that are part of the header, the routing label $L_{route}(t)$ (of Eq. (\ref{eq:Label-route-vertex})) and the routing table $R_{route}(s)$, $s$ can apply the decoding algorithm of 
Lemma \ref{lem:succint_path_routing} to determine if $s$ and $t$ are connected in $G_i \setminus F_\ell$. 
If the answer is no, the algorithm proceeds to the next phase $i+1$.
Otherwise, by applying the decoding algorithm of Lemma \ref{lem:succint_path_routing}, it computes the succinct path $\widehat{P}_\ell$. The path $\widehat{P}_\ell$ encodes an $s$-$t$ path in $G_i \setminus F_\ell$, that includes the relevant port and tree routing information of its vertices. The header of the message $H_\ell$ then contains 
$$H_\ell=\langle \widehat{P}_\ell, i, i^*(t), \{L_{route, i, i^*(t)}(e)\}_{e \in F_{\ell}}, q \rangle~,$$ where $q = O(f)$ is an index indicating the current segment of $\widehat{P}_\ell$ we explore. Note that the header $H_\ell$ contains the $f$ copies of connectivity labels of the $F_{\ell}$ edges, and not only the $\ell^{th}$ copy.
The size of the header is $\widetilde{O}(f^2)$, as the description of the path has size $\widetilde{O}(f)$, and additionally we have at most $f$ faulty edges with labels of size $\widetilde{O}(f)$.
%
%\mtodo{in some sense we don't really need to have all this $O(f^2)$ information on the header at once because it's enough that $s$ learns in each phase on one of the labels and then stores it locally, but this I guess doesn't work with the formal definition of routing.}
Let $P_\ell$ be the $G$-path encoded by the path $\mathcal{P}_\ell$. The algorithm then routes the message along $P_\ell$ in the same manner as in Sec. \ref{sec:routing-known}. In the case where $P_{\ell}\cap F=\emptyset$, the iteration successfully terminates at the destination vertex $t$. From now on, we consider the case that $P_{\ell}$ contains at least one faulty edge. 

Let $e=(u,v)$ be the first edge (closest to $s$) on the path $P_\ell$ that belongs to $F$. Since $P_\ell \cap F_\ell=\emptyset$, it holds that $e \in F \setminus F_\ell$. Without loss of generality, assume that $u$ is closer to $s$ on $P_\ell$. Thus the faulty edge $e$ is detected upon arriving to the vertex $u$. 
In the case where $e$ is a \emph{non-tree edge}, then it must be a $G$-edge on $\widehat{P}_\ell$. Since this path has the extended ids $\EID_{T_i}(e)$ of its $G$-edges, and since the connectivity label of a non-tree edge $e$ is its extended identifier $\EID_{T_i}(e)$ in all the $f'$ applications of the scheme on $G_i$\footnote{This is because we use the same random seed $\mathcal{S}_{ID}$ in all these applications.}, $u$ can add $L_{route,i,i^*(t)}(e)=\EID_{T_i}(e)$ to the header of the message. Assume now that $e$ is a tree edge in $T_i$. The vertex $u$ then adds the routing label $L_{route,i,i^*(t)}(e)$ to the header of the message, as $e$ is a tree edge adjacent to $u$ it has this information in its routing table. Finally, it marks the header with the sign $R$, indicating that the message should now be routed in the reverse direction, until arriving $s$ again. This completes the description of iteration $\ell$. It is easy to see that the invariant is maintained. If $s$ and $t$ are connected in $G_i \setminus F$, after at most $f$ iterations all faulty edges are detected. In the last iteration, the path computed based on the labeling information is free from faulty edges, and the routing is completed (in the same manner as in Sec. \ref{sec:routing-known}) at the destination $t$. We next bound the multiplicative stretch of the routing.

%The routing procedure has at most $f+1$ phases. Each phase will start at the source vertex $s$. We will maintain the following invariant in the beginning of each phase $\ell \in \{1,\ldots, f+1\}$: (i) the algorithm has already detected a subset of $\ell-1$ faulty edges $F_\ell \subseteq F$, and (ii) the header contains the labels $L_{route}(e)$ of all the edges $e \in F_\ell$. \mtodo{what happens with edges that are non-tree edges in some of the trees and tree edges in some later trees? Not sure that we learn the relevant information about it, maybe need to find it again?} Each phase $\ell \leq f$ will terminate either at the destination vertex $t$, or at the source vertex $s$. In addition, w.h.p., phase $f+1$ will terminate at $t$. \mtodo{if there is a path to $t$?}  The invariant holds vacuously for phase $1$. 

%We now describe the $\ell^{th}$ phase of the routing procedure given the invariant. The source vertex $s$ considers the $\ell^{th}$ copy of the FT-distance labels, $\FTDistLabel_\ell(w)$ for every $w \in \{s,t\} \cup F_\ell$. 
%By applying the decoding algorithm of Lemma \ref{lem:approx-dist-recovery}, it computes the succinct path $\widehat{P}_\ell$ along with a tree index $(i_\ell,j_\ell)$. The path $\widehat{P}_\ell$ encodes an $s$-$t$ path in $G[V(T_{(i_\ell,j_\ell)})] \setminus F_\ell$.  As in the previous section, the source $s$ augments this path with the tree labels (of Fact \ref{fc:route-trees}) of the vertices on $\mathcal{P}$. The header of the message $H_\ell$ then contains 
%$$H_\ell=\langle \widehat{P}_\ell, (i_\ell,j_\ell), \bigcup_{v \in \widehat{P}_\ell} L_{T_{i_\ell,j_\ell}}(v) \rangle~.$$
%Let $P_\ell$ be the $G$-path encoded by the path $\mathcal{P}_\ell$. The algorithm then routes the message along $P_\ell$ in the same manner as in %Sec. \ref{sec:routing-known}. In the case where $P_{\ell}\cap F=\emptyset$, the phase successfully terminates at the destination vertex $t$. From now on, we consider the case that $P_{\ell}$ contains at least one faulty edge. 

%Let $e=(u,v)$ be the first edge (closest to $s$) on the path $P_\ell$ that belongs to $F$. Since $P_\ell \cap F_\ell=\emptyset$, it holds that $e \in F \setminus F_\ell$. Without loss of generality, assume that $u$ is closer to $s$ on $P_\ell$. Thus the faulty edge $e$ is detected upon arriving to the vertex $u$. 
%In the case where $e$ is a \emph{non-tree edge}, then it must be a $G$-edge on $\widehat{P}_\ell$. Since this path is augmented with the extended ID of its $G$-edges, $u$ can add the extended ID of $e$ to the header of the message.  Assume now that $e$ is a tree edge, i.e., $e \in E_T$.  Specifically, by Lemma \ref{lem:approx-dist-recovery}, $e$ is an edge in the tree $T_{i_\ell,j_\ell}$. The vertex $u$ then adds the label $L_{route}(e)$ \mtodo{if we add the complete label, it makes the headers large} to the header of the message. Finally, it marks the header with the sign $R$, indicating that the message should now be routed in the reverse direction, until arriving $s$ again.  This completes the description of phase $\ell$. It is easy to see that the invariant is maintained, and thus after at most $f$ phases all faulty edges are detected. In the latter case, the path computed based on the labeling information is free from faulty edges, and the routing is completed (in the same manner as in Sec. \ref{sec:routing-known}) at the destination $t$. We next bound the multiplicative stretch of the routing.

%\mertodo{We might want to update the stretch to depend on $|F|$ (actual number of faults) rather than on $f$. Even more specifically, it depends on $|F_T|$. We can mention it maybe later.}
\begin{claim}\label{cl:route-length}
Fix a set of faulty edges $F$, and let $s,t$ be vertices that are connected in $G \setminus F$. Then, the message is routed from $s$ to $t$ within $32k (|F|+1)^2 \cdot \dist_{G \setminus F}(s,t)$ steps, w.h.p.
\end{claim}
\begin{proof}
First note that since each iteration and each graph $G_{i}$ uses an independent set of FT connectivity labels, then in each phase and each iteration the decoding algorithm succeeds w.h.p. and outputs an $s$-$t$ path $\widehat{P}_\ell$ if exists. 

Assume that $\dist_{G \setminus F}(s,t) \in (2^{i-1},2^i]$. Then, $s$ and $t$ are connected in $G_i \setminus F$, as $T_i = T_{i,i^*(t)}$ contains the $2^i$-ball around $t$. We show that the algorithm terminates at $t$ in phase $i$ or before it, and that in any phase $j \leq i$, the routing algorithm traverses a path of length at most $2(4k-1)(|F|+1)^2 \cdot 2^j$.

Let $j \leq i$. In the $\ell$'th iteration of phase $j$, the algorithm first checks if $s$ and $t$ are connected in $G_j \setminus F_{\ell}$, where $F_{\ell}$ is the set of currently detected faults. If the answer is no, the algorithm proceeds to the next phase. Otherwise, it tries to route a message from $s$ to $t$ on the path encoded by $\widehat{P}_{\ell}$. The length of the path is bounded by $(4k-1)(|F|+1)\cdot 2^j$ from Lemma \ref{lem:succint_path_routing}. The algorithm either succeeds, or finds a faulty edge on the way in which case it returns to $s$ by traversing the same path on the reverse direction. Overall, the algorithm traverses a path of length at most $2(4k-1)(|F|+1)\cdot 2^j$, in this iteration. In all $|F|+1$ iterations of phase $j$, the length of the path explored is at most $2(4k-1)(|F|+1)^2 \cdot 2^j$. Summing over all iterations $j \leq i$, the stretch is bounded by $$\sum_{j=1}^{i} 2(4k-1)(|F|+1)^2 \cdot 2^j = 2(4k-1)(|F|+1)^2 \sum_{j=1}^i 2^j \leq 2^{i+2} (4k-1)(|F|+1)^2 \leq 32k (|F|+1)^2 \dist_{G \setminus F}(s,t).$$ The last inequality uses the fact that $2^{i-1} \leq \dist_{G \setminus F}(s,t).$ 

In the $i$'th phase, since $s$ and $t$ are connected in $G_i \setminus F$, then for any $F_{\ell} \subseteq F$, $s$ and $t$ are connected in $G_i \setminus F_{\ell}$, hence the algorithm always finds a path $\widehat{P}_{\ell}$. Hence, it either succeeds in routing the message to $t$ in one of the iterations (or one of the previous phases), or learns about all the failures $F$. In the latter case, in iteration $|F|+1$ it learns about a failure-free path $\widehat{P}_{|F|+1}$, and the routing terminates at $t$. This completes the proof.
\end{proof}
To conclude, we have the following.

\begin{theorem}
For every integers $k,f$, there exists an $f$-FT compact routing scheme that given a message $M$ at the source vertex $s$ and a label $L_{route}(t)$ of the destination $t$, in the presence of at most $f$ faulty edges $F$ (unknown to $s$) routes $M$ from $s$ to $t$ in a distributed manner over a path of length at most $32k (|F|+1)^2\cdot \dist_{G \setminus F}(s,t)$. 
The global table size is $\widetilde{O}(f \cdot n^{1+1/k} \log{(nW)})$.
The header size of the messages is bounded by $\widetilde{O}(f^2)$ bits, and the label size of vertices is $O(\log{(nW)} \log{n})$. 
\end{theorem}


 %$R_{T}(u)$ for every $T \in \TreeCover_i$ for $i \in \{1,\ldots, \log (nW)\}$. In addition, $u$ stores the $(f,k)$ FT-approximate labels of $u$ and each of its incident edges in $\mathcal{T}$. Let $\dist_{G \setminus F}(s,t) \in (2^i, 2^{i+1}]$ and let $T_{i,j}$ be a tree in $\TreeCover_i$ containing both $s$ and $t$.  Initially the scheme attempts to route the message from $s$ to $t$ using the edges of $T_{i,j}$ alone. Note that indeed all vertices on $T_{i,j}$ contain the routing table $R_{T_{i,j}}$. If none of the faulty edges are on $T_{i,j}$, then we are done as the depth of $T_{i,j}$ is at most $(2k-1) 2^{i+1}$. Now, assume otherwise and let $e_1=(x_1,y_1)$ be the first edge on the $s$-$t$ path on $T_{i,j}$ that belongs to $F$. W.l.o.g. assume that $x_1$ is the vertex that appears first on the $\pi(s,t,T_{i,j})$ path. Since $e_1$ is in $T_{i,j}$ the vertex $x_1$ contains the FT-connectivity label of the edge $e_1$ in $G_{i,j}$. 
%
%Using Lemma \ref{lem:useful-recovery-edges}, the vertex $x_1$ which holds the labels $\FTConnLabel(s), \FTConnLabel(t)$ and $\FTConnLabel(e_1)$ can compute the recovery edge $q_1=(a_1,b_1)$ such that $(T_{i,j} \setminus e_1)\cup \{q_1\}$ is a tree that restores the connectivity of $s$ and $t$ (if possible).  The vertex $x_1$ then adds to the header of the message the identity of $e_1$, the recovery edge $q_1$ and the connectivity label $\FTConnLabel_{G_{i,j}}(e_1)$. The message is then forward to $a_1$ over the tree $T_{i,j}$. If the tree path from $x_1$ to $a_1$ in $T_{i,j}$ does not contain any edge from $F$, then we proceed to routing the message along the recovery edge $q_1$. Otherwise, another faulty edge $e_2=(x_2,y_2) \in F$ is detected. The endpoint $x_2$ then holds the FT-connectivity label of $e_2$, namely, $\FTConnLabel_{G_{i,j}}(e_2)$, and in addition from the header of the message and the label of $t$ is has $\FTConnLabel_{G_{i,j}}(w)$ for $w \in \{e_1,s,t\}$. Thus, it can compute the recovery edges $q'_1$ and $q'_2$. The names of the recovery edges as well as the FT-connectivity label of $e_2$ are added to the header of the message. Note that throughout the process the recovery edges provided at some point are turned out to be faulty as well. In the latter case, we will use the fact that the decoding algorithm of 
%the FT-connectivity scheme only needs the edge labels of $F \cap T_{i,j}$ and the identifiers of the remaining edges in $F \setminus T_{i,j}$.
%This process continues until all the faulty edges are revealed. In this case, at some point, some vertex $w$ holds the FT-connectivity labels of all the faulty edges in $T_{i,j}$ as well as the labels of $s$ and $t$. This allows $w$ to compute the of recovery edges $Q$ that restores the $s$-$t$ connectivity on $T_{i,j}\setminus F$. In addition, the decoding algorithm also outputs a succinct path description that describes the ordering of the $Q$ edges on the tree path in $(T_{i,j}\setminus F) \cup Q$. 


\paragraph{Improving the size of the routing tables.} 
So far, we have described a routing scheme that consumes a total space of $\widetilde{O}(f\cdot n^{1+1/k}\log (nW))$ bits, and multiplicative stretch %\footnote{Alternatively, by scaling this can be written as space of $\widetilde{O}(f\cdot n^{1+2/k}\log (nW))$ bits and stretch of $32(f+1)^2 k$.} 
$32(|F|+1)^2 k$. We now explain the required modifications needed to providing routing tables with $\widetilde{O}(f^3\cdot n^{1/k})$ bits per vertex. The most space consuming information for a vertex $u$ is the connectivity labeling
information of the edges incident to $u$ in each of the trees $T_{i,j} \in \mathcal{T}$. As the degree of $u$ in some of the trees might be $\Theta(n)$, it leads to tables of possible super-linear size. To reduce the space of the individual tables, we apply a load balancing idea which distributes the labeling information incident to \emph{high}-degree vertices among their neighbors. 

Instead of storing the labeling information of $e=(u,v)$ at the routing tables of $u$ and $v$, we define 
for every tree $T \in \mathcal{T}$ and an edge $e=(u,v) \in T$, a subset $\Gamma_T(e)$ of vertices that store the connectivity labeling information of $e$ in $T$. We will make sure that the information on some vertex in $\Gamma_T(e)$ can be easily extracted in the routing procedure upon arriving one of its endpoints. In addition, we will make sure that each vertex stores the information only for a small number of edges in each of its trees. Consider an edge $e=(u,v)$ in a tree $T$, and assume, without loss of generality, that $u$ is the parent of $v$ in the tree $T$. In the case where $\deg(u,T)\leq f+1$, we simply let $\Gamma_T(e)=\{u,v\}$. That is, the label of $e$ is stored by both endpoints of $e$ (as before). The interesting case is where $\deg(u,T)\geq f+2$, in which case, $u$ might not be able to store the label of $e$, and will be assisted by its other children as follows.  Let $Child(u,T)=[v_1,\ldots, v_\ell]$ be the lexicographically ordered list of the children of $u$ in $T$.  The algorithm partitions $Child(u,T)$ into consecutive blocks of size $f+1$ (the last block might have $2f+1$ vertices). Letting $[v_{q,1}, \ldots, v_{q,f+1}] \subseteq Child(u,T)$ be the block containing $v$, define
$$\Gamma_T(e)=\{v_{q,1}, \ldots, v_{q,f+1}\}~.$$
Note that in particular, $v \in \Gamma_T(e)$. Thus, the label of $e$ is stored by $v$ and $\ell \in [f,2f-1]$ additional children of $u$ in $T$. 

We then modify the tree labels from Fact \ref{fc:route-trees} to contain the port information of $\Gamma_T(e)$. 
%To do that, we re-define the identifier of an edge $e$ \mtodo{I think it should only affect the tree labels (of vertices)} to include the port information of $\Gamma_T(e)$. Thus, the identifier of an edge has $O(f\log n)$ bits.
In order to do that, we will be using the more relaxed variant of Fact \ref{fc:route-trees}, we have:
\begin{claim}\label{cl:route-trees-port}
For every $n$-vertex tree $T$, there exists a (deterministic) routing scheme that assigns each vertex $v \in V(T)$ a label $L_T(v)$ of $O(f\log^2 n)$ bits and table $R_T(v)$ of $O(f\log n)$ bits. Given the label $L_T(t)$ of the target $t$  
and the routing table $R_T(u)$, the vertex $u$ can compute in $\widetilde{O}(f)$ time: (i) the port number of the edge $e=(u,v)$ on its tree path to $t$, and (ii) the port numbers of the neighbors of $u$ in the set $\Gamma_T(e=(u,v))$. 
\end{claim}
\begin{proof}
The proof follows by slightly modifying the simpler scheme of Fact \ref{fc:route-trees} by \cite{thorup2001compact}. Specifically, we will be using the routing scheme based on heavy-light tree decomposition. This scheme assigns each vertex $v$ labels of $O(\log^2 n)$ bits that contain the port information of the at most $O(\log n)$ light edges on the root to $v$ path in $T$.  The vertices are enumerated in DFS ordering, and the label of each vertex  contains its DFS range, and the specification of all light edges on its path in $T$ from the root, along with a port information of these edges.  The routing table of $v$ stores its DFS range, the port number of the (unique) heavy child of $v$ and also the port to its parent. In our modification, we augment the label of each vertex $u$ with the port information of $\Gamma_T(e')$ for every light edge $e'$ appearing on the root to $u$ path in $T$. Since there are $O(\log n)$ such light edges, the total label information is encoded in $O(f\log^2 n)$ bits. The routing table $R_T(u)$ is augmented with the port information for the set $\Gamma_T(e'')$, where $e''$ is the (unique) heavy child of $u$.  The routing scheme is then exactly as described at \cite{thorup2001compact}, only that in addition to the port of the next-hop $e=(u,v)$, we also obtain the port information of $\Gamma_T(e)$. This increases the labels and tables in the scheme of \cite{thorup2001compact} by a factor of $O(f)$, the claim follows.  
%\mertodo{We can also make sure that $u$ always stores the label of its heavy child, and this will keep the routing tables bounded by $O(\log n)$ bits. Not sure if it worth the effort. Probably mention it in a footnote.}
\end{proof}

Since the modified claim of tree routing defines now both tree routing labels and tables, we employ the following modifications. The extended identifier $\EID_T(e)$ of an edge $e=(u,v)$ from Eq. (\ref{eq:edge-extended-routing})
contains the modified tree labels and thus has $O(f\log^2 n)$ bits.
 %is augmented also with the routing table $R_T(u)$ and $R_T(v)$ of its endpoints \mtodo{I don't think we need to add the routing tables to the ids of edges, just the labels as before (that are now longer). But we do need to add the routing tables to the routing tables of vertices for the tree routing to work.}. Thus, it has now $O(f\log^2 n)$ bits of information. In addition, the connectivity label of vertex $v$ from Eq. (\ref{eq:conn-vertex-label-routing}) is also augmented with the routing table $R_T(u)$ and consists of $O(f\log^2 n)$ bits as well. 
The \emph{routing labels} of Eq. (\ref{eq:route-edge-label}) are defined in the same manner only using the modified extended edge identifiers. The routing label of each edge has $\widetilde{O}(f^2)$ bits, and routing label of every vertex has $\widetilde{O}(f)$ bits. 
We are now ready to describe the more succinct \emph{routing tables} of each vertex $v$. We modify the definition of Eq. (\ref{eq:route-table-ij}) by letting:
\begin{equation*}\label{eq:route-table-ij-mod}
R_{route,i,j}(v)=\{L_{route,i,j}(e), e \in \Gamma_{T_{i,j}}(e)\} \cup \FTConnLabel^1_{G_{i,j},T_{i,j}}(v) \cup R_{T_{i,j}}(v)~,
\end{equation*}
thus the routing table $R_{route,i,j}(v)$ is augmented the tree routing tables $R_{T_{i,j}}(v)$ of Claim \ref{cl:route-trees-port}. In addition, $R_{route}(v)=\{R_{route,i,j}(v), (i,j) ~\mid~ T_{i,j} \in \mathcal{T}, v\in T_{i,j}\}$ as before.
We therefore have:
\begin{claim}\label{cl:route-balance-table}
The size of each routing table $R_{route}(v)$ is bounded by $\widetilde{O}(f^3 K n^{1/k})$ bits. %\mtodo{I think it should be $f^3$ as connectivity labels now have size $f^2$}
\end{claim}
\begin{proof}
For every tree $T_{i,j}$ containing $v$, $v$ stores the routing labels for the tree $T_{i,j}$ of all edges in the set $E'(v,T_{i,j})=\{e \in T_{i,j} ~\mid~ v \in  \Gamma_{T_{i,j}}(e)\}$. Since each connectivity label of an edge contains the modified tree labels from Fact \ref{cl:route-trees-port}, it has $\widetilde{O}(f)$ bits, and as the routing label for $T_{i,j}$ contains $O(f)$ copies of this label, overall each routing label of an edge has $\widetilde{O}(f^2)$ bits. Observe that $|E'(v,T_{i,j})|=O(f)$ as each vertex stores the label of its parent in the tree, $O(f)$ child edges, and $O(f)$ child edges of its parent in the tree. Since each $v$ participates in $\widetilde{O}(K n^{1/k})$ trees, overall its routing table has $\widetilde{O}(f^3 K n^{1/k})$ bits, as required. 
\end{proof}

It remains to explain the required modifications for the routing procedure over a tree $T_i=T_{i,i^*(t)}$. Upon arriving to a vertex $u$ incident to a faulty \emph{tree} edge $e=(u,v)$ the procedure is as follows. If $e$ is a non-tree edge or if $u$ stores the connectivity label $\FTConnLabel_{G_i,T_i}(e)$\footnote{This covers the cases where $v$ is either a parent of $u$ or else, it is one of the at most $f+1$ children of $u$ in $T_i$.}, then $u$ adds the routing label of the edge to the header, as before. In the remaining case it must hold that $e$ is the edge incident to $u$ on its tree path to some vertex $y$. By using the tree routing scheme of Claim \ref{cl:route-trees-port} we have that given the tree routing labels  $L_{T_{i}}(u)$ and $L_{T_{i}}(y)$, the vertex $u$ can also obtain the port numbers of its $\ell \in [f,2f-1]$ children in $\Gamma_{T_{i}}(e)$ that store the label $\FTConnLabel_{G_i,T_i}(e)$. Since there are at most $f$ edge faults in the network, and $\Gamma_{T_{i,j}}(e)$ contains information on at least $f+1$ ports of $u$'s neighbors that contain the label of $e$, the vertex $u$ can access a non-faulty neighbor, say $w$, that has the label information of $e$. That vertex can then add the labeling information of $e$ to the header of the message, and the routing algorithm proceeds as before. Since we use the modified tree labels of Claim \ref{cl:route-trees-port}, each connectivity label has $\widetilde{O}(f)$ bits, and each routing label of an edge for a tree $T_{i,j}$ has $\widetilde{O}(f^2)$ bits. Since the header stores the routing labels of $O(f)$ edges, it consists of $\widetilde{O}(f^3)$ bits. 


The stretch is still bounded by $32k (|F|+1)^2\cdot \dist_{G \setminus F}(s,t)$, as we next explain. Recall that in the proof of Claim \ref{cl:route-length}, we bounded the length of the path we explore in one iteration of the algorithm of phase $j$ by $2(4k-1)(|F|+1)2^j.$ In the new scheme, when we discover a faulty edge, the vertex $u$ may send messages to $|F|+1$ neighbors until it finds the label of the edge. This adds at most $2(|F|+1)2^j$ to the stretch, as the weight of edges in the tree of phase $j$ is at most $2^j$, and we may send messages in both directions. This gives that the length of the path we explore in one iteration is now at most $2(4k-1)(|F|+1)2^j+2(|F|+1)2^j=8k(|F|+1)2^j.$ The rest of the analysis proceeds as in the proof of Claim \ref{cl:route-length}, and gives that the stretch is bounded by $32k (|F|+1)^2\cdot \dist_{G \setminus F}(s,t)$ (we get the same bound as in the original proof we bounded $2(4k-1)$ with $8k$ during the analysis).
We therefore have:
\begin{theorem}\label{thm:routing-unknown}[Fault-Tolerant Routing]
For every integers $k,f$, there exists an $f$-sensitive compact routing scheme that given a message $M$ at the source vertex $s$ and a label $L_{route}(t)$ of the destination $t$, in the presence of at most $f$ faulty edges $F$ (unknown to $s$) routes $M$ from $s$ to $t$ in a distributed manner over a path of length at most $32k (|F|+1)^2\cdot \dist_{G \setminus F}(s,t)$. The routing labels have $\widetilde{O}(f)$ bits, the table size of each vertex is $\widetilde{O}(f^3 \cdot n^{1/k} \log(nW))$. The header size of the messages is bounded by $\widetilde{O}(f^3)$ bits. 
\end{theorem}


\paragraph{Lower Bound.} Finally, we show that the price of not knowing the set of faulty edges $F$ in advance might indeed incur a multiplicative stretch of $\Omega(f)$. 

\begin{proof}[Proof of Theorem \ref{thm:lb-routing}]
Consider a graph that consists of $f+1$ vertex disjoint $s$-$t$ paths, each of length $L=\Theta(n/f)$. The last edge of each of the paths, except for one, is faulty. Assume that the non-faulty path is chosen uniformly at random. Since the routing scheme is oblivious to the faulty edges, it can discover a faulty edge only upon sending the message to one of the edge endpoints. The expected length of the routing is given by:
$$\frac{L}{f+1} +2L \cdot \left(1-\frac{1}{f+1} \right)\cdot \frac{1}{f} + \ldots+ \left(f+1\right)L\cdot \prod_{i=0}^{f-1} \left(1-\frac{1}{f+1-i}\right)=\Omega(f L)~.$$ 
Since the $s$-$t$ shortest path under these faults is $L$, the proof follows. See Fig. \ref{fig:LB-stretch} for an illustration.
\end{proof}


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.40]{lb.pdf}
\caption{\sf Illustration for a stretch lower bound for any FT routing schemes. The $s$-$t$ pair are connected by $f+1$ vertex disjoint paths of length $L$. Since the faulty-edge is the last edge of the path, the routing requires $\Omega(L)$ steps to discover a single faulty edge. As the non-faulty path is chosen uniformly at random, in expectation, the routing requires $\Omega(fL)$ steps.  \label{fig:LB-stretch}
}
\end{center}
\end{figure}

%\begin{description}
%\item add the entire label of an edge to the ID of the edge
%\item for the routing scheme have f copies, one per number of current knowledge of faulty edges
%\item in the label of $s$ for every scale $i$ keep the index of the tree that contains the entire $2^i$ ball of $s$. 
%\end{description}