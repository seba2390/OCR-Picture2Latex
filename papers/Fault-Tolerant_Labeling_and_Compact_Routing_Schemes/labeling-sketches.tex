\subsection{Connectivity Labels Based on Graph Sketches}\label{sec:ftconn-sketch}

\mtodo{I'm not sure if we want to have the statement of the theorem with respect to a tree. Maybe only have a variant with a tree where it's needed (for the routing)}

In this section, we show the following:
\begin{theorem}
For every undirected $n$-vertex graph $G=(V,E)$ and a spanning tree $T \subseteq G$, a positive integer $f$, there is a randomized $f$-FS connectivity labels $\FTConnLabel_{G,T}: V \cup E \to \{0,1\}^{Q}$ of length $Q=O(\log^3 n)$ bits. 
\textbf{MP: add later the computation time of the scheme and the decoding time.}
\end{theorem}
In Section \ref{sec:label-alg}, we present the labeling algorithm which assigns labels based on the notion of graph sketches. In Section \ref{sec:dec-alg} we present the decoding algorithm that given the label information determines if $s$ and $t$ are connected in $G \setminus F$. When the graph $G$ and the spanning tree $T$ are clear from the context, we may omit it and simply write $\FTConnLabel$. 



\subsubsection{The Labeling Algorithm}\label{sec:label-alg}
Given a graph $G$, let $T$ be an arbitrary rooted tree in $G$ that is used throughout this section.
For any node $u \in V(T)$, let $V_u$ be the subset of nodes in the subtree of $T$ rooted at $u$. The algorithm starts by computing ancestry labels $\LCALabel(u)$ for all nodes $u$ given the tree $T$ using Lemma \ref{anc_labels}. Additionally, we assign to all vertices unique ids $\ID(v)$ between $\{1,...,n \}.$

\paragraph{Extended Edge Identifiers.} Each edge $e$ in $G$ is assigned to a unique identifier $ID_T(e)$ that is made of two parts: a \emph{distinguishing} part $ID_{1,T}(e)$ (that does not depend on $T$) and a \emph{logical part} $ID_{2,T}(e)$ that depends on $T$; each of $O(\log n)$ bits. The distinguishing part $ID_{1,T}(e)$ is defined in a way that guarantees that the XOR of several identifiers does not correspond to a legal identifier of any edge $e \in G$ w.h.p. The logical part $ID_{2,T}(e)$ contains auxiliary information that aids the decoding algorithm. 
The computation of the distinguishing parts $ID_{1,T}(e)$ is based on the notion of $\epsilon$-\emph{bias} sets \cite{naor1993small}. The construction is randomized and guarantees that, w.h.p., the XOR of the $ID_{1,T}$ part of each given subset of edges $S \subseteq E$, for $|S|\geq 2$, is not a legal $ID_{1,T}$ identifier of any edge.
%The algorithm will be able to detect whether a given $O(\log n)$ bits corresponding to an $\XOR(S)$ is a legal ID (in which case, $S$ contains a single edge) or not, w.h.p.
Let $\XOR(S)$ be the bitwise XOR of the extended identifiers of edges in $S$, i.e., $\XOR(S)=\oplus_{e \in S} \ID_T(e)$. In addition, let $\XOR_1(S)=\oplus_{e \in S} \ID_{1,T}(e)$.

\begin{lemma}[Modification of Lemma 2.4 in \cite{GhaffariP16}]
\label{cl:epsbias}
There is an algorithm that creates a collection $\mathcal{I}=\{\ID_1(e_1), \ldots, \ID_1(e_{M})\}$ of $M=\binom{n}{2}$ random identifiers for all possible edges $(u,v)$, each of $O(\log n)$-bits using a seed $\mathcal{S}_{ID}$ of $O(\log^2 n)$ bits. These identifiers are such that for each subset $E' \subseteq E$, where $|E'|\neq 1$, we have $\Pr[\XOR_1(E') \in \mathcal{I}] \leq 1/n^{10}$. In addition, given the identifiers $\ID(u), \ID(v)$ of the edge $e=(u,v)$ endpoints, and the seed $\mathcal{S}_{ID}$, one can determine $\ID_1(e)$ in $\widetilde{O}(1)$ time.
\end{lemma}
\begin{proof}
The lemma is proved in \cite{GhaffariP16}, the only part that is not discussed there is the time to determine $\ID_1(e)$ that follows from \cite{naor1993small}. 
By Theorem 3.1 of \cite{naor1993small}, given the seed $\mathcal{S}_{ID}$ and the edge identifier $e_j=(\ID(u), \ID(v))$, determining the $i^{th}$ bit of $\ID_1(e_{j})$ can be done in $O(\log n)$ time. Thus, determining all $O(\log n)$ bits, takes $O(\log^2 n)$ time. 
\end{proof}
The second part of the identifier $\ID_{2,T}(e)$ is given by $\ID_{2,T}(e)=[\ID(u), \ID(v), \LCALabel_T(u), \LCALabel_T(v)]$. 
The identifiers of $\ID_T(u), \ID_T(v)$ are used in order to verify the validity of the first part of the label $\ID_1(e)$. When the tree $T$ is clear from the context, we might omit it and simply write $\ID(e)$. 

\paragraph{Graph Sketches.}
Graph sketches are a powerful tool to identify outgoing edges \cite{kapron2013dynamic,ahn2012analyzing}. \mtodo{I can add some references later, maybe in the related work section} We start by illustrating the intuition behind them. For a vertex $v$, let $\bSketch(v)$ be the bitwise xor of all IDs of edges adjacent to $v$. If we take a subset of vertices $S$, and define  $\bSketch(S) = \oplus_{v \in S} \bSketch(v)$, we can see that all edges that have both endpoints in $S$ are cancelled, and we are left with the xor of outgoing edges from $S$. If there is only one such edge, we get its id. In the case there are more outgoing edges, we can use sampling to identify one outgoing edge. We next formalize this idea and show how to use it in our labels. 

\paragraph{Forbidden-Set Labels via Graph Sketches.} 
The graph sketches are based on random sub-sampling of the graph edges with logarithmic number of scales, i.e., with probability of $2^{-i}$ for every $i \in \{1,\ldots, m\}$. For our purposes and similarly to \cite{DuanConnectivityArxiv16,DuanConnectivitySODA17}, we use pairwise independent hash functions to decide whether to include edges in sampled sets. Choose $L=c\log n$ 
pairwise independent hash functions $h_1, \ldots, h_{L}:\{0,1\}^{2\log n} \to \{0, \ldots, 2^{\log m}-1\}$, and for each $i \in \{1, \ldots, L\}$ and $j \in [0,\log m]$, define the edge set 
$$E_{i,j} =\{ e \in E ~\mid~ h_i(e) \in [0,2^{\log m-j})\}~.$$ 
Each of these hash functions can be defined using a random seed of logarithmic length \cite{TCS-010}. Thus, a 
random seed $\mathcal{S}_h$ of length $O(L \log n)$ can be used to determine the collection of all these $L$ functions. As observed in \cite{DuanConnectivityArxiv16,GibbKKT15}, pairwise independence is sufficient to guarantee that for any set $E' \subset E$ and any $i$, there exists a $j$ such that with constant probability $\XOR(E' \cap E_{i,j})$ is the name (extended identifier) of one edge in $E'$, for a proof see Lemma 5.2 in  \cite{GibbKKT15}.
\begin{lemma}\label{lem:hitting-pairwise}
For any edge set $E'$ and any $i$, with constant probability there exists a $j$ satisfying that $|E' \cap E_{i,j}|=1$.
\end{lemma}


We also need to be able to tell that a bit string of $\XOR(E' \cap E_{i,j})$ is a legal edge ID or not.
\textbf{MP: all these lemmas and claims can (should) be moved to the subsequent analysis section.}

\begin{lemma}
Given the seed $\mathcal{S}_{ID}$, one can determine in $\widetilde{O}(1)$ time if $\XOR(E' \cap E_{i,j})$ corresponds to a single edge ID in $G$ or not, w.h.p.
\end{lemma}
\begin{proof}
Let $X=\XOR(E' \cap E_{i,j})$. Letting $E''=E' \cap E_{i,j}$, then $X$ can be written as the concatenation of $\XOR_1(E'')$ and $\XOR_2(E'')$. 
Using the seed and $\XOR_2(E'')$, one can test the validity of $\XOR_1(E'')$.
The algorithm detects the case that $|E''| \geq 2$ as follows. First, in the case that $E''$ is a single edge, $\XOR_2(E'')$ should contain legal ids $\ID(u),\ID(v)$. If this is not the case, it follows that $|E''| \neq 1$. If $\XOR_2(E'')$ contains legal ids $\ID(u),\ID(v)$, we use them and the seed $\mathcal{S}_{ID}$ to determine $\ID_1(e)$ for $e = (u,v)$, and we check if $\XOR_1(E'')=\ID_1(e)$. We have two options, either $E'' = \{e\}$ is the single edge $e$, in which case $\XOR_1(E'')=\ID_1(e) \in \mathcal{I}$, and the verification succeeds. Otherwise $|E''| \geq 2$, in which case, from Lemma \ref{cl:epsbias}, $\Pr[\XOR_1(E'') \in \mathcal{I}] \leq 1/n^{10}$, hence w.h.p $\XOR_1(E'') \neq \ID_1(e) \in \mathcal{I}$ and we identify that $|E''| \geq 2$.
%To show that the algorithm detects the case that $|E''|\geq 2$, we should show that w.h.p. 
%$$h(u_1,v_1) \oplus h(u_2,v_2) \neq h(u_1 \oplus u_2, v_1 \oplus v_2)$$ \mtodo{is it enough to show it for 2? I think that if we know what are the %original ids (say the set $\{1,...,n\}$), we can get a simpler proof using Lemma 2.9, I'm not sure if we want this assumption.}
%where $h(u,v)$ is $\ID_1(e)$ for $e=(u,v)$. TBD.
\end{proof}
For each vertex $v$ and indices $i,j$, let $E_{i,j}(v)$ be the edges incident to $v$ in $E_{i,j}$. 
The $i^{th}$ \emph{basic sketch unit} of each node $v$ is then given by:
\begin{equation}
\label{eq:vsketch}
\Sketch_i(v)=[\XOR(E_{i,0}(v)),\ldots,\XOR(E_{i,\log m}(v))].
\end{equation}
The sketch of each node $v$ is defined by a concatenation of $L=\Theta(\log n)$ basic sketch units: 
$$\Sketch(v)=[\Sketch_{1}(v),\Sketch_{2}(v), \ldots\Sketch_{L}(v)]~.$$ 
For every subset of vertices $S$, let 
$\Sketch(S)=\oplus_{v \in S}\Sketch(v).$ 

We are now ready to define the forbidden set \mtodo{fault-tolerant?} connectivity labels of vertices and edges. 
The label of each vertex $u$ is given by:
$$\FTConnLabel_{G,T}(u)=\langle \Sketch(V(T(u))), \Sketch(V), \LCALabel_T(u), \mathcal{S}_{ID}, \mathcal{S}_h\rangle,$$ 
where $\LCALabel_T(u)$ is the ancestry label of $u$ with respect to the tree $T$.
The label $\FTConnLabel_{G,T}(e)$ of each \emph{edge} $e=(u,v)$ is as given by:
%\textbf{MP: Suggestion: we may want to have distinct labels for tree edges and non-tree edges, as below. This facilitate the notation for the routing scheme}
\begin{equation*}
    \FTConnLabel(e)=
    \begin{cases}
      \langle \FTConnLabel_{G,T}(u), \FTConnLabel_{G,T}(v)\rangle ,& \mbox{~for~} e \in T \\
     \langle ID_T(e) \rangle,& \mbox{~Otherwise}.
    \end{cases}
\end{equation*}


\begin{claim}
The label length is $O(\log^3 n)$ bits.
\end{claim}
\begin{proof}
The label size is dominated by the sketching information $\Sketch(V_u)$, which is made of a concatenation of the bitwise XOR of $O(\log n)$ basic sketch units $\Sketch_i(u)$. By Eq. (\ref{eq:vsketch}), each unit has $O(\log^2 n)$ bits, and thus overall, the label has $O(\log^3 n)$ bits.
\end{proof}

\mtodo{I think maybe now we want something slightly different, that given a basic sketch unit, we can find with constant probability an outgoing edge? Also, should add a proof.}

\begin{lemma}\label{lem:sketch-property}
For any subset $S$, given $\Sketch(S)$ one can compute, w.h.p., an outgoing edge $E(S, V \setminus S)$ if such exists. 
\end{lemma}


\subsubsection{The Decoding Algorithm} \label{sec:dec-alg}
We next describe the decoding algorithm where given every triplet $s,t, F \in V \times V \times E^f$ along with their labels, it determines whether $s$ and $t$ are connected in $G\setminus F$, w.h.p. For our decoding algorithm it would actually be sufficient to get as input:
\begin{enumerate}[noitemsep]
\item the connectivity labels of $s,t$, the labels of the faulty tree-edge $F \cap E(T)$, and in addition,
\item the extended identifiers of the faulty non-tree edges $F \setminus T$ (which are part of the labels)\footnote{This property will be important later on for obtaining the compact routing schemes.}. 
\end{enumerate}
The decoding algorithm has four key steps: The first step identifies the at most $f+1$ components $\mathcal{C}_0=\{C_1,\ldots, C_\ell\}$ of $T \setminus F$, as well as the components of $s$ and $t$ in $\mathcal{C}_0$. The second step uses the label information to compute the sketch value $\Sketch(C_i)$ of each component $C_i \in \mathcal{C}_0$. The third step modifies this sketch information into $\Sketch_{G \setminus F}(C_i)$, by subtracting the information related to the faulty edges. The forth and final step uses the sketch information in order to simulate $L=O(\log n)$ steps of the Boruvka algorithm. At the end of these steps, the decoding algorithm identifies the connected components of both $s$ and $t$ in $G \setminus F$. In the case where $s$ and $t$ are indeed connected in $G \setminus F$, the algorithm also outputs a succinct representation of an $s$-$t$ path in $G \setminus F$. This extra information would be used later on by our compact routing scheme. We next describe these steps in details. 

\paragraph{Step 1: Identification of the connected components $\mathcal{C}_0$ in $T \setminus F$.} 
Let $F_T=F \cap T$ be the faulty tree edges and let $F_{NT}=F \setminus F_T$ be the faulty non-tree edges. Let $U=\{s,t\} \cup V(F_T)$.  Each component $C_i$ of $T \setminus F$ will be identified by the maximum vertex ID in $C_i \cap U$. Note that the non-tree faulty edges $F_{NT}$ have no impact on the components of $T \setminus F$ (thus their labels are indeed not needed for that step).
We next show that although we do not have full information about the tree $T$ and the vertices of each connected component, the ancestry labels of $V(F_T)$ give us enough information to identify the connected components of $T \setminus F$. Additionally, given an ancestry label of a vertex $u$, we can identify the connected component of $u$. To obtain this, it is helpful to look at the \emph{component tree} that is obtained by contracting each connected component of $T \setminus F$ to one vertex, as follows. Let $\ell = |F_T|+1.$ The component tree $T_C = (\mathcal{C}_0, E_C)$ is a tree of $\ell$ vertices representing the connected components in $T \setminus F$, and $|F_T|=\ell-1$ edges corresponding to the edges of $F_T$. There is an edge $\{C_i,C_j\} \in E_C$ iff there is an edge $\{u,v\} \in F_T$ where $u \in C_i, v \in C_j$. See Figure \ref{componentTreePic} for an illustration.  We can construct the tree $T_C$ using the ancestry labels of the edges $F_T$. For this we just need to identify for any edge in $F_T$ the set of edges from $F_T$ above it in $T$. Moreover, for a given vertex $v$, its connected component is exactly determined by the set of edges in $F_T$ above it in $T$, which can again be identified using the ancestry labels of $v \cup V(F_T)$. In particular, we can identify the connected components of $s$ and $t$. \mtodo{add the time complexity, we can probably get a faster algorithm if needed.}

\setlength{\intextsep}{0pt}
\begin{figure}[h]
\centering
\setlength{\abovecaptionskip}{-2pt}
\setlength{\belowcaptionskip}{6pt}
\includegraphics[scale=0.55]{componentTree.pdf}
 \caption{Illustration of the component tree where $F=\{e_1,e_2,e_3,e_4\}$. Each connected component of $T \setminus F$ is contracted to one vertex on the right.}
\label{componentTreePic}
\end{figure}
 

\paragraph{Step 2: Computing the sketch values of each component $\mathcal{C}_0$ in $G$.} 
For each component $C_j \in \mathcal{C}_0$ the algorithm computes $\Sketch_G(C_j)$ using the label information of the nodes in $U$.  The basic observation here is the following. Given $S' \subset S$ and $\Sketch(S), \Sketch(S')$, it holds that $\Sketch(S \setminus S')=\Sketch(S) ~\XOR~ \Sketch(S')$. To compute the sketch values, first, we define for each component a temporary value $\Sketch'_G(C_j)$ as follows. Let $v_j$ be the highest vertex in the component $C_j$. For the component of the root $r$, this is $r$. For any other component $C_j$, let $\{C_j,p(C_j)\}$ be the edge connecting $C_j$ to its parent in the component tree. This edge corresponds to an edge $\{v,p(v)\} \in F_T$, where $v$ is the highest vertex in $C_j$. We define $\Sketch'_G(C_j) = \Sketch_G(V_{v_j})$. Note that this value is part of the label of the vertex $v_j$. For any $v_j \neq r$, we have $v_j \in V(F_T)$, and we also learn the identity of $v_j$ when constructing the component tree in Step 1, hence we know $\Sketch'_G(C_j)$. We also know the temporary sketch value of the component of $r$, as $\Sketch_G(V_{r})=\Sketch_G(V)$ is part of the labels of all vertices. We next use the temporary sketch values to compute the sketch values of components using the following claim.

\begin{claim}
Let $C_j$ be a component in $T \setminus F$. If $C_j$ is a leaf in the component tree, we have $\Sketch_G(C_j) = \Sketch'_G(C_j).$ Otherwise, let $D=\{D_1,...,D_t\}$ be the children of $C_j$ in the component tree and let $\Sketch'(D)=\oplus_{1 \leq i \leq t} \Sketch'_G(D_i)$, then $\Sketch_G(C_j) = \Sketch'_G(C_j) \oplus \Sketch'(D).$ 
\end{claim}

\begin{proof}
It holds that $\Sketch_G(C_j) = \oplus_{v \in C_j} \Sketch_G(v)$. By definition, $\Sketch'_G(C_j)=\Sketch_G(V_{v_j}) = \oplus_{v \in V_{v_j}} \Sketch_G(v)$ is the xor of sketches of all vertices in the subtree of $v_j$. As $v_j$ is the highest vertex in $C_j$, if $C_j$ is a leaf component in the component tree, then the vertices in $C_j$ are exactly the vertices in $V_{v_j}$, and the claim follows. Otherwise, the vertices in $C_j$ are all vertices in $V_{v_j}$ that are not contained in any component below $C_j$. Hence, to compute the value $\Sketch_G(C_j)$, we should subtract from $\Sketch_G(V_{v_j})$ the sketch values of vertices in components below $C_j$. Let $D_1,...,D_t$ be the children of $C_j$ in the component tree, and let $u_1,...,u_t$ be the highest vertices in the components $D_1,...,D_t$. Any vertex that is in some component below $C_j$ is in exactly one of the subtrees $V_{u_1},...,V_{u_t}$. Hence the sketch value of vertices in components below $C_j$ equals $\oplus_{1 \leq i \leq t} \Sketch_G(V_{u_i})= \oplus_{1 \leq i \leq t} \Sketch'_G(D_i)=\Sketch'(D)$. To conclude, we get $\Sketch_G(C_j)=\Sketch_G(V_{v_j}) \oplus \Sketch'(D)=\Sketch'_G(C_j) \oplus \Sketch'(D)$, as needed.
\end{proof}

To conclude, from the values $\Sketch'_G(C_j)$, we can easily compute the values $\Sketch_G(C_j)$. The complexity is $\tilde{O}(f)$, as for each component, the sketch $\Sketch'(C_j)$ participates in two computations, and we have at most $O(f)$ components and the sketches have poly-logarithmic size.


\paragraph{Step 3: Computing the sketch values of each component $\mathcal{C}_0$ in $G \setminus F$.} 
For each faulty edge $e \in F$ (both tree and non-tree edges), our goal is to subtract the sketch information of $e$ from the corresponding components of the endpoint of $e$. The step does not require the label information of the edges, and it would be sufficient to know only the seed $\mathcal{S}_h$ that determines the sampling of edges into the sketches, and the extended identifier of the failing edges. 

Using the extended identifier of the faulty edge $e=(u,v)$, one can determine the components in $\mathcal{C}_0$ to which its endpoints belong from the ancestry labels of $u$ and $v$, as explained in Step 1. Using the identifier $\ID(e)$ and the seed $\mathcal{S}_h$, one can determine all the indices of the sketch to which the edge $e$ was sampled. \mtodo{what is the complexity of this? MP: It should be $\widetilde{O}(1)$ using Fact \ref{fc:pairwise}.}
Letting $C_u, C_v$ be the components of $u$ and $v$ in $T \setminus F$, respectively. The values $\Sketch_G(C_u),\Sketch_G(C_v)$ are updated by XORing them with the matrix that contains the identifier $\ID(e)$ in the relevant positions. \mtext{The complexity is poly-logarithmic, as the matrix has poly-logarithmic size.}
From that point on, all sketches of the components $\mathcal{C}_0$ can be treated as sketches that have been computed in $G \setminus F$.  


\paragraph{Step 4: Simulating the Boruvka algorithm.} Finally, our goal is to determine the identifiers of the maximal connected components of $s$ and $t$ of $G \setminus F$. The input to this step is the identifiers of the components $\mathcal{C}_0=\{C_{1}, \ldots, C_k\}$ in $T \setminus F$, along with their sketch information in $G \setminus F$. While the algorithm does not have information on the nodes of each component, it knows the component identifier of each node in $U$. 

The algorithm consists of $L=O(\log n)$ phases of the Boruvka algorithm. Each phase $i \in \{1,\ldots, L\}$ will be given as input a partitioning $\mathcal{C}_i=\{C_{i,1}, \ldots, C_{i,k_i}\}$ of (not necessarily maximal) connected components in $G \setminus F$.
These components are identified by an $O(\log n)$ bit identifier, where for each vertex in $U$, the algorithm receives its unique component identifier in  $\mathcal{C}_i$. In addition, the algorithm receives the sketch information of the components $\mathcal{C}_i$ in $G \setminus F$. The output of the phase is a partitioning $\mathcal{C}_{i+1}$, along with their sketch information in $G \setminus F$ and the identifiers of the components for each node in $U$. A component $C_{i,j} \in \mathcal{C}_i$ is \emph{growable} if it has at least one non-faulty outgoing edge to a node in $V \setminus C_{i,j}$. That is, the component is growable if it is strictly contained in some maximal connected component in $G \setminus F$. Letting $N_i$ denote the number of growable components in $\mathcal{C}_i$, the output partitioning $\mathcal{C}_{i+1}$ of the $i^{th}$ step guarantees that $N_{i+1}\leq N_i /2$ w.h.p. To obtain outgoings edges from the growable components in $\mathcal{C}_i$, the algorithm uses the $i^{th}$ basic-unit sketch $\Sketch_i(C_{i,j})$ of each $C_{i,j} \in \mathcal{C}_i$. By Lemma \ref{lem:sketch-property}, from every growable component in $\mathcal{C}_i$, we get one outgoing edge $e'=(x,y)$ with constant probability. Using the extended edge identifier of $e'$ the algorithm can also detect the component $C_{i,j'}$ to which the second endpoint, say $y$, of $e'$ belongs. Specifically, this is done using the ancestry label of the detected edge $e'$. That label allows us to compute the component of $y$ in the initial partitioning $T \setminus F$, i.e., the component $C_{0,q}$ of $y$ in $\mathcal{C}_0$. Thus $y$ belongs to the unique component $C_{i,j'} \in \mathcal{C}_i$ that contains 
$C_{0,q}$. 


%The algorithm uses the sketch information to compute at least one outgoing edge from each growable component $C_{i,j}$. This is done using the $i^{th}$ block of $K'=O(\log n)$ sketches $\{\Sketch_{(i-1)K+\ell}(C_{i,j}), \ell \in \{1,\ldots, K'\}\}$ to compute an outgoing edge. \mtodo{check indexes, $K$ or $K'$?}

As noted in prior works \cite{ahn2012analyzing,kapron2013dynamic,DuanConnectivityArxiv16}, it is important to use fresh randomness (i.e., independent sketch information) in each of the Boruvka phases. The reason is that the cut query, namely, asking for a cut edge between $S$ and $V \setminus S$, should not be correlated with the randomness of the sketches. Note that indeed the components of $\mathcal{C}_i$ are correlated with the randomness of the first $(i-1)$ basic sketch units of the vertices. Thus, in phase $i$ the algorithm uses the $i^{th}$ basic sketch units of the vertices (which are independent of the other sketch units) to determine the outgoing edges of the components in $\mathcal{C}_i$.

%\begin{claim}\label{cl:balg}
%Given a sketch $\Sketch_i(C_{i,j})$ of a growable compo
%W.h.p given the set of sketches $\{\Sketch_{(i-1)K+\ell}(C_{i,j}), \ell \in \{1,\ldots, K'\}\}$, one can determine an outgoing edge $e=(u,v) \in C_{i,j} \times (V\setminus C_{i,j})$ in time $\widetilde{O}(1)$ if such an edge exists. In addition, one can also compute the component $C_{i,j'}$ such that $v \in C_{i,j'}$ in $\widetilde{O}(1)$ time. 
%\end{claim}
%\begin{proof}
%
%\end{proof}
%By Cl. \ref{cl:balg}, w.h.p. the algorithm computes an outgoing edge from each of the components which leads to a merging of the components. 

The algorithm then computes the updated sketches of the merged components. This is done by xoring over the sketches of the components in $\mathcal{C}_i$ that got merged into a single component in 
$\mathcal{C}_{i+1}$. In expectation, the number of growable components is reduced by factor $2$ in each phase. Thus after $O(\log n)$ phases, the expected number of growable components is at most $1/n^5$, and using Markov inequality, we conclude w.h.p there are no growable components. The final partitioning $\mathcal{C}_L$ corresponds w.h.p to the maximal connected components in $G \setminus F$. The pair $s$ and $t$ are connected in $G \setminus F$ only if the components $C_s,C_t$ of $s,t$ respectively in $T \setminus F$ are connected in the final component decomposition.
\mtodo{add complexity.}

%For simplicity assume first that there is only one failing edge $e=(u,v)$ in $T$. W.l.o.g assume that $v$ is the parent of $u$ in the tree (this can be checked using the LCA labels). The forest $T \setminus \{e\}$ has two components given by $V_u$ and $\bar{V}_u=V \setminus V_u$. The sketch value $\Sketch(V_u)$ and $\Sketch(\bar{V}_u)$ are explicitly stored in the label of $u$ (which is part of $\FTConnLabel(e)$). To update these sketches into sketches in $G \setminus F$ we do as follows. First we cancel the effect of the edge $e$ by using the information stored in $\FTConnLabel(e)$. That is, we add $ID(e)$ to every entry in the sketch $\Sketch(V_u)$ and $\Sketch(\bar{V}_u)$ in which it appears. The cancellation of inter-cluster edges $e' \in F$ is performed in the same manner. 
%
%\begin{description}
%\item add information of LCA to the labels, so that we can detect the LCA label of the edge.
%\item bound the time in which we can tell that the XOR is not a legal edge.
%\end{description}
Finally, we show that the decoding algorithm can be slightly modified to output a compressed encoding of an $s$-$t$ path in $G \setminus F$, using $O(f\log n)$ bits. This encoding is represented by an $s$-$t$ path $\widehat{P}$ that has two type of edges, appearing in an alternate manner on  $\widehat{P}$: $G$-edges and edges $e'=(u,v)$ such that the $u$-$v$ tree path is intact in $T \setminus F$. See Figure \ref{fig:succ-paths}. 
\begin{lemma}\label{lem:useful-recovery-edges}
Consider a triplet $s,t,F$ such that $s$ and $t$ are connected in $G \setminus F$. 
The decoding algorithm can also output a set of at most $f$ recovery edges $Q$ such $(T \setminus F) \cup Q$ is a spanning tree. In addition, it outputs a labeled $s$-$t$ path $\widehat{P}$ of length $O(f)$ that provides a succinct description of the $s$-$t$ path. The edges of $\widehat{P}$ are labeled by $0$ and $1$, where $0$-labeled edges correspond to $G$-edges and $1$-labeled edges $e=(x,y)$ correspond to $x$-$y$ paths in $T \setminus F$. 
\end{lemma}
\begin{proof}
Let $C_s, C_t$ be the components of $s$ and $t$ in the initial partitioning $\mathcal{C}_0$. In Step $4$ of the decoding algorithm, the Boruvka algorithm is simulated up to the point that $C_s$ and $C_t$ are connected. Therefore, the algorithm has computed a path $P$ that connects the components $C_s$ and $C_t$. Each node on that path corresponds to a component in $\mathcal{C}_0$, and each edge corresponds to an outgoing edge (discovered using the sketch information). Since $\mathcal{C}_0$ has at most $f+1$ components, $|P|\leq f+1$. 
Each such edge $e' \in P$ corresponds to an edge in $G$. Let $e_1=(x_1,y_1),\ldots, e_k=(x_k,y_k)$ be the $G$-edges corresponding to the edges of $P$ ordered from $C_s$ to $C_t$. Letting $y_0=s$ and $x_{k+1}=t$, we get that 
$y_i$ and $x_{i+1}$ belong to the same component in $\mathcal{C}_0$, for every $i \in \{0,\ldots, k\}$. 
The labeled path is given by $\widehat{P}=[s, x_1,y_1, x_2, y_2, \ldots y_k,t]$ where the edges $(y_i,x_{i+1})$ are labeled $1$ and the edges $(x_{i}, y_i)$ are labeled $0$. Each $0$-labeled edge is a real edge in $G$, and each $1$-labeled edge $(x_{i}, y_i)$ corresponds to a tree path $\pi(x_i, y_i)$ in $T \setminus F$. 
\end{proof}


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.40]{suc-path.pdf}
\caption{\sf Shown is a tree $T$ with faulty edges $e_1,\ldots, e_4$. The $s$-$t$ path in $G \setminus F$ is represented by the path $\widehat{P}=[s,v_1]\circ (v_1,v_2) \circ [v_2,v_3] \circ (v_3,r) \circ [r,v_4] \circ (v_4, v_5) \circ [v_5,t]$. The recovery edges $(v_1,v_2), (v_3,r)$ and $(v_4, v_5)$ are shown in dashed lines.  \label{fig:succ-paths}
}
\end{center}
\end{figure}