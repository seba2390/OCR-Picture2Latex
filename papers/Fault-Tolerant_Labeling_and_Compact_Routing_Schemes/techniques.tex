\subsection{Our Techniques} \label{sec:techniques}

For our FT labeling schemes, we present two constructions based on different techniques. 
The first construction uses the \emph{cycle-space sampling} technique of Pritchard and Thurimella \cite{pritchard2011fast} to determine if $s$ and $t$ are disconnected by a set of failures $F$. This technique has been applied in the past mainly in the context of computing small cuts in the distributed setting. 
The second construction uses the tool of \emph{linear sketches} by Ahn et al. \cite{ahn2012analyzing} to try to find a path that connects $s$ and $t$ in $G \setminus F$. This scheme is also useful for routing.
%The first one uses the \emph{cycle space sampling} technique to determine if $s$ and $t$ are disconnected by a set of failures $F$. The second one, uses \emph{graph sketches} to try to find a path that connects $s$ and $t$ in $G \setminus F$. 
%Since our second scheme allows to find a path, if exists, it is also useful for routing. 
We next give an overview of the two approaches, and the applications for routing. Throughout, we assume that the graph $G$ is originally connected, otherwise the scheme can be applied to each connected component of $G$, which can be indicated in the label of the vertex.

\paragraph{Connectivity Labels Based on Cycle Space Sampling.} The cycle space sampling technique, introduced by Pritchard and Thurimella \cite{pritchard2011fast}, allows one to detect cuts in a graph by exploiting the interesting connection between cuts and cycles in a graph. This technique was used in \cite{pritchard2011fast} to design distributed algorithms for identifying small cuts in a graph. In more details, the technique is based on the relation between \emph{induced edge cuts} and \emph{binary circulations}, defined as follows. For a subset of vertices $S$, we denote by $\delta(S)$ the set of edges with exactly one endpoint in $S$. An \emph{induced edge cut} is a set of edges of the form $\delta(S)$ for some $S$. A \emph{binary circulation} is a set of edges in which every vertex has an even degree. For example, a cycle is a binary circulation. Note that if $F$ is an induced edge cut, and $\phi$ is a cycle, the number of edges in the intersection $|F \cap \phi|$ is even, as the cycle crosses the cut even number of times. This is also true for any binary circulation $\phi$. The cycle space technique extends this observation and shows that if $\phi$ is a random binary circulation and $F \subseteq E$, then
$$Pr[|F \cap \phi| \ is \ even] = \left\{
                \begin{array}{ll}
                  1,\ if\ F\ is\ an\ induced\ edge\ cut\\
                  1/2,\ otherwise
                \end{array}
              \right. $$ 
Hence, by choosing a \emph{random} binary circulation, one can detect if a set of edges $F$ is an induced edge cut with probability $1/2$.  To increase the success probability, we can choose $b$ random binary circulations. 
Based on these ideas, \cite{pritchard2011fast} showed how to assign the edges of the graph $b$-bit labels with the following property.  See Appendix \ref{sec:cycle_space_overview} for an overview.

\begin{restatable}{lemma}{cycle} \label{cycle_space_lemma}
There is an algorithm that assigns the edges of a graph $G=(V,E)$, $b$-bit labels $\phi(e)$ such that given a subset of edges $F \subseteq E$, we have:
$$Pr[\Moplus_{e \in F} \phi(e) = 0] = \left\{
                \begin{array}{ll}
                  1,\ if\ F\ is\ an\ induced\ edge\ cut\\
                  2^{-b},\ otherwise
                \end{array}
              \right. $$ 
Where $0$ is the all-zero vector. The time complexity for assigning the labels is $O((m+n)b)$.
\end{restatable}

\noindent\textbf{The connectivity labels.} We next explain how to use this technique to build FT connectivity labels. Our goal is to assign labels to the vertices and edges of the graph, such that given the labels of two vertices $s,t$ and a set of failures $F$, we can check if $s$ and $t$ are disconnected by $F$. It is easy to show that $s$ and $t$ are disconnected by $F$ iff there is an \emph{induced edge cut} $F' \subseteq F$ that disconnects $s$ and $t$. While we can use the cycle space labels to check if a subset of edges $F' \subseteq F$ is an induced edge cut, this is still not enough to solve FT connectivity. To do so, we should check if an induced edge cut $F'$ \emph{disconnects} the vertices $s$ and $t$. To check this, we bring to our construction \emph{ancestry labels} in trees, and show that we can determine if $s$ and $t$ are in the same side of cut (induced by $F'$) based on the ancestry labels of $s,t$ and $F'$. The key observation is that a spanning tree $T$ of the graph is disconnected to at most $|F'|+1$ connected components, upon removing $F'$, where for any $e \in F'$ both its endpoints reside on two different sides of the induced edge cut defined by $F'$.
We can use this to identify which components of $T \setminus F'$ are on the same side of the induced edge cut. Moreover, we show that the ancestry labels allow us to determine the connected components of $s$ and $t$ in $T \setminus F'$. A brute-force implementation of this approach leads to a decoding time that is \emph{exponential} in $|F|$. I.e., the algorithm should check for any subset $F' \subseteq F$ if $F'$ is an induced edge cut. To overcome it, we show an efficient way to find $F' \subseteq F$ that disconnects $s$ and $t$ if exists, by translating our problem to a system of linear equations. This results in a decoding time polynomial in $|F|$ and $\log{n}$. The size of the labels is $O(f+\log{n})$, to guarantee that the cycle space labels are correct for any $F' \subseteq F$ w.h.p.      

\paragraph{Connectivity Labels Based on Graph Sketches.} We next provide some flavor of our labels based graph sketches. The length of the labels obtained in this technique is $O(\log^3{n})$ bits, which is dominated by the sketching information. A \emph{graph sketch} of a vertex $v$ is a randomized string of $\widetilde{O}(1)$ bits that compresses $v$'s edges. The linearity of these sketches allows one to infer, given the sketches of subset of vertices $S$, an outgoing cut edge $(S, V \setminus S)$. Graph sketches have numerous applications in the context of connectivity computation under various computational settings, e.g., \cite{kapron2013dynamic,kapralov2014spanners,GibbKKT15,DBLP:conf/podc/KingKT15,DBLP:conf/wdag/MashreghiK18,GhaffariP16,DuanConnectivitySODA17}. More concretely, our sketch-based labels are inspired by the centralized connectivity sensitivity oracles of Duan and Pettie \cite{DuanConnectivitySODA17}.   A common approach for deducing the graph connectivity merely from the sketches of the individual vertices is based on the well-known Boruvka algorithm \cite{Boruvka}. This algorithm works in $O(\log n)$ phases, where in each phase, from each growable component an outgoing edge is selected. All these outgoing
edges are added to the forest, while ignoring cycles. Each such phase reduces the number of
growable components by a $2$ factor, thus within $O(\log n)$ phases, a maximal forest is computed. Since this algorithm only requires the computation of outgoing edges it can simulated using $O(\log n)$ independent sketches for each of the vertices. 

Our high level approach for determining the $s$-$t$ connectivity in $G \setminus F$ mimics this above mentioned procedure. For simplicity assume that $G$ is connected and let $T$ be some spanning tree in $G$. Using ancestry labels, one can infer the components of $T \setminus F$. Moreover, by augmenting the labels with graph sketching information, one can also deduce the sketch of each component in $T \setminus F$. 
Note however that these sketches are in $G$ and therefore might encode outgoing edges that belong to $F$. To overcome this technicality, our sketching scheme allows us to cancel out the effect of the faulty edges $F$ from the sketching information. Consequently, we obtain the sketches of each $T \setminus F$ component in the surviving graph $G \setminus F$. We can then apply the Boruvka's algorithm on the components of $T \setminus F$, and infer the $s$-$t$ connectivity in $G \setminus F$. The actual implementation of this labeling scheme is somewhat more delicate. We note that some of these technicalities are for the sake of our later extension of these labels into compact routing schemes.


%
%
%We use the graph sketches together with the well-known Boruvka algorithm \cite{Boruvka} to identify the connected components of the graph $G \setminus F$. This eventually allows us to check if $s$ and $t$ are connected in $G \setminus F$ based on their components. We start by describing our general approach, and then explain how to simulate it based only on labels of $s,t$ and $F$. Let $T$ be a spanning tree of the graph $G$. If the edges $F$ are removed from $G$, it breaks the tree $T$ to at most $|F|+1$ connected components. To figure out the connected components in $G \setminus F$, we apply Boruvka algorithm on the connected components of $T \setminus F$. In this algorithm, at each iteration we have a set of components, and our goal is to find an outgoing edge from each connected component, and then merge components connected by an edge. To find outgoing edges, we use the sketches of the components. After repeating the process for $O(\log{n})$ iterations, we find the connected components of $G \setminus F$ w.h.p. The vertices $s$ and $t$ are connected in $G \setminus F$ iff they are in the same component. 
%
%
%
%\mertodo{Since graph sketches are well known concept, I would considerably shorten this description. Specifically, we should focus on mentioning the following: 
%A sketch of a vertex is an $L_0$ sampler of its incident edges. By linearity, the sketch summation of a vertex connected subset $S$ is the sketch of the super vertex obtained by contracting the edges in $S \times S$. It is well-known that given the sketch values of all the vertices one can compute the connected components of $G$ by applying Boruvka algorithm. Here we can briefly mention how Boruvka works (as you did). On the high level, our goal is to apply this scheme on the sketch values of the at most $f+1$ connected components in $T \setminus F$. There are several challenges: computing the sketch values of these components in $G$ and updating these sketch information to $G \setminus F$. I think this description should be sufficient, note that also in \cite{DuanConnectivityArxiv16} they did not provide an introduction into the sketching technique, as it is considered to be sufficiently established.} \mtodo{I agree that the description here is too long, maybe the important part to know about sketches at this point is what's written in the first 3 lines, that it allows to identify an outgoing cut edge. Also, as there is currently a (different) motivation paragraph on this topic at the technical section, I think it's ok to just remove this text from the paper. Depending on space, it could be useful in the technical section of the camera-ready version (if there is no place to the whole description of the sketch based labels and we want to replace it with some overview), so let's keep it hidden in the file in case it's needed later.}
%Our second scheme is based on graph sketches, which are a powerful tool used for computing (and maintaining) connectivity in many computational settings. Specifically, given the sketches of a subset of vertices $S$, one can efficiently identify an outgoing cut edge from $S$. 
%Since their introduction in \cite{kapron2013dynamic,ahn2012analyzing}, they have found numerous applications, for example in dynamic and distributed algorithms for connectivity and minimum spanning trees \cite{kapron2013dynamic, DuanConnectivitySODA17,DBLP:conf/podc/KingKT15,DBLP:conf/wdag/MashreghiK18,GhaffariP16}. \mertodo{I already provided part of this list in the result section above Theorem 1.4, lets provide it all there.}

\remove{
\mertodo{This text can be omitted now, see if want to move elsewhere. We start by illustrating the underlying intuition for sketch. For a vertex $v$ and a subset of edges $E' \subseteq E$, let $\Sketch_{E'}(v)$ be the bitwise XOR of all the IDs of $E'$ edges adjacent to $v$.  
For a subset of vertices $S$, define $\Sketch_{E'}(S) = \oplus_{v \in S} \Sketch_{E'}(v)$. The useful property of sketches is that all edges of $E'$ that have both endpoints in $S$ are cancelled, and thus $\Sketch_{E'}(S)$ corresponds to the XOR of the identifiers of the $E'$ edges outgoing from $S$. If there is only one such edge, then
its ID corresponds to the value of $\Sketch_{E'}(S)$. By combining this idea with a basic sampling trick one can 
identify one outgoing edge from any subset $S$. But here we should also require special edge IDs in order to distinguish between an illegal ID, obtained by XORing IDs of several edges, and a true ID of a single edge.
Intuitively, we first define $O(\log{m})$ sets of edges $E_j$, where $E_j$ is obtained from $E$ by sampling each edge with probability $1/2^j$. Next, we define $\Sketch(v) = (\Sketch_{E_0}(v),...,\Sketch_{E_{\log{m}}}(v))$, and $\Sketch(S) = (\Sketch_{E_0}(S),...,\Sketch_{E_{\log{m}}}(S))$. These $O(\log^2{n})$-bit sketch units have the property that given $\Sketch(S)$, with constant probability there is a sketch unit that holds the identifier of exactly one outgoing edge of $S$. In our algorithm, we use $\Theta(\log{n})$ sketch units (each time with different sampled sets $E_j$) to be able to eventually find outgoing edges w.h.p. 
A crucial point in this regard is to be able to distinguish between sketch units that hold the XOR of at least two edge identifiers vs. units that store the identifier of \emph{exactly} one edge (i.e., an outing edge). For that purpose we employ the computation of edge identifiers by \cite{GhaffariP16}, that have the property that the XOR of any two edge identifiers is not a \emph{legal} edge identifier of a single edge. We also show that identification of the legal edge can be done efficiently, with no global information.
 %we can identify with constant probability an outgoing edge from $S$. 
\noindent\textbf{FT Connectivity from graph sketches.} We use the graph sketches together with the well-known Boruvka algorithm \cite{Boruvka} to identify the connected components of the graph $G \setminus F$. This eventually allows us to check if $s$ and $t$ are connected in $G \setminus F$ based on their components. We start by describing our general approach, and then explain how to simulate it based only on labels of $s,t$ and $F$. Let $T$ be a spanning tree of the graph $G$. If the edges $F$ are removed from $G$, it breaks the tree $T$ to at most $|F|+1$ connected components. To figure out the connected components in $G \setminus F$, we apply Boruvka algorithm on the connected components of $T \setminus F$. In this algorithm, at each iteration we have a set of components, and our goal is to find an outgoing edge from each connected component, and then merge components connected by an edge. To find outgoing edges, we use the sketches of the components. After repeating the process for $O(\log{n})$ iterations, we find the connected components of $G \setminus F$ w.h.p. The vertices $s$ and $t$ are connected in $G \setminus F$ iff they are in the same component. 
\noindent\textbf{The connectivity labels.} At a high-level, to simulate the algorithm using only the information provided by the connectivity labels, we include in the labels of vertices and edges ancestry labels in a spanning tree $T$. In addition, for any tree edge $e=\{u,v\} \in T$ we include in its label the sketch information of $T_v$ and $T_u$, as well as the sketch information of $T$, where $T_v,T_u$ are the subtrees of $T$ rooted at $v$ and $u$, respectively. 
We show that this information allows us to identify the connected components in $T \setminus F$, and compute the sketch information of each one of the components. Moreover, the ancestry labels give us an efficient way to identify the connected component of any vertex $v$. This is useful both for identifying the connected components of $s$ and $t$, and to find the connected components of any outgoing edge that the algorithm finds. When we merge components, the sketch information of the new component can be obtained by XORing the sketches of the components we merge. One delicate point in the algorithm is that we originally compute sketches in the original graph $G$, where our algorithm works in the graph $G \setminus F$, and so we need the sketch information in $G \setminus F$. To obtain this, we cancel the information about edges from $F$ in the sketches by XORing their IDs in the relevant places. This can be done efficiently by using pairwise independence hash functions to generate the sketches. 
}
}


\paragraph{Applications for Routing Schemes.} The starting point to our routing scheme is given by our (sketch-based) labeling scheme. These labels allows one to deduce also a succinct description of an $s-t$ path in $G \setminus F$ if exists, by following the component merging procedure of the Boruvka algorithm. This description is composed of $O(f)$ path segments, where each segment $\{u,v\}$ either corresponds to an outgoing (non-tree) edge found in the algorithm using the sketch information, or to a tree path between two vertices $u$ and $v$ in the same connected component in $T \setminus F$. Given the connectivity labels of $s,t$ and $F$, we can find this description, and use it for routing. Routing across an edge $\{u,v\}$ just requires sending a message over the edge, while routing on a tree path between $u$ and $v$ can be done using a routing scheme for trees. 
While this approach allows to send a message from $s$ to $t$, there is no bound on the length of the path traversed. Additionally, this approach assumes that the set of failures $F$ is known in advance. We next explain how to overcome these issues.
\\
\noindent\textbf{Bounding the stretch.} To route messages on low-stretch paths we use the notion of \emph{tree covers}, following the approach in \cite{chechik2012f}. This approach also allows us to translate our connectivity labels to approximate distance labels as we discuss in Section \ref{sec:ft-distance}. Here, instead of applying our connectivity scheme on just one graph $G$, we apply it on many subgraphs $G_{i,j}$ of $G$ with the following properties. 
\begin{enumerate}
\item Each vertex $v$ is contained in $\widetilde{O}(n^{1/k})$ subgraphs.
\item For any $1 \leq i \leq \log(nW)$, and any vertex $v$, there is a subgraph $G_{i,i^*(v)}$ that contains all the vertices in the $2^i$-neighborhood of $v$.
\item If $v$ and $u$ are connected in the graph $G_{i,i^*(v)} \setminus F$, then there is a path between them of length at most $O(k|F| 2^i)$ in the graph $G_{i,i^*(v)} \setminus F$.\label{prop_path}
\end{enumerate}
By applying our connectivity scheme on each one of the subgraphs $G_{i,j}$, we can route a message from $s$ to $t$ on a path of stretch $O(k|F|)$. The size of the labels and routing tables of vertices is $\widetilde{O}(n^{1/k})$ as each vertex and edge participate in $\widetilde{O}(n^{1/k})$ subgraphs.
%
%
 %and have the labels of $s,t$ and $F$ in all these applications, we can route a message from $s$ to $t$ on a path of stretch $O(k|F|)$, as follows. First, we find the smallest $i$ such that $s$ and $t$ are connected in $G_{i,i^*(s)} \setminus F$, and then we route the message from $s$ to $t$ according to the succinct path description provided by the connectivity scheme. We can prove based on property \ref{prop_path} that the stretch of the path is bounded by $O(k|F|)$. The size of the labels and routing tables of vertices is $\widetilde{O}(n^{1/k})$ as each vertex and edge participate in $\widetilde{O}(n^{1/k})$ subgraphs.
\\
\noindent\textbf{Faulty edges are unknown.} The scheme we described assumes that the routing algorithm knows the labels of $s,t$ and $F$ in advance, we next explain how to avoid this assumption. Our general approach is to work in phases, where in each phase we try to route a message from $s$ to $t$ according to the currently set of known faults. We either succeed, or learn about the label of a new faulty edge $e \in F$ and try again. The stretch of the scheme increases to $O(k|F|^2)$ because of the $|F|+1$ phases. Direct application of this approach may require large routing tables, as each vertex may need to know the labels of all edges adjacent to it, to be able to learn the labels of faulty edges found in the algorithm. To overcome it we use the following ingredients. 

First, recall that in our connectivity labeling scheme we use a spanning tree $T$. In the routing scheme, these are the trees of the tree cover. We show that it is enough for each vertex to store labels only of its adjacent \emph{tree} edges. 
%
%\mtext{Towards that goal, our connectivity labeling scheme is designed in a way that assigns distinct forms of labels to tree edges vs. non-tree edges. Specifically, the labels of the non-tree edges contain deterministic information of only $O(\log n)$ bits, that we treat as part of the \emph{extended identifier} of an edge. The labels of tree edges contain the (randomized) sketch information that guides the Boruvka connectivity algorithm. As we mentioned before, the decoding algorithm of the connectivity scheme also outputs the identifiers of the recovery edges that restore the $s$-$t$ connectivity. These recovery edges are non-tree edges, by definition. Thus by using the extended identifier as the edge identifier in the sketch computation, the algorithm obtains the connectivity labels of these edges as well, which are used for the subsequent steps in the routing procedure (e.g., upon detecting additional faulty edges). Over all, our routing scheme \emph{explicitly} stores the labels of the the tree edges (for every tree in the tree cover), and \emph{implicitly} stores the labels of the non-tree edges (hidden in the sketch information of the tree edges).} \mtodo{The part I marked seems too detailed and relies on specific properties of the connectivity labels, we may want to remove or shorten it. Other parts in the routing overview seem good to me.} 
Consequently, the total size of all routing tables can be bounded by $\widetilde{O}(fn^{1+1/k})$.\footnote{The $f$ term in the size comes from the fact we apply the connectivity labels $f+1$ times to support the $|F|+1$ phases.}
However, this alone is not enough to bound the size of individual routing tables of vertices, as the degree of a vertex in a tree may be linear. To overcome this, we show a clever way to load balance the labels' information between $v$ and its children in the tree. This results in tables of size $\widetilde{O}(f^3 n^{1/k})$ per vertex, while keeping the same stretch of the scheme. The increase in the total size of tables comes from the fact we now duplicate labels $f+1$ times, to be able to recover them in the presence of $f$ failures. 