\section{Prioritization and Selection Process}
\label{pas}

The PAS process starts with preprocessing FIS inputs. Preprocessing includes construction of SRL and calculation of impacts for security requirements in the SRL. Subsequently, impacts, costs and technical-abilities will be fuzzified \cite{bede2013fuzzy} to serve as the inputs of the FIS. A Mamdani-type \cite{mamdani1974application} fuzzy inference system then specifies the priorities of security requirements. Prioritization can be performed with special focus on satisfaction of a security goal. Finally, prioritized requirements will be partially selected (when tolerated) through RELAX-ation of their satisfaction conditions. To perform RELAX-ation, we need to obtain Required Degree of Satisfaction (RDS) for each security requirement through deffuzification of priority values. %The RELAX-ed requirements will then be listed in the optimal SRL of the system. In Section 3.1 we introduce data preprocessing activities. Prioritization activities are discussed in Section 3.2 and Section 3.3 explains partial selection of security requirements. 

%\begin{figure*}[!htbp]
%	\centering
%	\centerline{\fbox{\includegraphics[scale=0.7]{figs/code1}}}
%	\caption{Java Implementation of Data Preprocessing }
%	\label{fig_code1}
%\end{figure*}
%\vspace{1em}
%\begin{algorithm*}
%	\small
%	\caption{Computing the strengths of value dependencies}
%	\label{alg_strength}
%%	\begin{multicols}{1}
%		\begin{algorithmic}[1]
%			\STATE \textbf{class} dataPreprocessing $\{$
%			\STATE \quad dataPreprocessing $\{$ \textbackslash\textbackslash constructor
%			\STATE \quad\quad calculateImpact();
%		    \STATE \quad\quad buildRequirementList();
%		    \STATE \quad $\}$
%			\STATE $\}$
%			
%			\STATE \quad dataPreprocessing $\{$ \textbackslash\textbackslash constructor
%			\STATE \quad\quad calculateImpact();
%			\STATE \quad\quad buildRequirementList();
%			\STATE \quad $\}$
%			
%			\ENSURE $\rho^{+\infty}, \rho^{-\infty}$
%			\FOR{\textbf{each} $r_i \in R$}
%			\FOR{\textbf{each} $r_j \in R$}
%			\STATE $\rho_{i,j}^{+\infty} \leftarrow -\infty$ 
%			\STATE $\rho_{i,j}^{-\infty} \leftarrow -\infty$ 
%			\ENDFOR
%			\ENDFOR
%			\FOR{\textbf{each} $r_i \in R$}
%			\STATE $\rho_{i,i}^{+\infty} \leftarrow 0$
%			\STATE $\rho_{i,i}^{-\infty} \leftarrow 0$
%			\ENDFOR
%			\FOR{\textbf{each} $r_i \in R$}
%			\FOR{\textbf{each} $r_j \in R$}
%			\IF{$\sigma_{i,j} = +$}
%			\STATE $\rho_{i,j}^{+\infty} \leftarrow \rho_{i,j}$
%			\ELSIF{$\sigma_{i,j} = -$}
%			\STATE $\rho_{i,j}^{-\infty} \leftarrow \rho_{i,j}$
%			\ENDIF
%			\ENDFOR
%			\ENDFOR
%			\FOR{\textbf{each} $r_k \in R$}
%			\FOR{\textbf{each} $r_i \in R$}
%			\FOR{\textbf{each} $r_j \in R$}
%			\IF{$min(\rho_{i,k}^{+\infty}, \rho_{k,j}^{+\infty}) > \rho_{i,j}^{+\infty}$}
%			\STATE $\rho_{i,j}^{+\infty} \leftarrow  min(\rho_{i,k}^{+\infty}, \rho_{k,j}^{+\infty})$
%			\ENDIF
%			\IF{$min(\rho_{i,k}^{-\infty}, \rho_{k,j}^{-\infty}) > \rho_{i,j}^{+\infty}$}
%			\STATE $\rho_{i,j}^{+\infty} \leftarrow  min(\rho_{i,k}^{-\infty}, \rho_{k,j}^{-\infty})$
%			\ENDIF
%			\IF{$min(\rho_{i,k}^{+\infty}, \rho_{k,j}^{-\infty}) > \rho_{i,j}^{-\infty}$}
%			\STATE $\rho_{i,j}^{-\infty} \leftarrow  min(\rho_{i,k}^{+\infty}, \rho_{k,j}^{-\infty})$
%			\ENDIF
%			\IF{$min(\rho_{i,k}^{-\infty}, \rho_{k,j}^{+\infty}) > \rho_{i,j}^{-\infty}$}
%			\STATE $\rho_{i,j}^{-\infty} \leftarrow  min(\rho_{i,k}^{-\infty}, \rho_{k,j}^{+\infty})$
%			\ENDIF
%			\ENDFOR
%			\ENDFOR
%			\ENDFOR
%		\end{algorithmic}
%%	\end{multicols}
%\end{algorithm*}

