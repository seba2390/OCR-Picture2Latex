\section{Preliminaries}
\label{sec:basic}

\subsection{Basic Notions}
\label{sec:basic_notions}

Time is represented by a linearly ordered set of time points $(\mathbb{T},\leq)$, where $\mathbb{T} \subseteq \mathbb{Q^+}$ are the non-negative rational numbers. 
%
An \textbf{\textit{event}} $e$ is a data tuple describing an incident of interest to the application. An event $e$ has a time stamp $e.time \in \mathbb{T}$ assigned by the event source. 
An event $e$ belongs to a particular event type $E$, denoted \textit{e.type=E} and described by a schema that specifies the set of event attributes and the domains of their values. A specific attribute $\mathit{attr}$ of $E$ is referred to as $E.\mathit{attr}$.
Table~\ref{tab:notation} summarizes the notation.

Events are sent by event producers (e.g., vehicles and mobile devices) to an  \textbf{\textit{event stream}} $I$. We assume that events arrive in order by their time stamps. Existing approaches to handle out-of-order events can be applied~\cite{CGM10, LTSPJM08, LLGRC09, SW04}.

An event consumer (e.g., Uber stream analytics) continuously monitors the stream with \textbf{\textit{event queries}}. We adopt the commonly used query language and semantics from SASE~\cite{ADGI08, WDR06, ZDI14}.
The query workload in Figure~\ref{fig:queries} is expressed in this language. We assume that the workload is static. Adding or removing a query from a workload requires migration of the execution plan to a new workload which can be handled by existing approaches~\cite{KWF06, ZhuRH04}.


\input{sections/table_of_notation}


%{\color{blue} EAR:  i do not see where you enforce that at least one pi (e?) has a kleene, and that others may not have a kleene?}
% Olga: fixed

\begin{definition}(\textbf{Kleene Pattern})
%
A pattern $P$ can be in the form of 
$E$, $P_1+$, ($\mynot\ P_1$),
\seq$(P_1,$ $P_2)$, $(P_1 \vee P_2)$, or $(P_1 \wedge P_2)$, 
where 
$E$ is an event type,
$P_1,P_2$ are patterns, 
$+$ is a Kleene plus, 
$\mynot$ is a negation,
\seq\ is an event sequence,
$\vee$ is a disjunction, and
$\wedge$ is a conjunction.
%
$P_1$ and $P_2$ are called sub-patterns of $P$.
%
If a pattern $P$ contains a Kleene plus operator, $P$ is called a Kleene pattern.
% If an operator in a pattern $P$ is applied to the result of another operator, the pattern $P$ is called nested. Otherwise, the pattern $P$ is flat.
%
\label{def:pattern}
\end{definition}

%----------------- First and last event type in a pattern
%\begin{definition}(\textbf{Start and End Type of a Pattern})
%
%Let $P$ be a pattern.
%Let $start(P)$ denote the start and $end(P)$ denote the end event type of $P$.
%
%For an event type $E$, $start(E)=end(E)=E$.
%For a Kleene pattern $P+$, $start(P+)=start(P)$ and $end(P+)=end(P)$.
%For a sequence pattern $\seq(P_1,P_2)$, $start(\seq(P_1,P_2))=start(P_1)$ and $end(\seq(P_1,P_2))=end(P_2)$.
%
%\label{def:start-and-end-type-in-a-pattern}
%\end{definition}

% We focus on Kleene patterns that allow us to specify arbitrarily long event pattern matches, called event trends (Definition~\ref{def:query}). 
% To keep our discussion focused in Sections~\ref{sec:tempalte}--\ref{sec:runtime}, we consider Kleene patterns that neither contain other operators (e.g., conjunction, negation), nor are nested. We generalize \app\ in Section~\ref{sec:other}.


%{\color{blue} EAR: Below does not seem to enforce that te pattern has to be a kleene enriched pattern, thus this not necessarily a  "trend" query???}
% olga: fixed

%------------------ Query
\begin{definition}(\textbf{Event Trend Aggregation Query})
%
An event trend aggregation query $q$ consists of five clauses:

$\bullet$ Aggregation result specification (\textsf{RETURN} clause),

$\bullet$ Kleene pattern $P$ (\textsf{PATTERN} clause) as per Definition~\ref{def:pattern},

$\bullet$ Predicates $\theta$ (optional \textsf{WHERE} clause),

$\bullet$ Grouping $G$ (optional \textsf{GROUPBY} clause), and

$\bullet$ Window $w$ (\textsf{WITHIN/SLIDE} clause).
%
\label{def:query}
\end{definition}

%------------------ Trend
\begin{definition}(\textbf{Event Trend})
%
Let $q$ be a query per Definition~\ref{def:query}.
An event trend $tr = (e_1, \ldots, e_k)$ corresponds to a sequence of events that conform to the pattern $P$ of $q$. All events in a trend $tr$ satisfy predicates $\theta$, have the same values of grouping attributes $G$, and are within one window $w$ of $q$. 
%
\label{def:trend}
\end{definition}

%------------------------------
\textbf{Aggregation of Event Trends}.
Within each window specified by the query $q$, event trends are grouped by the values of grouping attributes $G$. Aggregates are then computed per group. 
% {\color{blue} Below is not true for Q1. so i have altered the stmt to say Q2 and Q3.  did you mean  Q1 on purpose be be a groupby over each driver only? even if drivers drive through multiple districts? will you explain the relationship of driver vs district somewhere???}  
% olga: i changed the example
%For example, queries $q_1$--$q_3$ in Figure~\ref{fig:queries} group trips per district and compute the number, total duration, and average speed of trips.
\app\ focuses on distributive (\mycount, \mymin, \mymax, \mysum) and algebraic aggregation functions (\myavg) since they can be computed incrementally~\cite{Gray97}. 
%
Let $E$ be an event type,
$\mathit{attr}$ be an attribute of $E$, and
$e$ be an event of type $E$.
%
While $\mycount(*)$ returns the number of all trends per group,
$\mycount(E)$ computes the number of all events $e$ in all trends per group. 
%
$\mysum(E.\mathit{attr})$ ($\myavg(E.\mathit{attr})$) calculates the summation (average) of the value of $\mathit{attr}$ of all events $e$ in all trends per group.
%
$\mymin(E.\mathit{attr})$ ($\mymax(E.\mathit{attr})$) computes the minimal (maximal) value of $\mathit{attr}$ for all events $e$ in all trends per group.


%\textbf{\textit{Count}}.
%\mycount$\mathit{(*)}$ returns the number of trends per group.
%Let \textit{tr.}\mycount(\textit{E}) be the number of events of type $E$ in a trend $tr$. \mycount(\textit{E}) corresponds to the sum of \textit{tr.}\mycount$(E)$ of all trends per group.


%\textbf{\textit{Minimum and Maximum}}.
%Let \textit{tr.}\mymin(\textit{E.attr}) be the minimal value of an attribute \textit{attr} of events of type $E$ in a trend $tr$.
%\mymin(\textit{E.attr}) returns the minimal value of \textit{tr.}\mymin$(E.attr)$ of all trends per group.
%\mymax(\textit{E.attr}) is defined analogously to \mymin$(E.\mathit{attr})$.

%\textbf{\textit{Summation and Average}}.
%Let \textit{tr.}\mysum(\textit{E.attr}) be the sum of values of an attribute \textit{attr} of events of type $E$ in a trend $tr$.
%\mysum(\textit{E.attr}) corresponds to the sum of \textit{tr.}\mysum(\textit{E.attr}) of all trends per group.
%\myavg(\textit{E.attr}) = \mysum(\textit{E.attr}) / \mycount(\textit{E}) per group.

%------------------------------
%\textbf{Predicates}.
%
% Predicates on single events and on pairs of adjacent events in a trend are commonly used to specify expressive CEP queries in diverse applications~\cite{ADGI08, DGPRSW07, MM09, PLRM18}. Thus, we focus on such predicates in this paper and leave predicates on non-adjacent events for future research.
%We differentiate between three types of predicates:

%\textit{Local predicates} filter events in the stream based on their attribute values. For example, query $q_2$ in Figure~\ref{fig:queries} matches only pool ride requests which is expressed by the local predicate $(R.\mathit{type} = \mathit{Pool})$.

%\textit{Equivalence predicates} partition the event stream so that all events in a trend have the same attribute value. The predicate [driver, rider] in Figure~\ref{fig:queries} specifies that all events in a trend must have the same driver and rider identifiers.

%\textit{Predicates on adjacent events} in a trend. For example, the predicate $(E.\mathit{price} < \textsf{NEXT}(E).\mathit{price})$ requires a trend of  events of type $E$ to strictly increase in price.

%------------------------------
% \textbf{Event Matching Semantics}.
%
% Our queries are evaluated under the skip-till-any-match semantics which is the most flexible semantics since it allows to detect the set of all matches of a query~\cite{ADGI08, WDR06, ZDI14}. An exponential number of matches in the number of input events can be produced in the worst case~\cite{ZDI14}. Trends conforming to more restrictive semantics can be extracted from the set of all matches~\cite{PLRM19}.
