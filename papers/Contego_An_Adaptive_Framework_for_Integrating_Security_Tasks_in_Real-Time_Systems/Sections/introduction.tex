 \documentclass[../rt_server_main.tex]{subfiles}

 \begin{document}

\section{Introduction}

Embedded real-time systems (RTS) are used to monitor and control physical
systems and processes in many domains, \eg manned and unmanned vehicles
including aircraft, spacecraft, unmanned aerial vehicles (UAVs), submarines and
self-driving cars, critical infrastructures like the electric grid and process control systems in industrial plants, to name just a few.	
They rely on a variety of inputs for 
correct operation and have to meet stringent safety and timing requirements.
Failures in RTS can have catastrophic consequences for the
environment, the system, and/or human safety \cite{abrams2008malicious, checkoway2011comprehensive}. 

Traditionally, RTS were designed using proprietary protocols, platforms and software and were
not connected to the rest of the world, \ie they were air gapped. As a result cyber-security
was not a design priority in such systems.
%\note[RBB]{swapped sentence order}
However, the drive towards remote monitoring and control
facilitated by the growth of the Internet, the rise in the use of
commercial-off-the-shelf (COTS) components, standardized communication protocols
and the high value of these systems to adversaries have been challenging the status
quo. While safety and fault-tolerance have long been important design
considerations in such systems, traditional fault-tolerance techniques that
were designed to counter and survive random or accidental faults are not
sufficient to deal with cyber-attacks orchestrated by an intelligent and
capable adversary. A number of high-profile attacks on real systems, \eg Stuxnet \cite{stuxnet} and attack demonstrations by researchers on
automobiles \cite{ris_rts_1, checkoway2011comprehensive} and medical devices
\cite{security_medical} have shown that the threat is real. %In the last few years there has been a lot of focus on securing critical cyber-physical infrastructures like energy delivery systems(\eg~\cite{CardenasBBH14,ZonouzDDB14,DavisDZBB15}) and critical cyber-physical systems like implantable medical devices~\cite{HalperinHFK08,ClarkF12}. A major focus of such work has been on securing communication protocols in such systems and on monitoring and detection mechanisms at the network level and application level. 


Given the
increasing cyber-security risks, it is essential to have a layered
defense and integrate resilience against such attacks into the design of
controllers and actuators (\ie embedded RTS). It is
also critical to retrofit existing controllers and actuators with protection,
detection, survival and recovery mechanisms. However, \textit{any security mechanisms have to co-exist with real-time tasks in
the system and have to operate without impacting the timing and safety
constraints of the control logic}. This creates an apparent tension between
security requirements (\eg having enough cycles for effective monitoring and 
detection) and the timing and safety requirements. For example, how often and
how long should a monitoring and detection task run to be effective but not
interfere with real-time control or other safety-critical tasks? While this
tension could potentially be addressed for newer systems at design time, it
is especially challenging in the retrofitting of \textit{legacy} systems for which the control
tasks are already in place and perhaps \textit{cannot be modified}. %For instance, a fundamental problem is to slice a monitoring mechanism be so that a legacy system can be accommodated without diminishing detection capability. \hl{[RBB: Do we address this challenge in this paper?] MH: No actually! Removed this statement.} 
Another challenge
is to ensure that an adversary
cannot easily evade such mechanisms. Further, the deterministic nature of task
schedules in RTS may provide attackers with known windows of opportunity
in which they can run undetected \cite{cy_side_channel,taskshuffler}. 

In order to integrate security mechanisms into RTS, performance criteria such as \textit{frequency of monitoring} and \textit{responsiveness} must be considered. %\cite{mhasan_rtss16}. 
For example, security tasks\footnote{We use the terms \textit{security tasks}, \textit{intrusion detection tasks} and \textit{monitoring tasks} interchangeably throughout the paper.} may need to be executed quite frequently to provide good protection. If the interval between consecutive monitoring events is too large, then an attacker may remain undetected and cause harm to the system between two invocations of the security task. In contrast, if the security tasks are executed very frequently, it may impact the schedulability (\ie timely execution) of the real-time tasks \cite{sibin_deeply}. In some circumstances a security task may need to complete with less interference (\eg better responsiveness) from higher-priority real-time tasks. As an example, consider the scenario in which a security breach is suspected and a security task may be required to perform more fine-grained checking instead of waiting for its next  execution slot. At the same time, the scheduling policy needs to ensure that the system does not violate real-time constraints for critical, high-priority control tasks. 



Our focus in this work is on \textit{retrofitting security mechanisms into legacy RTS}, for which modification of existing real-time tasks' parameters (such as run-times, period, task execution order, \etc) is not always feasible. In contrast to existing mechanisms \cite{slack_cornell, securecore}, the proposed method does \textit{not} require any architectural modifications and hence is particularity suitable for systems designed using COTS components. The framework developed in this paper is based on our earlier work \cite{mhasan_rtss16} %where we proposed to execute security routines only when real-time tasks are \textit{not} running. Our earlier approach is suitable for integrating security mechanisms into legacy systems since the execution order and schedulability of the real-time tasks are not affected. However, as illustrated in Section \ref{sec:evaluation}, the cost of not perturbing all of the real-time task schedule is the reduced speed of detecting intrusions. 
in which we proposed to incorporate monitoring and detection mechanisms by implementing them as separate \textit{sporadic tasks} and executing them \textit{opportunistically}, that is, with the lowest priority so that real-time tasks are not affected.
%\hl{[RBB: Is this this paper's solution or Opportunistic Execution paper's?]  %MH: yes, the RTSS one. rewritten as you suggested with anonymous reference. Could you please check.} 
%This brings up the challenge of determining the \textit{right periods} (\viz minimum inter-execution time) for the security tasks. For instance, some critical security routines may be required to execute more frequently than others. However, if the period is too short (\eg the security task repeats too often) then it will use too much of the processor time and eventually lower the overall system utilization. As a result, the security mechanism itself might prove to be a hindrance to the system and reduce the overall functionality or worse, safety. In contrast, if the period is too long, the security task may not always detect violations since attacks could be launched between two instances of the security task. 
However, if the security tasks always execute with lowest priority, they suffer more interference (\ie preemption from high-priority real-time tasks) and the consequent longer detection time (due to poor response time) will make the security mechanisms less effective. In order to provide \textit{better responsiveness} and increase the effectiveness of monitoring and detection mechanisms,  
we now propose a multi-mode framework called \coolname\footnote{A preliminary version \cite{mhasan_certs16} of this work was presented at a workshop without published proceedings.}. For the most part, \coolname executes in a \pve mode with opportunistic execution of intrusion detection tasks as before~\cite{mhasan_rtss16}. However, \coolname will \textit{switch to an \ave mode of operation} to perform additional checks as needed (\eg fine-grained analysis, used as an example in Section \ref{subsec:implementation_BBB}). This \ave mode potentially executes with higher priority, while ensuring the schedulability of real-time tasks. Thus \coolname subsumes the approach in our earlier work~\cite{mhasan_rtss16} and provides faster detection.  

%to \textit{switch the mode of operation} to perform fine-grained checking with higher priority when needed. We refer this framework as \coolname.

%against integrity violation or suspicion against any anomalous behavior,

The contributions of this paper can be summarized as follows:

\begin{itemize}
\item We introduce \coolname, an extensible framework to integrate security tasks into legacy RTS (Section \ref{sec:system_model}). 

\item \coolname allows the security tasks to execute with minimal perturbation of the scheduling order of the real-time tasks while guaranteeing their timing constraints (Sections \ref{sec:sec_server}--\ref{sec:algo}). The proposed method can adapt to changes due to malicious activities by switching its mode of operation. %\remove[RBB]{Surprisingly, this has not been been addressed comprehensively in the context of RTS security.}


\item We propose a metric to measure the security posture of the system in terms of frequency of execution (Section \ref{sec:period_adapt}).

\item We evaluate the schedulability and security of the proposed approach using a range of synthetic task sets and a prototype implementation on an ARM-based development board with real-time Linux (Section \ref{sec:evaluation}).

%\item \hl{We implement a prototype of the proposed approach on an ARM-based development board with real-time Linux and evaluate it for schedulability and security} (Section \ref{sec:evaluation}).

%\item We evaluate the proposed approach for schedulability and security, as well as a prototype implementation on an ARM-based development board and real-time Linux (Section \ref{sec:evaluation}).

\end{itemize}

 \end{document}
