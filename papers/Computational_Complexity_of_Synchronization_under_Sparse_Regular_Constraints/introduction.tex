
A deterministic semi-automaton is \emph{synchronizing} if it admits a reset word, i.e., a word which leads to a definite
state, regardless of the starting state. This notion has a wide range of applications, from software testing, circuit synthesis, communication engineering and the like, see~\cite{DBLP:journals/et/ChoJSP93,San2005,Vol2008}.  
The famous \v{C}ern\'y conjecture \cite{Cer64}
states that a minimal synchronizing word, for an $n$ state automaton, has length
at most $(n-1)^2$. %hier vielleicht ncoh mehr zu schreiben,  Shitov JALC-paper?
We refer to the mentioned survey articles for details~\cite{San2005,Vol2008}. 



Due to its importance, the notion of synchronization has undergone a range of generalizations and variations
for other automata models.
%There are different notions of synchronization
%for partial automata, or for non-deterministic automata. 
% It was noted in~\cite{Martyugin12} that in some  generalizations only certain paths, or input words, are allowed (namely those for which the input automaton is defined). In~\cite{Gusev:2012}
% the notion of constrained synchronization was %implicitly 
% introduced in connection with a reduction procedure
% for synchronizing automata, but it was not formulated as a computational problem in itself
% and only used as an auxiliary tool with a very specific constraint language.
The paper~\cite{DBLP:conf/mfcs/FernauGHHVW19} introduced the constrained synchronization problem (CSP\footnote{In computer science the
acronym CSP is usually used for the constraint satisfaction problem~\cite{Lecoutre09}. However, as here we are not concerned with
constrained satisfaction problems at all, no confusion should arise.}). 
In this problem, we search for a synchronizing word coming from a specific subset of allowed
input sequences. 
To sketch a few applications:

\input{motivation}



%For further motivation and applications we refer to the aforementioned paper \cite{DBLP:conf/mfcs/FernauGHHVW19}.
In~\cite{DBLP:conf/mfcs/FernauGHHVW19}, a complete analysis of the complexity landscape when the constraint language is given by small partial automata was done. It is natural to extend this result to other language classes.%, or
%even to give a complete classification of all the complexity classes that could arise.
%For commutative regular constraint languages, a full classification of the realizable
%complexities was given in~\cite{DBLP:conf/cocoon/Hoffmann20}.
%In~\cite{DBLP:conf/ictcs/Hoffmann20}, it was shown that for polycyclic constraint languages, the problem is always in $\NP$.


In general there exist constraint languages yielding 
\PSPACE-complete constrained problems~\cite{DBLP:conf/mfcs/FernauGHHVW19}. 
A language is polycyclic~\cite{DBLP:conf/ictcs/Hoffmann20}, if it is recognizable by an automaton
such that every strongly connected component forms a single cycle,
and a language is sparse~\cite{DBLP:reference/hfl/Yu97} if only polynomially many words of a specific length are in the language.
As shown in~\cite{DBLP:conf/ictcs/Hoffmann20}
for polycyclic languages, which, as we show, equal the sparse regular
languages, the problem is always in \NP. This motivates investigating this class further. 
Also, as written in more detail in Remark~\ref{rem:motivation_strictly_bounded},
a subclass of these languages has a close relation to the commutative languages, and as for commutative constraint
languages a trichotomy result has been established~\cite{DBLP:conf/cocoon/Hoffmann20},
tackling the sparse languages seems to be the next logical step.
In fact, we show a dichotomy result for a subclass
that contains the class corresponding to the commutative languages.
Additionally, as has been noted in~\cite{DBLP:conf/mfcs/FernauGHHVW19},
the constraint language $ab^*a$ is the smallest language, in terms of a recognizing
automaton, giving an \NP-complete CSP. The class of languages
for which our dichotomy holds true contains this language.


%Here, we will look at the complexity landscape for strictly bounded regular constraint languages
%and bounded regular constraint languages induced by strongly self-synchronizing codes.

% Here, we will look at the complexity landscape for sparse regular constraint
% languages. We will show that they equal the bounded regular and the polycyclic languages.
% Then, we will investigate the problem for the strictly bounded constraint
% languages and constraint languages induced by strongly self-synchronizing codes.


Let us mention that restricting the solution space by a regular language
has also been applied in other areas, for example to topological sorting~\cite{DBLP:conf/icalp/AmarilliP18},
solving word equations~\cite{Diekert98TR,DBLP:journals/iandc/DiekertGH05}, constraint programming~\cite{DBLP:conf/cp/Pesant04}, or
shortest path problems~\cite{DBLP:journals/ipl/Romeuf88}.
The famous road coloring theorem~\cite{adler1970similarity,Trahtman09} states
that every finite strongly connected and directed aperiodic graph of uniform out-degree admits a labelling of its edges 
such that a synchronizing
automaton results. A related problem to our problem of constrained synchronization is to restrict the possible labelling(s), and
this problem was investigated in~\cite{DBLP:journals/jcss/VorelR19}.






\paragraph{Outline and Contribution.} 
%\subsection{Outlnie and Constribution}
Here, we look at the complexity landscape for sparse regular constraint
languages.
In Section~\ref{sec:sparse}
 we introduce the sparse languages and show that the regular sparse
 languages are characterized by
 polycyclic automata introduced in~\cite{DBLP:conf/ictcs/Hoffmann20}.
 A similar characterization in terms of non-deterministic
 automata was already given in~\cite[Lemma 2]{DBLP:journals/ijfcs/GawrychowskiKRS10}.
 In this sense, we extend this characterization to the deterministic
 case. As for polycyclic constraint automata the constrained
 problem is always in \NP, see~\cite[Theorem 2]{DBLP:conf/ictcs/Hoffmann20},
 we can deduce the same for sparse regular constraint languages, which
 equal the bounded regular languages~\cite{DBLP:journals/eik/LatteuxT84}.
 
 
In Section~\ref{sec:strictly_bounded_case}
we introduce the letter-bounded languages, a proper subset of the sparse languages,
and show that for letter-bounded  constraint languages, the constrained
synchronization problem is either in \PTIME\ or \NP-complete.
 
 
 The difficulty why we cannot handle the general case yet lies in the fact that
 in the reductions, %for arbitrary (sparse) constraint languages
 %used for the special case, 
 in the general case, we need auxiliary states and it is not clear
 how to handle them properly, i.e, 
 how to synchronize them properly while staying inside the constraint language.
 
 
 In Section~\ref{sec:strongly_self_sync}
 we introduce the class of strongly self-synchronizing
 codes. 
 The strongly self-synchronizing codes allow us to handle these auxiliary states mentioned before.
 We show that for homomorphisms given by such codes,
 the constrained problem for the homomorphic image of a language has the same computational
 complexity as for the original language.
 This result holds in general, and hence is of independent interest.
 Here we apply it to the special case
 of bounded, or sparse, regular languages given by such codes.
 
 
 Lastly, we present a bounded language giving an \NP-complete constrained
 problem that could not be handled by our methods so far.
 
 

