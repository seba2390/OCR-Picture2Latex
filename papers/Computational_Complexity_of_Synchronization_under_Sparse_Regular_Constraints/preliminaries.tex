
%\subsection{General notions} 
%\subsection{General Notions} % and Problems Related to Automata and Synchronization}
%\subsection{Definitions and problems related to automata and synchronization}

% Sigma und so definieren, todo, tcs paper
%By $\mathbb N_0 = \{0,1,2,\ldots\}$ we denote the natural numbers with zero. 



We assume the reader to have some basic knowledge in computational complexity theory and formal language theory, as contained, e.g., in~\cite{HopUll79}. For instance, we make use of  regular expressions to describe languages.
%We also identify singleton sets with its elements. 
By $\Sigma$ we denote the \emph{alphabet}, a finite set.
For a word $w \in \Sigma^*$ we denote by $|w|$ its \emph{length},
and, for a symbol $x \in \Sigma$, we write $|w|_x$ to denote the \emph{number of occurrences of $x$}
in the word. We denote the empty word, i.e., the word of length zero, by $\varepsilon$.
For $L \subseteq \Sigma^*$, we set $\pref(L) = \{ u \in \Sigma^* \mid \exists v \in \Sigma^* : uv \in L \}$.
A word $u \in \Sigma^*$ is a \emph{factor} (or \emph{infix}) of $w \in \Sigma^*$ if there exist words $x,y \in \Sigma^*$ such that $w = xuy$. 
For $U, V \subseteq \Sigma^*$, we set $U\cdot V = UV = \{ uv \mid u \in U, v \in V \}$
and 
$U^0 = \{ \varepsilon \}$, $U^{i+1} = U^i U$, 
and $U^* = \bigcup_{i \ge 0} U^i$ and $U^+ = \bigcup_{i > 0} U^i$.
We also make use of complexity classes like $\PTIME$, $\NP$, or $\PSPACE$.
With  $\leq^{\log}_m$ we denote a logspace many-one reduction.
If for two problems $L_1, L_2$ it holds that $L_1 \leq^{\log}_m L_2$ and $L_2 \leq^{\log}_m L_1$, then we write $L_1 \equiv^{\log}_m L_2$.



A \emph{partial deterministic finite automaton (PDFA)} is a tuple $\mathcal A = (\Sigma, Q, \delta, q_0, F)$,
where $\Sigma$ is a finite set of \emph{input symbols},~$Q$ is the finite \emph{state set}, $q_0 \in Q$ the \emph{start state}, $F \subseteq Q$ the \emph{final state set} and $\delta \colon Q\times \Sigma \rightharpoonup Q$ the \emph{partial transition function}.
The \emph{partial transition function} $\delta \colon Q\times \Sigma \rightharpoonup Q$ extends to words from $\Sigma^*$ in the usual way. 
Furthermore, for $S \subseteq Q$ and $w \in \Sigma^*$, we set $\delta(S, w) = \{\,\delta(q, w) \mid \mbox{$\delta(q,w)$ is defined and } q \in S\,\}$.
We call $\mathcal A$ \emph{complete} if~$\delta$ is defined for every $(q,a)\in Q \times \Sigma$.
If $|\Sigma| = 1$, we call $\mathcal A$ a \emph{unary automaton} and
 $L \subseteq \Sigma^*$ is also called a \emph{unary language}.
The set $L(\mathcal A) = \{\, w \in \Sigma^* \mid \delta(q_0, w) \in F\,\}$ denotes the language
\emph{recognized} %(or \emph{accepted}) 
by~$\mathcal A$.


A \emph{deterministic and complete semi-automaton (DCSA)} $\mathcal A = (\Sigma, Q, \delta)$
is a deterministic and complete finite automaton without a specified start state
and with no specified set of final states.
When the context is clear, we call both deterministic finite automata and semi-automata simply \emph{automata}.

% A \emph{semi-automaton} $\mathcal A = (\Sigma, Q, \delta)$
% is a finite automaton without a specified start state
% and with no specified set of final states.
% The properties of being \emph{deterministic}, \emph{partial}, and \emph{complete} for semi-automata are defined as for DFAs.
% When the context is clear, we call both deterministic finite automata and semi-automata simply \emph{automata}.
% We call a deterministic and complete semi-automaton a DCSA for short.
%e call a deterministic complete semi-automaton a DCSA and a partial deterministic finite automaton a PDFA for short. 

%If we want to add an explicit initial state $r$ and an explicit set of  final states $S$ to a 
%deterministic semi-automaton $\mathcal A$ or change them in a DFA~$\mathcal A$, we use the notation $A_{r,S}$.
A complete automaton $\mathcal A$ is called \emph{synchronizing} if there exists a word $w \in \Sigma^*$ with $|\delta(Q, w)| = 1$. In this case, we call $w$ a \emph{synchronizing word} for $\mathcal A$.
%For a word $w$, we call a state in $\delta(Q, w)$ an \emph{active} state. 
We call a state $q\in Q$ with $\delta(Q, w)=\{q\}$ for some $w\in \Sigma^*$ a \emph{synchronizing state}.
%A state from which some final state is reachable is called \emph{co-accessible}.
%For a set $S \subseteq Q$, we say $S$ is \emph{reachable} from $Q$ or $Q$ is synchronizable to $S$ if %there exists a word $w \in \Sigma^*$ such that $\delta(Q, w) = S$.
%An automaton $A$ is called \emph{returning}, if for every state $q \in Q$, there exists a word $w \in \Sigma^*$ such that $\delta(q, w) = q_0$, where $q_0$ is the start state of $A$.
%If $\delta(q, v) = q'$
For a semi-automaton (or PDFA) with state set $Q$ and transition function $\delta : Q \times \Sigma \rightharpoonup Q$,
a state $q$ is called a \emph{sink state}, if for all $x \in \Sigma$ we have $\delta(q,x) = q$.
Note that, if a synchronizing automaton has a sink state, then the
synchronizing state is unique and must equal the sink state.



In~\cite{DBLP:conf/mfcs/FernauGHHVW19} the \emph{constrained synchronization problem (CSP)} 
was defined for a fixed PDFA
$\mathcal B = (\Sigma, P, \mu, p_0, F)$. % ..., for some fixed ... komma?

\begin{decproblem}\label{def:problem_L-constr_Sync}
  \problemtitle{\cite{DBLP:conf/mfcs/FernauGHHVW19}~\textsc{$L(\mathcal B)$-Constr-Sync}}
  \probleminput{DCSA $\mathcal A = (\Sigma, Q, \delta)$.}
  \problemquestion{Is there a synchronizing word $w \in \Sigma^*$ for $\mathcal A$ with  $w \in L(\mathcal B)$?}
\end{decproblem}

The automaton $\mathcal B$ will be called the \emph{constraint automaton}.
If an automaton~$\mathcal A$ is a yes-instance of \textsc{$L(\mathcal B)$-Constr-Sync} we call $\mathcal A$ \emph{synchronizing with respect to~$\mathcal{B}$}. %In \cite{DBLP:conf/mfcs/FernauGHHVW19} the following was stated.
Occasionally,
we do not specify $\mathcal{B}$ and rather talk about \textsc{$L$-Constr-Sync}.
For example, for the unconstrained case, 
we have $\Sigma^*\textsc{-Constr-Sync}\in \PTIME$~\cite{Cer64,Vol2008}.



\begin{toappendix}
The following obvious remark, stating that the set of synchronizing words
is a two-sided ideal, will be used frequently without further mentioning.

\begin{lemma}
	\label{lem:append_sync} %\cite{FernauHoffmann19}
	Let $\mathcal A = (\Sigma, Q, \delta)$ be a deterministic and complete semi-automaton and $w\in \Sigma^*$ be a synchronizing word for $\mathcal A$. Then for every $u, v \in \Sigma^*$, the word $uwv$ is also synchronizing. % for~$\mathcal A$. %\todo[backgroundcolor=purple!70]{HF wanted to restate this}
\end{lemma}
\end{toappendix}



In our $\NP$-hardness reduction, we will need the following problem
from~\cite{DBLP:conf/ictcs/Hoffmann20}.

\begin{decproblem}\label{def:unary_set_transpoer}
  \problemtitle{\textsc{DisjointSetTransporter}}
  \probleminput{DCSA $\mathcal A = (\Sigma, Q, \delta)$ and disjoint $S, T \subseteq Q$.}
  \problemquestion{Is there a word $w \in \Sigma^*$ such that $\delta(S, w) \subseteq T$?}
\end{decproblem}

%This problem is a variant of a problem
%introduced in~\cite{DBLP:journals/cc/BlondinKM16,DBLP:journals/jcss/LuksM88}.
%In general, this problem is $\PSPACE$-complete, but for
%unary
%input semi-automata, it is $\NP$-complete~\cite{DBLP:journals/cc/BlondinKM16,DBLP:conf/ictcs/Hoffmann20,DBLP:journals/jcss/LuksM88}

\begin{theorem}
\label{prop:set_transporter_np_complete}
 For unary deterministic and complete input semi-automata the problem \textsc{DisjointSetTransporter}
 is $\NP$-complete.
\end{theorem}


 

A PDFA $\mathcal A=(\Sigma, Q, \delta, q_0, F)$
is called \emph{polycyclic}, if for each $q \in Q$
there exists $u \in \Sigma^*$ such that
%\footnote{Languages $L\subseteq \Sigma^*$ such that
%$L \subseteq w^*$ for some $w \in \Sigma^*$ are called commutative
%in~\cite{GinsburgSpanier64,GinsburgSpanier66,DBLP:journals/ijfcs/GawrychowskiKRS10},
%as these are precisely the languages such that $xy = yx$ for all $x,y \in L$.
%But this is a different meaning of commutativity as we have introduced here, but aside
%from the mentioned papers, commutativity in formal language theory is mostly used
%in the sense as introduced and used in this work.}
%which
%seems to be the more commonly used meaning.}
%and seems
%to be the significantly less used than the meaning as used and introduced here.}
$\{ w \in \Sigma^* \mid \delta(q, w) = q \} \subseteq u^*$. %The same definition holds for non-deterministic automata.
%and the corresponding types of semi-automata.
A PDFA is polycyclic if and only if every strongly connected
component consists of a single cycle~\cite[Proposition 3]{DBLP:conf/ictcs/Hoffmann20}, where each transition in the cycle is labelled by precisely one
letter. %\footnote{This is only mentioned because automata are often drawn by combining parallel transitions into a single one having possibly multiple labels. For example, a strongly connected component consisting of a self-loop with two distinct letters should be excluded. Formally, of course, every transition corresponds to precisely one letter.}~\cite{DBLP:conf/ictcs/Hoffmann20}.
Formally, %in the PDFA case,
for each strongly connected component $S \subseteq Q$ 
and $q \in S$, we
have\footnote{In~\cite{DBLP:conf/ictcs/Hoffmann20}, I made an error in my formalization
by writing
$|\{ \delta(q, x) : x \in \Sigma, \delta(q, x) \mbox{ is defined } \} \cap S| \le 1$.} %I am sorry for that!}
$|\{ x : x \in \Sigma \mbox{ and } \delta(q, x) \mbox{ is defined and in $S$} \}| \le 1$ (note that in the special case $|S| = 1$, the aforementioned set might be empty if the single state in $S$ has no self-loops).
%This definition could be adapted to non-deterministic automata. % siehe todo note
A precursor of this characterization of polycyclic automata in
a special case was given in~\cite{DBLP:conf/stacs/GanardiHKLM18}
under the term \emph{linear cycle automata}.

\begin{toappendix}

\begin{example} A few examples and non-examples of polycyclic automata 
(start and final states not indicated, as they are irrelevant for these examples).
 
 %\begin{tikzpicture}[shorten >=1pt,->]
 %\tikzstyle{vertex}=[circle,fill=black!25,minimum size=10pt,inner sep=0pt]
  \begin{tikzpicture}[node distance=15mm, auto]
  \tikzstyle{vertex}=[circle,fill=black!25,minimum size=10pt,inner sep=0pt]
   
   \node at (0.5,0) {};
  
   \foreach \name/\x in {s/1.5, 2/2.25}
    \node[vertex] (G-\name) at (\x,0) {};
    
   \foreach \name/\angle/\text in {P-1/180/5, P-2/108/6, 
                                   P-3/36/7, P-4/-36/8, P-5/-108/9}
    \node[vertex,xshift=4cm] (\name) at (\angle:0.9cm) {};
    
    
  \foreach \name/\angle/\text in {Q-1/90/5, Q-2/180/6, 
                                  Q-3/0/7}
    \node[vertex,xshift=2cm,yshift=-1.9cm] (\name) at (\angle:0.6cm) {};
    
  \node[vertex] (S1) at (5.7,0.5) {};
  \node[vertex] (S2) at (6.5,0.5) {};
  
  \foreach \from/\to/\label in {G-s/G-2/a,G-2/P-1/b,P-1/P-2/a,P-2/P-3/c,P-3/P-4/c,P-4/P-5/c,P-5/P-1/a,P-5/Q-1/b,Q-1/Q-3/a,Q-3/Q-2/b,Q-2/Q-1/b}
     \path[->] (\from) edge node {$\label$} (\to);
     
  \path[->] (P-3) edge node {$a$} (S1);
  \path[->] (S1) edge node {$b$} (S2);
  \path[->] (S2) edge [loop below] node {$a$} (S2);
   \node at (5,-1.7) {polycyclic PDFA};
  
   \node[vertex] (S1) at (9,0.5) {};
   \path[->] (S1) edge [loop above] node {\emph{$a,b$}} (S1);
   \node at (9,0) {not polycyclic};
   
   
    \foreach \name/\angle/\text in {T-1/90/5, T-2/180/6, 
                                  T-3/0/7}
    \node[vertex,xshift=9cm,yshift=-1.6cm] (\name) at (\angle:0.85cm) {};
    
    \path[->] (T-1) edge node {\emph{$a,b$}} (T-3)
              (T-3) edge node [above]  {$a$} (T-2)
              (T-2) edge node  {$a$} (T-1);
    
      \node at (9,-2) {not polycyclic};
 \end{tikzpicture} 
 \end{example}    

Note that a complete DFA over a non-unary alphabet is never polycyclic.
This could be seen with Theorem~\ref{thm:bounded_characterization},
as the complement of a language with polynomial growth cannot have polynomial growth
itself, or by using the property that every strongly connected
component is a single cycle. % induced by a single letter.
Then, for two distinct letters and a strongly connected component, if one maps a state in the cycle into the cycle, the other one must leave the cycle. However, if we topologically sort
the strongly connected components, the component at the end must be closed
under any letter.
\end{toappendix}



\begin{comment}
\begin{toappendix}
\subsection{Strictly Bounded and Commutative Languages}

% nicht direkt übertragbar

Let $\Sigma = \{a_1, \ldots, a_k\}$
be an alphabet of size $k$
and $\psi : \Sigma^* \to \mathbb N_0^k$
be the \emph{Parikh morphism}
given by $\psi(w) = (|w|_{a_1}, \ldots, |w|_{a_k})$
for $w \in \Sigma^*$, where $|w|_{a_i}$, for $i \in \{1,\ldots,k\}$, counts the number of occurrences of the symbol $a_i$ in $w$.

Between the commutative languages over $\Sigma$
and the strictly bounded languages in $a_1^* \cdots a_k^*$, the mappings
\[
\Phi(L) = L \cap a_1^* \cdots a_k^* \quad\mbox{and}\quad
\perm(L) = \{ u \mid \psi(u) \in \psi(L) \}
\]
are mutually inverse and inclusion preserving. % correspondences between these language classes.
Furthermore, for strictly bounded languages of the form $A_1 \cdots A_k \subseteq a_1^* \cdots a_k^*$
with $A_j \subseteq a_j^*$, $j \in \{1,\ldots, k\}$, we have
\[
 \perm(A_1 \cdots A_k) = A_1 \shuffle \cdots \shuffle A_k.
\]
Theorem~\ref{thm:bounded_regular_form}, with the help of these observations
and in its formulation
for strictly bounded languages, and
Theorem~\ref{thm:reg_commutative_form}
could be derived from each other.
It also implies that the commutative closure is regularity-preserving
for strictly bounded languages\footnote{However, this is not true
for general bounded languages, as $\perm((ab)^*) = \{ w \in \{a,b\}^* \mid |w|_a = |w|_b \}$
is not regular.}. 
More specifically, the above correspondence between
the two language classes is regularity-preserving.
The close relation between the commutative and the strictly bounded languages
motivates to also study the constrained synchronization problem
for strictly bounded constraint languages. As a classification for the former
was achieved~\cite{DBLP:conf/cocoon/Hoffmann20}, a classification
for the latter seems achievable.
However, the methods used in~\cite{DBLP:conf/cocoon/Hoffmann20}
are not directly applicable to strictly bounded languages.
For commutative constraint languages, we can realize $\PSPACE$-complete
problems, but, as we will derive from a more general result from~\cite{DBLP:conf/ictcs/Hoffmann20},
for strictly bounded languages, the constrained problem is always in $\NP$.
Moreover, we will prove that only problems in $\PTIME$
or $\NP$-complete problem are realizable with these constraint languages.
So, we have a dichotomy result for strictly bounded constraint languages.
\end{toappendix}
\end{comment}

 
\begin{toappendix}


We will need the following result from~\cite{DBLP:conf/cocoon/Hoffmann20}.

\begin{lemma}[\cite{DBLP:conf/cocoon/Hoffmann20}]
	\label{lem:union}
	Let $\mathcal X$ denote any of the complexity classes
	$\PTIME$, $\NP$ or $\PSPACE$.
	If $L(\mathcal B)$ is a finite union of languages $L(\mathcal B_1),
	L(\mathcal B_2), \dots, L(\mathcal B_n)$ such that for each $1\leq i\leq n$
the problem $L(\mathcal B_i)\textsc{-Constr-Sync}\in \mathcal X$, 
	then we have $L(\mathcal B)\textsc{-Constr-Sync } \in \mathcal X$.
\end{lemma}
\end{toappendix}


The following slight generalization  % Theorem~\ref{thm:membership-preserving}.
of~\cite[Theorem 27]{DBLP:conf/mfcs/FernauGHHVW19} will be needed.

\begin{propositionrep}
\label{prop:hom_lower_bound_complexity}
 Let $\varphi \colon \Sigma^* \to \Gamma^*$ be a homomorphism.
 Then, for each regular $L \subseteq \Sigma^*$, we have 
 $\varphi(L)\textsc{-Constr-Sync} \le_m^{\log} L\textsc{-Constr-Sync}$.
\end{propositionrep}
\begin{proof}
%  Let $A = (\Gamma, Q, \delta)$ be an input semi-automaton.
%  Construct $\varphi(A)$ 
 
%  über $\Sigma$\todo{Genauer.}.
 
%  $\varphi(A)$ has one in $L$ iff $A$ has one in $\varphi(L)$.

 Let $\mathcal A = (\Gamma, Q, \delta)$ be a DCSA.
	We want to know if it is synchronizing with respect to~$\varphi(L)$.
	Build the automaton $\mathcal A' = (\Sigma, Q, \delta')$ according to the rule
	$$
	\delta'(p, x) = q\quad\mbox{if and only if}\quad
        \delta(p, \varphi(x)) = q,$$ for $x\in\Sigma^*$.
	As~$\varphi$ is a mapping,~$\mathcal A'$ is indeed deterministic and
        complete, as~$\mathcal A$ is a DCSA. As the homomorphism~$\varphi$ is
        independent of $\mathcal A$, automaton~$\mathcal A'$ can be constructed from~$\mathcal A$
        in logarithmic space.  Next we prove that the 
        translation is indeed a reduction.

        If $u \in \varphi(L)$ is some synchronizing word for~$\mathcal A$, then there is
        some~$s\in Q$ such that $\delta(r,u)=s$, for all $r\in Q$.  By
        choice of $u$, we find $w \in L$ such that $u = \varphi(w)$. As with
        $\delta(r,\varphi(w))=s$, it follows $\delta'(r,w)=s$, hence~$w$
        is a synchronizing word for~$\mathcal A$.
%	
        Conversely, if $w \in L$ is a synchronizing word
        for~$\mathcal A'$, then there is some $s\in Q$ such that
        $\delta'(r,w)=s$, for all $r\in Q$.  Further, $\varphi(w)$ is
        a synchronizing word for $\mathcal A$, as by definition for all $r\in
        Q$, we have $\delta(r,\varphi(w))=s$. 
\end{proof}



\begin{toappendix}

In the proofs of this appendix, we will need the following results
and constructions.


If $|L(\mathcal B)| = 1$, then $L(\mathcal B)\textsc{-Constr-Sync}$
is obviously in $\PTIME$. Simply feed this single word into the input
semi-automaton for every state and check if a unique state results.
Hence by Lemma \ref{lem:union} the next is implied.

\begin{lemma}\label{lem:finite} 
 Let $\mathcal B = (\Sigma, P, \mu, p_0, F)$ be a constraint automaton
 such that $L(\mathcal B)$ is finite, then
 $L(\mathcal B)\textsc{-Constr-Sync} \in \PTIME$.
\end{lemma}



\begin{lemma}\label{lem:union_single_final_state}
 Every regular language could be written as a finite union of regular languages
 recognizable by automata with a single final state.
\end{lemma}
\begin{proof}
 Let $\mathcal A = (\Sigma, Q, \delta, q_0, F)$ be a DFA.
 Then, $L(\mathcal A) = \bigcup_{q \in F} \{ w \in \Sigma^* \mid \delta(q_0, w) = q\}$
 and $\{ w \in \Sigma^* \mid \delta(q_0, w) = q\} = L((\Sigma, Q, \delta, q_0, \{q\}))$.
\end{proof}

Let $\Sigma = \{a\}$ be a unary alphabet. Suppose $L \subseteq \Sigma^{\ast}$ is regular
with a recognizing complete deterministic automaton $\mathcal A = (\Sigma, Q, \delta, q_0, F)$. Then, by considering
the sequence of states $\delta(q_0, a^1), \delta(q_0, a^2), \delta(q_0, a^3), \ldots$, we find numbers\footnote{Note that these numbers are independent of the language recognized by the automaton.}
$i \ge 0, p > 0$ with $i+p$ minimal such that $\delta(q_0, a^i) = \delta(q_0, a^{i+p})$.
We call these numbers the \emph{index} $i$ and the \emph{period} $p$ of the automaton $\mathcal A$.
If $Q = \{\delta(q_0, a^m) \mid m \ge 0 \}$, i.e., every state is reachable from the start state, then  $i + p = |Q|$.
 In our discussion, unary languages that are recognized by
 automata with a single final state appear.
 
 \begin{lemma}[\cite{DBLP:conf/cai/Hoffmann19}]
\label{lem::unary_single_final}
  Let $L \subseteq \{a\}^{\ast}$ be a unary language that is recognized
  by an automaton with a single final state, index $i$ and period $p$.
  Then either $L = \{u\}$ with $|u| < i$ (and if the automaton is minimal we would have $p = 1$),
  or $L$ is infinite with $L = a^{i+m}(a^p)^{\ast}$ and $0 \le m < p$. Hence
  two words $u,v$ with $\min\{|u|, |v|\} \ge i$ are both in $L$ or not if and only
  if $|u| \equiv |v| \pmod{p}$.
 \end{lemma}
 
We need an additional construction, which we call \emph{inflating}
a given automaton $\mathcal A = (\Sigma, Q, \delta, q_0, F)$


\begin{definition}[Aut. Inflation by a factor $N > 0$]
\label{def:inflate_aut}
 Let $\mathcal A = (\Sigma, Q, \delta, q_0, F)$
 be a given automaton and $N > 0$.
 Then, the 
 \emph{inflated automaton (of $\mathcal A$) by $N$ } 
 is $\mathcal A' = (\Sigma, Q', \delta', q_0, F)$, where
\[
 Q' = Q \cup \bigcup_{x\in \Sigma} ( Q_{1,x} \cup \ldots \cup Q_{N-1, x} )
\]
and the $Q_{i,x}$ are disjoint copies of $Q$.
The states $Q_{1,x}, \ldots, Q_{N-1,x}$
are called \emph{auxiliary states} in this context.
Then, for $q \in Q'$ and $x \in \Sigma$, set
\[
 \delta'(q, x) = \left\{
 \begin{array}{ll}
  q_{i+1,x}    & \mbox{if } q = q_{i,x} \land i \in \{1,\ldots, N-2\}; \\
  \delta(q, x) & \mbox{if } q = q_{N-1,x}; \\
  q_{1,x}      & \mbox{if } q \in Q; \\
  q            & \mbox{otherwise.}
 \end{array}
 \right.
\]
\end{definition}

Intuitively, a transition labelled by $x$ is replaced by a path labelled by $x^N$.
Note that, for $q,q' \in Q$
\[
 \delta(q, x) = q' \mbox{ in } \mathcal A
 \Leftrightarrow \delta'(q, x^N) = q' \mbox{ in } \mathcal A'
\]
and $\delta'(q, w) \in Q$ implies that $|w|$
is divisible by $N$.
\end{toappendix}