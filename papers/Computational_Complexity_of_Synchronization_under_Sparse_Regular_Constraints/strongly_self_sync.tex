\section{Constraints from Strongly Self-Synchronizing Codes}
\label{sec:strongly_self_sync}
%
% ergebnisse bounded, beispiele
% dann noch ab(ba)^*ab zeigen, und dann erstmal paper abschließen. vgl ictcs kriterium

Here, we introduce strongly self-synchronizing codes and investigate $L$\textsc{-Constr-Sync}
for bounded constraint languages $L \subseteq w_1^* \cdots w_k^*$
where $\{ w_1, \ldots, w_k \}$ is such a code. %a strongly self-synchronizing code.

Let $C \subseteq \Sigma^+$ be non-empty.
Then, $C$ is called a \emph{self-synchronizing code}~\cite{zbMATH03943051,DBLP:books/daglib/0025093,Hsieh1989SomeAP},
if $C^2 \cap \Sigma^+ C \Sigma^+ = \emptyset$. If, additionally, $C \subseteq \Sigma^n$
for some $n > 0$, then it is called\footnote{In~\cite{Hsieh1989SomeAP}
 this distinction is not made and self-synchronizing codes are also called comma-free codes.}
a \emph{comma-free code}~\cite{golomb_gordon_welch_1958}.
Every self-synchronizing code is an infix code, i.e., no proper factor of a word from $C$ is in $C$~\cite{Hsieh1989SomeAP}.
A \emph{strongly self-synchronizing code}
is a self-synchronizing code $C \subseteq \Sigma^+$ \todo{nicht bloss $\cap C\Sigma^+$ möglich? für beweis ausreichend?}
such that, additionally, $(\pref(C) \setminus C)C \cap \Sigma^*C \Sigma^+ = \emptyset$.
%, i.e, even when appending code words to proper prefixes
%If $\pref(C)C \cap \Sigma^+ C \Sigma^+ = \emptyset$,
%we call $C$ a \emph{strongly self-synchronizing code}.
\begin{comment}
A language $C \subseteq \Sigma^+$ is called a \emph{self-synchronizing code},
if for any $u,v\in C$, $w \in \Sigma^*$ and $x,y \in \Sigma^+$
where $u \ne v$ we have that $uv = xwy$ or $u = xw$ or $u = wx$ implies $w \notin C$.
% if for any $u,v \in C$ and $x,y \in \Sigma^*$,
% the condition $uv = xwy$ with $|x| > 0$ or $|y| > 0$
% implies $w \notin C$, i.e., no code word or concatenation
% of two codewords 
These codes, which are a generalization of comma-free codes, 
are well-studied~\cite{zbMATH03943051,DBLP:books/daglib/0025093,golomb_gordon_welch_1958}. % auch comma-free erwähnen, intuition, wie auf wikipedia?
As a new notion, we introduce \emph{strongly self-synchronizing codes} $C \subseteq \Sigma^+$
as languages which fulfill the condition that, for
any $u \in \pref(C)$ and $v \in C$, 
%with $u \notin \pref(v)$ 
%and $x,y \in \Sigma^+$,
%the conditions $uv = xwy$ or $v = xw$ or $v = wx$ imply $w \notin C$. % prefix und suffix erwähnen?
% zu schwach, kann ja in der mitte v als faktor auftreten
%we have $\{ u \} \subseteq \fact(uv) \cap C \subseteq \{ v, u \}$.
if we write $uv = x_1 \cdots x_n$
with $x_i \in \Sigma$ for $i \in \{1,\ldots, n\}$,
then, for any $j \in \{1,\ldots,n\}$ and $k \ge 0$ where $j + k \le n$,
we have that $x_j x_{j + 1} \cdots x_{j+k-1} \in C$
implies\footnote{If $k = 0$, we mean $x_j x_{j+1} \cdots x_{j + k - 1}$ to denote the empty
string. So, $k = |x_j x_{j+1} \cdots x_{j + k - 1}|$. However, note that by definition $\varepsilon\notin C$.} $j = |u| + 1$ and $k = |u| + |v|$
or $j = 1$ and $k = |u|$.
Intuitively, in $uv$ only the last $|v|$ symbols form a factor in $C$
and possibly the first $|u|$ symbols\footnote{Note that,
for example, stipulating that $\{ u \} \subseteq \factor(uv) \cap C \subseteq \{ v, u \}$
for $u \in \pref(C)$ and $v \in C$ is actually a weaker condition.
It allows, for instance, for the factors $u,v$ to occur in the middle of $uv$,
which is excluded.}.
%However, I have seen examples in the literature were such fine points were
%not paid attention too, probably because it is most often intuitively clear
%what is meant. For example, a precursor to self-synchronizing codes
%were comma-free codes, and the original definition~\cite{golomb 2x}
%does not mention that the concatenated words have to be distinct, but
%give examples as $\{ aa, bb \}$ for comma-free codes.
Recall that by definition $\varepsilon \notin C$,
and by choosing $u = \varepsilon$, we find that these codes are infix codes, i.e.,
no proper factor is a code word in $C$. Also, every strongly self-synchronizing code
is a self-synchronizing codes. In Remark~\ref{rem:code_construction},
we will give a method to construct strongly self-synchronizing codes.
\end{comment}

To give some intuition for the strongly self-synchronizing
codes, we also present an alternative characterization, a few examples and a way to construct such codes.

\begin{propositionrep}
A non-empty $C \subseteq \Sigma^+$
is a strongly self-synchronizing code
if and only if, for
all $u \in \pref(C)$ and $v \in C$, 
if we write $uv = x_1 \cdots x_n$
with $x_i \in \Sigma$ for $i \in \{1,\ldots, n\}$,
then, for all $j \in \{1,\ldots,n\}$ and $k \ge 1$ where $j + k - 1 \le n$,
we have that $x_j x_{j + 1} \cdots x_{j+k-1} \in C$
implies $j = |u| + 1$ and $k = |v|$
or $j = 1$ and $k = |u|$.
Intuitively, in $uv$ only the last $|v|$ symbols form a factor in $C$
and possibly the first $|u|$ symbols.
\end{propositionrep}
\begin{proof}
 Let $C \subseteq \Sigma^+$ be a strongly self-synchronizing code.
 Suppose $u \in \pref(C)$ and $v \in C$.
 If $u \notin C$, then we must have $uv \notin \Sigma^*C\Sigma^+$,
 so that, if $uv = x_1 \cdots x_n$ as in the statement,
 we have $x_j \cdots x_{j+k-1}$ if and only if $j = |u| + 1$
 and $k = |u| + |v|$.
 If $u \in C$, then, as $uv \notin \Sigma^+ C \Sigma^+$,
 we find that we have only the possibilities
 $j = 1$ and $k = |u|$ or $j = |u| + 1$ and $k = |u| + |v|$.
 
 Conversely, suppose $C \subseteq \Sigma^+$ is non-empty
 and fulfills the condition mentioned in the statement.
 If $u, v \in C$ and $uv \in \Sigma^+ C \Sigma^+$,
 then we can write $uv = x_1 \cdots x_n$ with $x_i \in \Sigma$ for $i \in \{1,\ldots,n\}$
 and find $2 \le i \le j \le n - 1$
 such that $x_i \cdots x_j \in C$, which contradicts
 the condition in the statement.
 Similarly, if $u \in \pref(C) \setminus C$
 and $v \in C$ with $uv \in \Sigma^*C\Sigma^+$,
 then we can write $uv = x_1 \cdots x_n$ with $x_i \in \Sigma$ for $i \in \{1,\ldots,n\}$
 and find $1 \le i \le j \le n - 1$
 such that $x_i \cdots x_j \in C$, which would contradict
 the condition too. So, we must
 have $C^2 \cap \Sigma^+ C \Sigma^+ = \emptyset$
 and $(\pref(C) \setminus C) C \cap \Sigma^* C \Sigma^+ = \emptyset$.\qed 
\end{proof}

%\begin{remark}
%  To give some intuition on strongly self-synchronizing
%  codes with respect to CSP:
%  These codes ensure that auxiliary states that have to be introduced
%  when passing from words to letters in the reductions
%  were synchronized too, i.e., in some sense the defining conditions ensure that input words
%  do not stay on certain paths between these auxiliary states.
%\end{remark}

 When passing from letters to words by applying a homomorphism, in the reductions,
 we have to introduce additional states. The definition of the strongly synchronizing
 codes was motivated by the demand that these states also have to be synchronized, which turns out to be difficult in general.

\begin{example}\label{ex:strongly_self_sync}
 The code $\{aacc,bbc,bac\}$
 is strongly self-synchronizing.
 The code $\{ aab, bccc, abc \}$ is self-synchronizing, but
 not strongly self-synchronizing as, for example, $(a)(abc)$ 
 contains $aab$ or $(aa)(bccc)$ contains $abc$. 
\end{example}

\begin{toappendix}
 To give a proof of the claim made in Example~\ref{ex:strongly_self_sync}.
\begin{proposition}
 The code $\{aacc,bbc,bac\}$ is strongly self-synchronizing.
\end{proposition}
\begin{proof}
 By checking all cases to combine prefixes with code words:
 \[ 
 \begin{array}{llll}
     \mbox{Non-empty prefixes of $aacc$:} & (a)aacc & (a)bbc & (a)bac \\ 
      & (aa)aacc  & (aa)bbc  & (aa)bac \\ 
      & (aac)aacc & (aac)bbc & (aac)bac \\ 
      & (aacc)aacc & (aacc)bbc & (aacc)bac \\ 
      \\
     \mbox{Non-empty prefixes of $bbc$:} & (b)aacc   & (b)bbc   & (b)bac \\    
     & (bb)aacc  & (bb)bbc  & (bb)bac \\ 
     & (bbc)aacc & (bbc)bbc & (bbc)bac \\ 
     \\
     \mbox{Non-empty prefixes of $bac$:} & (b)aacc   & (b)bbc   & (b)bac \\    
     & (ba)aacc  & (ba)bbc  & (ba)bac \\ 
     & (bac)aacc & (bac)bbc & (bac)bac. 
 \end{array}
 \]
 So, we see that the defining conditions are satisfied. Note that $C \cap \Sigma^*C\Sigma^+ = \emptyset$
 is always satisfied for self-synchronizing codes, as they are infix codes. \qed
\end{proof}
\end{toappendix}



% achso, ne quatsch, c^k+1varphi(L) ist ja nicht das bild varphi(c^{k+1}varphi)
\begin{remark}[Construction] %[Construction of Strongly Self-Synchronizing Codes]
\label{rem:code_construction}
% und damit auch weitere besipiele für self-sync strongly codes
% bzw gibt auch methode zur konstruktion solcher codes
% % darauf in einführung verweisen.
%  Theorem~\ref{thm:constr_sync_hom_strongly_self_sync}
%  is a true generalization of Theorem~\ref{thm:forward_hom}
%  because the code constructed in the assumption
%  is a strongly self-synchronizing code, as we will show next.
%  This also yields a method to construct infinitely many such codes.
% Take any präfix code $X \subseteq \Sigma^*$ and 
% symbol $c \in \Sigma$.
 %such that no word in $X$ begins with it, i.e.,
 %we have $c\Sigma^* \cap X = \emptyset$.
 Take any non-empty finite language $X \subseteq \Sigma^n$, $n > 0$,
 and a symbol $c \in \Sigma$ such that $\{c\}\Sigma^* \cap X = \emptyset$.
 Let $k=\max\{\,\ell\geq0\mid \exists u,v\in\Sigma^*:uc^\ell v\in X\,\}$.
 Then, $Y = c^{k+1}X$
 is a strongly self-synchronizing code.
 %For if $u \in \pref(Y)$ and $v \in Y$,
 %then  in $uv$ no proper factor, except the last $|v|$
 %symbols and possibly the first $u$ symbols, start with $c^{k+1}$. Hence,
 %no such factor is a code word from~$Y$.
\end{remark}

\begin{example}\label{ex:strongly_self_sync_construction}
Let $\Sigma = \{a,b,c\}$
and $C = \{ ab,ba, aa\}$.
Then, $\{ cab, cba, caa \}$ or $\{ bbab, bbaa \}$
are strongly self-synchronizing codes by Remark~\ref{rem:code_construction}.
%constructed according
%to the scheme described in Remark~\ref{rem:code_construction}.
\end{example}




Our next result, which holds in general, states conditions on a homomorphism
such that we not only have a reduction from the problem
for the homomorphic image to our original problem, as stated in Proposition~\ref{prop:hom_lower_bound_complexity},
but also a reduction in the other direction.

\begin{theoremrep}
\label{thm:constr_sync_hom_strongly_self_sync}
 Let $\varphi : \Sigma^* \to \Gamma^*$
 be a homomorphism such that $\varphi(\Sigma)$
 is a strongly self-synchronizing code and $|\varphi(\Sigma)| = |\Sigma|$.
 Then, for each regular $L \subseteq \Sigma^*$ we have
 $
  L\textsc{-Constr-Sync} \equiv_m^{\log} \varphi(L)\textsc{-Constr-Sync}.
 $
\end{theoremrep}
\begin{proof}
 By Proposition~\ref{prop:hom_lower_bound_complexity}, we have 
 $\varphi(L)\textsc{-Constr-Sync} \le_m^{\log} L\textsc{-Constr-Sync}$.
 
 
 Next, we give a reduction 
 from $L\textsc{-Constr-Sync}$ % problem, mit sink state. ne geht auch ohne, wenn in ausgang, dann eifnach noch ein beliebiges zeichen dranhängen vorne, andersrum werden die aus Q gesynct.
 to $\varphi(L)\textsc{-Constr-Sync}$.
 % aber kann man immer ein zeichen dranhängen??? d.h. L muss
 % erlauben, dass zu jedem wort w \in L es u \in \Sigma^+ gibt, so dass uw \in L.
 % bei bounded nicht unbedingt erfüllt...
 %
 % problem L-constr-Sync-sink definieren.
 %
 % für strongly connected äquivalent, wenn man neues zeichen einführt
 %
 %  von einem zustand mit neuen zeichen zu einem sink zustand, andere loopen
 % aber der zustand muss mit consraint-wort erreichbar sein.
 
 %
 % doch geht, wenn in q_x und y und q_{xy} nicht definiert, dann zu q_y, und so bewegt 
 % man sich "in gleihe Richtung" wie das erste ZEichen
 % geht nur vür |u|_i <= 2, also wenn nur ein hilfszustand, sonst größtes
 % suffix von xy so dass noch definiert?
 %
 % am ende soll gelten delta(q_x, \varphi(u)) = delta(q,\varphi(u))
 %  So, delta(q_x, y) = q_z mit z maximales suffix von xy so dass q_x definiert.
 %
 % x\varphi(u) nie präfix für x != eps, also ist varphi(U) das längste derartige suffix.
 %
 Write $\Sigma = \{a_1, \ldots, a_n\}$ with $n = |\Sigma|$
 and $u_i = \varphi(a_i)$ for $i \in \{1,\ldots,n\}$.
 Let $\mathcal A = (\Sigma, Q, \delta)$
 be an input semi-automaton for $L\textsc{-Constr-Sync}$.
 
  We construct a semi-automaton $\mathcal A' = (\Gamma, Q', \delta')$.
  The state set will be
  \[
   Q' = \{ q_x \mid q \in Q, x \in \pref(\{ u_1,\ldots,u_n \}) \setminus \{ u_1,\ldots,u_n \} \}. 
  \]
  By identifying $q_{\varepsilon}$ with the state $q \in Q$,
  we can assume $Q \subseteq Q'$.
  Then, for $q_x \in Q'$ and $y \in \Sigma$, 
  let $z$ be the longest suffix of $xy$
  such that $z \in \pref(\{ u_1,\ldots,u_n\})$ and set\footnote{Note
  the implicit correspondence between the states $q$
  and $q_z$ for $z \in \pref(\varphi(\Sigma)) \setminus \varphi(\Sigma)$.}
  \begin{equation}\label{eqn:def_delta_bar}
   \delta'(q_x, y) = \left\{
   \begin{array}{ll} % todo noch besser formatieren.
    q_{z}          & \mbox{if } z \in \pref(\{ u_1,\ldots,u_n\}) \setminus \{ u_1, \ldots, u_n \}; \\ 
    \delta(q, a_i)  & \mbox{if } \exists i \in \{ 1, \ldots, n \} : z = u_i.
   \end{array}
   \right.
  \end{equation}
  As $|\varphi(\Sigma)| = |\Sigma|$ and $\{ u_1, \ldots, u_n \}$ is a prefix code\footnote{A code
  is a prefix code, if no code word is the proper prefix of another code word.}, the transition function % todo das genauer? opben schreiben impliziert prefix-free, siehe mfcs19
  is well-defined.
%   Then, more generally, for $q_x, q_y \in Q'$
%   and $u \in \Sigma^*$, we
%   have %todo induktiv zeigen?
%   \begin{equation}
%       \delta'(q_x, u) = q_y % q delta
%       \Longleftrightarrow
%       \mbox{$y$ is the longest suffix of $xu$ in $f$
%   \end{equation}
  By construction, for any $u \in \Sigma^*$ and $q \in Q$,
  we have  
  \begin{equation}\label{eqn:comma_free_reduction}
      \delta(q, u) = \delta'(q, \varphi(u)).
  \end{equation}
  
  
  
  
\begin{comment}  
  But we need a more precise statement.
  
  \begin{myclaiminproof}
   Let $q_x, q'_z \in Q'$ and $y \in \Sigma^*$.
   Then,
   \[
    \delta'(q_x, y) = q'_z,
   \]
   where $xy = x_0 u_{i_1} x_1 u_{i_2}\cdots u_{i_m} x_m$
   for $i_1, \ldots, i_m \in \{1,\ldots,n\}$
   and $m$ is maximal with\footnote{Intuitively, these conditions
   express that $xy$ is ``parsed'' greedily for the factors
   from $\varphi(\Sigma)$.}:
   \begin{enumerate}
   \item $u_{i_j} \in \varphi(\Sigma)$ for $j \in \{1,\ldots,m\}$;
   \item for any $j \in \{0,\ldots, m-1\}$
    the word $x_j \in \Sigma^*$ is the shortest word 
    such that there exists $i_{j+1} \in \{1,\ldots,n\}$
    so that $u_{i_{j+1}} \in \varphi(\Sigma)$ and $x_0 u_{i_1} x_1 \cdots u_{i_{j}} x_j u_{i_{j+1}}$
    is a prefix of $xy$
    and $x_m \in \Sigma^*$ is the shortest word which contains
    no factor in $\varphi(\Sigma)$ and could be appended to give $xy$;
   \item $z$ is the longest suffix of $x_m$ in $\pref(\varphi(\Sigma))\setminus \varphi(\Sigma)$;
   \item $q' = \delta'(q, u_{i_1} \cdots u_{i_m}) = \delta(q, a_{i_1}\cdots a_{i_m})$,
    where $a_{i_j} \in \Sigma$ is the unique symbol with $u_{i_j} = \varphi(a_{i_j})$
    for $j \in \{1,\ldots,m\}$.
   \end{enumerate}
  \end{myclaiminproof}
  \begin{myclaimproof}
   We do induction on the length of $y$.
   If $y = \varepsilon$,
   as $q_x \in Q'$, and so $x \in \pref(\varphi(\Sigma)) \setminus \varphi(\Sigma)$,
   as $\varphi(\Sigma)$ is strongly self-synchronizing code,
   %\footnote{Actually, by a closer investigation
   %of the operational mode of the automaton, we see that from any state $q \in Q$
   %we never arrive at a state $q_x$ where $x$ contains a word from $\varphi(\Sigma)$
   %as a factor, even if $\varphi(\Sigma)$ is not strongly self-synchronizing, but only a prefix code.}, 
   the word cannot contain a word from $\varphi(\Sigma)$
   as a proper factor and so $m = 0$ in the above form and we find $z = x$
   and $q' = q$.
   So, now we evaluate $\delta'(q_x, ya)$ for $y \in \Sigma^*$ and $a \in \Sigma$.
   By induction hypothesis, we can write $\delta'(q_x, y) = q_z'$
   with a decomposition of $xy$ as written in the statement of the claim
   for some $m \ge 0$.
   Let $v$ be the longest suffix of $za$ which gives a word in $\pref(\varphi(\Sigma))$
   and write $za = wv$ with $w \in \Sigma^*$.
   If $v \notin \varphi(\Sigma)$,
   then
   \[ %todo x_ma = x'_ma setzen?
    xya = x_0 u_{i_1} x_1 u_{i_2}\cdots u_{i_m} (x_ma)
   \]
   is a new decomposition fulfilling the conditions of the claim
   but with $v$ in place of $z$ and $\delta'(q'_z, a) = q_{v}$.
   If $v\in \varphi(\Sigma)$, then let $i_{m+1} \in \{1,\ldots, n\}$
   be such that $v = u_{i_{m+1}}$ and we find
   \begin{equation}\label{eqn:claim}
    xya = x_0 u_{i_1} x_1 u_{i_2}\cdots u_{i_m} x_m' u_{i_{m+1}}
   \end{equation}
   for some $x_m' \in \Sigma^*$ with $x_m a = x_m' u_{i_{m+1}}$.
   By Equation~\eqref{eqn:comma_free_reduction}, $\delta'(q'_z, a) = \delta'(q', u_{i_{m+1}}) = \delta(q', a_{i_{m+1}})$
   and the claimed conditions are satisfied for the decomposition
   written in Equation~\eqref{eqn:claim}.
  \end{myclaimproof}
\end{comment}

 
\begin{comment}
 \begin{myclaiminproof}
  Let $i \in \{1,\ldots,n\}$ and $q_x \in Q'$.
  Then,
  \[
   \delta'(q_x, u_i) = \delta'(q, u_i) = \delta(q, a_i).
  \]
 \end{myclaiminproof}
 \begin{myclaimproof}
  If $x = \varepsilon$, this is a special case of Equation~\eqref{eqn:comma_free_reduction}.
  So, assume $x \ne \varepsilon$.
  As $\varphi(\Sigma)$
  is a variable-length comma-free code, so in particular a suffix code,
  the longest prefix of $u_i$ which, concatenated with $x$ in front,
  gives a word in $\pref(\{u_1, \ldots, u_n\})$
  is not $u_i$ itself.
  So, we can write $u_i = zay$ with $z,y \in \Sigma^*$ and $a \in \Sigma$ such that
  $z$ is the longest prefix for which
  $xz \in \pref(\{u_1, \ldots, u_n\})$
  holds true. Then,
  $xza \notin \pref(\{u_1, \ldots, u_n\})$
  and let $v$ be the longest suffix of $xza$
  in $\pref(\{u_1, \ldots, u_n\})$.
  By choice $za \in \pref(\{u_1, \ldots, u_n\})$.
  So, $|za| \le |v|$ and $za$ is a suffix of $v$.
  As $xza \notin\pref(\{u_1, \ldots, u_n\})$,
  we have $|v| < |xza|$.
  Write $v = x'za$ with $x' \in \Sigma^*$
  being a proper suffix of $x$.
  %As $q_x \in Q'$, which gives $x \in \pref(\{u_1, \ldots, u_n\}) \setminus \{u_1, \ldots,u_n\}$,
  Write $x = x'' x'$ with $x'' \in \Sigma^+$.
  Then, % todo vereinfachen? bilder zeichnen
  \[
   \delta'(q_{x''}, x') = q_x.
  \]
  %We have $xz \notin \{u_1, \ldots, u_n\}$,
  %as it is a proper factor of $xu_i$
  
  \begin{enumerate}
  \item $xz \notin \{u_1, \ldots, u_n\}$, $v \notin \{u_1, \ldots, u_n\}$
  
   Then, $\delta'(q_x, z) = q_{xz}$
   and $\delta'(q_{xz}, a) = q_v$.
      
  \end{enumerate}
  
  
  
  
  
  %
  % falsch, suffix, nicht präfix
  also $x' \in \pref(\{u_1, \ldots, u_n\}) \setminus \{u_1, \ldots,u_n\}$
  and we find a state $q_{x'} \in Q$.
  Then, as $vy = x'zay = x'u_i$, we can reason inductively, as $|x'| < |x|$,
  that
  \[
   \delta'(q_{x'}, u_i) = \delta'(q, u_i) = \delta(q, a_i).
  \]
  But if we write $x = x' x''$ with $x'' \in \Sigma^+$, by %todo hier equaino nummer referenzieren
  the definition of the transition function
  \[
   \delta'(q_{x'}, x'') = q_{x'x''} = q_x
  \]
  and so
  \[
   \delta(q_x, u_i) = \delta(\delta'(q_{x'}, x''), u_i)
  \]
  
  
  % wenn v \in \{u_1,...,u_n\} dann inducitively 
  
  As $\varphi(\Sigma)$
  is a comma-free code, we cannot have $v \in \{u_1, \ldots, u_n\}$,
  as $v$ is a proper factor of $xzay = xu_i$
  
  
  
  % wenn v nicht in {u1,...,un}
  By the definition of the transition function,
  \[
   \delta(q_x, xza) = q_v
  \]
 
  Then, 
  we must have
  $vy = u_i$.
  
  
 \end{myclaimproof}
\end{comment}

  Let $x \in \pref(\varphi(\Sigma)) \setminus \varphi(\Sigma)$
  and $u_i \in \varphi(\Sigma)$, $i \in \{1,\ldots,n\}$.
  Then, as $\varphi(\Sigma)$
  is a strongly self-synchronizing code, the word $xu_i$ does not contain
  a word from $\varphi(\Sigma)$ , except the suffix $u_i$,
  as a factor. Next, we will argue that, for the unique $a_i \in \Sigma$
  with $\varphi(a_i) = u_i$, the following equations 
  holds true:
  \begin{equation}\label{eqn:strongly_self_sync_transition}
   \delta'(q_x, u_i) = \delta'(q, u_i) = \delta(q, a_i).
  \end{equation}
  For if $v \in \pref(\{ u_i \}) \cap \Sigma$, then the longest suffix of $xv$
  in $\pref(\varphi(\Sigma))$ must be~$v$.
  First, it is a suffix
  from this set.
  Second, if there exists longer one, say $w$,
  then write $ww' \in \varphi(\Sigma)$ for some $w' \in \Sigma^*$.
  In that case, with $xv = x'w$ ($|x'| < |x|$), we have $x'ww' \in xu_i\Sigma^*$
  or $xu_i \in x'ww'\Sigma^+$.
  In the first case, $ww'$ contains the proper factor $u_i \in \varphi(\Sigma)$,
  which is not possible as $\varphi(\Sigma)$ is, in particular, an infix code.
  In the second case, $\{ x'u_i \} \cap \Sigma^* \varphi(\Sigma) \Sigma^+ \ne \emptyset$,
  which is excluded by the property of $\varphi(\Sigma)$ being strongly self-synchronizing.
  So, by the defining equation of $\delta'$, Equation~\eqref{eqn:def_delta_bar},
  if $v \notin \varphi(\Sigma)$, we have
  \[
   \delta'(q_x, v) = q_v,
  \]
  and if $v \in \varphi(\Sigma)$, then $v = u_i$, as $\varphi(\Sigma)$ is a prefix code,
  and
  \[
   \delta'(q_x, v) = \delta'(q_x, u_i) = \delta'(q, u_i) = \delta(q, a_i)
  \]
  with the unique $a_i \in \Sigma$ as above.
  So, in the latter case Equation~\eqref{eqn:strongly_self_sync_transition}
  was established. In the former case,
  if $u_i = vv'v''$, then $\delta'(q_v, v') = q_{vv'}$
  which is easily seen as we always read in a word giving a prefix from $\varphi(\Sigma)$, hence
  this word itself is the longest suffix from $\varphi(\Sigma)$.
  So, after reading the entire word $u_i$, by Equation~\eqref{eqn:def_delta_bar},
  Equation~\eqref{eqn:strongly_self_sync_transition}
  is implied.
  
  
  Lastly, we show that this gives a valid reduction.
  
  \begin{myclaiminproof}
   The automaton $\mathcal A = (\Sigma, Q, \delta)$
   has a synchronizing word in $L$
   if and only if $\mathcal A' = (\Gamma, Q', \delta')$
   has a synchronizing word in $\varphi(L)$.
  \end{myclaiminproof}
  \begin{myclaimproof}
   %\begin{enumerate}
   %\item 
   First, suppose there exists $u \in L$ such that $|\delta(Q, u)| = 1$.
    %By appending words if necessary, we can assume $|u| > 0$. %immernoch sync, zitieren AAHA, ncihtmehr in L unbedingt!!
    If $|Q| = 1$ every word is synchronizing and the statement is obviously true.
    So, we can assume $|Q| > 1$, which implies $|u| > 0$.
    Write $u = av$ with $a \in \Sigma$.
    % Let $q_x \in Q'$.
    % If $x = \varepsilon$, then, by Equation~\eqref{todo, todo in gleichung falsches alphabet!},
    % \[
    %  \delta'(q_x, \varphi(u)) = \delta(q, u).
    % \]
    % Now, suppose $x \ne \varepsilon$ and write $u = av$ with $a \in \Sigma$.
    By Equation~\eqref{eqn:strongly_self_sync_transition}, then, for any $x \in \pref(\varphi(\Sigma))\setminus\varphi(\Sigma)$,
    \[
     \delta'(q_x, \varphi(a)) = \delta(q, a).
    \]
    Hence, $\delta'(Q', \varphi(a)) = \delta(Q, a)$.
    As $\delta'(Q', \varphi(a)) \subseteq Q$, by Equation~\eqref{eqn:strongly_self_sync_transition},
    or its formulation for the special case of states in $Q$, Equation~\eqref{eqn:comma_free_reduction},
    we find
    \[
     \delta'(\delta(Q, a), \varphi(v))) = \delta(\delta(Q, a), v) = \delta(Q, u).
    \]
    The last set is, by assumption, a singleton set. Hence, the word $\varphi(u)$
    synchronizes~$\mathcal A'$. %sprechweise singelton set einführen? todo
   
    \medskip 
    
    Now, suppose there exists $u \in \varphi(L)$ such that $|\delta'(Q', u)| = 1$.
     Let $v \in \Sigma^*$ be such that $\varphi(v) = u$.
     By Equation~\eqref{eqn:strongly_self_sync_transition} (or Equation~\eqref{eqn:comma_free_reduction}),
     we have
     \[
      \delta(Q, v) = \delta'(Q, \varphi(v)).
     \]
     By assumption, the set on the right side is a singleton set. 
     Hence, $v$ synchronizes $\mathcal A$.
   %\end{enumerate}
  \end{myclaimproof}
  So, we find $L\textsc{-Constr-Sync} \le_m^{\log} \varphi(L)\textsc{-Constr-Sync}$
  and the proof is done.
\end{proof}

\begin{comment}
% Doch komplizierter, erstmal rauslassen.
% 
%We need the following fact, which is implied by the constructions
%in the previous proof. 
In general, regular languages are closed under homomorphic mappings,
but an exponential blow-ups might occur~\cite{projections paper}.
However, such a blow-up does not occur for mappings whose images
are strongly self-synchronizing codes.

\begin{proposition}
 Let $\varphi : \Sigma^* \to \Gamma^*$
 be a homomorphism such that $\varphi(\Sigma)$
 is a strongly self-synchronizing code and $\mathcal A = (\Sigma, Q, \delta, q_0, F)$
 be a PDFA.
 Then, we can construct in polynomial time
 a PDFA $\mathcal A' = (\Gamma, Q', \delta', q_0', F')$
 such that $\varphi(L) = L(\mathcal A')$.
\end{proposition}
\begin{proof}
%  Let $\mathcal A' = (\Gamma, Q', \delta', q_0', F')$
%  be the PDFA where the state set is given by Equation~\eqref{todo oben}
%  and the transition function given by Equation~\eqref{todo oben},
%  derived from the state set and transition function of $\mathcal A$.
%  As written in the proof of Theorem~\ref{thm:constr_sync_hom_strongly_self_sync},
%  we can assume $Q \subseteq Q'$.
%  Then, set $q_0' = q_0$ and $F' = F$.
%  By Equation~\eqref{eqn:strongly_self_sync_transition},
%  we have $\varphi(L) = L(\mathcal A')$.
%  % ne, nur varphi(L) \substeq L(\mathcal A'), wenn z.B. u \in L, dann uU x\varphi(u) 
 % mit der zurücklauf-Regel!!!! siehe den claim danach

 Todo, insbesondere präfixcode, teile dazwischen undefiniert lassen
 aber kann von teilen dazwische zu final laufen?
 dann aber suffix oder so, zeigen, dass hier nicht sein kann.
 
 
 Oder, ohne automaten? aber darstellunge mit j,p's muss auch berechnet werden...
 % unitär, d.h. single-state final bounded languages?
 
 
 Mit $C^*$ schneiden und nutzen, dass suffix code?
\end{proof}
\end{comment}

Finally, we apply Theorem~\ref{thm:constr_sync_hom_strongly_self_sync} to bounded languages
such that $\{ w_1, \ldots, w_k\}$ forms a strongly self-synchronizing code.

\begin{theoremrep}
 Let $L \subseteq w_1^* \cdots w_k^*$
 be regular such that $\{ w_1, \ldots, w_k \}$
 is a strongly self-synchronizing code.
 Then, $L\textsc{-Constr-Sync}$
 is either $\NP$-complete or in $\PTIME$. %solvable in polynomial time.
 %Moreover, the complexity itself, given a constraint PDFA as input,
 %could be decided in polynomial time.
\end{theoremrep}
\begin{proof}
 Let $\Gamma = \{ a_1, \ldots, a_n \}$
 be a new alphabet and let $\varphi : \Gamma^* \to \Sigma^*$
 be the homomorphism given by
 $\varphi(a_i) = w_i$ for $i \in \{1,\ldots, n\}$.
% As $\{ u_1, \ldots, u_n \}$ is a code, the homomorphism
% is injective % todo berstel/perrin zitieren?
% and 
 Let $U = \varphi^{-1}(L)$. 
 As every word in $L$
 is a concatentation of words from $\{ w_1, \ldots, w_n \}$,
 we have $L \subseteq \varphi(\Gamma^*)$.
 So, we find $\varphi(U) = L$.
%  By Theorem~\cite{todo}, we can write
%  \[
%   L = \bigcup_{r=1} 
%  \]
%  for numbers $j_i^{(r)}, p_i^{(r)}$
%  By Theorem~\cite{todo}, we can write $L$
%  as a finite union of languages of the form
%  \[
%   u_1^{j_1} (u_1^{p_1})^* \cdots u_n^{j_n} (u_n^{p_n})^*
%  \]
%  for numbers $j_i, p_i \ge 0$, $i \in \{1,\ldots,n\}$.
%  Now, observe that
%  \[
%   \varphi(  a_1^{j_1} (a_1^{p_1})^* \cdots a_n^{j_n} (a_n^{p_n})^* ) = 
%   u_1^{j_1} (u_1^{p_1})^* \cdots u_n^{j_n} (u_n^{p_n})^*.
%  \]
%  Also, as function application on sets preserves the union,
%  $\varphi(L)$
%  is a union of languages 
%  of the form $a_1^{j_1} (a_1^{p_1})^* \cdots a_n^{j_n} (a_n^{p_n})^*$
%  such that the numbers $j_i, p_i$, $i \in \{1,\ldots,n\}$,
%  are the same as those of the corresponding part in $L$.
%  So, we an apply Proposition~\ref{strictly bounded np-hard}
%  and Proposition~\ref{striclty bounded poly}
%  are preserved, i.e., we can apply those proposition

 By Theorem~\ref{thm:constr_sync_hom_strongly_self_sync},
 the languages $U$ and $L$
 have the same computational complexity.
 Also, as is easy to check, we have $U \subseteq a_1^* \cdots a_n^*$
 and $U$ is regular.
 So, by Theorem~\ref{thm:dichotomy}
 the constrained synchronization problem for $L$
 is either $\NP$-complete or in $\PTIME$.
\end{proof}

\begin{example}
 (1) $((aacc)(bbc)^*(bac))$\textsc{-Constr-Sync} is \NP-complete. \\
 (2) $((bbc)(aacc)(bac)^* \cup (bbc)^*)$\textsc{-Constr-Sync} is in \PTIME.
\end{example}


% \begin{theorem} \label{thm:forward_hom}
% 	Let $L\subseteq\Sigma^*$.
% 	%	Let $\mathcal B = (\Sigma, Q, \mu, q_0, F)$ and $\mathcal B' = (\Gamma, Q', \mu', q_0', F')$
% 	%	be two 	constraint automata.
% 	Let $\varphi : \Sigma \to \Gamma^*$ be a homomorphism %injective\todo{HF: Ich habe Inj. nicht benötigt!}
% 	such that $\varphi(\Sigma)$ is a prefix code.
% 	%and $\varphi(L(\mathcal B)) = L(\mathcal B')$.
% 	%	Let $c\notin\Gamma$.
% 	Let $c \in \Gamma$ with $\{c\}\Gamma^*\cap \varphi(\Sigma)=\emptyset$.
% 	Let $k:=\max\{\,\ell\geq0\mid \exists u,v\in\Gamma^*:uc^\ell v\in\varphi(\Sigma)\,\}$.
% 	% and let $k$ be the maximal number of consecutive appearances of $c$ in any code-word of $\varphi(\Sigma)$.
% 	Then
% 	$
% 	L%(\mathcal B)
% 	%	\textsc{-Constr-Sync} \leq^{\log}_m \{c\}\varphi(L)%(\mathcal B')
% 	\textsc{-Constr-Sync} \leq^{\log}_m \{c^{k+1}\}\varphi(L)%(\mathcal B')
% 	\textsc{-Constr-Sync}\,.
% 	$	
% 	%	with $L(\mathcal B'') = cL(\mathcal B')$.
% \end{theorem}



%
% Künstliches problem
%
%  Sigma mit Input-Automaten nur max {a,b} != Identität
%  mit ergebnissen 3-state case pspace-falls, np-fall alles realisierbar
%  
% aber ist praktische gleich zu alfphabet auf {a,b} einschränken...
%
% L \subseteq u^* v^* w^*
%
% ersetze durch (ccu)^* (ccv)^* (ccw)^*
%
% u_1^* ... u_n^* 
% kann man durch löschen eines buchstaben strongly self-sync code herstellen?
% falls ja, gelöschter buchstaben eingabeautomat identität, dann gleiche komplexität
%
% kann ich u^*v^*w^* entschieden, dann auch (ccu)^* (ccv)^* (ccw)^*, wobei
% c identität auf eingabeautomaten.
%
% andersrum definieren ccu, ccv, ccw als eingabe;
% so umdefinieren, dass in neuem autoamten ccu = u usw als abbildugnen
% wenn u,v,w einzelner buchstaben, dann geht es einfach. aber allgemein
% z.B. ccab, ccba, ccbb
% 
% kann man a,b so umdefinieren, dass ab = ccab usw?
% (btw entscheidungsproblem)
% 
% gegeben eine abbildung f und ein wort w über a,b
% Frage: Kann man a,b so als abbilungen belegen, dass f = w wenn w darüber ausgewertet?
% -> in dem fall klar, a^|w| = f, b = identität geht
% ein wenig wie gleichungen lösen