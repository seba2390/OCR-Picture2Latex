\documentclass[runningheads,envcountsame]{llncs}
%\documentclass{article}
%
%\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{comment}
%\usepackage[color=gray!27]{todonotes}
\usepackage[disable]{todonotes}
\usepackage[utf8]{inputenc}
%\usepackage[english,russian]{babel}
\usepackage{inputenc}
\usepackage{shuffle}
\usepackage{multirow}
\usepackage{listings}
\usepackage{mathabx}
%\usepackage[sectionbib, square,sort,comma,numbers]{natbib}
%\usepackage{adjustbox}

%\usepackage{thmtools, thm-restate}
\usepackage{hyperref}

\usepackage{shuffle}

\usepackage{tikz}
\usetikzlibrary{positioning,shadows,arrows}
\usetikzlibrary{arrows,automata,positioning,calc}


% https://tex.stackexchange.com/questions/7262/diagonally-divided-table-cell?noredirect=1&lq=1
\usepackage{diagbox}
\usepackage{slashbox}
\usepackage{tikz}
\usetikzlibrary{matrix}


%todo extradatei für review-bemerkungen
\lstset{%
  language=[LaTeX]TeX,
  backgroundcolor=\color{gray!10},
  basicstyle=\ttfamily,
  breaklines=true,
  columns=fullflexible
}


%\usetikzlibrary{arrows,shapes,automata,positioning}

\newcommand{\perm}{\operatorname{perm}}
\newcommand{\stc}{\operatorname{sc}}
\newcommand{\lastsym}{\operatorname{last}}




\usepackage{blindtext,tikz}
\usetikzlibrary{calc}


% \usepackage{apxproof}
% \theoremstyle{plain}
% \newtheoremrep{theorem}{Theorem}%[section]
% \newtheoremrep{proposition}[theorem]{Proposition}
% \newtheoremrep{lemma}[theorem]{Lemma}
% \newtheoremrep{claim}[theorem]{Claim}
% \newtheoremrep{conjecture}[theorem]{Conjecture}
% \newtheoremrep{corollary}[theorem]{Corollary}
% \newtheoremrep{definition}[theorem]{Definition}
 
 
\usepackage{apxproof}
\theoremstyle{plain}
%\newcounter{theorem2}
% \newtheoremrep{theorem}{Theorem}[section] % wie mit einem zähler durchnummerieren?
% \newtheoremrep{proposition}[theorem]{Proposition}
% \newtheoremrep{lemma}[theorem]{Lemma}
% \newtheoremrep{claim}[theorem]{Claim}
% \newtheoremrep{conjecture}[theorem]{Conjecture}
% \newtheoremrep{corollary}[theorem]{Corollary}
% \theoremstyle{definition}
% \newtheoremrep{definition}[theorem]{Definition}
%\theoremstyle{remark}
%\newtheoremrep{example}[theorem]{Example}
%\newtheoremrep{remark}[theorem]{Remark}
\newtheoremrep{theorem}{Theorem}
\newtheoremrep{proposition}[theorem]{Proposition}
\newtheoremrep{lemma}[theorem]{Lemma}
\newtheoremrep{claim}[theorem]{Claim}
\newtheoremrep{conjecture}[theorem]{Conjecture}
\newtheoremrep{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheoremrep{definition}[theorem]{Definition}
 
% https://tex.stackexchange.com/questions/104098/create-a-claim-environment
\newenvironment{claiminproof}[1]{\medskip\par\noindent\underline{Claim:}\space#1}{}
\newenvironment{claimproof}[1]{\begin{quote}\par\noindent\emph{Proof of the Claim:}\space#1}{[\emph{End, Proof of the Claim}]\end{quote}}%\newline}
% {\leavevmode\unskip\penalty9999 \hbox{}\nobreak\hfill\quad\hbox{$\blacksquare$}}
 
% \usepackage[printwatermark]{xwatermark}
% \usepackage{xcolor}
% \usepackage{graphicx}
% \newwatermark[pagex={1},color=gray!20,angle=45,scale=1.5,xpos=-10,ypos=70]{This paper eligible for the best student paper award, \\ as I am a PhD student
% under the supervision of Prof. Dr. Henning Fernau.} %Submission for review. \\ Full proofs in Appendix.}



\usepackage{fancyhdr}

 
\DeclareMathOperator{\lcm}{lcm}

%\def\baselinestretch{0.99}
%\linespread{0.9}
  
 %\usepackage[small,compact]{titlesec}
%\usepackage[small]{titlesec}

%\usepackage[text={12cm,20cm}]{geometry}
% \usepackage[compact]{titlesec}
% \titlespacing*{\section}{0pt}{2ex}{1ex}
%\titlespacing*{\subsection}{0pt}{1.6ex}{0.7ex}

% http://www.terminally-incoherent.com/blog/2007/09/19/latex-squeezing-the-vertical-white-space/
% http://www-h.eng.cam.ac.uk/help/tpl/textprocessing/squeeze.html
% https://robjhyndman.com/hyndsight/squeezing-space-with-latex/
   
 
%\def\dotminus{\mathbin{\ooalign{\hss\raise1ex\hbox{.}\hss\cr
%  \mathsurround=0pt$-$}}} 
 
% https://tex.stackexchange.com/questions/103735/list-of-todos-todonotes-is-empty-with-llncs?noredirect=1
%\setcounter{tocdepth}{1}



% https://tex.stackexchange.com/questions/186677/big-shuffle-symbol
% large ops, copied from shuffle font package
\DeclareFontFamily{U}{bigshuffle}{}
\DeclareFontShape{U}{bigshuffle}{m}{n}{
  <5-8> s*[1.7] shuffle7
  <8->  s*[1.7] shuffle10
}{}
\DeclareSymbolFont{BigShuffle}{U}{bigshuffle}{m}{n}
\DeclareMathSymbol\bigshuffle{\mathop}{BigShuffle}{"001}
\DeclareMathSymbol\bigcshuffle{\mathop}{BigShuffle}{"002}

\newcommand{\suff}{\operatorname{Suff}}
\newcommand{\factor}{\operatorname{Fact}}

\newcommand{\pref}{\operatorname{Pref}}

\newcommand{\Orb}{\operatorname{Orb}}

\newcommand{\NC}{\textsf{NC}}
\newcommand{\NL}{\textsf{NL}}
\newcommand{\NP}{\textsf{NP}}
\newcommand{\PSPACE}{\textsf{PSPACE}}
\newcommand{\NPSPACE}{\textsf{NPSPACE}}
\newcommand{\PTIME}{\textsf{P}}
\newcommand{\XP}{\textsf{XP}}


% https://latex.org/forum/viewtopic.php?t=10877
% https://latex.org/forum/viewtopic.php?f=47&t=10862
% https://tex.stackexchange.com/questions/36423/random-unwanted-space-between-paragraphs
%\raggedbottom



% https://tex.stackexchange.com/questions/255673/problem-definition-environment
% https://www.overleaf.com/learn/latex/Environments
% https://de.overleaf.com/learn/latex/Counters
% https://en.wikibooks.org/wiki/LaTeX/Counters
% https://de.wikibooks.org/wiki/LaTeX-W%C3%B6rterbuch:_refstepcounter
\usepackage{tabularx,lipsum,environ,amsmath,amssymb}

%\usepackage{natbib}
%\usepackage{biblatex}
%\addbibresource{ms.bib}


\newcounter{problemcounter}
\makeatletter
\newcommand{\problemtitle}[1]{\gdef\@problemtitle{#1}}% Store problem title
\newcommand{\probleminput}[1]{\gdef\@probleminput{#1}}% Store problem input
\newcommand{\problemquestion}[1]{\gdef\@problemquestion{#1}}% Store problem question
\NewEnviron{decproblem}{
  \refstepcounter{problemcounter}
  \problemtitle{}\probleminput{}\problemquestion{}% Default input is empty
  \BODY% Parse input
  \par\addvspace{.5\baselineskip}
  \noindent
  \begin{tabularx}{\textwidth}{@{\hspace{\parindent}} l X c}
    \multicolumn{2}{@{\hspace{\parindent}}l}{\textbf{Decision Problem \theproblemcounter:} \@problemtitle} \\% Title
    \textbf{Input:} & \@probleminput \\% Input
    \textbf{Question:} & \@problemquestion% Question
  \end{tabularx}
  \par\addvspace{.5\baselineskip}
}
\makeatother
 
 
 
% % https://tex.stackexchange.com/questions/104098/create-a-claim-environment
 \newenvironment{myclaiminproof}[1]{\medskip\par\noindent\underline{Claim:}\space#1}{}
 \newenvironment{myclaimproof}[1]{\begin{quote}\par\noindent\emph{Proof of the Claim:}\space#1}{[\emph{End, Proof of the Claim}]\end{quote}}%\newline}
% % {\leavevmode\unskip\penalty9999 \hbox{}\nobreak\hfill\quad\hbox{$\blacksquare$}}




\renewcommand{\headrulewidth}{0pt}
\fancypagestyle{AllPages}{
\chead{2016 IEEE/ACM International Conference on Advances in Social Networks Analysis and Mining (ASONAM)}
}
\fancypagestyle{FirstPage}{
\chead{2016 IEEE/ACM International Conference on Advances in Social Networks Analysis and Mining (ASONAM)}
\lfoot{IEEE/ACM ASONAM 2016, August 18-21\\2016, San Francisco, CA,     USA\\
978-1-5090-2846-7/16/\$~\copyright~2016 IEEE}
}

\chead{2016 IEEE/ACM International Conference on Advances in Social Networks Analysis and Mining (ASONAM)}


\begin{document}

%
\title{Computational Complexity of Synchronization under Sparse Regular Constraints}
%\title{State Complexity of Projected Languages of Permutation Automata}
%\title{State Complexity of Projection on Permutation Automata}
\titlerunning{Synchronization under Sparse Regular Constraints}

%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Stefan Hoffmann\orcidID{0000-0002-7866-075X}}
%
\authorrunning{S. Hoffmann}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Informatikwissenschaften, FB IV, 
  Universit\"at Trier, Germany, 
  \email{hoffmanns@informatik.uni-trier.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
%  We investigate the constrained synchronization problem for weakly acyclic, or partially ordered,
%  input automata. We show that, for input automata of this type, the problem is always
%  in $\NP$.
%  Furthermore, we give a full classification of the realizable complexities for constraint
%  automata with at most two states and over a ternary alphabet.
%  For certain constraint languages, for which the general problem is $\PSPACE$-complete,
%  for weakly acyclic automata we get $\NP$-complete problems, whereas there are also
%  problems that are $\PSPACE$-complete in general, but for which
%  it is polynomial time solvable in our setting.
%  %when only weakly acyclic automata
%  %are considered as input. 
%  %In the course of our investigation, 
%  We also investigate
%  two problems related to subset synchronization, namely if there exists
%  a word mapping all states into a given target subset of states, and
%  if there exists a word mapping one subset into another. Both problems
%  are $\PSPACE$-complete in general, but in our setting the former is polynomial time solvable and the latter is $\NP$-complete.
%  %
%  % genauer bescchreiben
%  % sync wort in vorgegebener
%  % reg. sprache?
 The constrained synchronization problem (CSP) asks
 for a synchronizing word of a given input automaton
 contained in a regular set of constraints. It could be viewed
 as a special case of synchronization of a discrete event system
 under supervisory control.
 Here, we study the computational complexity of this %the constrained synchronization
 problem for the class of sparse regular constraint languages.
 We give a new characterization of sparse regular sets, which
 equal the bounded regular sets,
 and derive a full classification of the computational complexity
 of CSP for letter-bounded regular constraint
 languages, which properly
 contain the strictly bounded regular languages.
 %In addition, we derive a polynomial time decision procedure
 %for the complexity of the constrained synchronization problem, given
 %a constraint automaton recognizing a strictly bounded regular language
 %as input.
 Then, we introduce strongly self-synchronizing codes
 and investigate CSP for  bounded languages induced by these codes.
 With our previous result, we deduce a full classification
 for these languages as well.
 In both cases, depending on the constraint language, our problem
 becomes $\NP$-complete or polynomial time solvable.
 %Additionally, we state a new characterization of bounded languages.
 
 %
 % keywords überarbeiten
 % und hinweis für student best paper
\keywords{automata theory \and constrained synchronization \and computational complexity \and sparse languages \and bounded languages \and strongly self-synchronizing codes} 
\end{abstract}
%
%
%

%\thispagestyle{FirstPage}
% \thispagestyle{fancy}
% \chead{}%\hspace*{-4cm} 
% \lhead{}
% \definecolor{mygray}{gray}{0.6}
% \definecolor{mypink1}{rgb}{0.558, 0.188, 0.278}
% \lfoot{\footnotesize \textcolor{mypink1}{Paper eligible for best student \\ paper award. I am a PhD student \\
%  under the supervision of \\ Prof. Dr. Henning Fernau.}}

% https://tex.stackexchange.com/questions/7400/watermark-on-first-page-in-left-margin-like-arxiv

%\blinddocument 



\section{Introduction} %contribution
\label{sec:introduction}




\input{introduction}

\section{Preliminaries and Definitions}
\label{sec:preliminaries}

\input{preliminaries}


\input{sparse}

\input{strictly_bounded}


\input{strongly_self_sync}

\section{Conclusion and Discussion}

We have looked at the constrained synchronization problem (Problem~\ref{def:problem_L-constr_Sync}) -- CSP for short -- for letter-bounded regular constraint languages and bounded languages induced by strongly self-synchronizing codes, thereby
continuing the investigation started in~\cite{DBLP:conf/mfcs/FernauGHHVW19}.
The complexity landscape in these cases is completely understood.
Only the complexity classes $\PTIME$ and $\NP$-complete arise.
%, and
%we have given conditions precisely when it is in $\PTIME$ and when it is $\NP$-complete.
In~\cite{DBLP:conf/ictcs/Hoffmann20} the question was raised if we can find sparse constraint languages
that give constrained problems complete for some candidate $\NP$-intermediate complexity class. At least for the
language classes investigated here
this is not the case. 
%Lastly, we have given a polynomial time procedure to decide the computational complexity of $L(\mathcal B)\textsc{-Constr-Sync}$, for a given automaton $\mathcal B$ accepting a strictly bounded regular language. 
For general sparse regular languages, it is still open if a corresponding
dichotomy theorem holds, or candidate $\NP$-intermediate problems arise. By the results obtained so far and the methods
of proofs, we conjecture that in fact a dichotomy
result holds true.


%
% Ne, kann sogar gemacht werden, da ja nur inverse bild automat gebaut werden muss, und das geht
% ohne blow-up.
%A decision procedure as exhibited in Subsection~\ref{sec:decision_procedure}
%could also be easily given for the constraint languages considered in Subsection~\ref{subsec:strongly_self_sync}
%by the methods of proof and a homomorphic mapping from a strictly bounded language. However, I do not know if this is also possible in polynomial time,  as 

%In a previous work~\cite{DBLP:conf/ictcs/Hoffmann20}, we have shown that for polycyclic languages,
%which equal the sparse regular languages by Theorem~\ref{thm:bounded_characterizations},
%CSP is always in \NP\  and also gave partial result for \NP-hardness and containment in \PTIME.

Let us relate our results to the previous work~\cite{DBLP:conf/ictcs/Hoffmann20}, where
partial results for \NP-hardness and containment in \PTIME\  were given.
Namely, by setting $\factor(L) = \{ v \in \Sigma^* \mid \exists u,w \in \Sigma^* : uvw \in L \}$
and $\mathcal B_{p,E} = (\Sigma, P, \mu, q, E)$
for $\mathcal B = (\Sigma, P, \mu, p_0, F)$ with $E \subseteq P$ and $q \in P$,
the following was stated.

\begin{proposition}[\cite{DBLP:conf/ictcs/Hoffmann20}]
\label{prop:NPc}
 Suppose we find $u, v \in \Sigma^*$ 
 such that we can write
$
 L = u v^* U
$
 for some non-empty language $U \subseteq \Sigma^*$
 with 
 $
  u \notin \factor(v^*), %\quad
  v \notin \factor(U) \mbox{ and } %\quad
  \pref(v^*) \cap U = \emptyset.
 $
 Then $L\textsc{-Constr-Sync}$ is $\NP$-hard.
\end{proposition}

\begin{proposition}[\cite{DBLP:conf/ictcs/Hoffmann20}]
\label{prop:NP_in_P}
  Let $\mathcal{B} = (\Sigma, P, \mu, p_0, F)$ be a polycyclic PDFA.
  If for every reachable $p \in P$ with $L(\mathcal B_{p, \{p\}}) \ne \{\varepsilon\}$ 
  we have $L(\mathcal B_{p_0, \{p\}}) \subseteq \suff(L(\mathcal B_{p, \{p\}}))$,
  then the problem $L(\mathcal B)\textsc{-Constr-Sync}$ is solvable
  in polynomial time.
\end{proposition}

Note that Proposition~\ref{prop:NPc} implies that $ab^*a$
gives an \NP-complete CSP. However, in the letter-bounded
case there exist constraint languages giving \NP-complete problems
for which this is not implied by Proposition~\ref{prop:NPc},
for example: $ab^*ba$, $ab^*ab$, $aa^*abb^*a$ or $ba^*b \cup a$.
Also, Proposition~\ref{prop:NP_in_P}
is weaker than our Proposition~\ref{prop:stricly_bounded_P}
in the case of letter-bounded constraints.
For example, it does not apply to $ab^*b$, every PDFA for this languages
has a loop exclusively labelled by the letter~$b$
and reachable after reading the letter $a$ from the start state, and
so words along this loop cannot have a word starting with $a$ as a suffix.






For general bounded languages, let us note the following implication of Propositions~\ref{prop:hom_lower_bound_complexity}
and~\ref{prop:stricly_bounded_P}.

\todo{Sind thin languages eigentlich die in $w^*$?}

\begin{propositionrep}
 Let $u,v \in \Sigma^*$. If $L \subseteq u^* v^*$ is regular, then $L$\textsc{-Constr-Sync} is solvable
 in polynomial time.
\end{propositionrep}
\begin{proof}
 Let $\Gamma = \{a,b\}$
 and $\varphi : \Gamma^* \to \Sigma^*$
 be the homomorphism given by $\varphi(a) = u$
 and $\varphi(b) = v$.
 Define $N = \{ (i,j) \mid u^i v^j \in L \}$
 and set $L' = \{ a^i b^j \mid (i,j) \in N \} \subseteq a^* b^*$.
 Then, $\varphi(L') = L$
 and by Proposition~\ref{prop:stricly_bounded_P}
 we have $L'\textsc{-Constr-Sync} \in \PTIME$.
 So, with Proposition~\ref{prop:hom_lower_bound_complexity}
 also $L\textsc{-Constr-Sync} \in \PTIME$.~\qed
\end{proof}

Next, in Proposition~\ref{prop:np_complete_case}, we give an example
of a bounded regular language yielding an $\NP$-complete synchronization problem,
 but for which this is
 not directly implied by the results we have so far.

% \begin{remark}\label{rem:np_complete_case}
%  The bounded language $L = (ab)(ba)^*(ab)$
%  gives an $\NP$-complete synchronization problem, but this is
%  not directly implied by our methods.
 
 \begin{propositionrep}\label{prop:np_complete_case}
  The problem $((ab)(ba)^*(ab))$\textsc{-Constr-Sync} is $\NP$-complete.
 \end{propositionrep}
 \begin{proof}
 We give a reduction from $\textsc{DisjointSetTransporter}$
 for unary input semi-automata, which is $\NP$-complete
 by Theorem~\ref{prop:set_transporter_np_complete}.
 Let $\mathcal A = (\{c\}, Q, \delta)$
 with $S, T \subseteq Q$ being disjoint.
 Construct the automaton $\mathcal A' = (\{a,b\}, Q', \delta')$
 with
 \[
  Q' = Q \cup \{ q_a \mid q \in Q \} \cup \{ q_b \mid q \in Q \} \cup \{ t \}. 
 \]
 Fix some $\hat s \in S$.
 Then, for $q \in Q$, set
 % loop q_a mit a, und q_b bei b
 % aber dass für reduktion von cd^*c - vielleicht auch bemerken.
%  \[
%   \delta'(q, x) = \left\{ 
%   \begin{array}{ll}
%   q_x  & \mbox{if } q \in Q; \\ 
%   q    & \mbox{if } q  
%   \end{array}
%   \right.
%  \]
\begin{align*}
    \delta'(t,   x) & = t \mbox{ for } x \in \Sigma \mbox{ and }
    \delta'(q,   x) = q_x \mbox{ for } x \in \Sigma; \\
    \delta'(q_b, b) & = t   \mbox{ for } q_b \in Q'  \mbox{ and } 
    \delta'(q_b, a) = \delta(q, c); \\
    \delta'(q_a, a) & = q_a \mbox{ for } q_a \in Q'; \\
    \delta'(q_a, b) & = \left\{ 
    \begin{array}{ll}
     \hat s & \mbox{if } q \in Q \setminus (T \cup S); \\
     q      & \mbox{if } q \in S; \\
     t      & \mbox{if } q \in T.
    \end{array}
    \right.
\end{align*}
 Then, there exists $n \ge 0$
 with $\delta(S, c^n) \subseteq T$
 if and only if $\mathcal A'$ has a synchronizing word in $L$.
 % S,T disjoint, deswegen ba mindestens einmal
 
 First, suppose there exists $n \ge 0$
 such that $\delta(S, c^n) \subseteq T$.
 By construction, $S \subseteq \delta'(Q', ab) \subseteq S \cup \{t\} \cup Q_b$,
 or more precisely $\delta'(Q', ab) = S \cup \{t\} \cup \{ q_b \mid q \in \delta(Q, c) \}$.
 Note that, as $S$ and $T$ are disjoint,
 we must have $n > 0$.
 As, for any $q \in Q$, $\delta'(q, ba) = \delta(q, c)$
 and $\delta(q_b, b) = t$,
 we find $\delta'(\delta'(Q', ab), (ba)^n) \subseteq T \cup \{t\}$,
 where we needed $n > 0$ to map those states in $\{ q_b \mid q \in \delta(Q, c) \}$
 to $T$.
 Finally, $\delta(T \cup \{t\}, ab) = \{t\}$
 and so $\delta'(Q', ab(ba)^nab) = \{t\}$.
 
 
 Conversely, suppose there exists $n \ge 0$
 such that $\delta'(Q', ab(ba)^nab)$
 is a singleton set. So, as $t$ is a sink state,
 $\delta'(Q', ab(ba)^nab) = \{ t \}$.
 By construction, a state in $Q'$ is mapped to $t$
 by $ab$
 if and only if it is contained in $T \cup \{t\}$.
 Hence, $\delta'(Q', ab(ba)^n) \subseteq T \cup \{t\}$.
 As before, $\delta'(Q', ab) = S \cup \{t\} \cup \{ q_b : q \in \delta(Q, c) \}$.
 In particular, we must have $\delta'(S, (ba)^n) \subseteq T \cup \{t\}$.
 As, for any $q \in Q$, $\delta'(q, ba) = \delta(q, c)$,
 this implies that $\delta'(S, (ba)^n) \subseteq T$
 and that for $u = c^n$ we have $\delta(S, c^n) \subseteq T$.
 
 
 By Theorem~\ref{thm:sparse_in_NP}, $L\textsc{-Constr-Sync}\in \NP$
 and by the above reduction the problem is $\NP$-complete.
 \end{proof}
%\end{remark}

 By Proposition~\ref{prop:np_complete_case},
 for the homomorphism $\varphi : \{a,b\}^* \to \{a,b\}^*$
 given by $\varphi(a) = ab$ and $\varphi(b) = ba$
 both problems $ab^*a$ and $\varphi(ab^*a) = ab(ba)^*ab$
 are \NP-complete. So, this is a homomorphisms
 which preserves, in this concrete instance, the computational complexity.
 But its image $\{ab,ba\}$ is not even a self-synchronizing code.\todo{Ich glaube in dem fall schon. die reduktion sollte immer gehen...}
 However, I do not know if this homomorphism always preserves the complexity.
 Similary, I do not know
 if the condition from Theorem~\ref{thm:constr_sync_hom_strongly_self_sync}
 characterizes those homomorphisms which preserve the complexity.
 %also shows that injective homomorphisms whose image forms a strongly
 %connected code do not characterize those homomorphisms



 In the reduction used in Lemma~\ref{lem:np_hardness}
 the resulting automaton has a sink state. However, in general, for questions
 of synchronizability it makes a difference if we have a sink state
 or not, at least with respect to the \v{C}ern\'y conjecture~\cite{Cer64},
 as for automata with a sink state this conjecture holds true,
 even with the better bound\footnote{In~\cite{DBLP:journals/tcs/Rystsov97}
 erroneously the bound $n(n+1)/2$ was reported as being sharp, but the overall argument
 in fact works to yield the sharp bound $n(n-1)/2$.}
 $\frac{n(n-1)}{2}$~\cite{DBLP:journals/tcs/Rystsov97,DBLP:journals/tcs/Volkov09}. However,
 even in~\cite{DBLP:conf/mfcs/FernauGHHVW19}
 certain reductions establishing \PSPACE-completeness
 use only automata with a sink state. Hence, for hardness
 these automata are sufficient at least in certain instances.
 So, it might be interesting to know
 if in terms of computational complexity of the CSP,
 %it makes no difference if we consider automata with or without a sink state.
 we can, without loss of generality, limit ourselves to input automata
 with a sink state. The methods of proof for the letter-bounded constraints
 show that in this case, we can actually do this, as these input automata
 are sufficient to establish all cases of intractability.
 

 Lastly, let us mention the following related problem\footnote{This was actually suggested
 by a reviewer of a previous version.} one could come up with.
 Fix a deterministic and complete semi-automaton~$\mathcal A$.
 Then, for input PDFAs~$\mathcal B$, what is the computational complexity to determine
 if $\mathcal A = (\Sigma, Q, \delta)$ has a synchronizing word in $L(\mathcal B)$?
 As the set of synchronizing words 
 $ \{ w \in \Sigma^* : |\delta(Q, w)| = 1 \} = \bigcup_{q \in Q} \bigcap_{q' \in Q} L((\Sigma, Q, \delta, q', \{q\})) $
 is a regular language, we have to test
 for non-emptiness of intersection of this fixed regular language 
 with $L(\mathcal B)$. This could be done in \NL, hence in \PTIME.
 

\smallskip \noindent {\footnotesize
\textbf{Acknowledgement.} I thank  anonymous reviewers
of a previous version for detailed feedback.
I also sincerely thank the reviewers of the current version (at least one reviewers saw both versions) for careful reading and giving valuable feedback to improve my scientific writing
and pointing to two instances were I overlooked, in retrospect, two simple conclusions.}





\bibliographystyle{splncs04}
\bibliography{ms} 
\end{document}