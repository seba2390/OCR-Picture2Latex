\section{Discussion}
\label{sec:Discussion}

By comparing the results between all studied systems, we observed remarkable differences in the proportions and types of mutations of design anti-patterns and design patterns. For example, in oVirt in Table \ref{tab:Ovirtmarkov}, 29.9\% of Blob mutated to AntiSingleton (the highest mutation percentages). However, we did not observe in the same system any mutation from Blob to a design pattern. On the contrary, in Nuxeo, although the mutation of Blob to AntiSingleton remains frequent (28.3\%), the highest mutation proportion observed is Blob to Factory Method (29.7\%).

Another remarkable observation is that, in all studied systems, the occurrences of the design anti-pattern SwissArmyKnife and of the design pattern Prototype never mutated. We cannot draw any conclusion about a potential impact of the mutation of these patterns on the quality of the systems. 

% These observations show different mutation scenarios depending on the systems. They could be due to different change types implemented during the maintenance activities in the systems, to the differences of architectures of the systems and their distinct features. They may also be the result of a dissimilar way of software development (open source or closed source).

Different software systems may have different design patterns and--or design anti-patterns and may evolve differently. From our analysis, we observe different mutation behavior for all analyzed systems because these systems have different designs, contexts, and development teams. We observed that some design patterns and--or design anti-patterns remained unchanged in all releases and they did not mutate during evolution. 

For example, class \emph{org.mule.test.infrastructure.process.MuleUtils} in all the snapshots of Mule, is a LongMethod design anti-pattern. This design anti-pattern is introduced when developers continue adding new functionalities to a method while nothing is never taken out. Usually, developers prefer to add code to an existing method instead of creating a new one \cite{brown1998antipatterns}, which means that another line is added and then another, giving birth to a tangle of spaghetti code. This longer method or function become harder to understand and maintain.

We found that some of the design anti-patterns are mutated frequently to design patterns when developers are correcting faults during the evolution of the systems. Blob is the most mutated design anti-pattern in Apache Ignite. It mutated to AntiSingleton with 37.5\% probability. Blob presents a single class with a large number of attributes, operations, etc., surrounded by a number of data classes. A Blob is too complex for reuse and testing, while such classes are inefficient, and expensive to load into memory. 

There are also some design patterns that mutated to design anti-patterns. Command is an example of a design pattern that often mutated into SwissArmyKnife (38.7\% of the time) in Matsim. SwissArmyKnife is an excessively complex class interface. Developers attempted to provide for all possible uses of the class. They added a large number of interfaces (APIs) to meet all possible needs. The code to create separate Command classes grow to encompass more functionalities and become a SwissArmyKnife.

We observed that the change types that led to more mutations are Renaming, Comment, Operator, and Declaration, in most of the studied systems. These types of changes helped developers to correct their systems and remove some design anti-patterns. We also noticed that the most frequent mutation was LongParameterList to LongMethod.

We found in some analysed systems, that design anti-patterns are more fault-prone than classes involved in design patterns, while in some other systems, it is quite the opposite. Although these observations mean that employing design patterns may not always benefit the software quality, and introducing anti-patterns will not systemically compromise the software quality, some previous research related similar observations.

Bieman \etal{} \cite{bieman2003design} observed that large classes participating to design patterns were more change-prone. Voka\v{c} \etal{} \cite{vokavc2004defect} found a significant differences in the fault-proneness of different design patterns. Gatrell \etal{} \cite{gatrell2009design} observed that pattern-based classes are more change-prone and less stable than non-pattern classes \cite{vokavc2004defect}. Long \cite{long2001software} showed the benefits of some anti-patterns in the context of code reuse.

The context of using design anti-patterns or design patterns \cite{long2001software}, their static and historical relationships \cite{jaafar2013analysing,jaafar2013mining}, and their internal characteristics, such as their numbers of lines of code  \cite{bieman2003design}, could be compounding factors that lead to our previous observations, which confirm previous findings that software quality decreases with design anti-patterns and increases with design patterns.

A fault is an error that causes a software system to produce an incorrect or unexpected result or to behave in unintended ways. Although several previous works, \eg{} \cite{khomh2012exploratory,jaafar2014anti}, showed that an important proportion of faults may be related to design patterns, anti-patterns, and mutations among them, many other faults remain unrelated to patterns or their mutations. Table \ref{tab:fault} shows the numbers of (unique) faults per classes participating or not in some design (anti-)patterns. It shows that, in all studied systems except Matsim, the numbers of classes with faults but not participating in any design (anti-)pattern is higher than the number of classes with faults and participating in some design (anti-)pattern.

The results in this paper generally confirm results from previous studies and provide new research directions to further understand the impact of programming practices, like patterns and evolution, on software quality. First, while we confirmed that, generally, classes participating in design anti-patterns have more faults than classes participating in design patterns or no patterns; we also reported contradictory cases, like the design anti-pattern SwissArmyKnife and the design pattern Prototype. Thus, further studies are needed to understand the root causes of such cases, through manual, qualitative analyses of the changes leading to the faults.

We showed that some mutations are more frequent than others between some design anti-patterns and design patterns. We reported changes that led, concretely, to these mutations. However, our study is only on co-occurrences of these changes and mutations: more studies are required to understand why some patterns mutate into others in some systems but not others. We believe that these mutations and their differences may be due to the systems themselves and their developers but further studies are required to identify root causes and assert causation.

Finally, we showed that some mutations are more fault prone than others, which could guide developers but also researchers. For developers, our observations can help avoiding harmful changes, \ie{} fault-prone mutations, and focus some refactoring activities on beneficial changes. For researchers, our observations provide a first step in understanding the introduction of patterns and the changes that may lead to them as well as their impact on fault-proneness.