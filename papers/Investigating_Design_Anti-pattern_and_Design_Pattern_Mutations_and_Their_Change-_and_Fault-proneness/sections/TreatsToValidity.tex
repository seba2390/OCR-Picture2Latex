\section{Threats to Validity}
\label{sec:Treats to Validity}

We now discuss potential threats to the validity of the results of our study, following existing guidelines \cite{yin2013case,wohlin2012experimentation}.


\paragraph{Construct validity} These threats concern the relation between theory and observation. We know that the used design pattern and design anti-pattern detection techniques (DECOR and DeMIMA) in this study include some subjective understanding related to the definition of design patterns and design anti-patterns. Their authors reported recall rates of 100$\%$ for both techniques while the precision in the worst case was 31$\%$. We accept that the precision of these techniques is a concern. Some false positive classes may pass the validation because they ``looks like'' playing a role in some patterns.

We also accept that, in finding change types which led to faults, we could have matched classes that are not representing the actual same class. For example, class \texttt{C} is not match with \texttt{a.b.C.java} but could be matched with the \texttt{b.c.java}. Moreover, we know that during evolution, class names change as well. As for precision, the manual validation could be affected by subjectiveness or human error.  We should consider each type of renaming as we may misinterpret that there is a mutation between design patterns and design anti-patterns, while in fact the class name changed and the patterns remained stable. 



\paragraph{Internal validity} This threat concerns factors affecting our results. This threat is about the causality drawn from the study. It concerns our selection of studied systems and methodology. The accuracy of DECOR and DeMIMA impacts our results, because the number of design patterns and design anti-patterns computed with DECOR and DeMIMA is used to calculate the probabilities of mutations. Other detection techniques should be used to validate our findings.

Our results show correlations between design anti-patterns and design patterns, their mutations, and faults. However, they do not show causation. Hence, it is possible that some of the changes, which led to mutations, \eg{} changes to comments, although correlated to mutations, are not the root causes of these mutations. Identifying these root causes would require studying each change leading to mutations individually, manually, which is future work.



\paragraph{Conclusion validity} These threats concern the relationship between the treatment and the results. We paid attention in choosing the systems.

We used the SZZ algorithm \cite{sliwerski2005changes} to identify commits introducing faults. Although this algorithm may yield false positive results, it has been successfully employed in previous works, such as \cite{kamei2013large,fukushima2014empirical}. In this paper, to increase the algorithm's accuracy, we removed all fault-inducing commit candidates that only changed blank or comment lines. Moreover, the static analysis tool, srcML, can identify about 100 types of code elements from source code.

To make our results more actionable for software practitioners, we manually grouped similar element tags into 12 major change types as shown in Table~\ref{tab:Change_types}, which can help developers carefully change and review fault-prone code.



\paragraph{Reliability Validity} These threats concern the possibility of replicating the study. We provide all the necessary data on-line\footnote{\url{http://www.ptidej.net/downloads/replications/emse19c/}} to help other researchers replicate our work.



\paragraph{External validity} These threats concern the ability to generalize our results. We studied seven software systems with different sizes, domains, and complexity. We selected only Java systems because of the tools. We also chose some of these systems because they have been used in previous studies. Their numbers of lines of code range from hundred of thousands to several millions. These systems are widely used and have active developers community. They have several years of evolution histories. They are available on-line. However, all of them are written in Java and are open source. In the future, we plan to investigate more diverse set of systems. Moreover, we also want to study larger projects, with other programming languages, such as C++. 

We analysed commits instead of releases to cover as much as possible the whole histories of these systems. We choose thirteen design anti-patterns and eight design patterns among the many available patterns.