While LAVA-M is widely used, Google's fuzzer-test-suite is more practical with many more code lines and containing real-world bugs. To reveal the effectiveness of ensemble fuzzing, we run \toolThree ~(which only ensembles AFL, AFLFast, LibFuzzer and Radamsa) on all of the 24 real-world applications of Google's fuzzer-test-suite for 24 hours 10 times. %The reason we do not include QSYM will be discussed in \ref{Evaluation}. 
As a comparison, we also run each base fuzzer in parallel mode with four CPU cores used. To identify unique bugs, we used stack backtraces to deduplicate crashes.
The results are presented in Tables \ref{tab:google_path}, \ref{tab:google_branch} and \ref{tab:google_bug}, which shows the average number of paths executed, branches covered and unique bugs detected by AFL, AFLFast, FairFuzz, LibFuzzer, Radamsa, QSYM and \toolThree ~respectively.

\newcolumntype{B}{R{1.0 cm}}
\newcolumntype{C}{R{0.8 cm}}
\NewEnviron{mytable_google}[2]{
  \begin{table}[!htbp]
    \caption{#1}
    \scalebox{0.74}[0.74]{%
      \label{tab:#2}
      \begin{tabular}{l|CBCBCCB}
        \toprule
        {\mysize Project}
        & {\mysize AFL}
        & {\mysize AFLFast}
        & {\mysize FairFuzz}
        & {\mysize LibFuzzer}
        & {\mysize Radamsa}
        & {\mysize QSYM}
        & {\mysize \toolThree}\\
        \midrule
        \BODY
        \bottomrule
      \end{tabular}
    }
  \end{table}%
}

\vspace{-0.5cm}
\begin{mytable_google}{Average number of paths covered by each tool on Google's fuzzer-test-suite for ten times.}{google_path}
boringssl     & 3286   & 2816   & 3393   & 5525   & 3430   & 2973   & \textbf{7136 }  \\
c-ares        & 146    & 116    & 146    & 191    & 146    & 132    & \textbf{253  }  \\
guetzli       & 3248   & 2550   & 1818   & 3844   & 3342   & 2981   & \textbf{4508 }  \\
lcms          & 1682   & 1393   & 1491   & 1121   & 1416   & 1552   & \textbf{2433 }  \\
libarchive    & 12842  & 10111  & 12594  & 22597  & 12953  & 11984  & \textbf{31778}  \\
libssh        & 110    & 102    & 110    & 362    & 110    & 149    & \textbf{377  }  \\
libxml2       & 14888  & 13804  & 14498  & 28797  & 17360  & 13172  & \textbf{35983}  \\
openssl-1.0.1 & 3992   & 3501   & 3914   & 2298   & 3719   & 3880   & \textbf{4552 }  \\
openssl-1.0.2 & 4090   & 3425   & 3956   & 2304   & 3328   & 3243   & \textbf{4991 }  \\
openssl-1.1.0 & 4051   & 3992   & 4052   & 2638   & 3593   & 4012   & \textbf{4801 }  \\
pcre2         & 79581  & 66894  & 71671  & 59616  & 78347  & 60348  & \textbf{85386}  \\
proj4         & 342    & 302    & 322    & 509    & 341    & 323    & \textbf{709  }  \\
re2           & 12093  & 10863  & 12085  & 15682  & 12182  & 10492  & \textbf{17155}  \\
woff2         & 23     & 16     & 20     & 447    & 22     & 24     & \textbf{1324 }  \\
freetype2     & 19086  & 18401  & 20655  & 25621  & 18609  & 17707  & \textbf{27812}  \\
harfbuzz      & 12398  & 11141  & 14381  & 16771  & 11021  & 12557  & \textbf{16894}  \\
json          & 1096   & 963    & 721    & 1081   & 1206   & 1184   & \textbf{1298 }  \\
libjpeg       & 1805   & 1579   & 2482   & 1486   & 1632   & 1636   & \textbf{2638 }  \\
libpng        & 582    & 568    & 587    & 586    & 547    & 606    & \textbf{781  }  \\
llvm          & 8302   & 8640   & 9509   & 10169  & 8019   & 7040   & \textbf{10935}  \\
openthread    & 268    & 213    & 230    & 1429   & 266    & 365    & \textbf{1506 }  \\
sqlite        & 298    & 322    & 294    & 580    & 413    & 300    & \textbf{636  }  \\
vorbis        & 1484   & 1548   & 1593   & 1039   & 1381   & 1496   & \textbf{1699 }  \\
wpantund      & 4914   & 5112   & 5691   & 4881   & 4891   & 4941   & \textbf{5823 }  \\
\midrule  \textbf{
Tota}l         & 190607 & 168372 & 186213 & 209574 & 188274 & 163097 & \textbf{271408} \\
\midrule
Improvement &--     & \small{11\% $\downarrow$} & 2\% $\downarrow$ & 9\% $\uparrow$ & 1\% $\downarrow$ & 14\%$\downarrow$ & \textbf{42\% $\uparrow$} \\
\end{mytable_google}
\vspace{-0.2cm}

The first six columns of Table \ref{tab:google_path} reveal the issue of the performance variation in those base fuzzers, as they perform variously on different applications. Comparing
AFL family tools, AFL performs better than the other two optimized fuzzers on 14 applications. %FairFuzz performs the best on the other 2 applications, AFLFast fails to perform the best on any application. 
Compared with AFL, libFuzzer performs better on 15 applications, but worse on 9 applications. 
Radamsa performs better on 8 applications, but also worse on 16 applications.
QSYM performs better on 9 applications, but also worse on 15 applications.
Table \ref{tab:google_branch} and Table \ref{tab:google_bug} show similar results on branch coverage and bugs. %It is interesting to see that most optimized versions perform worse than the original AFL. 

From Table \ref{tab:google_path}, it is interesting to see that compared with those optimized fuzzers based on AFL (AFLFast, FairFuzz, Radamsa and QSYM), original AFL performs the best on 14 applications in parallel mode with 4 CPU cores. For the total number of paths executed, AFL performs the best and AFLFast performs the worst in parallel mode. While in single mode with one CPU core used, the situation is exactly the opposite, and the original AFL only performs the best on 5 applications, as presented in Table \ref{tab:single_path} of the appendix.

The reason for performance degradation of these optimizations in parallel mode is that their studies lack the consideration for synchronizing the  additional guiding information.
Take AFLFast for example, it models coverage-based fuzzing as Markov Chain, and the times of random mutation for each seed will be computed by a power scheduler. This strategy works well in single mode, %as their evaluation presented, 
but it would fail in parallel mode because the statistics of each fuzzer's scheduler are limited in current thread. %This is critical, because fuzzers generally work in parallel on practical industry applications. 
Our evaluation demonstrates that many optimized fuzzing strategies could be useful in single mode, but fail in the parallel mode even if this is the mode widely used in industry practice. This experiment has been missing by many prior literature studies. A potential solution for this degradation is to synchronize the additional guiding information in their implementation, similar to the work presented in PAFL\cite{liang2018pafl}. 
%when they conclude that the optimization performs better than the traditional AFL

%\vspace{-0.5cm}
\NewEnviron{mytable_google2}[2]{
  \begin{table}[!htbp]
    \caption{#1}
    \scalebox{0.74}[0.74]{%
      \label{tab:#2}
      \begin{tabular}{l|CCCBBCB}
        \toprule
        {\mysize Project}
        & {\mysize AFL}
        & {\mysize AFLFast}
        & {\mysize FairFuzz}
        & {\mysize LibFuzzer}
        & {\mysize Radamsa}
        & {\mysize QSYM}
        & {\mysize \toolThree}\\
        \midrule
        \BODY
        \bottomrule
      \end{tabular}
    }
  \end{table}%
}

\vspace{-0.59cm}
\begin{mytable_google2}{Average number of branches covered by each tool on n Google's fuzzer-test-suite for ten times.}{google_branch}
boringssl     & 3834   & 3635   & 3894   & 3863   & 3880   & 3680   & \textbf{4108 }  \\
c-ares        & \textbf{285  }  & 276    & \textbf{285  }    & 202    & \textbf{285  }    & \textbf{285  }    & \textbf{285  }  \\
guetzli       & 3022   & 2723   & 1514   & \textbf{4016}   & 3177   & 3011   & 3644   \\
lcms          & 3985   & 3681   & 3642   & 3015   & 2857   & 3731   & \textbf{4169 }  \\
libarchive    & 10580  & 9267   & 8646   & 8635   & 11415  & 9416   & \textbf{13949}  \\
libssh        & 614    & 614    & 614    & 573    & 614    & \textbf{636}    & 614    \\
libxml2       & 15204  & 14845  & 14298  & 13346  & 19865  & 14747  & \textbf{21899}  \\
openssl-1.0.1 & 4011   & 3967   & 3996   & 3715   & 4117   & 4032   & \textbf{4673 }  \\
openssl-1.0.2 & 4079   & 4004   & 4021   & 3923   & 4074   & 3892   & \textbf{4216 }  \\
openssl-1.1.0 & 9125   & 9075   & 9123   & 8712   & 9017   & 9058   & \textbf{9827 }  \\
pcre2         & 50558  & 48004  & 49430  & 36539  & 51881  & 36208  & \textbf{53912}  \\
proj4         & 267    & 267    & 267    & 798    & 267    & 261    & \textbf{907  }  \\
re2           & 17918  & 17069  & 17360  & 16001  & 17312  & 16323  & \textbf{19688}  \\
woff2         & 120    & 120    & 120    & 2785   & 120    & 121    & \textbf{3945 }  \\
freetype2     & 53339  & 52404  & 56653  & 57325  & 52715  & 48547  & \textbf{58192}  \\
harfbuzz      & 38163  & 36313  & 43077  & 39712  & 37959  & 38194  & \textbf{44708}  \\
json          & 7048   & 6622   & 5138   & 6583   & 7231   & 7169   & \textbf{7339 }  \\
libjpeg       & 12345  & 11350  & 15688  & 10342  & 12009  & 11468  & \textbf{17071}  \\
libpng        & 4135   & 4393   & 4110   & 4003   & 3961   & 4085   & \textbf{4696 }  \\
llvm          & 55003  & 56619  & 58306  & 57021  & 54312  & 48008  & \textbf{62918}  \\
openthread    & 3109   & 2959   & 2989   & 5421   & 3102   & 3634   & \textbf{5579 }  \\
sqlite        & 2850   & 2847   & 2838   & 3123   & 3012   & 2853   & \textbf{3216 }  \\
vorbis        & 12136  & 13524  & 13053  & 10032  & 11234  & 12849  & \textbf{14318}  \\
wpantund      & 40667  & 40867  & 41404  & 39816  & 40317  & 40556  & \textbf{43217}  \\
\midrule
Total         & 352397 & 345445 & 360466 & 339501 & 354733 & 322764 & \textbf{407090} \\
\midrule  
Improvement &--     & \small{1\% $\downarrow$} & 2\% $\downarrow$ & 3\% $\uparrow$ & 0.6\% $\downarrow$ & 8\%$\downarrow$ & \textbf{16\% $\uparrow$} \\
\end{mytable_google2}


\NewEnviron{mytable_google3}[2]{
  \begin{table}[!htbp]
    \caption{#1}
    \scalebox{0.74}[0.74]{%
      \label{tab:#2}
      \begin{tabular}{l|CBBBCCB}
        \toprule
        {\mysize Project}
        & {\mysize AFL}
        & {\mysize AFLFast}
        & {\mysize FairFuzz}
        & {\mysize LibFuzzer}
        & {\mysize Radamsa}
        & {\mysize QSYM}
        & {\mysize \toolThree}\\
        \midrule
        \BODY
        \bottomrule
      \end{tabular}
    }
  \end{table}%
}

\vspace{-0.5cm}
\begin{mytable_google3}{Average number of unique bugs found by each tool on n Google's fuzzer-test-suite for ten times.}{google_bug}
boringssl     & 0  & 0  & 0  & \textbf{1}  & 0  & 0  & \textbf{1}  \\
c-ares        & \textbf{3}  & 2  & \textbf{3}  & 1  & 2  & 2  & \textbf{3}  \\
guetzli       & 0  & 0  & 0  & \textbf{1}  & 0  & 0  & \textbf{1}  \\
lcms          & 1  & 1  & 1  & \textbf{2}  & 1  & 1  & \textbf{2}  \\
libarchive    & 0  & 0  & 0  & \textbf{1}  & 0  & 0  & \textbf{1}  \\
libssh        & 0  & 0  & 0  & 1  & 0  & 1  & \textbf{2}  \\
libxml2       & 1  & 1  & 1  & \textbf{3}  & 2  & 1  & \textbf{3}  \\
openssl-1.0.1 & 3  & 2  & 3  & 2  & 2  & 3  & \textbf{4}  \\
openssl-1.0.2 & 5  & 4  & 4  & 1  & 5  & 5  & \textbf{6}  \\
openssl-1.1.0 & 5  & 5  & 5  & 3  & 4  & 5  & \textbf{6}  \\
pcre2         & 6  & 4  & 5  & 2  & 5  & 4  & \textbf{8}  \\
proj4         & 2  & 0  & 1  & 1  & 1  & 1  & \textbf{3}  \\
re2           & 1  & 0  & 1  & 1  & 0  & 1  & \textbf{2}  \\
woff2         & 1  & 0  & 0  & \textbf{2}  & 1  & 1  & 1  \\
freetype2     & 0  & 0  & 0  & 0  & 0  & 0  & 0  \\
harfbuzz      & 0  & 0  & \textbf{1}  & \textbf{1}  & 0  & 0  & \textbf{1}  \\
json          & 2  & 1  & 0  & 1  & \textbf{3}  & 2  & \textbf{3}  \\
libjpeg       & 0  & 0  & 0  & 0  & 0  & 0  & 0  \\
libpng        & 0  & 0  & 0  & 0  & 0  & 0  & 0  \\
llvm          & 1  & 1  & \textbf{2}  & \textbf{2}  & 1  & 1  & \textbf{2}  \\
openthread    & 0  & 0  & 0  & \textbf{4}  & 0  & 0  & \textbf{4}  \\
sqlite        & 0  & 0  & 0  & \textbf{3}  & 1  & 1  & \textbf{3}  \\
vorbis        & 3  & \textbf{4}  & 3  & 3  & 3  & \textbf{4}  & \textbf{4}  \\
wpantund      & 0  & 0  & 0  & 0  & 0  & 0  & 0  \\
\midrule  
Total         & 34 & 25 & 30 & 37 & 31 & 33 & \textbf{60} \\
\midrule  
Improvement &--     & \small{26\% $\downarrow$} & 12\% $\uparrow$ & 6\% $\downarrow$ & 9\% $\uparrow$ & 3\%$\downarrow$ & \textbf{76\% $\uparrow$} \\
\end{mytable_google3}












%8. 在多线程场景，radamsa的提升比单线程下要低： （1）radamsa生成的大量无用input会影响afl多线程之间的通信。 （2）afl多线程之间通过共享种子，能够有效自己的性能，这和radamsa所能提供的提升重合了
From the fifth columns of Table \ref{tab:google_path} and Table \ref{tab:single_path}, we find that compared with Radamsa in single mode, the improvement achieved by Radamsa is limited in parallel mode. There are two main reasons:
(1) Too many useless inputs generated by Radamsa slow down the seed-sharing efficiency among all instances of AFL. This seed-sharing mechanism does not exist in single mode.
(2) Some interesting seeds can be created in parallel mode and shared among all instances of AFL. 
These seeds overlap with the inputs generated by Radamsa. So this improvement is limited in parallel mode.

%% 实验结果出来后可能要加一QSYM的分析，也可能不用

For the \toolThree ~which integrates AFL, AFLFast, libFuzzer and Radamsa as base fuzzers and, compared with AFL, AFLFast, FairFuzz, QSYM, LibFuzzer and Radamsa, it shows the strongest robustness and always performs the best.
In total, it discovers 76.4\%, 140\%, 100\%, 81.8\%, 66.7\% and 93.5\% more unique bugs, executes 42.4\%, 61.2\%, 45.8\%, 66.4\%, 29.5\% and 44.2\% more paths and covers 15.5\%, 17.8\%, 12.9\%, 26.1\%, 19.9\% and 14.8\% more branches respectively.
These statistics demonstrate that it helps mitigate performance variation and improves robustness and performance by the ensemble  approach  with  globally  asynchronous  and  locally  synchronous seed synchronization mechanism.
