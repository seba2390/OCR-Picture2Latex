We implement ensemble fuzzing based on six state-of-the-art fuzzers, including three edge-coverage guided mutation-based fuzzers -- AFL, AFLFast and FairFuzz, one block-coverage guided mutation-based fuzzer -- libFuzzer, one generation-based fuzzer -- Radamsa and one most recently hybrid fuzzer -- QSYM. These are chosen as the base fuzzers for the following reasons (Note that \toolThree ~is not limited to these six and other fuzzers can also be easily integrated, such as honggfuzz, ClusterFuzzer etc.):

\begin{itemize}
\item Easy integration.
All the fuzzers are open-source and have their core algorithms implemented precisely. It is easy to integrate those existing fuzzers into our ensemble architecture. We do not have to implement them on our own, which eliminates any implementation errors or deviations that might be introduced by us.

\item Fair comparison. All the fuzzers perform very well and are the latest and widely used fuzzers, as is seen by their comparisons with each other in prior literature, for example, QSYM outperforms similar fuzzers such as Angora\cite{chen2018angora} and VUzzer. We can evaluate their performance on real-world applications without modification.

\item Diversity demonstration. All these fuzzers have different fuzzing strategies and reflect the diversity among  correspondence with the three base diversity heuristics mentioned in section \ref{Base Fuzzer Selection}: coverage information granularity diversity, input generation strategy diversity,  seed mutation and selection strategy diversity. The concrete diversity among these base fuzzers is listed in Table \ref{tab:diversity}.

\end{itemize}

%Several engineering challenges need to be solved firstly: 
To demonstrate the performance of ensemble fuzzing and the influence of diversity among base fuzzers, 
five prototypes are developed. (1) \toolOne, an ensemble fuzzer only based on AFL, AFLFast and FairFuzz. 
% thus the diversity of \toolOne ~is little. 
(2) \toolFive, an ensemble fuzzer based on AFL, AFLFast, FairFuzz and QSYM, a practical concolic execution engine is included. 
(3) \toolTwo, an ensemble fuzzer based on AFL, AFLFast, FairFuzz and libFuzzer, a block-coverage guided fuzzer is included. %, and the diversity of \toolTwo ~is larger. 
(4) \toolThree, an ensemble fuzzer based on AFL, AFLFast, libFuzzer and Radamsa, a generation-based fuzzer is further added .%, and the diversity of \toolThree ~is the largest among them.
(5) \toolFour, ~with the ensemble of same base fuzzers (AFL, AFLFast and FairFuzz), but without the seed synchronization, to demonstrate the effectiveness of the global asynchronous and local synchronous based seed synchronization mechanism.  
During implementation of the proposed ensemble mechanism, we address the following challenges: 


\newcolumntype{C}{>{\arraybackslash}p{6.3cm}}
\NewEnviron{mytable_diversity}[2]{
  \begin{table}[tbp]
    \caption{#1}
    \scalebox{1.0}[1.0]{%
      \label{tab:#2}
      \begin{tabular}{l|Cp{1cm}}
        \toprule
        {\mysize Tool}
        & {\mysize diversity compared with AFL}\\
        \midrule
        \BODY
        \bottomrule
      \end{tabular}
    }
  \end{table}%
}


\begin{mytable_diversity}{Diversity among these base fuzzers}{diversity} 
AFLFast  		& Seed mutation and selection strategy based rule: the times of random mutation for each seed is computed by a Markov chain model. The seed selection strategy is different. \\	\hline 
FairFuzz 		& Seed mutation and selection strategy based rule: only mutates seeds which hit rare branches and strives to ensure the mutant seeds hit the rarest one. The seed mutation strategy is different. \\  \hline
libFuzzer  	 	& Coverage information granularity based rule: libFuzzer mutates seeds by utilizing the SanitizerCoverage instrumentation, which supports tracking block coverage; while AFL uses static instrumentation with a bitmap to track edge coverage. The coverage information granularity is different.\\	\hline
Radamsa       	& Input generation strategy based rule: Radamsa is a widely used generation-based fuzzer which generates different inputs sample files of valid data. The input generation strategy is different. \\		\hline
QSYM       	& QSYM is a practical fast concolic execution engine tailored for hybrid fuzzing. It makes hybrid fuzzing scalable enough to test complex, real-world
applications.   \\ % and outperforms similar fuzzers such as \textbf{Angora}
\end{mytable_diversity}



\textit{1) Standard Interface Encapsulating}
The interfaces of these fuzzers are different. For example, AFL family tools use the function \texttt{main}, but libFuzzer use a function \texttt{LLVMFuzzerTestOneInput}. Therefore, it is hard to ensemble them together.
We design a standard interface to encapsulate the complexity of different fuzzing tools.
This standard interface takes seeds from the file system, and writes the results back to the file system.
All base fuzzers receive inputs and produce results through this standard interface, through which different base fuzzers can be ensembled easily.

\textit{2) libFuzzer Continuously Fuzzing}
The fuzzing engine of libFuzzer  will be shut down when it finds a crash, while other tools continue fuzzing until manually closed. It is unfair to compare libFuzzer  with other tools when the fuzzing time is different.
The persistent mode of AFL is a good solution to this problem. Once AFL sets up, the fuzzer parent will \texttt{fork} and \texttt{execve} a new process to fuzz the target. When the target process crashes, the parent will collect the crash and resume the target, then the process simply loops back to the start.
Inspired by the AFL persistent mode, we set up a thread named \texttt{Parent} to monitor the state of libFuzzer. Once it shuts down, \texttt{Parent} will resume the libFuzzer. %and restart the fuzzing process.

\begin{comment}
\subsubsection{Radamsa Effectively Working}
Radamsa is a widely used generation-based fuzzer. There are two key obstacles to using Radamsa effectively. 
Firstly, Radamsa requires some sample files of input data, but AFL family tools and libFuzzer do not need. 
Secondly, AFL and libFuzzer mutate seeds by coverage information, but Radamsa does not, to compare them in terms of coverage is unfair. %It is unfair to compare generation-based fuzzers with mutation-based fuzzers directly in terms of path or branch coverage.
However, according to the original experiments of Radamsa and Skyfire, they pair generation-based fuzzers with mutation-based fuzzers to solve the two problems. We follow their setup to pare Radamsa with AFL: when AFL is running, Radamsa periodically read seeds generated by AFL as inputs and generates lots of outputs which will be fed back to AFL. Radamsa and AFL are running alternately on one CPU core.
%In this way, Radamsa will work effectively with AFL, and achieve high performance.
\end{comment}

\textit{3) Bugs De-duplicating and Triaging}
%To analyse crashes effectively, we need de-duplicate and triage these crashes first.
%Accordingly, 
We develop a tool for crash analysis.
We compile all the target applications with AddressSanitizer, and test them with the crash samples. 
When the target applications crash, the coredump file, which consists of the recorded state of the working memory will be saved. %Some key pieces of program state are usually dumped at the same time, including the processor registers, which may include the program counter and stack pointer, memory management information, and operating system flags and information.
Our tool first loads coredump files, then gathers the frames of each crash; finally, it identifies two crashes as identical if and only if the top frame is identical to the other frame. The method above is prone to underestimating bugs. For example, two occurrences of heap overflow may crash at the cleanup function at exit. However, the target program is instrumented with AddressSanitizer. As the program terminates immediately when memory safety problems occur, the top frame is always relevant to the real bug.
%Our tool automatically collects these coredump files, analyses and records each crash's stack backtraces based on LLDB, then de-duplicates and triages crashes according to these key information. %Finally, it reports the root causes of these crashes.
In practice, the original duplicate unique crashes have been drastically de-duplicated to a humanly check-able number of unique bugs, usually without duplication. Even though there are some extreme cases that different top frames for one bug, the result can be further refined by manual crash analysis. 


\textit{4) Seeds effectively Synchronizing}
The implementation of the seed synchronization mechanism: 
all base fuzzers have implemented the communication logic following the standard interface. Each base fuzzer will put interesting seeds into its own local seed pool, and the monitor thread \texttt{sync} will periodically make each single base fuzzer pull synchronized seeds from the global seed pool through a communication channel. This communication channel is implemented based on file system. 
%The time period of the seed synchronization mechanism is set to 120 seconds. 
A shorter period consumes too many resources, which leads to a decrease in fuzzing performance. 
A longer period will make seed synchronizing untimely, which also affects the performance.
After multiple attempts with different values, it is found that the synchronization interval affects the performance at the beginning of fuzzing, while little impact was observed in the long term. The interval of 120s is identified with the fastest convergence.

%The implementation of result integration mechanism:
%the core idea of result integrating is de-duplicating the paths covered, branches exercised and crashes detected by all the base fuzzers.
%The crash de-duplicating has been introduced above; similar to it, to de-duplicate the paths and branches, we develop a tool to collect all seeds generated by each base fuzzer into a global seeds pool automatically. Then our tool runs the target application with these seeds one by one, at the meantime the tool will analyse and record paths and branches coverage of each seed. After processing all seeds, the global coverage information can be reported.





