\def\year{2017}\relax
%File: formatting-instruction.tex
\documentclass[letterpaper]{article} %DO NOT CHANGE THIS
\usepackage{aaai17}  %Required
\usepackage{times}  %Required
\usepackage{helvet}  %Required
\usepackage{courier}  %Required
\usepackage{url}  %Required
\usepackage{graphicx}  %Required
\frenchspacing  %Required
\setlength{\pdfpagewidth}{8.5in}  %Required
\setlength{\pdfpageheight}{11in}  %Required

\usepackage{clrscode3e}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage[draft]{hyperref}
%\usepackage{hyperref} % https://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink
\usepackage{graphicx}
\usepackage{graphics}
\usepackage{caption}
%\usepackage{float}
\usepackage{standalone}
\usepackage[draft]{minted}
% https://tex.stackexchange.com/questions/280590/work-around-for-minted-code-highlighting-in-arxiv

\usepackage{hhline}
\usepackage[rgb]{xcolor}
\usepackage{colortbl}
\definecolor{Gray}{gray}{0.85}
\newcolumntype{g}{>{\columncolor{Gray}}c}
\newcolumntype{w}{>{\columncolor{white}}c}

\nocopyright

%\usepackage[author={Caelan Garrett}, color=blue, icon=note]{pdfcomment}
\usepackage{todonotes}
\newcommand\note[1]{\todo[inline, color=blue!10, linecolor=blue!90,
  size=\footnotesize]{\linespread{0.9}\selectfont{{\bf CRG:} #1}\par}}
\newcommand\lpknote[1]{\todo[inline, color=green!10, linecolor=green!90,
  size=\footnotesize]{\linespread{0.9}\selectfont{{\bf LPK:} #1}\par}}

\theoremstyle{plain}\newtheorem{thm}{Theorem}
\theoremstyle{definition}\newtheorem{defn}{Definition}
\theoremstyle{plain}\newtheorem{lem}{Lemma}
\theoremstyle{plain}\newtheorem{cor}{Corollary}

\newcommand{\algname}{{\sc strips}tream}
\newcommand{\strips}{{\sc strips}}
\newcommand{\pddl}{{\sc pddl}}
\newcommand{\eager}{incremental}
\newcommand{\Eager}{Incremental}
\newcommand{\focused}{focused}

%\newif\ifacknowledgments
%\acknowledgmentstrue
%\acknowledgmentsfalse

\frenchspacing
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}

%%%%%

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

%%%%%

\makeatletter
\def\PYGdefault@reset{\let\PYGdefault@it=\relax \let\PYGdefault@bf=\relax%
    \let\PYGdefault@ul=\relax \let\PYGdefault@tc=\relax%
    \let\PYGdefault@bc=\relax \let\PYGdefault@ff=\relax}
\def\PYGdefault@tok#1{\csname PYGdefault@tok@#1\endcsname}
\def\PYGdefault@toks#1+{\ifx\relax#1\empty\else%
    \PYGdefault@tok{#1}\expandafter\PYGdefault@toks\fi}
\def\PYGdefault@do#1{\PYGdefault@bc{\PYGdefault@tc{\PYGdefault@ul{%
    \PYGdefault@it{\PYGdefault@bf{\PYGdefault@ff{#1}}}}}}}
\def\PYGdefault#1#2{\PYGdefault@reset\PYGdefault@toks#1+\relax+\PYGdefault@do{#2}}

\expandafter\def\csname PYGdefault@tok@gd\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@gu\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@gt\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYGdefault@tok@gs\endcsname{\let\PYGdefault@bf=\textbf}
\expandafter\def\csname PYGdefault@tok@gr\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@cm\endcsname{\let\PYGdefault@it=\textit\def\PYGdefault@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@vg\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYGdefault@tok@vi\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYGdefault@tok@mh\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@cs\endcsname{\let\PYGdefault@it=\textit\def\PYGdefault@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@ge\endcsname{\let\PYGdefault@it=\textit}
\expandafter\def\csname PYGdefault@tok@vc\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYGdefault@tok@il\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@go\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PYGdefault@tok@cp\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@gi\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@gh\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@ni\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PYGdefault@tok@nl\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@nn\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@no\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@na\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PYGdefault@tok@nb\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@nc\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@nd\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@ne\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PYGdefault@tok@nf\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@si\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PYGdefault@tok@s2\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYGdefault@tok@nt\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@nv\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYGdefault@tok@s1\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYGdefault@tok@ch\endcsname{\let\PYGdefault@it=\textit\def\PYGdefault@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@m\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@gp\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@sh\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYGdefault@tok@ow\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@sx\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@bp\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@c1\endcsname{\let\PYGdefault@it=\textit\def\PYGdefault@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@o\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@kc\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@c\endcsname{\let\PYGdefault@it=\textit\def\PYGdefault@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@mf\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@err\endcsname{\def\PYGdefault@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYGdefault@tok@mb\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@ss\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PYGdefault@tok@sr\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PYGdefault@tok@mo\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@kd\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@mi\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYGdefault@tok@kn\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@cpf\endcsname{\let\PYGdefault@it=\textit\def\PYGdefault@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PYGdefault@tok@kr\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@s\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYGdefault@tok@kp\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@w\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYGdefault@tok@kt\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PYGdefault@tok@sc\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYGdefault@tok@sb\endcsname{\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PYGdefault@tok@k\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PYGdefault@tok@se\endcsname{\let\PYGdefault@bf=\textbf\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PYGdefault@tok@sd\endcsname{\let\PYGdefault@it=\textit\def\PYGdefault@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYGdefaultZbs{\char`\\}
\def\PYGdefaultZus{\char`\_}
\def\PYGdefaultZob{\char`\{}
\def\PYGdefaultZcb{\char`\}}
\def\PYGdefaultZca{\char`\^}
\def\PYGdefaultZam{\char`\&}
\def\PYGdefaultZlt{\char`\<}
\def\PYGdefaultZgt{\char`\>}
\def\PYGdefaultZsh{\char`\#}
\def\PYGdefaultZpc{\char`\%}
\def\PYGdefaultZdl{\char`\$}
\def\PYGdefaultZhy{\char`\-}
\def\PYGdefaultZsq{\char`\'}
\def\PYGdefaultZdq{\char`\"}
\def\PYGdefaultZti{\char`\~}
% for compatibility with earlier versions
\def\PYGdefaultZat{@}
\def\PYGdefaultZlb{[}
\def\PYGdefaultZrb{]}
\makeatother

%%%%%

\setcounter{secnumdepth}{0}
 \begin{document}
% The file aaai.sty is the style file for AAAI Press
% proceedings, working notes, and technical reports.
%
\title{STRIPS Planning in Infinite Domains}

 \pdfinfo{
 /Title (STRIPS Planning in Infinite Domains)
 /Author (Caelan Reed Garrett, Tom\'as Lozano-P\'erez, and Leslie Pack
 Kaelbling)}
 
 \author{Caelan Reed Garrett, Tom\'as Lozano-P\'erez, and Leslie Pack Kaelbling \\
 MIT CSAIL\\
 32 Vassar Street \\
 Cambridge, MA 02139, USA\\
 {\tt\small \{caelan,tlp,lpk\}@csail.mit.edu}}

\maketitle

% Authors may submit long papers (8 pages AAAI style plus up to one
% page of references) or short papers (4 pages plus up to one page of
% references) In addition to the submitted PDF paper, authors can
% additionally submit supplementary material (videos, technical
% proofs, additional experimental results) for their paper. Please
% make sure that the supporting material is also anonymized. Papers
% should be self-contained; reviewers are encouraged, but not
% obligated, to consider supporting material in their decision.

\begin{abstract}
\begin{quote}  
  Many robotic planning applications involve continuous
  actions with highly non-linear constraints, which
  cannot be modeled using modern planners that construct a
  propositional representation.  We introduce \algname{}: an
  extension of the \strips{} language which can model these domains
  by supporting the specification of blackbox generators to handle complex constraints. 
  The outputs of these generators interact with actions through possibly infinite streams of
  objects and static predicates. 
  We provide two algorithms which both
  reduce \algname{} problems to a sequence of finite-domain planning
  problems. The representation and algorithms are entirely
  domain independent.  We demonstrate our framework on simple illustrative
  domains, and then on a high-dimensional, continuous robotic task
  and motion planning domain.  
\end{quote}
\end{abstract}
% practical -> robotic, quantities -> actions

%Many robotic planning applications involve continuous actions with highly non-linear constraints, which cannot be modeled using modern planners that construct a propositional representation.  We introduce STRIPStream: an extension of the STRIPS language which can model these domains by supporting the specification of blackbox generators to handle complex constraints. The outputs of these generators interact with actions through possibly infinite streams of objects and static predicates. We provide two algorithms which both reduce STRIPStream problems to a sequence of finite-domain planning problems. The representation and algorithms are entirely domain independent.  We demonstrate our framework on simple illustrative domains, and then on a high-dimensional, continuous robotic task and motion planning domain.  

\section{Introduction}

Many important planning domains naturally occur in continuous spaces involving
complex constraints among variables. Consider planning for a robot tasked with
organizing several blocks in a room. 
The robot must find a sequence of {\em pick}, {\em place}, and {\em move} actions
involving continuous robot configurations, robot trajectories, block poses, and block grasps.
These variables must satisfy highly non-linear kinematic, collision, and motion constraints 
which affect the feasibility of the actions. 
Each constraint typically requires a special purpose procedure to efficiently evaluate it or produce satisfying values for it such as an inverse kinematic solver, collision checker, or motion planner. 
%Thus, such a domain cannot be effectively modeled in PDDL. 
%Such a domain cannot be directly modeled using discrete action languages such as \strips{} or \pddl{}. 
% Sentence about PDDL+

%Such problems include spatial planning, including robot task and motion
%planning, problems with dynamics where state may include velocities,
%as well as planning with other kinds of resources, such as fuel or
%storage space.

We propose an approach, called \algname{}, which can model such a
domain by providing a generic interface for blackbox procedures to be incorporated
in an action language. The implementation of the procedures is abstracted away using
{\em streams}: finite or infinite sequences of objects such as poses, configurations, and trajectories.
%Just allowing objects in a \strips{} planning specification to be drawn
%from domains specified as infinite streams does not make many new
%problems feasible. 
%: to do so, we must manage the generation of new
%objects so that they are focused on parts of the space that are likely
%to contribute to a solution to the problem instance at hand.  
We introduce the following 
%We use two techniques to 
two additional stream capabilities to effectively model
domains with complex predicates that are only true for small sets 
of their argument values:
\begin{itemize}
\item {\bf conditional streams}:  a stream of objects may be defined
  as a function of other objects; for example, a stream of possible
  positions of one object given the position of another object that it
  must be on top of or a stream of possible settings of parameters of
  a factory machine given desired properties of its output.
\item {\bf certified streams}: streams of objects may be declared not
  only to be of a specific type, but also to satisfy an arbitrary
  conjunction of predicates;  for example, one might define a
  certified conditional stream that generates positions for an object
  that satisfy requirements that the object be on a surface, that a
  robot be able to reach the object at that position, and that the
  robot be able to see the object while reaching.   
%  Although it might
%  be possible to construct conditional streams satisfying each of
%  these predicates individually, in some domains the likelihood of all
%  three streams independently generating a candidate that has all
%  three properties would be very low, requiring such objects to be
%  explicitly generated.
%\item {\bf plan-focused sampling}:  planning may proceed using
%  abstract objects that ``stand in'' for particular individuals if
%  appropriate concrete objects are not yet available;  our focused
%  algorithm explicitly plans to generate new individuals satisfying
%  those specifications and then does so, causing the particular
%  streams from which objects are generated to be strongly driven
%  by their utility for planning.
\end{itemize}
%As a result of these three strategies, we are able to effectively model domains with complex predicates that are only true for small sets of their argument values. % Removed

\begin{figure}[ht]
\centering
\includegraphics[width=0.4\textwidth]{images/distract_16_small.png}
\caption{Problem 2-16.} 
\label{fig:tamp_domains}
\end{figure}

Through streams, \algname{} can compactly model
a large class of continuous, countably infinite, and large finite domains.
By conditioning on partial argument values
and using sampling, it can even effectively
model domains where the set of valid action argument values is lower
dimensional than the possible argument space. For example, in our robotics domain, the set of 
inverse kinematics solutions for a particular pose and grasp is much lower dimensional than the full set of robot configurations. However, using a conditional
stream, we can specify an inverse kinematics solver which directly samples from this
set given a pose and grasp.
%producing values of continuous variables 
%or discrete but very large or even unbounded.  
%representation of continuous, countably infinite, and large finite domains using streams. 

%Additionally, using plan-focused sampling, we can efficiently solve problems
%where calling streams is computationally expensive by carefully 
%choosing to only call potentially useful streams.

The approach is entirely domain-independent, and reduces to \strips{} in
the case of finite domains.  The only additional requirement is the
specification of a set of streams that can generate objects satisfying
the static predicates in the domain. 
It is accompanied by two algorithms, a simple
and a focused version, which operate by constructing and solving a
sequence of \strips{} planning problems.  
This strategy takes advantage
of the highly optimized search strategies and heuristics that exist
for \strips{} planning, while expanding the domain of
applicability of those techniques.
Additionally, the focused version can efficiently solve problems where using streams is computationally expensive by carefully choosing to only call potentially useful streams. % Removed

\section{Related work}
There are a number of existing general-purpose approaches to solving planning problems in infinite domains, each of which has some significant limitation when modeling our robot domain.

% Time is a particular special case of a continuous dimension that has
% been well studied; for domains whose only continuous aspect is time,
% there are a number of effective techniques, e.g.~\cite{coles2012colin}

%The continuous aspects of an important set of planning problems, including 
Temporal planning, such as defined in {\sc pddl2.1}~\cite{Fox03pddl2.1:an}, is often formulated in terms of linear constraints on plan variables and is typically solved using techniques based on linear programming~\cite{hoffmann2003metric,coles2013hybrid}. 
% LPRPG:
% http://www.cis.strath.ac.uk/cis/research/publications/papers/strath_cis_publication_2267.pdf
%POPF does mixed integer LP.
% http://www.aaai.org/ocs/index.php/ICAPS/ICAPS10/paper/view/1421/1527
{\sc pddl+}~\cite{fox2006modelling} extends {\sc pddl2.1} by introducing exogenous events and continuous processes. 
%Many PDDL+ planners are limited to linear process models. 
Although {\sc pddl+} supports continuous variables, the values of continuous variables are functions of the sequence of discrete actions performed at particular times. 
Thus, time is the only truly non-dependent continuous variable. 
In contrast, our motivating robot domain has no notion of time but instead a continuously infinite branching factor.
%are entirely dependent on time and discrete actions.
Many planners solve {\sc pddl+} problems with non-linear process models by discretizing time~\cite{della2009upmurphi,piotrowski2016heuristic}. Some recent planners can solve {\sc pddl+} problems with polynomial process models exactly without time discretization~\cite{bryce2015smt,cashmore2016compilation}.
However, even in simplified robotics domains that {\sc pddl+} can model, modern {\sc pddl+} planners are ineffective at planning with collision and kinematic constraints (both highly non-polynomial constraints), particularly in high-dimensional systems.
%using external procedures can result in a more compact and representation and more efficient algorithms.

%Problems are typically solved by discretizing time and solving the induced discrete problem {piotrowski2016heuristic}. 
%Because PDDL+ is restricted to discrete actions and forward simulation of variables, it not general enough to capture more general constraints, such as from robot kinematics and motion trajectories, that arise in robotics applications.
% collision avoidance and
%  "In this case, the user specifies the error precision within which the non-linear effects can be evaluated. Even in this case, the main issue is scalability as the problem size increases."

General-purpose lifted and first-order approaches, such as
those based on first-order situation calculus or Prolog, provide
semi-decision procedures for a large class of lifted planning
problems.  However, the generality tends to come at a huge price in
efficiency and these planning strategies are rarely practical. % Removed

%The most relevant approaches to this work start with a lifted domain description
%and construct one or more finite propsitionalized versions of it, and
%solve them using existing efficient techniques.  For example, the {\sc
%  ffrob} system~\cite{garrett2016ffrob} addresses robotic task and motion
%planning problems in continuous spaces by using domain-dependent
%sampling strategies to construct a finite planning problem instance
%and then solving it using strategies similar to FF~\cite{HoffmannN01}.

%https://pdfs.semanticscholar.org/73a9/693f0686bc83c7ca6b9c9a95589918358138.pdf
% Engineering an incremental ASP solver

%Another similar approach is found in the {\sc iclingo}
%Answer Set Programming (ASP) system~\cite{gebser2008engineering}.  It operates iteratively, first fixing a level
%of ``depth'' used in the derivation of an atom, and then making a
%finite propositional grounding of the lifted problem to that depth.
%It seeks an answer in the grounded problem;  if one is found, it is
%returned.  If an answer is not obtained, the depth limit is increased,
%a new grounding is constructed and attempted to be solved, etc.  

%This process is carefully constructed to re-use as much work as possible.
%It is demonstrated as a strategy for making plans in which the depth
%is unknown {\em a priori}, so that it is necessary to incrementally
%increase the number of time instants available to the planner.  
The Answer Set Programming (ASP) literature contains analysis on reasoning in infinite domains through finitary, $\omega$-restricted, finitely ground, and finite domain ASPs~\cite{bonatti2010answer}. 
The DLV-Complex system~\cite{calimeri2009asp} is able to solve feasible finitely ground programs by extending the DataLog with Disjunction (DLV) system to support functions, lists, and set terms.
We believe %that these approaches could be extended to handle other infinite domains and 
that the language of ASP allows specification of
conditional and certified streams.  
However, the ground ASP solver
still has to address a much more general and difficult problem and
will not have the appropriate heuristic strategies that make current
domain-independent \strips{} planners so effective. % Removed

% or in some cases non-linear constraints~\cite{bajada2015temporal}, 
% "More specifically, we consider those that manifest a monotonic increase or decrease between two discrete time-points in the plan".
Semantic attachments~\cite{dornhege09icaps}, predicates computed
by an external program, also provide a way of integrating blackbox
procedures and {\sc pddl} planners. 
%This allows the evaluation of grounded predicates as well as the change of fluents by externally specified functions
Because semantic attachments take 
a state as input, they can only be used in forward state-space search.
Furthermore, semantic attachments are ignored in heuristics. This results in poor planner performance, particularly when the attachments are expensive to evaluate such as in robotics domains. 
%considering the overhead of attachments that, for example, perform motion planning.
Finally, because semantic attachments are restricted to be functions, they are unable to model domains
with infinitely many possible successor states.
% Unable to produce several or infinitely many values
% Restricted to forward when generating

Many approaches to robotics planning problems, including motion
planning and task-and-motion planning, have developed strategies for
handling continuous spaces that go beyond {\em a priori}
discretization. %These approaches have been very successful in their intended domains of application but are not articulated as domain-independent methods.  Randomized sampling, for example, can be
%made to be effective in some spaces (as evidenced by the success of
%the RRT and PRM algorithms~\cite{Lavalle06} for robot motion
%planning).  
Several approaches, for example~\cite{HPN,Erdem,Srivastava14,GarrettIROS15,dantam2016tmp,garrett2016ffrob}, have been suggested for
% lozano2014constraint, GarrettWAFR14
integrating these sampling-based robot motion planning methods with
symbolic planning methods.  Of these approaches, those able to plan in
realistic robot domains have typically been quite special purpose; the
more general purpose approaches have typically been less capable.  
% Reviewer 1: On the other hand, I think the author's slightly misrepresent the cited paper by Srivastava et al. by suggesting that it's not domain independent

% Reviewer 1: Missing though, I think is the mention of the work on Infinite Streams in the Constraint Programming community, which is relevant from a formal standpoint, and perhaps practical, as this research discusses in depth similar notions to those in these papers, such as unbounded variable domains and non-periodicity, which complicates compact representation amenable for efficient propagation. See for instance "Constraint Programming on Infinite Data Streams" by A. Lallouet et al, IJCAI-11.

%\lpknote{Also mention here Srivastava?}
%\lpknote{Look at current state of Fox/Long work}
%\lpknote{Study iclingo; maybe try an example.}
%\lpknote{Look at Erdem and Mohan Sridharan and how they use ASP}
%\lpknote{Relevance Grounding for Planning in Relational Domains--Lang Toussaint} 
%\note{Look at the Brian William's flow tube stuff?}
%http://groups.csail.mit.edu/mers/publication_uploads/Publications/2015/Fernandez_Karpas_Williams_ICAPS_PlanRob_2015/scotty_PlanRob2015_cameraReady.pdf

%\note{Existing approaches only use linear dynamics and discretize in order to handle nonlinearity.}
%https://scungao.github.io/papers/planning.pdf
%http://www.inf.kcl.ac.uk/staff/danmag/mypapers/DiNoPaper.pdf
%http://www.cs.umd.edu/~nau/papers/alford2009translating.pdf
%\lpknote{Should we cite Alford, Nau on translating into pddl?}

\section{Representation}
In this section we describe the representational components of a
planning domain and problem, which include static and fluent
predicates, operators, and streams.  {\em Objects} 
serve as arguments to predicates and as
parameters to operators;  they are generated by streams.

A {\em static predicate} is a predicate which, for any tuple of
objects, has a constant truth value throughout a problem instance.
Static predicates generally serve to represent constraints on the
parameters of an operator. We restrict static predicates to only ever 
be mentioned positively because, in the general infinite case, it is not possible to 
verify that a predicate does not hold.

An {\em operator} schema is specified by a tuple of formal parameters $(X_1,
\ldots, X_n)$ and conjunctions of static positive
preconditions \kw{stat}, fluent literal preconditions \kw{pre}, and
fluent literal effects \kw{eff} and has the same semantics as in \strips.
% Distinction between group static preconditions and normal ones
% Leting $\id{IsP}$ be a generic static predicate and $\id{P1}, \id{P2},
% \id{P3}, \id{P4}$ be generic fluent predicates, the following is a
% sample operator:
% \begin{codebox}
% \Procname{\proc{Operator}$(X_1, ..., X_n)$:}
% \zi \kw{stat} = $\{\id{IsP}(X_1, ..., X_n), ...\}$
% \zi \kw{pre} = $\{\id{P1}(X_1, ..., X_n), ..., \neg \id{P3}(X_1, ..., X_n) ...\}$
% \zi \kw{eff} = $\{\id{P2}(X_1, ..., X_n), ..., \neg \id{P4}(X_1, ..., X_n)...\}$
% \end{codebox}
An operator instance is a ground instantiation of an operator schema
with objects substituted in for the formal parameters.
When necessary, we augment the set of operator schemas with a set of axioms
that naively use the same schema form as operators. We assume the set
of axioms can be compiled into a set of derived predicates as used in \pddl.   

A {\em generator} $g = \langle \bar{o}^1, \bar{o}^2, ... \rangle$ is a
finite or infinite sequence of object tuples $\bar{o} = (o_1, ...,
o_n)$.
The procedure $\proc{next}(g)$ returns the next element in generator
$g$ and returns the special object $\kw{None}$ to indicate that the
stream has been exhausted and contains no more objects.
A {\em conditional generator} $f(\bar{x})$ is a function from $\bar{x}
= x_1, ..., x_n$ to a generator $g_{\bar{x}}$ which generates tuples
from a domain not necessarily the same as the domain of $\bar{x}$. 

An {\em stream} schema, $\sigma(\bar{Y} \mid \bar{X})$, is specified
by a 
tuple of input parameters $\bar{X} = (X_1, ..., X_m)$, a tuple of
output parameters $\bar{Y} = (Y_1, ..., Y_n)$, a conditional generator
$\kw{gen} =  f(\bar{X})$ defined on $\bar{X}$, a conjunction of input static
atoms $\kw{inp}$ defined on $\bar{X}$, and a conjunction of output static
atoms $\kw{out}$ defined on $\bar{X}$ and $\bar{Y}$. 
The conditional generator $f$ is a function, implemented in the host
programming language, that returns a generator such that,
for all $\bar{x}$ satisfying the conditions \kw{inp}, $\forall \bar{y}
\in f(\bar{x}), (\bar{x}, \bar{y})$ satisfy the conditions \kw{out}. 
A stream instance is a ground instantiation of a stream schema with
objects substituted in for input parameters $(X_1, \ldots, X_n)$;  it
is {\em conditioned} on those object values and, if the \kw{inp}
conditions are satisfied, then it will generate a stream of tuples of
objects each of which satisfies the certification conditions \kw{out}.

% Figure~\label{fig:stream} gives an example stream template.
% Let $\id{IsP1}$ and $\id{IsP2}$ be generic static predicates.

% \begin{figure}[h!]
% \begin{codebox}
% \Procname{\proc{Stream}$(Y_1, ..., Y_n \mid X_1, ..., X_m)$:}
% %\zi \kw{gen} = $f: (x_1 \times ... \times x_m) \to \mathcal{P}(Y_1 \times ... \times Y_n)$
% %\zi \kw{gen} = $f: (x_1 \times ... \times x_m) \to \mathcal{P}(Y_1 \times ... \times Y_n)$
% %\zi \kw{gen} = $f: (x_1, ..., x_m) \to \langle (y_1^1, ..., y_n^1), (y_1^2, ..., y_n^2), ... \rangle$
% \zi \kw{gen} = $f(X_1, ..., X_m)$
% \zi \kw{inp} = $\{\id{IsP1}(X_1, ..., X_m), ...\}$
% \zi \kw{out} = $\{\id{IsP2}(X_1, ..., X_m, Y_1, ..., Y_n), ... \}$
% \end{codebox}
% \caption{A template stream.} \label{fig:stream}
% \end{figure}
% I'm not quite sure how to call the function $f$ here

The notion of a conditional stream is quite general;  there are two
specific cases that are worth understanding in detail.
An {\em unconditional stream} $\sigma(\bar{Y} \mid ())$ is a stream
with no inputs whose associated function $f$ returns a single
generator, which might be used to generate objects of a given type,
for example, independent of whatever other objects are specified in a
domain.
A {\em test stream} $\sigma(() \mid \bar{X})$ is a degenerate, but
still useful, type of stream with no outputs.  In this case, 
$f(X_1, ..., X_m)$ contains either the single element $()$, indicating
that the \kw{inp} conditions hold of $\bar{X}$, or
contains no elements at all, indicating that the \kw{inp} conditions
do not hold of $\bar{X}$.  It can be interpreted as an implicit
Boolean test.

%\begin{figure}[h!]
%\begin{codebox}
%\Procname{\proc{Test}$(() \mid x_1, ..., x_m)$:}
%\zi \kw{gen} = $f(x_1, ..., x_m)$
%\zi \kw{inp} = $\{\id{IsP1}(x_1, ..., x_m), ...\}$
%\zi \kw{out} = $\{\id{IsP2}(x_1, ..., x_m, Y_1, ..., Y_n), ... \}$
%\end{codebox}
%\caption{A template stream.} \label{fig:template}
%\end{figure}

A {\em planning domain}
${\cal D} = ({\cal P}_s, {\cal P}_f, {\cal C}_0, {\cal A}, {\cal X},
\Sigma)$ is specified by finite sets of static predicates
${\cal P}_s$, fluent predicates ${\cal P}_f$, initial constant objects
${\cal C}_0$, operator schemas ${\cal A}$, axiom schemas ${\cal X}$, and
stream schemas $\Sigma$.  Note that the initial objects (as well as
objects generated by the streams) may in general not be simple
symbols, but can be numeric values or even structures such as matrices
or objects in an underlying programming language.  They must provide a
unique ID, such as a hash value, for use in the STRIPS planning phase.
%method that converts to a string, without loss of information,
 
A {\em \algname{} problem} $\Pi = ({\cal D}, O_0, s_0, s_*)$ is
specified by a planning domain ${\cal D}$, a finite set of initial objects
$O_0$, an initial state composed of a finite set of static or fluent
atoms $s_0$, and a goal set defined to be the set of states satisfying
fluent literals $s_*$.  
% If we later made the solution be a sequence of streams and plan
% we could make the goal stream include static predicates
% Could I have a problem where you need to find an object that has a
% certain property? In this case, the static predicate would be in the
% goal 
We make a version of the closed world assumption on the initial state
$s_0$, assuming that all true fluents 
%and all true static atoms involving elements of ${\cal C}_0 \cup O_0$ 
are contained in it.  This
initial state will not be complete: in general, it will be impossible
to assert all true static atoms when the universe is infinite.

Let ${\cal O}_\Pi$ and ${\cal S}_\Pi$ be the universe of all objects and the set of true initial atoms
that can be generated from
a finite set $\Sigma$ of stream schemas, a finite set $C_0 \cup O_0$ of
initial objects, and initial state $s_0$. We give all proofs in the the appendix.
%The ${\cal S}_\Pi$ be the set of true initial atoms constructed by applying 
%static predicates in ${\cal P}_S$ to finite tuples of elements of ${\cal O}_\Pi$.
\begin{thm}  \label{thm:re}
${\cal O}_\Pi$ and ${\cal S}_\Pi$ are recursively enumerable (RE). 
\end{thm}
%\begin{proof}
%Consider an enumeration procedure for ${\cal O}_\Pi$ and ${\cal S}_\Pi$:
%\begin{itemize}
%\item The first sequences of elements in ${\cal O}_\Pi$ and 
%${\cal S}_\Pi$ are ${\cal C}_0 \cup O_0$ and $s_0$ respectively.
%\item Initialize a set of stream instances $\Sigma_\Pi = \{\;\}$.
%\item Repeat:
%\begin{itemize}
%\item For each stream schema $\sigma \in \Sigma$, add all
%  instantiations $\sigma(\bar{Y} \mid \bar{x})$ where $x \subseteq {\cal O}_\Pi$ such that
%  $\sigma.\kw{inp}(\bar{x})$ is contained within ${\cal S}_\Pi$,
%  to $\Sigma_\Pi$. There are finitely many new elements of
%  $\Sigma_\Pi$.
%\item For each stream instance $\sigma(\bar{Y} \mid \bar{x}) \in \Sigma_\Pi$, add
%  $\bar{y} = \proc{next}(\sigma.f(\bar{x}))$ to ${\cal O}_\Pi$ and add
%  $\sigma^*.\kw{out}((\bar{x}, \bar{y}))$ to ${\cal S}_\Pi$.
%  There are finitely many new elements of ${\cal O}_\Pi$ and ${\cal S}_\Pi$.
%\end{itemize}
%\end{itemize}
%This procedure will enumerate all possible objects and all possible
%initial atoms generated within the problem $\Pi$.
%\end{proof}
% Induction on levels

%  The set ${\cal A}_\Pi$ of all ground instances of operator schemas in set
%  $A$ with arguments in ${\cal O}_\Pi$ is RE because the 
%  Cartesian product of finitely many RE sets is RE.

% Let ${\cal S}_\Pi$ be the countable set of initial atoms satisfied by ${\cal O}^\Pi$. 
% We give recursive, constructive definitions for ${\cal O}_\Pi$ and ${\cal S}_\Pi$. % parallel
% Objects ${\cal C}_0 \cup O_0$ are members of ${\cal O}_\Pi$.
% Atoms $s_0$ are members of ${\cal S}_\Pi$.
% For all $\sigma \in \Sigma$ and $\hat{o} \in {\cal O}_\Pi^{m_\sigma}$
% where $\sigma.\kw{inp}(\hat{o}) \subseteq {\cal S}_\Pi$, then for all
% $\hat{o}' \in \sigma.f(\hat{o})$, $\hat{o}'$ are members of ${\cal
%   O}_\Pi$ and $\sigma.\kw{out}((\hat{o}, \hat{o}'))$ are members of
% ${\cal S}_\Pi$.
%$${\cal C}_0 \cup O_0 \subseteq {\cal O}_\Pi$$
%$$\Big(\bigcup_{\bar{o}' \in \sigma.f(\bar{o})}\bar{o}'\Big) \subseteq {\cal O}_\Pi, \forall \bar{o} \in {\cal O}_\Pi, \forall \sigma \in \Sigma$$ 
%\note{Need to actually state that they meet the input conditions.}
%$$s_0 \subseteq {\cal S}_\Pi$$
%A planning problem $\Pi$ is {\em feasible} if there exists a correct
%plan $p$ from ${\cal S}_\Pi$ to $s_*$ formed from a finite sequence of
%action instances from ${\cal A}_\Pi$. 
%\lpknote{Do we need to define correct?  Do we need this feasible definition? (Correct may be more important, but so tedious!)}

%We prove this and other theorems in the appendix.
A {\em solution} to a \algname{} problem $\Pi$ is a finite sequence of operator instances $\pi_*$ with object parameters contained within ${\cal O}_\Pi$ that is applicable from ${\cal S}_\Pi$ and results in a state that satisfies $s_*$.
\algname{} is undecidable but semi-decidable, so we restrict our attention
to feasible instances.

\begin{thm}\label{thm:decide}
The existence of a solution for a \algname{} problem $\Pi$ is
undecidable. 
\end{thm}
%\begin{proof}
%See the appendix.
%We use a reduction from the halting problem.
%Given a Turning machine TM, we construct a \algname{} 
%problem $\Pi_{TM}$ with a single operator
%\proc{Halt}(X) with $\kw{stat} = \{\id{IsReachable}(X)\}$, 
%$\kw{pre} = \emptyset$, and $\kw{eff} = \{\id{Reached}(X)\}$ where
%$\id{IsReachable}$ and $\id{Reached}$ are a static and fluent predicate
%defined on TM's states. There is a single unconditional stream $\proc{Reachable-U}(X \mid ())$ which 
%enumerates the states of TM by simulating one step of TM upon each call.
%Let $s_0 = \emptyset$ and $s_* = \{\id{Reached}(a)\}$
%where $a$ is the accept state for TM. $\Pi_{TM}$ has a solution if and only if TM halts.
%Thus, \algname{} is undecidable.
%\end{proof}

\begin{thm}\label{thm:decide}
The existence of a solution for a \algname{} problem $\Pi$ is
semi-decidable. 
\end{thm}
%\begin{proof}
%See the appendix.
%From the recursive enumeration of ${\cal O}_\Pi$ we can obtain a
%recursive enumeration of finite planning problems (planning problem
%$i$ is grounded using all objects enumerated up through element $i$).
%Plan existence in a finite universe is decidable.  If a finite plan
%exists, it will exist for a finite planning problem.  Thus, applying a
%finite decision procedure to the sequence of finite planning problems
%will eventually reach a planning problem for which a plan exists and
%find it, or run forever.
%\end{proof}
%\note{Could also test sequence of plans}

% Reviewer 1: Giving the Algorithms but not a formal description of the space of potential solutions - "the model" - is not something I endorse or appreciate and harks back to the prehistory of planning (i.e. before 1997). The reasons why automated planning has moved to decouple languages, models and algorithms are sound, and there is no good excuse to try to escape from that.

\section{Planning algorithms}
We present two algorithms for solving \algname{} problems:  the {\em
  \eager{}} planner takes advantage of certified conditional streams in
the problem specification to generate the necessary objects for solving
the problem;  the {\em focused} planner adds the ability to focus the
object-generation process based on the requirements of the plan being
constructed.  Both algorithms are sound and complete: if a solution
exists they will find it in finite time.

Both planners operate iteratively, alternating between adding elements
and atoms to a current set of objects and initial atoms and constructing and
solving \strips{} planning problem instances. 
%by constructing a \pddl{} problem description.
%and calling any sound and complete planner for the \strips{} subset of \pddl{}.  
A \strips{} problem $({\cal P}, {\cal
  A}, O, s_\id{init}, s_*)$ is specified by a set of predicates, a set of
operator schemas, a set of constant symbols, an initial set of
atoms, and a set of goal literals.  
Let $\proc{s-plan}({\cal P}, {\cal A}, O, s_\id{init}, s_*)$ be any sound and complete
planner for the \strips{} subset of \pddl{}.
We implement \proc{s-plan} using FastDownward~\cite{helmert2006fast}.

\subsection{\Eager{} planner} 

The \eager{} planner maintains a queue of
stream instances $Q$ and incrementally constructs set ${\cal O}$ of
objects and set ${\cal S}$ of fluents and static atoms that are true in the
initial state.  
%At any point in the algorithm ${\cal S}$ contains all 
%instances of ${\cal P}_s$ grounded using objects from ${\cal O}$.  
The {\em done} set $D$ contains all streams that have been constructed and
exhausted.  In each iteration of the main loop, a \strips{} planning
instance is constructed from the current sets ${\cal
  O}$ and ${\cal S}$, with the same predicates, operator and axiom schemas, and goal.  If a
plan is obtained, it is returned.  If not, then $K \geq 1$ attempts to add
new objects are made where $K$ is a meta-parameter.
In each one, a stream $\sigma(\bar{Y}\mid\bar{x})$
is popped from $Q$ and a new tuple of objects $\bar{y}$ is extracted
from it.  If the stream is exhausted, it is stored in $D$.  
Otherwise, the objects in $\bar{y}$ are added to
${\cal O}$, the output fluents from $\sigma$ applied to $(\bar{x},
\bar{y})$ are added to ${\cal S}$, and a new set of streams $\Sigma_n$
is constructed.  For all stream schemas $\sigma$ and possible tuples
of the appropriate size $\bar{x}'$, if the input conditions
$\sigma'.\kw{inp}(\bar{x}')$ are in ${\cal S}$, then the instantiated
stream $\sigma'(\bar{Y}'\mid{\bar x}')$ is added to $Q$ if it has not
been added previously.  We also return the stream
$\sigma(\bar{Y}\mid\bar{x})$ to $Q$ so we may revisit it in the future.
The pseudo-code is shown below.

\begin{footnotesize}
\begin{codebox}
\Procname{$\proc{\eager{}}((({\cal P}_s, {\cal P}_f,  {\cal
    C}_0, {\cal A}, {\cal X}, \Sigma), O_0, s_0, s_*),
  \proc{s-plan}, K):$} % Need to update the list of static predicates 
\zi ${\cal O} = {\cal C}_0 \cup O_0;\; {\cal S} = s_0;\; D = \emptyset$
\zi $Q = \proc{Queue}(\{\sigma(\bar{Y} \mid \bar{x}) \mid \sigma(\bar{Y} \mid \bar{X}) \in \Sigma$,
\zi \;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;$\bar{x} \in {\cal O}^{|\bar{X}|}, \sigma.\kw{inp}(\bar{x}) \subseteq {\cal S}\})$
\zi \While \kw{True}: \Do
\zi $\pi_* = \proc{s-plan}({\cal P}_s \cup {\cal P}_f, {\cal A}\cup{\cal
  X}, {\cal  O}, {\cal S}, s_*)$ 
\zi \If $\pi_* \neq \kw{None}$: \Then
\zi \Return $\pi_*$
\End
\zi \If $\proc{empty}(Q)$: \Then
\zi \Return $\kw{None}$
\End
\zi \For $k \in \{1, ..., \proc{min}(K, \proc{len}(Q))\}$: \Do
\zi $\sigma(\bar{Y} \mid \bar{x}) = \proc{pop}(Q)$
\zi $\bar{y} = \proc{next}(\sigma.f(\bar{x}))$
\zi \If $\bar{y} = \kw{None}$: \Then 
\zi $D = D \cup \{\sigma(\bar{Y} \mid \bar{x})\}$
\zi \kw{continue}
\End
\zi ${\cal O} = {\cal O} \cup \bar{y};\; {\cal S} = {\cal S} \cup
\sigma.\kw{out}((\bar{x}, \bar{y}))$ 
\zi \For $\sigma'(\bar{Y}' \mid \bar{X}') \in \Sigma$: \Do
\zi \For $\bar{x}' \in {\cal O}^{|\bar{X}'|}$: \Do
\zi \If $\sigma'.\kw{inp}(\bar{x}') \subseteq {\cal S}$, $\sigma'(\bar{Y}' \mid \bar{x}') \notin (Q \cup D)$: \Then
\zi $\proc{push}(Q, \sigma'(\bar{Y}' \mid \bar{x}'))$
\End\End\End
\zi $\proc{push}(Q, \sigma(\bar{Y} \mid \bar{x}))$
\End\End
\end{codebox}
\end{footnotesize}

In practice, many \proc{s-plan} calls report infeasibility immediately because they
have infinite admissible heuristic values. 
%We also can avoid immediately replanning if ${\cal O}$ and ${\cal S}$ have not
%changed from the last call.
We prove the \eager{} algorithm is complete in the appendix.
% Timeout to declare infeasible

\begin{thm}
The \eager{} algorithm is complete.
%\begin{proof}
%See the appendix.
%The \eager{} algorithm constructs ${\cal O}$ and ${\cal S}$ in the same way 
%as the enumeration procedure in theorem~\ref{thm:re} except that it 
%calls \proc{next} in batches of $K$. Thus, for any finite subsets of 
%${\cal O}_\Pi$ and ${\cal S}_\Pi$, after a finite number of iterations
%${\cal O}$ and ${\cal S}$ will contain those subsets.
%\proc{s-plan} is complete and therefore runs in finite time. On the first
%iteration where ${\cal O}$ and ${\cal S}$ contain the set of objects and static
%predicates used on a solution, \proc{s-plan} will produce a solution.
%\end{proof}
\end{thm}

\subsection{Focused planner}  

The focused planner is particularly aimed
at domains for which it is expensive to draw an object from a stream;
this occurs when the stream elements are certified to satisfy
geometric properties such as being collision-free or having
appropriate inverse kinematics relationships, for example.  To focus
the generation of objects on the most relevant parts of the space, we
allow the planner to use ``dummy'' abstract objects as long as it
plans to generate concrete values for them.  These concrete values
will be generated in the next iteration and will, hopefully,
contribute to finding a solution with all ground objects.
% Smaller planning problem?

As before, we transform the \algname{} problem into a sequence of
\pddl{} problems, but this time we augment the planning domain with
abstract objects, two new fluents, and a new set of operator schemas.  
Let $\{\gamma_1, ..., \gamma_\theta\}$ be a set of {\em
  abstract objects} which are not assumed to satisfy any static
predicates in the initial state. % where $\theta$ is a positive integer parameter.
%We choose $\theta$ as a large
%constant, which can be increased in the event that $\theta$ abstract
%objects is insufficient.
%If the solver is able to support functions, this set could be constructed implicitly on demand
%In practice, we use ${\id Active}(x)$ and ${\id Next}(x_1, x_2)$ in order to restrict the next abstract object used and limit the increase in branching factor.
We introduce the fluent predicate $\id{Concrete}$, which is initially
false for any object $\gamma_i$ but true for all actual ground
objects; so for all $o \in {\cal O}$, we add $\id{Concrete}(o)$ to
$s_{init}$.  The planner can ``cause'' an abstract object $\gamma_i$ to
satisfy $\id{Concrete}(\gamma_i)$ by generating it using a special
{\em stream operator}, as described below.  
We define procedure \proc{tform-ops}
that transforms each operator scheme $a(x_1, ..., x_n) \in {\cal A}$
by adding preconditions $\id{Concrete}(x_i)$ for $i = 1, ..., n$ to 
ensure that the parameters for $a$ are grounded before its
application during the search. 

To manage the balance in which streams are called,
for each stream schema $\sigma$, we introduce a new predicate
$\id{Blocked}_\sigma$; when applied to arguments
$(X_1, \ldots, X_n)$, it will temporarily prevent the use of stream
$\sigma(Y_1, ... Y_m \mid X_1, ..., X_n)$. Additionally, we add any new objects
and static atoms first to sets ${\cal O}_t$ and ${\cal S}_t$ temporarily before adding 
them to ${\cal O}$ and ${\cal S}$ to ensure any necessary existing streams
are called. Alternatively, we can immediately add directly to ${\cal O}$ and ${\cal S}$
a finite number of times before first adding to ${\cal O}_t$ and ${\cal S}_t$ and
still preserve completeness.
%In practice, a finite number of objects can be immediately added 
Let the procedure
\proc{tform-streams} convert each stream schema into an operator
schema $\sigma$ of the following form.

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{StreamOperator}$_\sigma(X_1, ..., X_m, Y_1, ..., Y_n)$:}
%\zi \kw{stat} = $\emptyset$ 
%\zi \kw{stat} = $\{\neg \id{Blocked}_\sigma(X_1, ..., X_m)\}$

% This should be blocked... - Yes & no. It is a static predicate, but it is not on of "our special" ones. It's also mentioned negatively here...
\zi \kw{pre} = $\sigma.\kw{inp} \;\cup\;$ \=$\{\id{Concrete}(X_i) \mid i = 1,
..., m\}\; \cup$ 
%\zi\> $\{\neg \id{Concrete}(Y_j) \mid j = 1,..., n\}\; $%\cup$
\zi\>$\{\neg \id{Blocked}_\sigma(X_1, ..., X_m)\}$
\zi \kw{eff} = $\sigma.\kw{out} \;\cup \{\id{Concrete}(Y_i) \mid i = 1, ..., n\}$
\end{codebox}
\end{footnotesize}

\noindent
It allows \proc{s-plan} to explicitly plan to generate a tuple of
concrete objects from stream $\sigma(Y_1, ... Y_m \mid x_1, ..., x_n)$
as long as the $x_i$ have been made concrete and the stream instance
is not blocked.  
% the $Y_j$ have not been made concrete,
%The preconditions $\{\neg \id{Concrete}(Y_i) \mid i = 1,..., n\}$ ensure $\gamma_i$ is only produced once. 
%The negative preconditions are dropped when $Y_j = \gamma_\theta$ in case more than $\theta$ abstract objects are needed.
%Additionally, for each non-test stream, we create a {\em derived test stream action} by treating its outputs as inputs. This action attempts to certify a predicate with concrete arguments by calling non-test stream.
% Output the same abstract object (i.e. Y_1 = Y_2)?
% Alternatively, I could just say I increase the cost when $Y_i$ are shared

% This restriction also prevents cyclic loops when assigning properties to objects.
% Additionally, there is a $\neg {\id Blocked}_\sigma(x_1, ..., x_n)$ precondition which is used to temporarily block the action from use.
% The effects are that the output values $Y_1, ..., Y_n$ are now grounded, and the inputs and outputs collectively satisfy properties $\sigma.\kw{out}$.

% Blocking prevents the STRIPS planner \proc{s-plan} from returning the same plan on each iteration.
% It is analogous to using a queue in the basic algorithm.
% It ensures that all streams useful to a plan will be called possibly an arbitrarily large number of time. 

% We transform static predicates into fluents

% \note{Make tform add the new predicates?}
%$\theta$ induces a maximum plan length. However, it will continuous
%to grow on the next iteration if I replenish $X_1, ..., X_\theta$

The procedure $\proc{\focused{}}$, shown below, implements the \focused{}
approach to planning.  It takes the same inputs as the \eager{}
version, but with the maximum number of abstract objects $\theta \geq 1$
specified as a meta-parameter, rather than $K$.  It also maintains a set ${\cal O}$ of
concrete objects and a set ${\cal S}$ of fluent and static atoms true in the
initial state.
In each iteration of the main loop, a
\strips{} planning instance is constructed: the initial state is
augmented with the set of static atoms indicating which streams are
blocked and fluents asserting that the objects in ${\cal O}$ are
concrete; the set of operator schemas is transformed as described above
and augmented with the stream operator schemas, and the set of objects
is augmented with the abstract objects.  If a plan is obtained and it
contains only operator instances, then it will have only concrete
objects, and it can be returned directly.  If the plan contains abstract objects, it also contains stream
operators, and \proc{add-objects}
is called to generate an appropriate set of new objects.  If no plan
is obtained, and if no streams are currently blocked as well as no new objects
or initial atoms have been produced since the last reset, then the problem
is proved to be infeasible.  
%Finally, if no plan is found, but some streams are blocked, then 
Otherwise, the problem is reset by unblocking all streams and adding
${\cal O}_t$ and ${\cal S}_t$ to ${\cal O}$ and ${\cal S}$, in order to allow
a new plan with abstract objects to be generated.
% Horizon of planning problem?
% Drawback is that the original problem is slightly harder
% Does temporary withholding static atoms do anything? They could if they involve existing objects

\begin{footnotesize}
\begin{codebox}
\Procname{$\proc{focused}((({\cal P}_s, {\cal P}_f,  {\cal C}_0, {\cal A}, {\cal X}, \Sigma), O_0, s_0, s_*), \proc{s-plan}, \theta):$}
\zi ${\cal O} =  {\cal C}_0 \cup O_0;\; {\cal S} = s_0$;\; ${\cal O}_t = {\cal S}_t = \beta_t = \beta_p = \emptyset$ 
%\zi ${\cal P} = \{{\id Concrete}(o) \mid o \in {\cal O}\}$
\zi $\bar{\cal A} = \proc{tform-ops}({\cal A});\; \bar{\Sigma} = \proc{tform-streams}(\Sigma)$ % Don't need to transform axioms
%\zi ${\cal A}, {\cal G} = \{\proc{tform}(a) \mid a \in A\}, \{\proc{tform}(g) \mid g \in G\}$
\zi \While \kw{True}: \Do
\zi $\pi = \proc{s-plan}($\=${\cal P}_s \cup {\cal P}_f, \bar{\cal A} \cup {\cal X} \cup \bar{\Sigma}, {\cal O} \cup \{\gamma_1, ..., \gamma_\theta\},$
\zi \> $\;{\cal S} \cup \beta_t \cup \beta_p \cup \{\id{Concrete}(o \in {\cal O})\} ,s_*)$ 
\zi \If $\pi $\=$\;\not= \kw{None}$: \Then 
\zi \If $\forall a \in \pi$, $\proc{schema}(a) \in \bar{\cal A}$: \Then 
\zi \Return $\pi$
\End
%\zi ${\cal O}_t, {\cal S}_t, \beta_t, \beta_p = \proc{add-objects}(\pi, {\cal O}_t, {\cal S}_t,  \beta_t, \beta_p, \bar{\Sigma})$ % Could also just make $\beta_p$ be $\beta$
\zi $\proc{add-objects}(\pi, {\cal O}_t, {\cal S}_t,  \beta_t, \beta_p, \bar{\Sigma})$ % Could also just make $\beta_p$ be $\beta$
\zi \Else
\zi \If ${\cal O}_t = {\cal S}_t = \beta_t = \emptyset$: \Then
\zi \Return $\kw{None}$ \Comment Infeasible
\End
\zi ${\cal O} = {\cal O} \cup {\cal O}_t; {\cal S} = {\cal S} \cup {\cal S}_t$
\zi ${\cal O}_t = {\cal S}_t = \beta_t = \emptyset$ \Comment Enable all objects \& streams
\End\End\End
\end{codebox}
\end{footnotesize}
% \tilde{\pi}

Given a plan $\pi$ that contains abstract objects, we process it
from beginning to end, to generate a collection of new objects with
appropriate conditional relationships.  Procedure \proc{add-objects}
initializes an empty binding environment and then loops through the
instances $a$ of stream operators in $\pi$.  For each stream operator
instance, we substitute concrete objects in for abstract objects, in
the input parameters, dictated by the bindings \id{bd}, and then draw
a new tuple of objects from that conditional stream.  If there is no such
tuple of objects, the stream is exhausted and it is permanently removed from
future consideration by adding the fluent
$\id{Blocked}_\sigma(\bar{o}_x)$ to the set $\beta_p$. Otherwise, the new
objects are added to ${\cal O}_t$ and appropriate new static atoms to
${\cal S}_t$.  This stream is temporarily blocked by adding fluent
$\id{Blocked}_\sigma(\bar{o}_x)$ to the set $\beta_t$, and the
bindings for abstract objects are recorded.
% Selector to bind only until conflict or only apply first?
% Timeout to declare infeasible

\begin{footnotesize}
\begin{codebox}
\Procname{$\proc{add-objects}(\pi, {\cal O}_t, {\cal S}_t, \beta_t, \beta_p, \bar{\Sigma}):$} % Find assignment
\zi $\id{bd} = \{\;\}$ \Comment Empty dictionary
\zi \For $\sigma (\bar{y} \mid \bar{x}) \in \{a \mid a \in \pi$
\kw{and} $\proc{schema}(a) \in \bar{\Sigma}\}$: \Do
\zi $\bar{o}_x = \proc{apply-bindings}(\id{bd}, \bar{x})$
\zi \If $\bar{o}_x  \neq \kw{None}$: \Then 
\zi $\bar{o}_y = \proc{next}(\sigma.f(\bar{o}_x))$  
\zi \If $\bar{o}_y  \neq \kw{None}$: \Then 
\zi ${\cal O}_t = {\cal O}_t \cup \bar{o}_y; {\cal S}_t ={\cal S}_t \cup \sigma.\kw{out}((\bar{o}_x, \bar{o}_y))$ 
\zi $\beta_t = \beta_t \cup \{\id{Blocked}_\sigma(\bar{o}_x)\}$ \Comment Temporary
\zi \For $i \in \{1, ..., |\bar{y}|\}$: \Then
\zi $\id{bd}[y_i] = o_{y, i}$
\End
\zi \Else
\zi $\beta_p = \beta_p \cup \{\id{Blocked}_\sigma(\bar{o}_x)\}$ \Comment Permanent
\End\End\End
\zi \Return ${\cal O}_t, {\cal S}_t, \beta_t, \beta_p$
\end{codebox}
\end{footnotesize}

% \begin{footnotesize}
% \begin{codebox}
% \Procname{$\proc{get-bindings}(\pi; {\cal O}, {\cal S},  \bar{\cal A}, \bar{\Sigma}, \id{blocked}):$} % Find assignment
% \zi $\id{bd} = \{x_i: x_i \mid a(x_1, ..., x_n) \in (\pi \setminus \bar{\cal A}), i = 1, ..., n, x_i \in {\cal O}\}$ \Comment Non-abstract bindings
% \zi \For $\sigma (\bar{y} \mid \bar{x}) \in (\pi \cap \bar{\Sigma})$: \Do
% \zi $\bar{o}_x = (\id{bd}[x_1], ..., \id{bd}[x_m])$
% \zi $\bar{o}_y = \proc{next}(\sigma.f(\bar{o}_x))$  
% \zi \If $\bar{o}_y  = \kw{None}$: \Then 
% \zi ${\cal S} = {\cal S} \cup \{\id{Blocked}_\sigma(\bar{o}_x)\}$ \Comment Permanently blocked
% \zi \Return \kw{None}, ${\cal O}, {\cal S}$
% \End
% \zi ${\cal O} = {\cal O} \cup \bar{o}_y; {\cal S} ={\cal S} \cup \sigma.\kw{out}((\bar{o}_x, \bar{o}_y))$ 
% \zi $\id{blocked} = \id{blocked} \cup \{\id{Blocked}_\sigma(\bar{o}_x)\}$ \Comment Temporarily blocked
% \zi \For $i = 1, ..., m$: \Do
% %\zi \If $Y_i \in {\id bd}$ \kw{and} ${\id bd}[Y_i] \neq y_i$: \Return \kw{None}
% \zi \If $y_i \in \id{bd}$ \kw{and} $\id{bd}[y_i] \neq o_{y, i}$: \Then 
% \zi \Return \kw{None}, ${\cal O}, {\cal S}$ \Comment Conflicting binding
% \End
% \zi $\id{bd}[y_i] = o_{y, i}$
% \End\End
% \zi \Return $\id{bd}, {\cal O}, {\cal S}$
% $(a(\id{bd}[x_1], ..., \id{bd}[x_n]) \mid a(x_1, ..., x_n) \in (\pi \cap \bar{\cal A}))$
% \end{codebox}
% \end{footnotesize}

The \focused{} algorithm is similar to the lazy shortest path
algorithm for motion planning in that it determines which streams to call, or 
analogously which edges to evaluate, by repeatedly solving optimistic problems~\cite{bohlin2000path,dellin2016unifying}.
Stream operators can be given meta-costs that reflect the time overhead to 
draw elements from the stream and the likelihood the stream produces the desired values. 
%For example, derived test stream actions can be given a large meta-cost because they are generally unlikely to certify a desired predicate.
For example, stream operators that use already concrete outputs can be given large meta-costs because they will only certify a desired predicate in the typically unlikely event that their generator returns objects matching the desired outputs.
A cost-sensitive planner will avoid returning
plans that require drawing elements from expensive or unnecessary streams. 
We can combine the behaviors of \eager{} and \focused{} algorithms to
eagerly call inexpensive streams and lazily call expensive streams. This can 
be seen as automatically applying some stream operators before calling \proc{s-plan}.
% Collisions, containment, etc...
% We assume that conflicting add and remove effects are cancelled (and nothing happens)

%In practice, I can share the last $\gamma_\theta$ such that it can still find a plan even if $\theta$ is too small (assuming $\theta \geq 1$. Because the assignment is conflicting, it will have to replan on the next iteration.

\begin{thm}
The \focused{} algorithm is complete.
%\begin{proof}
%See the appendix.
%\end{proof}
\end{thm}

% TODO - generative plan discussion

%Can trace identify a sequence of streams required to produce the objects along the plan along with the validation that they satisfy static predicates.
%\begin{defn}
%A {\em single source} is one where each object is the output of a single stream. 
%\end{defn}

%When restricting an object to be constructed by a single conditional stream, ${\id Concrete}(x)$ can also prevent repeat constructions.
%When planning for continuous domains where the intersection of two variables is unlikely to be nonempty, we add the following additional preconditions to ensure an abstract object is constructed by a single conditional stream.
%$\sigma.\kw{pre} = \sigma.\kw{pre}\cup \{\neg \id{Concrete}(y_i) \mid i = 1, ..., n\}$

%We can make abstract objects that are specific to the outputs of a single stream. 
%Otherwise, it will just use a single abstract object for everything which is not highly desirable. 
%Discuss why we don't include negative static predicates. We cannot ever truly verify if something doesn't have a property. We also don't want to introduce inconsistencies.

%Both the basic and focused algorithms work better when the single source property is satisfied. It means that there exists a plan that does not require intersecting two streams.

%\subsection{Online Planning}
% Planner that does the search and testing at the same time...
% Ignore in the heuristic but complete when about to apply an action for instance
% Relation to planning and execution

\section{Example discrete domain}

Although the specification language is domain independent, our primary
motivating examples for the application of \algname{} are 
pick-and-place problems in infinite domains.  
We start by specifying an infinite discrete pick-and-place domain as shown in figure~\ref{fig:countable_tamp}.
We purposefully describe the domain in a way that will generalize well
to continuous and high-dimensional versions of fundamentally the same
problem.  The objects in this domain include a finite set of blocks
(that can be picked up and placed), an infinite set of poses
(locations in the world) indexed by the positive integers, and an
infinite set of robot configurations (settings of the robot's physical
degrees of freedom) also indexed by the positive integers.  
%Figure~\ref{fig:python} gives a complete Python implementation of this domain in \algname{}.
In this appendix, we give a complete Python implementation of this domain in \algname{}
The static predicates in this domain include simple static types (\id{IsConf},
\id{IsPose}, \id{IsBlock}) and typical fluents (\id{HandEmpty},
\id{Holding}, \id{AtPose}, \id{AtConfig}).  In addition, atoms of the form
$\id{IsKin}(P, Q)$ describe a static relationship between an object pose
$P$ and a robot configuration $Q$:  in this simple domain, the atom is
true if and only if $P = Q$.  Finally, fluents of the form
$\id{Safe}(b', B, P)$ are true in the circumstance that: if object $B$ were
placed at pose $P$, it would not collide with object $b'$ at its
current pose.  Because the set of blocks {\cal B} is known statically
in advance, we explicitly include all the \id{Safe} conditions.
%although this could be achieved more compactly using quantification.
These predicate definitions enable the following operator schemas definitions:

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{Move}$(Q_1, Q_2)$:}
\zi \kw{stat} = $\{\id{IsConf}(Q_1), \id{IsConf}(Q_2)\}$
\zi \kw{pre} = $\{\id{AtConf}(Q_1)\}$
\zi \kw{eff} = $\{\id{AtConf}(Q_2), \neg \id{AtConf}(Q_1)\}$
\end{codebox}
\begin{codebox}
\Procname{\proc{Pick}$(B, P, Q)$:}
\zi \kw{stat} = $\{\id{IsBlock}(B), \id{IsPose}(P), \id{IsConf}(Q), \id{IsKin(P, Q)}\}$
\zi \kw{pre} = $\{\id{AtPose}(B, P), \id{HandEmpty}(), \id{AtConfig}(Q)\}$
\zi \kw{eff} = $\{\id{Holding}(B), \neg \id{AtPose}(B, P), \neg \id{HandEmpty}()\}$
\end{codebox}
\begin{codebox}
\Procname{\proc{Place}$(B, P, Q)$:}
\zi \kw{stat} = $\{\id{IsBlock}(B), \id{IsPose}(P), \id{IsConf}(Q), \id{IsKin(P, Q)}\}$
%\zi \kw{pre} = $\{\id{Holding}(B), \id{AtConfig}(Q)\} \cup \{\id{Safe}(b', B, P) \mid b' \in {\cal B}\}$
\zi \kw{pre} = $\{\id{Holding}(B), \id{AtConfig}(Q)\} \cup \{\id{Safe}(b' \in {\cal B}, B, P)\}$
\zi \kw{eff} = $\{\id{AtPose}(B, P), \id{HandEmpty}(), \neg \id{Holding}(B)\}$
\end{codebox}
\end{footnotesize}

We use the following axioms to evaluate the \id{Safe} predicate.
%provide a compact definition of 
We need two slightly different definitions to handle the cases where the block $B_1$ is placed at a pose,
and where it is in the robot's hand.
The \id{Safe} axioms mention each block independently which allows us to compactly perform collision checking. 
Without using axioms, \proc{Place} would require a parameter for the pose of each block in ${\cal B}$, resulting in an prohibitively large grounded problem.
%This results in a much more compact grounded representation of \proc{Place} than if we had 

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{SafeAxiom}$(B_1, P_1, B_2, P_2)$:}
\zi \kw{stat} = $\{\id{IsBlock}(B_1), \id{IsPose}(P_1), \id{IsBlock}(B_2),$ \Indentmore
\zi $\id{IsPose}(P_2), \id{IsCollisionFree}(B_1, P_1, B_2, P_2)\}$ \End
\zi \kw{pre} = $\{\id{AtPose}(B_1, P_1)\}$
\zi \kw{eff} =$\{\id{Safe}(B_1, B_2, P_2)\}$
\end{codebox}
\begin{codebox}
\Procname{\proc{SafeAxiomH}$(B_1, B_2, P_2)$:}
\zi \kw{stat} = $\{\id{IsBlock}(B_1), \id{IsBlock}(B_2), \id{IsPose}(P_2)\}$ \End
\zi \kw{pre} = $\{\id{Holding}(B_1)\}$
\zi \kw{eff} =$\{\id{Safe}(B_1, B_2, P_2)\}$
\end{codebox}
% \begin{codebox}
% \Procname{\proc{RegionAxiom}$(B, P, R)$:}
% \zi \kw{stat} = $\{\id{IsBlock}(B), \id{IsPose}(P), \id{IsRegion}(R), \id{IsCont}(R, B, P)\}$ \End
% \zi \kw{pre} =$\{\id{AtPose}(B, P)\}$
% \zi \kw{eff}= $\{\id{InRegion}(B, R)\}$
% \end{codebox}
\end{footnotesize}

\paragraph{Discrete stream specification}

Next, we provide stream definitions.  The simplest stream is an
unconditional generator of poses, which are represented as objects
$\proc{Pose}(i)$ and satisfy the static predicate $\id{IsPose}$.

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{Pose-U}$(P \mid ())$:}
\zi \kw{gen} = $\kw{lambda} (): \langle (\proc{Pose}(i)) \;\kw{for}\; i = 0, 1, 2 ... \rangle$
\zi \kw{inp} = $\emptyset$
\zi \kw{out} = $\{\id{IsPose}(P)\}$
\end{codebox}
\end{footnotesize}

The conditional stream \proc{CFree-T} is a test, calling the
underlying function $\proc{collide}(B_1, P_1, B_2, P_2)$;  the stream
is empty if block $B_1$ at pose $P_1$ collides with block $B_2$ at
pose $P_2$, and contains the single element $(\;)$ if it does not
collide.  It is used to certify that the tuple $(B_1, P_1, B_2, P_2)$
statically satisfies the \id{IsCollisionFree} predicate.
%\begin{codebox}
%\Procname{\proc{PoseTest}$(() \mid p )$:}
%\zi \kw{gen}: $F(p) = \langle () \rangle$
%\zi \kw{inp}: $\{\}$
%\zi \kw{out}: $\{{\id IsPose}(p)\}$
%\end{codebox}
%\caption{The pose test.} \label{fig:ik}

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{CFree-T}$(() \mid B_1, P_1, B_2, P_2)$:}
\zi \kw{gen} = $\kw{lambda} (B_1, P_1, B_2, P_2):$ 
\zi \>\>\> $\langle () \;\kw{if} \;\kw{not}\; \proc{collide}(B_1, P_1, B_2, P_2) \rangle$
\zi \kw{inp} = $\{\id{IsBlock}(B_1), \id{IsPose}(P_1), \id{IsBlock}(B_2), \id{IsPose}(P_2)\}$
%\zi \kw{out} = $\{{\id IsCollisionFree}(o_1, p_1, o_2, p_2)\}$
%\zi \kw{out} = $\{{\id IsCollisionFree}(B_1, P_1, B_2, P_2), {\id IsCollisionFree}(B_2, P_2, B_1, P_1)\}$
\zi \kw{out} = $\{\id{IsCollisionFree}(B_1, P_1, B_2, P_2)\}$
\end{codebox}
% \begin{codebox}
% \Procname{\proc{ContainedT}$(() \mid R, B, P)$:}
% %\zi \kw{gen}: $F(r, p) = \langle  () \rangle$
% \zi \kw{gen} = $\kw{lambda} (R, B, P): \langle () \;\kw{if}\; \proc{inside}(R, B, P) \rangle$
% \zi \kw{inp} = $\{\id{IsRegion}(R), \id{IsBlock}(B), \id{IsPose}(P)\}$
% \zi \kw{out} = $\{\id{IsCont}(R, B, P)\}$
% \end{codebox}
\end{footnotesize}

When we have a static relation on more than one variable, such as
\id{IsKin}, we have to make modeling choices when defining streams that
certify it.

We will consider three formulations of streams that certify \id{IsKin}
and compare them in terms of their effectiveness in a simple countable pick-and-place
problem requiring the robot gripper to pick block $A$ at a distant
initial pose $p_0 >> 1$, shown in figure~\ref{fig:countable_tamp}.

\proc{Kin-U} specifies an unconditional stream on block poses and
robot configurations;  it has no difficulty certifying the \id{IsKin}
relation between the two output variables, but it has no good way of
producing configurations that are appropriate for poses that are
mentioned in the initial state or goal.  

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{Kin-U}$(P, Q \mid ())$:}
%\Procname{\proc{IKConstStream}$(P, Q \mid ())$:}
%\zi \text{gen}: $\kw{lambda} (): \langle (\text{p\_i}, \text{q\_i}) \;\For\; \text{i} = 1, 2, ... \rangle$
\zi \kw{gen} = $\kw{lambda} (): \langle (\proc{Pose}(i), \proc{Conf}(i)) \;\For\; \text{i} = 1, 2, ... \rangle$
%\zi \kw{cond}: $F() = \langle (p_0, q_0), (p_1, q_1), ... \rangle$
\zi \kw{inp} $ = \emptyset$
%\zi \textit{inp} $\{\}$
\zi \kw{out} = $\{\id{IsPose}(P), \id{IsConf}(Q), \id{IsKin}(P, Q)\}$
%\zi \text{infer}: $\{\text{IsPose}(P), \text{IsConf}(Q), \text{IsIK}(P, Q)\}$
\end{codebox}
\end{footnotesize}

\proc{Kin-T} specifies a test stream that can be used, together with
the \proc{Pose-U} stream and an analogous stream for generic
configurations to produce certified kinematic pairs $P, Q$.  This is
an encoding of a ``generate-and-test'' strategy, which may be highly
inefficient, relying on luck that the pose generator and the
configuration generator will independently produce values that have
the appropriate relationship.

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{Kin-T}$(() \mid P, Q)$:}
%\zi \kw{cond}: $F(p_i) = \langle (q_i) \rangle$
%\zi \kw{gen} = $\kw{lambda} (p): \langle (\text{q\_}p[1:]) \rangle$
\zi \kw{gen} = $\kw{lambda} (P, Q): \langle () \;\kw{if}\; Q = \proc{inverse-kin}(P)\rangle$
\zi \kw{inp} = $\{\id{IsPose}(P), \id{IsConf}(Q)\}$
\zi \kw{out} = $\{\id{IsKin}(P, Q)\}$
\end{codebox}
\end{footnotesize}

Finally, \proc{Kin-C} specifies a conditional stream, which takes a
pose $P$ as input and generates a stream of configurations (in this
very simple case, containing a single element) certified to satisfy
the \id{IsKin} relation.  It relies on an underlying function
$\proc{inverse-kin}(p)$ to produce an appropriate robot configuration
given a block pose.

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{Kin-C}$(Q \mid P)$:}
%\zi \kw{cond}: $F(p_i) = \langle (q_i) \rangle$
%\zi \kw{gen} = $\kw{lambda} (p): \langle (\text{q\_}p[1:]) \rangle$
\zi \kw{gen} = $\kw{lambda} (P): \langle (\proc{inverse-kin}(P)) \rangle$
\zi \kw{inp} = $\{\id{IsPose}(P)\}$
\zi \kw{out} = $\{\id{IsConf}(Q), \id{IsIK}(P, Q)\}$
\end{codebox}
\end{footnotesize}

In our example domain, both \proc{Kin-U} and \proc{Kin-T} require the
enumeration of poses and configurations $(p_i, q_i)$ from $i = 0, 1,
..., p_0$ before certifying $\id{IsIK}(p_*, q_*)$, allowing \strips{}
to make a plan include the operator
$\proc{Pick}(A, p_*, q_*)$. Moreover, \proc{Kin-T} will test all pairs
of configurations and poses.  In contrast, \proc{Kin-C}  can produce
$q$ directly from $p_0$ without enumerating any other poses or
configurations. The conditional formulation is advantageous
because it produces a paired inverse kinematics configuration quickly
and without substantially expanding the size of the problem. 

Table~\ref{fig:countable_table} validates this intuition though an
experiment comparing these stream specifications.  The initial pose of
the object $p_0$ is chosen from $1, 100, 1000$.  All trials have a timeout of 120 seconds and use the
\eager{} algorithm with $K=1$ implemented in Python.
%The table shows the runtime (t), number of search iterations (i), and number of generator calls (c).  
As predicted, the \proc{Kin-U} and \proc{Kin-T}
streams require many more calls than \proc{Kin-C} as $p_0$ increases
and lead to substantially longer runtimes for a very simple problem.
%lead larger problems as $p_0$ increases while \proc{IK-G} is not affected by varying $p_0$.

%\note{Minimum number of calls to contain a solution property}
%\note{Could also do IK q to p}

\begin{figure}[ht]
\centering
\includegraphics[width=0.23\textwidth]{images/countable_initial.pdf}
\includegraphics[width=0.23\textwidth]{images/countable_goal.pdf}
\caption{The initial state and goal state in an infinite, discrete pick-and-place problem requiring picking block A. } 
\label{fig:countable_tamp}
\end{figure}

\begin{table}[t]
\begin{footnotesize}
\begin{tabular}{||c||g|c|c||g|c|c||g|c|c||}
\hline
$p_0$ & \multicolumn{3}{|c||}{\proc{Kin-U}}&\multicolumn{3}{|c||}{\proc{Kin-T}}&\multicolumn{3}{|c||}{\proc{Kin-C}}\\
\hline
&
t & i & c &
t & i & c &
t & i & c \\
\hline
1 & 
%.09 & 3 & 2 &
%.15 & 6 & 9 &
%.08 & 3 & 2 \\
.1 & 3 & 2 &
.2 & 6 & 9 &
.1 & 3 & 2 \\
\hline
100 & 
%28.86 & 102 & 101 &
%70.94 & 303 & 10360 &
29 & 102 & 101 &
71 & 303 & 10360 &
%.09 & 3 & 2 \\ % The difference from 2 & 1 is just the ordering of sample pose vs IK
.1 & 3 & 2 \\
\hline
1000 & 
- & 180 & 179 &
- & 381 & 16383 &
%.08 & 3 & 2 \\
.1 & 3 & 2 \\
\hline
\end{tabular}
\end{footnotesize}
%\caption{Countable pick-and-place \proc{Kin} stream representation experiment with a timeout of 120 seconds.}
\caption{The runtime (t), number of search iterations (i), and number of
generator calls (c) for the countable pick-and-place \proc{Kin} stream representation experiment.}
\label{table}
\label{fig:countable_table}
\end{table}
% The q -> p generative algorithm is like the constant
% The implicit algorithm must try a bunch of bad pairs
% Search time, average search time, #test, #non-tests
% Minimum # calls 
% Search iterations

\section{Continuous domains}

The \algname{} approach can be applied directly in continuous domains such as the problem in figure~\ref{fig:obstruction}.
In this case, the streams will have to generate samples from sets of continuous
dimensions, and the way that samples are generated may have a
significant impact on the efficiency and completeness of the approach
with respect to the domain problem.  (Note that the \algname{} planing
algorithms are complete with respect to the streams of enumerated
values they are given, but if these value streams are not, in some
sense, complete with respect to the underlying problem domain, then
the resulting combined system may not be complete with respect to the
original problem.)  Samplers that produce a {\em dense}
sequence~\cite{Lavalle06} are good candidates for stream generation.

\subsection{Continuous stream specification}

With some minor modifications, we can extend our discrete
pick-and-place domain to a bounded interval $[0, L]$ of the real
line.  Poses and configurations are now continuous objects
$p, q \in [0, L]$ from an uncountably infinite domain.  
% resolution, rational numbers, uniformly at random, ...
The stream \proc{Pose-U} now has a generator that samples $[0, L]$
uniformly at random.  
%When streams are stochastic, they define a
%distribution of problems where the drawn problem instance is unveiled
%to a planner dynamically using the principle of deferred decisions.
%\lpknote{I don't understand the preceding sentence at all}
%Finally, collision checks now take into account object geometries. 
%New external procedures are $p \sim \proc{uniform-interval}()$, $p \sim \proc{uniform}()$, $p \sim \proc{uniform}(\proc{min}(r),  \proc{max}(r))$

While in the discrete case the choice of streams just affected the
size of the problem, in the continuous case, the choice of streams can
affect the feasibility of the problem. 
%While in the discrete case the choice of streams just affected the
%size of the problem, in the continuous case, the choice of streams can
%affect the feasibility of the problem.  
%The \proc{Kin}$(P, Q \mid ())$ stream has zero probability of producing
%any desired pose or configuration. The \proc{Kin}$(() \mid P, Q)$ test
%stream requires a pose and configuration as inputs. 
%When sampled independently at random, there is zero probability that they form a valid kinematic pair.
%%See the extended version of this paper for additional discussion~\cite{garrett2017strips}.
In the continuous simple pick-and-place domain, suppose that the blocks have width 1 and the
gripper has width $\delta \geq 1$.  A kinematics pair $(p,q)$ is valid
if and only if the gripper is entirely over the block, i.e.,
$p + 1/2 \leq q + \delta/2$ and $p - 1/2 \geq q -\delta/2$.  Consider
the case where \proc{Kin-U} and \proc{Kin-C} are implemented using
random samplers.  \proc{Kin-U} will almost certainly generate a
sequence of infeasible \strips{} problems, because the probability
that the point $p_0$ is produced from its generator is zero.  For
$\delta > 1$, the configuration stream has nonzero probability of
generating a $q$ that would constitute a valid kinematics pair with
$p$ as certified by \proc{Kin-T}. But this probability can be made
arbitrary small as $\delta \to 1$. Only the \proc{Kin-C} strategy
is robust to the choice of $\delta$. Table~\ref{fig:continuous_table}
shows the results of an experiment analogous to the one in
table~\ref{fig:countable_table}, but which varies
$\delta \in \{1.5, 1.01\}$ instead of varying $p_0$. \proc{Kin-U} was unable
to solve either problem and \proc{Kin-T} could not find a solution in
under two minutes for $\delta = 1.01$. But once again, the conditional
formulation using \proc{Kin-C} performs equivalently for different
values of $\delta$.
%In the continuous domain, \proc{IK-U} has a generator which samples $[0, L]$ uniformly at random.  
%If the sampling in \proc{IK-U} is done deterministically and fixed, any problem with a $p_0$ that is not within the sequence will be infeasible. If the sampling in \proc{IK-G} is done stochastically, then $p_0$ will not be in the generated sequence with probability one. Thus, the \proc{IK-G} formulation is the only one which would generically be able to solve the problem for any $p_0$.
%The constant stream specification (Const.) is unable to solve any of these problems because the probability that a sampled $p, q$ pair is equal to the initial pose $p_0$ is zero. Thus, the problem using the constant stream specification is infeasible with probability 1.
%The test stream specification (Test) is able to solve the first problem when $\Delta = 1.5$, albeit less efficiently than the generative stream specification. However, when $\Delta = 1.01$, the test stream specification is ineffective because the probability that independently sampled poses and grasps are less than $.05$ units apart is small ($.01$). This inefficiency is even more prevalent when moving to high dimensional variables.
% Expected number of iterations is 10/.1
%This example highlights a key consideration when modeling continuous domains that the streams be specified in a way that only generatively produces each continuous object. The probability that two random samplings intersect is zero
% Product/intersection

\begin{table}[t]
\begin{footnotesize}
\begin{tabular}{||c||g|c|c||g|c|c||g|c|c||}
\hline
$\delta$ & \multicolumn{3}{|c||}{\proc{Kin-U}}&\multicolumn{3}{|c||}{\proc{Kin-T}}&\multicolumn{3}{|c||}{\proc{Kin-C}}\\
\hline
& %time & iter & calls &
t & i & c &
t & i & c &
t & i & c \\
\hline
1.5 & 
- & 191 & 190 &
3.1 & 75 & 745 &
%3.18 & 75 & 745 &
%.07 & 2 & 1 \\
.1 & 2 & 1 \\
\hline
1.01 & 
- & 181 & 180 &
- & 297 & 18768 &
%.07 & 2 & 1 \\
.1 & 2 & 1 \\
\hline
\end{tabular}
\end{footnotesize}
\caption{The runtime (t), number of search iterations (i), and number of generator calls (c) for the continuous pick-and-place \proc{Kin} stream representation experiment.}
\label{table}
\label{fig:continuous_table}
\end{table}

%\begin{figure}[h]
%\centering
%\includegraphics[width=0.45\textwidth]{images/continuous_initial.png}
%\caption{The initial state in a 1D continuous TAMP problem requiring picking block A. } 
%\label{fig:1D_tamp}
%\end{figure}

%\paragraph{Intersecting Constraints}
%
%Conditional streams can also be used to sample at the intersection of constraints that are not contained within a single operator.
%Consider an example in which the gripper must place a block in the intersection of two regions $R_1$ and $R_2$. Suppose that there intersection has width 1, so the block only fits within both at one point. A problem specification that only included \proc{Contained-S}$(P \mid R, B)$ would lead to an infeasible problem with high probability because the conjunctive constraint reduces the dimensionality of valid goal poses.
%However, a problem specification that included an additional pairwise stream \proc{Contained-S2}$(P \mid R_1, R_2, B)$ could directly sample from this lower dimensional manifold, admitting a feasible problem. In general, when modeling an application where continuous values are must satisfy a dimensionality reducing constraint, it is important to model application with streams that are able to produce objects that satisfy these constraints.  
%To model an extremely adversarial problem, one might need a stream that produces objects using any combination of 

%\begin{figure}[h!]
%\begin{footnotesize}
%\begin{codebox}
%\Procname{\proc{Contained-S1}$(P \mid R, B)$:}
%\zi \kw{gen} = $\kw{lambda}(R, B): \langle p \sim \proc{uniform}(R) \rangle$
%\zi \kw{inp} = $\{\id{IsRegion}(R), \id{IsBlock}(B)\}$
%\zi \kw{out} = $\{\id{IsPose}(P), \id{IsCont}(R, B, P)\}$
%\end{codebox}
%\begin{codebox}
%\Procname{\proc{Contained-S2}$(P \mid R_1, R_2, B)$:}
%\zi \kw{gen} = $\kw{lambda}(R_1, R_2 B): \langle p \sim \proc{uniform}(R_1 \cap R_2) \rangle$
%\zi \kw{inp} = $\{\id{IsRegion}(R_1), \id{IsRegion}(R_2), \id{IsBlock}(B)\}$
%\zi \kw{out} = $\{\id{IsPose}(P), \id{IsCont}(R_1, B, P), \id{IsCont}(R_2, B, P)\}$
%\end{codebox}
%\end{footnotesize}
%\caption{The joint containment stream.} \label{fig:ik}
%\end{figure}

%\begin{figure}[h]
%\centering
%\includegraphics[width=0.23\textwidth]{images/region_initial.png}
%\includegraphics[width=0.23\textwidth]{images/region_goal.png}
%\caption{The initial state in a 1D continuous TAMP problem requiring placing block A such that it is contained in both region R1 and region R2. } 
%\label{fig:region}
%\end{figure}

\subsection{Focused algorithm example}

\begin{figure*}[ht]
\centering
\includegraphics[width=0.23\textwidth]{images/continuous_initial.pdf}
\includegraphics[width=0.23\textwidth]{images/continuous_goal.pdf}
\includegraphics[width=0.23\textwidth]{images/continuous_middle.pdf}
\caption{Initial state for countable pick-and-place problem requiring
  picking and placing block A, with a single obstacle.} 
%\caption{The goal state achieved by the plan.} 
\label{fig:obstruction}
\end{figure*}

The previous examples investigated the effect of different representational choices on the tractability and even feasibility of the resulting \algname{} problem. 

%The subsequent examples instead investigate the difference between the eager and lazy planners. Consider the countable problem in figure~\ref{fig:distractions}. This problem can be extended to the continuous case without loss of generality.
%The goal is similar as in figure~\ref{fig:countable_tamp}; however, there are 100 other blocks on the line. While these do not impact the solution to the problem, they can impact the performance of the planners. For instance, the eager algorithm would blindly produce \proc{IK-C} pairs for each block despite only one being needed. In contrast, the lazy algorithm would just produce \proc{IK-C} for block A because it simultaneously reasons about which conditional streams to apply while finding a solution.
%This can frequently avoid producing objects that are not necessary for a solution.
%In practice, performing IK many times can be computationally expensive rendering the eager algorithm prohibitive.

%\begin{figure}[h]
%\centering
%\includegraphics[width=0.45\textwidth]{images/distractions_initial.png}
%\caption{The initial state in a countable TAMP problem requiring picking block A in a environment with many obstacles.} 
%\label{fig:distractions}
%\end{figure}

The example in figure~\ref{fig:obstruction} illustrates the behavior
of the focused algorithm on continuous a pick-and-place problem with the
goal condition that block $A$ is at pose $p_*$. Because block A, when
at $p_*$, collides with block B at its initial pose $p_0'$, solving
this problem requires
moving block $B$ out of the way to place block $A$. Suppose we use
\proc{Kin-C} to model the problem.  We will omit \proc{Move} operators
for the sake of clarity,  and use capital letters to denote abstract
objects. On the first iteration, the \focused{} algorithm will produce the
following plan (possibly ordered slightly differently):
%$$\proc{Pick}(A, p_0, Q_1) \to \proc{Place}(A, p_*, Q_2)$$

\begin{footnotesize}
\begin{align*}
\pi_1 &=  \big(\proc{Kin-C}(Q_1 \mid p_0), \proc{Pick}(A, p_0, Q_1), \proc{Kin-C}(Q_2 \mid p_*), \\
& \proc{CFree-T}(() \mid B, p_0', A, p_*), \proc{Place}(A, p_*, Q_2)\big)
\end{align*}
\end{footnotesize}

The generation of values proceeds as follows.
$\proc{Kin-C}(Q_1 \mid p_0)$ will produce $Q_1 \leftarrow
q_1$. $\proc{Kin-C}(Q_2 \mid p_*)$ will produce $Q_2 \leftarrow
q_2$. However, $\proc{CFree-T}(() \mid B, p_0', A, p_0)$ will produce the
empty stream because $p_0'$ collides with $p_*$. Thus, the plan
$\pi_1$ definitively cannot be completed. The algorithm adds $q_1$ and
$q_2$ to the current \pddl{} problem and records the failure of
$\proc{CFree-T}(() \mid B, p_0', A, p_0)$. 
On the next iteration, the \focused{} algorithm will produce the
following plan. 

\begin{footnotesize}
\begin{align*}
\pi_2 &=  \big(\proc{Kin-C}(Q_1 \mid p_0'), \proc{Pick}(B, p_0', Q_1), \proc{Pose-U}(P_1 \mid ()), \\
& \proc{Kin-C}(Q_2 \mid P_1), \proc{CFree-T}(() \mid A, p_0, B, P_1), \proc{Place}(B, P_1, Q_2), \\
& \proc{Pick}(A, p_0, q_1), \proc{CFree-T}(() \mid B, P_1, A, p_*), \proc{Place}(A, p_*, q_2) \big)
\end{align*}
\end{footnotesize}

The generation of values proceeds as follows.
$\proc{Kin-C}(Q_1 \mid p_0')$ will produce $Q_1 \leftarrow
q_3$. $\proc{Pose-U}(P_1 \mid ())$ will produce $P_1 \leftarrow p_1$.
$\proc{Kin-C}(Q_2 \mid p_1)$ will produce $Q_2 \leftarrow q_4$.  Let's
assume that $P_1 \leftarrow p_1$ is randomly sampled and turns out to
not be in collision with $p_*$. If $p_1$ turned out to be in collision
with $p_*$, the next iteration would first fail once, then repeat this
process on the next iteration to generate a new $P_1$.  So,
$\proc{CFree-T}(() \mid A, p_1, B, p_0)$ will produce the stream
$\langle () \rangle$ indicating that $p_1$ and $p_0$ are not in
collision.  Thus, all of the properties have been successfully
satisfied, so the following plan is a solution.
% Need to include the other place collision as well
It is critical to note that, for example, had there been several other
pose constants appearing in the initial state, \focused{} would never have
found inverse kinematic solutions for them:
because the planner guides the sampling, only stream elements that
play a direct role in a plausible plan are generated.
% Both the eager and lazy algorithm solve this in under a second

\begin{footnotesize}
\begin{align*}
\pi_* &=  \big(\proc{Pick}(B, p_0', q_3), \proc{Place}(B, p_1, q_4), \proc{Pick}(A, p_0, q_1), \\
& \proc{Place}(A, p_*, q_2)\big)
\end{align*}
\end{footnotesize}
%
%\subsection{Rocket domain}
%
%%\note{The "SpaceX" challenge?}
%\algname{} can be used to model a general class of systems that
%involve continuous variables and nonlinear predicates. Here we
%consider a 1D rocket that must deliver a satellite into orbit. We
%assume simplified nonlinear, continuous dynamics in which the rocket
%can generate a sequence of commands, each of which consists of the
%application of of a continuous bounded acceleration $a$ for a duration of
%time $\Delta t$.
%%The rocket can choose any continuous valued force and duration within a control limit and time limit respectively.
%%The rocket is affected by gravity.
%%The mass of the rocket is constant and negligibly affected by the satellite. 
%For simplicity, we ignore the effect of mass.
%The rocket must deploy the satellite at a specified
%altitude $h_*$ and at zero velocity, and then must land safely, again
%at zero velocity.
%% Collisions with the ground?
%%Relevant actions include \proc{LiftOff}, \proc{Burst}, \proc{Glide}, \proc{Deploy}, and \proc{Land}. 
%Because the rocket must precisely reach a state $x = (p, v)$ with position $p =
%h_*$ and velocity of $v = 0$,  we must solve a two-point boundary
%value problem to find controls $a$, $\Delta t$ from another state
%$p_1, v_1$. Thus, this problem cannot be implemented using PDDL+
%processes which can only forward simulate differential dynamics.
%A solution may not exist if the required acceleration or time is
%outside their limits or the trajectory causes the rocket to crash. 
%Our simple planner can solve an example instance in less than a
%second, requiring three bursts to reach orbit.   
%
%%The domain is described in detail in supplementary material;  
%The most
%interesting part of the formalization are the stream schemas with certify the $\id{IsBurst}(X_1, A, \Delta T, X_2)$ static predicate which is a precondition of operator $\proc{Burst}(X_1, A, \Delta T, X_2)$: 
%\begin{itemize}
%\item $\proc{ForwardBurst-C}(X_2 \mid X_1, A, \Delta T)$: given a
%  previous state $X_1 = (P_1, V_1)$ and control $A, \Delta T$, generate the
%  resulting state $X_2 = (P_2, V_2)$ using $P_2 = P_1 + V_1\Delta T + .5(A - 9.8){\Delta T}^2$ and $V_2 = V_1+(A - 9.8)\Delta T$.
%\item $\proc{BVBurst-C}(A, \Delta T \mid X_1, X_2)$: Given two
%  states $X_1 = (P_1, V_1)$ and $X_2 = (P_2, V_2)$, generate a control $A, \Delta T$
%  that will move between them using $\Delta T = 2 (P_2 - P_1)/(V_2 + V_1)$
%$A = (V_2 - V_1)/{\Delta T} + 9.8$.
%% \item $\proc{ForceS}(F, T \mid ())$: generate a stream of legal
%%   controls $(F, T)$.
%% \item $\proc{TimeS}(T \mid ())$: 
%\end{itemize}
%Given these streams and four straightforward operator schemas, we obtain the
%following plan: 
%
%%\begin{scriptsize}
%%\begin{verbatim}
%%takeoff
%%burst: x((0, 0)), a(20.0), t(1.0), x((10.7, 10.2))
%%burst: x((10.7, 10.2)), a(20.0), t(1.0), x((31.6,20.4))
%%burst: x((31.6, 20.4)), a(-1.509), t(1.804), x((50, 0))
%%deploy: x((50, 0)), p(50), satellite1
%%burst: x((50, 0)), a(-10.0), t(1.0), x((30.7, -19.8))
%%burst: x((30.7, -19.8)), a(16.185), t(3.101), x((0,0))
%%land
%%\end{verbatim}
%%\end{scriptsize}
%
%\begin{footnotesize}
%\begin{enumerate}
%\itemsep0em 
%\item \proc{TakeOff}() 
%\item \proc{Burst}(x(0, 0), a(20.0), t(1.0), x(10.7, 10.2)) 
%\item \proc{Burst}(x(10.7, 10.2), a(20.0), t(1.0), x(31.6,20.4)) 
%\item \proc{Burst}(x(31.6, 20.4), a(-1.509), t(1.804), x(50, 0)) 
%\item \proc{Deploy}(x(50, 0), p(50), satellite1) 
%\item \proc{Burst}(x(50, 0), a(-10.0), t(1.0), x(30.7, -19.8)) 
%\item \proc{Burst}(x(30.7, -19.8), a(16.185), t(3.101), x(0,0)) 
%\item \proc{Land}()
%\end{enumerate}
%\end{footnotesize}
%
%
%%\begin{figure}
%%\begin{codebox}
%%\Procname{\proc{ControlS}$(F, T \mid ())$:}
%%\zi \kw{gen} = $\kw{lambda}(): \langle (f, t) \mid f \sim \proc{uniform}(f_{\id{min}}, f_{\id{max}}) \rangle$
%%\zi \kw{inp} = $\emptyset$
%%\zi \kw{out} = $\{{\id IsForce}(P), {\id IsTime}(T)\}$
%%\end{codebox}
%%\caption{A forward burst stream.} \label{fig:ik}
%%\end{figure}
%%
%%\begin{figure}
%%\begin{codebox}
%%\Procname{\proc{ForwardBurstS}$(X_2, V_2,  \mid X_1, V_1, F, T)$:}
%%\zi \kw{gen} = $\kw{lambda}(R_1, R_2 B): \langle p \sim \proc{uniform}(R_1 \cap R_2) \rangle$
%%\zi \kw{inp} = $\{{\id IsPos}(X_1), {\id IsVel}(V_1)\}$
%%\zi \kw{out} = $\{{\id IsPose}(P), {\id IsCont}(r_1, b, P), {\id IsCont}(r_2, b, P)\}$
%%\end{codebox}
%%\caption{A forward burst stream.} \label{fig:ik}
%%\end{figure}
%%
%%\begin{figure}
%%\begin{codebox}
%%\Procname{\proc{BVBurstS}$(F, T \mid X_1, V_1, X_2, V_2)$:}
%%\zi \kw{gen} = $\kw{lambda}(R_1, R_2 B): \langle p \sim \proc{uniform}(R_1 \cap R_2) \rangle$
%%\zi \kw{inp} = $\{{\id IsPos}(X_1), {\id IsVel}(V_1)\}$
%%\zi \kw{out} = $\{{\id IsPose}(P), {\id IsCont}(r_1, b, P), {\id IsCont}(r_2, b, P)\}$
%%\end{codebox}
%%\caption{The joint containment stream.} \label{fig:ik}
%%\end{figure}
%
%%\begin{figure}[h]
%%\centering
%%\includegraphics[width=0.23\textwidth]{images/rocket.png}
%%\caption{The initial state in a 1D continuous TAMP problem requiring placing block A such that it is contained in both region R1 and region R2. } 
%%\label{fig:region}
%%\end{figure}

%\section{High-Dimensional TAMP}
\section{Realistic robot domain}

%\begin{figure*}
%\centering
%\includegraphics[width=0.31\textwidth]{images/move_regrasp_small.png}
%\includegraphics[width=0.31\textwidth]{images/distract_0.png}
%%\includegraphics[width=0.31\textwidth]{images/distract_16.png}
%\includegraphics[width=0.31\textwidth]{images/distract_16_small.png}
%%\caption{From left to right: a regrasp problem, a large set of distractors, and a long horizon problem.} 
%\caption{From left to right: problem 1, problem 2-0, and problem 2-16.} 
%\label{fig:tamp_domains}
%\end{figure*}

\begin{table*}
\centering
%\includegraphics[width=0.31\textwidth]{images/separate28.png}
\begin{footnotesize}
\begin{tabular}{||c||c|g|c|c||c|g|c|c||c|g|c|c||}
\hline
$\Pi$ & \multicolumn{4}{|c||}{\eager{}, $K=1$}&\multicolumn{4}{|c||}{\eager{}, $K=100$}&\multicolumn{4}{|c||}{\focused{}}\\
\hline
&
\% & t & i & c &
\% & t & i & c &
\% & t & i & c \\
\hline
1 & 
88 & 2 & 23 & 268 &
68 & 5 & 2 & 751 &
84 & 11 & 6 & 129 \\
\hline
2-0 & 
100 & 23 & 85 & 1757 &
100 & 9 & 3 & 2270 &
100 & 2 & 3 & 180 \\
\hline
2-8 & 
0 & - & - & - &
100 & 55 & 5 & 17217 &
100 & 7 & 3 & 352 \\
\hline
2-16 & 
0 & - & - & - &
100 & 112 & 6 & 36580 &
100 & 19 & 3 & 506 \\
%\hline
%3 & 
%0 & - & - & - &
%0 & - & - & - &
%25 & 57 & 7 & 5019 \\
\hline
\end{tabular}
\end{footnotesize}
%\caption{High-dimensional task and motion planning experiment results.}
\caption{The success percentage (\%), runtime (t), search iterations (i), and
number of stream calls (c) for the high-dimensional task and motion planning experiments.}
\label{table:results}
\end{table*}
%\note{Include the $\theta$ parameter?}

%We can once more extend our continuous pick-and-place to the high-dimensional setting of a robot operating in the human environments.
%Poses and configurations are now 6D and 11D continuous vectors for a PR2 robot. We introduce two new object types: poses and trajectories. 
%Each block has a set of 6D relative grasp transforms at which the robot can pick and place the object.
%Trajectories are finite sequences of configuration waypoints which must be included in collisions. Figure 
%~\ref{fig:TAMP_actions} gives the extended \proc{Pick} action and \proc{Kin-C} stream. 
%\proc{Pick} adds grasp $G$ and trajectory $T$ as parameters and includes $\id{Safe}(b', B, G, T)$ preconditions verify
%that $T$ while holding $B$ at grasp $G$ is safe with respect to each other block $b'$.
%$\id{Safe}(b', B, G, T)$ is updated using \proc{SafeAxiom} which has a $\id{IsCollisionFree}(B_1, P_1, B_2, G, T)$ static precondition.
%Here, a collision check for block $B_1$ at pose $P_1$ is performed for each configuration in $T$. 
%Although checking collisions here is more complication than in 1D, it can be treated the same as just an external function.
%% Poses and grasps specific to an object
%Collisions are taken with respect to robot trajectories in additional to object poses.  The inverse kinematics also produces a motion plan. Blocks have differing geometry. Poses and objects are distinct to blocks.
%While the procedures for performing collision checks, containment tests, and sampling are more complicated, they have the same function at heart.

Finally, we extend our continuous pick-and-place to the
high-dimensional setting of a robot operating in household-like
environments.  Poses of physical blocks are 6-dimensional and robot
configurations are 11-dimensional.  We introduce two new object types:
grasps and trajectories.  Each block has a set of 6D relative grasp
transforms at 
which it can be grasped by the robot.  Trajectories are
finite sequences of configuration waypoints which must be included in
collision checking.
The extended \proc{Pick} operator, \proc{CFree-T} test and \proc{Kin-C}
stream templates are:

\begin{footnotesize}
\begin{codebox}
\Procname{\proc{Pick}$(B, P, G, Q, T)$:}
\zi \kw{stat} = $\{\id{IsBlock}(B), ..., \id{IsTraj}(T), \id{IsKin(P, G, Q, T)}\}$
\zi \kw{pre} = $\{\id{AtPose}(B, P), \id{HandEmpty}(), \id{AtConfig}(Q)\} \;\cup$ \Indentmore
\zi $\{\id{Safe}(b', B, G, T) \mid b' \in {\cal B}\}$ \End
\zi \kw{eff} = $\{\id{Holding}(B, G), \neg \id{AtPose}(B, P), \neg \id{HandEmpty}()\}$
\end{codebox}
\begin{codebox}
\Procname{\proc{CFree-T}$(() \mid B_1, P_1, B_2, G, T)$:}
\zi \kw{gen} = $\kw{lambda} (B_1, P_1, B_2, G, T):$ 
\zi \>\>\> $\langle () \;\kw{if} \;\kw{not}\; \proc{collide}(B_1, P_1, B_2, G, T) \rangle$
\zi \kw{inp} = $\{\id{IsBlock}(B_1),...,  \id{IsTraj}(T)\}$
\zi \kw{out} = $\{\id{IsCollisionFree}(B_1, P_1, B_2, G, T)\}$
\end{codebox}
\begin{codebox}
\Procname{\proc{Kin-C}$(Q, T \mid P, G)$:}
%\zi \kw{cond}: $F(p_i) = \langle (q_i) \rangle$
%\zi \kw{gen} = $\kw{lambda} (p): \langle (\text{q\_}p[1:]) \rangle$
\zi \kw{gen} = $\kw{lambda} (P): \langle (Q, T) \mid Q \sim \proc{inverse-kin}(PG^{-1}), $\Indentmore
\zi $T \sim \proc{motions}(q_{rest}, Q) \rangle$ \End
\zi \kw{inp} = $\{\id{IsPose}(P), \id{IsGrasp}(G)\}$
\zi \kw{out} = $\{\id{IsKin}(P, G, Q, T), \id{IsConf}(Q), \id{IsTraj}(T)\}$
\end{codebox}
\end{footnotesize}

\proc{Pick} adds grasp $G$ and trajectory $T$ as parameters and includes
$\id{Safe}(b', B, G, T)$ preconditions to verify that $T$ while holding
$B$ at grasp $G$ is safe with respect to each other block $b'$.
$\id{Safe}(b', B, G, T)$ is updated using \proc{SafeAxiom} which has a
$\id{IsCollisionFree}(B_1, P_1, B_2, G, T)$ static precondition.
Here, a collision check for block $B_1$ at pose $P_1$ is performed for
each configuration in $T$. Instead of simple
blocks, physical objects in this domain are general unions of convex
polygons. Although checking collisions here is more
complication than in 1D, it can be treated in the same way, as an
external function.

% Poses and grasps specific to an object
%Collisions are checked with respect to robot trajectories in addition
%to object poses.  
The \proc{Kin} streams must first produce a grasp configuration $Q$
that reaches manipulator transform $PQ^{-1}$ using \proc{inverse-kin}. Additionally, they include 
a motion planner \proc{motions} to generate legal trajectory values $T$ from a constant rest configuration $q_{rest}$
to the grasping configuration $Q$ that do not
collide with the fixed environment. In this domain, the procedures for collision checking and 
finding kinematic solutions are significantly more involved and
computationally expensive than in the previous domains, but their
underlying function is the same.

\subsection{Experiments}

We applied the \eager{} and \focused{} algorithms on four challenging
pick-and-place problems to demonstrate that a general-purpose
representation and algorithms can be used to achieve good performance
in difficult problems.  For both algorithms, test streams are
always evaluated as soon as they are instantiated.  
% Again, the algorithms and implementations
% are completely domain independent in contrast with most current
% strategies for solving robotic planning problems.
We experimented on two domains shown in
figure~\ref{fig:tamp_domains}, which are similar to problems
introduced by~\cite{GarrettIROS15}. The first domain, in which problem 1 is
defined, has goal conditions that the green object be in the right bin
and the blue object remain at its initial pose. This requires the
robot to not only move and replace the blue block but also to place
the green object in order to find a new grasp to insert it into the
bin.  The second domain, in which problems 2-0, 2-8, and 2-16 are
defined, requires moving an object out of the way and placing the
green object in the green region. For problem 2-$n$ where
$n \in \{0, 8, 16\}$ there are $n$ other blocks on a separate table
that serve as distractors. The streams were implemented using
the OpenRAVE robotics framework~\cite{openrave}.
A Python implementation of \algname{} can be found here:
\texttt{https://github.com/caelan/stripstream}.

\begin{figure}[h]
\centering
\includegraphics[width=0.30\textwidth]{images/move_regrasp_small.png}
\caption{Problem 1.} 
\label{fig:tamp_domains}
\end{figure}

The results compare the \eager{} algorithm where $K=1$ and $K=100$
with the \focused{} algorithm.  Table~\ref{table:results} shows the
results of 25 trials, each with a timeout of 120 seconds.
%A dash (-) indicates an algorithm did not solve any problem within the timeout
%The success percentage (\%), runtime (t), %search iterations (i), 
%and number of stream calls (c) are displayed.  
The \eager{} algorithms result in
significantly more stream calls than the focused algorithm.
These calls can significantly increase the total runtime
because each inverse kinematic and collision primitive itself is expensive.
Additionally, the \eager{} algorithms are significantly affected by
the increased number of distractors, making them unsuitable for
complex real-world environments. The \focused{} algorithm, however, is
able to selectively choose which streams to call resulting in
significantly better performance in these environments.
%In our implementation, we use FF to solve pddl instances.
%Initial implementation is competitive
%Competitive with state of the art no input assumptions
%The two large points are how representation can affect performance and how the focused algorithm is better than the basic algorithm.
%Several stages of sampling (need a pose and grasp to get a config).
%Invariance to large number of objects. Regrasps and collisions.

\section{Conclusion}

The \algname{} problem specification formalism can be used to describe
a large class of planning problems in infinite domains and provides a
clear and clean interface to problem-specific sampling methods in
continuous domains.  
The \eager{} and, in particular, \focused{} planning algorithms
take advantage of the specification to provide efficient solutions to
difficult problems.

\newpage
\bibliographystyle{named}
\bibliography{references}

\newpage

\section{Appendix}

%\subsection{Focused Algorithm Completeness}~\label{app:focused}

\begin{thm}  \label{thm:re}
${\cal O}_\Pi$ and ${\cal S}_\Pi$ are recursively enumerable (RE). 
\end{thm}
\begin{proof}
Consider an enumeration procedure for ${\cal O}_\Pi$ and ${\cal S}_\Pi$:
\begin{itemize}
\item The first sequences of elements in ${\cal O}_\Pi$ and 
${\cal S}_\Pi$ are ${\cal C}_0 \cup O_0$ and $s_0$ respectively.
\item Initialize a set of stream instances $\Sigma_\Pi = \emptyset$.
\item Repeat:
\begin{itemize}
\item For each stream schema $\sigma \in \Sigma$, add all
  instantiations $\sigma(\bar{Y} \mid \bar{x})$ where $x \subseteq {\cal O}_\Pi$ such that
  $\sigma.\kw{inp}(\bar{x})$ is contained within ${\cal S}_\Pi$,
  to $\Sigma_\Pi$. There are finitely many new elements of
  $\Sigma_\Pi$.
\item For each stream instance $\sigma(\bar{Y} \mid \bar{x}) \in \Sigma_\Pi$, add
  $\bar{y} = \proc{next}(\sigma.f(\bar{x}))$ to ${\cal O}_\Pi$ and add
  $\sigma^*.\kw{out}((\bar{x}, \bar{y}))$ to ${\cal S}_\Pi$.
  There are finitely many new elements of ${\cal O}_\Pi$ and ${\cal S}_\Pi$.
\end{itemize}
\end{itemize}
This procedure will enumerate all possible objects and all possible
initial atoms generated within the problem $\Pi$.
\end{proof}

\begin{thm}
The existence of a solution for a \algname{} problem $\Pi$ is
undecidable. 
\end{thm}
\begin{proof}
We use a reduction from the halting problem.
Given a Turning machine TM, we construct a \algname{} 
problem $\Pi_{TM}$ with a single operator
\proc{Halt}(X) with $\kw{stat} = \{\id{IsReachable}(X)\}$, 
$\kw{pre} = \emptyset$, and $\kw{eff} = \{\id{Reached}(X)\}$ where
$\id{IsReachable}$ and $\id{Reached}$ are a static and fluent predicate
defined on TM's states. There is a single unconditional stream $\proc{Reachable-U}(X \mid ())$ which 
enumerates the states of TM by simulating one step of TM upon each call.
Let $s_0 = \emptyset$ and $s_* = \{\id{Reached}(a)\}$
where $a$ is the accept state for TM. $\Pi_{TM}$ has a solution if and only if TM halts.
Thus, \algname{} is undecidable.
\end{proof}

\begin{thm}
The existence of a solution for a \algname{} problem $\Pi$ is
semi-decidable. 
\end{thm}
\begin{proof}
From the recursive enumeration of ${\cal O}_\Pi$ and ${\cal S}_\Pi$ we produce a
recursive enumeration of finite planning problems. Planning problem
$i$ is grounded using all objects and static atoms enumerated up through element $i$.
Plan existence in a finite universe is decidable. 
%If a finite plan exists, it will exist for a finite planning problem. 
Thus, for feasible problems, applying a finite decision procedure to the sequence of finite planning problems
will eventually reach a planning problem for which a plan exists and
produce it.
\end{proof}
%\note{Could also test sequence of plans}

% Without loss of generality one plan?
\begin{thm}
The \eager{} algorithm is complete.
\end{thm}
\begin{proof}
The \eager{} algorithm constructs ${\cal O}$ and ${\cal S}$ in the same way 
as theorem~\ref{thm:re} for ${\cal O}_\Pi$ and ${\cal S}_\Pi$ %in theorem~\ref{thm:re} 
except that it 
calls \proc{next} in batches of $K$. 
%Thus, for any finite subsets of 
%${\cal O}_\Pi$ and ${\cal S}_\Pi$, after a finite number of iterations
Thus, any finite subsets of 
${\cal O}_\Pi$ and ${\cal S}_\Pi$ will be included in ${\cal O}$ and ${\cal S}$
after a finite number of iterations.
Let $\pi_*$ be a solution to a feasible \algname{} problem $\Pi$.
Consider the first iteration where ${\cal O}$ and ${\cal S}$ contain the set of objects used along $\pi_*$ and static atoms supporting $\pi_*$.
On that iteration, \proc{s-plan} will return some solution (if not $\pi_*$) in finite time because it is sound and complete.
% if not $\pi$.
\end{proof}

\begin{thm}
The \focused{} algorithm is complete.
\begin{proof}

% We have non-redundant because \proc{strips} can't be guaranteed to find a redundant plan.
%Define a {\em non-redundant} plan to be any correct plan that does not admit a correct strict subplan. % Doesn't rule out minimum cost
% Non-redundant stream calls?
Define an episode as the \focused{} algorithm iterations between the last reset (${\cal O}_t = {\cal S}_t = \beta_t = \emptyset$) and the next reset. % (the start of the episode) and is next reset (the end of the episode).
% Some stream calls may not directly help the plan, but that's okays
Consider a minimum length solution $\pi_*$ to a feasible \algname{} problem $\Pi$. Let ${\cal O}_* \subseteq {\cal O}_\Pi$ be the set of objects used along $\pi_*$ and ${\cal S}_* \subseteq {\cal S}_\Pi$ be the set of static atoms supporting $\pi_*$.
%We will assume $\Sigma_*$ is a minimal length sequence which satisfies this contract.

For each episode, consider the following argument.
By theorem~\ref{thm:re}, there exists a sequence of stream instance calls which produces ${\cal O}_*$ and ${\cal S}_*$ from the current ${\cal O}$ and ${\cal S}$. Let $\Sigma_*$ be the minimum length sequence that satisfies this property.
$\Sigma_*$ may include the same stream instance several times if multiple calls are needed to produce the necessary values.
On each iteration, \proc{\focused{}} creates a finite \strips{} problem $\tilde{\Pi}$ by augmenting $\Pi$ with the abstract objects $\{\gamma_1, ..., \gamma_\theta\}$ and the stream operators $\bar{\Sigma}$. 
Because ${\cal O}_t$ and ${\cal S}_t$ are withheld, ${\cal O}$ and ${\cal S}$ are fixed for all iterations within the episode. 
%$\tilde{\Pi}$ is fixed for all iterations within the episode. 
Thus, a finite number of simple plans are solutions for $\tilde{\Pi}$.
One of these plans, $\tilde{\pi}_*$, is $\Sigma_*$ concatenated with $\pi_*$ where additionally any object $o \in ({\cal O}_* \setminus {\cal O})$ is replaced with some abstract object $\gamma$. Assume all redundant stream operators are removed from $\tilde{\pi}_*$.
% Can ignore the multiple calls
%The plan prefix $\Sigma_*$ produces each abstract object $\gamma$ as well as certify any static atoms within ${\cal S}_*$ that involve them.
The same $\gamma$ can stand in for several $o$ on $\tilde{\pi}_*$ at once.
Thus, \proc{\focused{}} will be complete for any $\theta \geq 1$.
% as long as \proc{s-plan} allows objects to be repeated in operator parameters.

%that can be returned by \proc{s-plan} during each episode.
We will show that at least one %the first stream instance 
stream instance in $\Sigma_*$ will called performed during each episode.
On each iteration, \proc{s-plan} will identify a plan $\pi$. 
If $\pi$ does not involve any abstract objects and is fully supported, it is a solution. 
% Can't guarantee it will return the non-redundant plan we have in mind. Just want to show there exists one
Otherwise, \proc{add-objects} will call each stream $\sigma(\bar{Y} \mid \bar{o}_x)$ associated with $\pi$. It adds $\id{Blocked}_\sigma(\bar{o}_x)$ to $\beta_t$, preventing $\pi$ and all other plans using $\sigma(\bar{Y} \mid \bar{o}_x)$ from being re-identified within this episode. 
If $\pi$ overlaps with $\tilde{\pi}_*$ and $\sigma(\bar{Y} \mid \bar{o}_x) \in \Sigma_*$, then the episode has succeeded.
%A $\sigma_*(\bar{Y} \mid \bar{x}_*) \in $ may called while processing $\pi$ in the event where $\pi$ overlaps with $\tilde{\pi}_*$. % because $\sigma(\bar{Y} \mid \bar{o}_x) \in \Sigma_*$.
Otherwise, this process repeats on the next iteration. 
Eventually a stream instance in $\Sigma_*$ will be called, or $\tilde{\pi}_*$ itself will be the only remaining unblocked plan for $\tilde{\Pi}$. In which case, \proc{s-plan} will return $\tilde{\pi}_*$, and \proc{add-objects} will call a stream instance in $\Sigma_*$.

$|\Sigma_*|$ strictly decreases after each episode. Inductively applying this, after a finite number of episodes, 
%Inductively applying this for all of $\Sigma_*$, \proc{\focused{}} will call each stream instance in $\Sigma_*$ after at most $|\Sigma_*|$ episodes.
${\cal O}_* \subseteq {\cal O}$ and ${\cal S}_* \subseteq {\cal S}$. During the next episode, \proc{s-plan} will be guaranteed to return some solution (if not $\pi_*$).
%Finally, each episode is composed of a finite number of iterations and each iteration runs in finite time because \proc{s-plan} runs in finite time, so \focused{} will produce a solution in a finite amount of time if one exists.
% Alternatively, this is like doing lazy shortest path repeatedly

%When a called stream may also be along $\pi_*'$. Otherwise, 
%This in turn, will prevent the path from being reidentified. Eventually, the plan $\pi$ will be found and  
%Because abstract objects must be concrete before applied to functions, if a plan involves an abstract object, there exists a stream that can be called. Upon each iteration, a plan found and these initial streams will be blocked. Eventually, a stream along that plan will be called before the next reset. Finite number of iterations before reset.

%Consider any \cprop{} problem $\Pi$ with a non-redundant solution $p = (\aii{1}, ..., \aii{n})$. The set of completions $F_p$ is sufficient to produce the objects along $p$.
%Without loss of generality, consider only the sequence of useful completions $f(\ov{}) \in F_p$, and let each step $j$ correspond to the completion of $f_j(\ov{}_j)$. 
%Because $f(\ov{})$ may require many invocations of $\proc{next}(f(\ov{}))$ to produce its useful objects, we will consider each call as a separate completion in the sequence.
%Start with an empty completion sequence for $j=0$. By the definition of \cprop{}, on each step, there exists a correct abstract plan $p_j = (\alpha_{i_1}, ..., \alpha_{i_k})$ that is an abstracted subplan of $p$. 
%%Each completable value $v$ on this plan must be $v_{i+1}$ for some legal permutation of $(v_1, ..., v_m)$. 
%On each search iteration, \proc{search} will produce a correct plan $p$ which may not be $p_j$. \proc{select} will generate a non-empty subset of the completions on $p_j$. 
%If some $f(\ov{}) \in F_p$ is performed, we proceed to the next step. Otherwise, each $f(\ov{})$ is added to $V_1$ and temporarily removed from the abstracted problem, and \alg{} continues to the next search iteration. \proc{search} will be unable to find the same plan because of the removal. After a finite number of iterations, \alg{} will produce a plan such that $p_j$ is a subplan and complete some $f_j(\ov{}_j)$. Applying this inductively, it will produce a solution on step $|D_p|$.
%Note that this is because there are a finite number of completions because of $O_*$ and ${\cal A}_*$
\end{proof}
\end{thm}

%\section{Rocket Domain}
%
%\begin{footnotesize}
%\begin{codebox}
%\Procname{\proc{Pick}$(B, P, G, Q, T)$:}
%\zi \kw{stat} = $\{\id{IsBlock}(B), ..., \id{IsTraj}(T), \id{IsKin(P, G, Q, T)}\}$
%\zi \kw{pre} = $\{\id{AtPose}(B, P), \id{HandEmpty}(), \id{AtConfig}(Q)\} \;\cup$ \Indentmore
%\zi $\{\id{Safe}(b', B, G, T) \mid b' \in {\cal B}\}$ \End
%\zi \kw{eff} = $\{\id{Holding}(B, G), \neg \id{AtPose}(B, P), \neg \id{HandEmpty}()\}$
%\end{codebox}
%\begin{codebox}
%\Procname{\proc{CFree-T}$(() \mid B_1, P_1, B_2, G, T)$:}
%\zi \kw{gen} = $\kw{lambda} (B_1, P_1, B_2, G, T):$ 
%\zi \>\>\> $\langle () \;\kw{if} \;\kw{not}\; \proc{collide}(B_1, P_1, B_2, G, T) \rangle$
%\zi \kw{inp} = $\{\id{IsBlock}(B_1),...,  \id{IsTraj}(T)\}$
%\zi \kw{out} = $\{\id{IsCollisionFree}(B_1, P_1, B_2, G, T)\}$
%\end{codebox}
%\begin{codebox}
%\Procname{\proc{Kin-C}$(Q, T \mid P, G)$:}
%%\zi \kw{cond}: $F(p_i) = \langle (q_i) \rangle$
%%\zi \kw{gen} = $\kw{lambda} (p): \langle (\text{q\_}p[1:]) \rangle$
%\zi \kw{gen} = $\kw{lambda} (P): \langle (Q, T) \mid Q \sim \proc{inverse-kin}(PG^{-1}), $\Indentmore
%\zi $T \sim \proc{motions}(q_{rest}, Q) \rangle$ \End
%\zi \kw{inp} = $\{\id{IsPose}(P), \id{IsGrasp}(G)\}$
%\zi \kw{out} = $\{\id{IsKin}(P, G, Q, T), \id{IsConf}(Q), \id{IsTraj}(T)\}$
%\end{codebox}
%\end{footnotesize}

\subsection{Python example discrete domain}

Figure~\ref{fig:python} gives a complete encoding of the example discrete domain and a problem instance within it using our Python implementation of \algname{}. In the specified problem instance, the initial state consists of three blocks placed in a row. The goal is to shift each of the blocks over one pose. The Python syntax of \algname{} intentionally resembles the Planning Domain Definition Language (\pddl{})~\cite{mcdermott1998pddl}. We use several common features of \pddl{} that extend \strips{}. The resulting encoding is equivalent to previously described \strips{} formulation but is more compact. 
We use object types \proc{BLOCK}, \proc{POSE}, \proc{CONF} instead of static predicates \id{IsBlock}, \id{IsPose}, and \id{IsConf}.
Additionally, we use several Action Description Language ({\sc ADL}) logical operations including \proc{Or}, \proc{Equal}, \proc{ForAll}, and \proc{Exists}. The universal quantifier (\proc{ForAll}) is over \proc{BLOCK}, a finite type, and thus is a finite conjunction. 
%Arbitrary universal quantifiers over infinite types may not be evaluable in finite time and thus are not permitted 

\begin{figure*}
\begin{footnotesize}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{stripstream} \PYG{k+kn}{import} \PYG{n}{Type}\PYG{p}{,} \PYG{n}{Param}\PYG{p}{,} \PYG{n}{Pred}\PYG{p}{,} \PYG{n}{Not}\PYG{p}{,} \PYG{n}{Or}\PYG{p}{,} \PYG{n}{And}\PYG{p}{,} \PYG{n}{Equal}\PYG{p}{,} \PYG{n}{Exists}\PYG{p}{,} \PYGZbs{}
  \PYG{n}{ForAll}\PYG{p}{,} \PYG{n}{Action}\PYG{p}{,} \PYG{n}{Axiom}\PYG{p}{,} \PYG{n}{GeneratorStream}\PYG{p}{,} \PYG{n}{TestStream}\PYG{p}{,} \PYG{n}{STRIPStreamProblem}

\PYG{n}{blocks} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}block}\PYG{l+s+si}{\PYGZpc{}i}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{\PYGZpc{}}\PYG{n}{i} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)]}
\PYG{n}{num\PYGZus{}poses} \PYG{o}{=} \PYG{n+nb}{pow}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} a very large number of poses}
\PYG{n}{initial\PYGZus{}config} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} initial robot configuration is 0}
\PYG{n}{initial\PYGZus{}poses} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{block}\PYG{p}{:} \PYG{n}{i} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{block} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{blocks}\PYG{p}{)\PYGZcb{}} \PYG{c+c1}{\PYGZsh{} initial pose for block i is i}
\PYG{n}{goal\PYGZus{}poses} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{block}\PYG{p}{:} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{block} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{blocks}\PYG{p}{)\PYGZcb{}} \PYG{c+c1}{\PYGZsh{} goal pose for block i is i+1}

\PYG{n}{BLOCK}\PYG{p}{,} \PYG{n}{POSE}\PYG{p}{,} \PYG{n}{CONF} \PYG{o}{=} \PYG{n}{Type}\PYG{p}{(),} \PYG{n}{Type}\PYG{p}{(),} \PYG{n}{Type}\PYG{p}{()} \PYG{c+c1}{\PYGZsh{} Object types}
\PYG{n}{B1}\PYG{p}{,} \PYG{n}{B2} \PYG{o}{=} \PYG{n}{Param}\PYG{p}{(}\PYG{n}{BLOCK}\PYG{p}{),} \PYG{n}{Param}\PYG{p}{(}\PYG{n}{BLOCK}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Free parameters}
\PYG{n}{P1}\PYG{p}{,} \PYG{n}{P2} \PYG{o}{=} \PYG{n}{Param}\PYG{p}{(}\PYG{n}{POSE}\PYG{p}{),} \PYG{n}{Param}\PYG{p}{(}\PYG{n}{POSE}\PYG{p}{)}
\PYG{n}{Q1}\PYG{p}{,} \PYG{n}{Q2} \PYG{o}{=} \PYG{n}{Param}\PYG{p}{(}\PYG{n}{CONF}\PYG{p}{),} \PYG{n}{Param}\PYG{p}{(}\PYG{n}{CONF}\PYG{p}{)}

\PYG{n}{AtConf} \PYG{o}{=} \PYG{n}{Pred}\PYG{p}{(}\PYG{n}{CONF}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Fluent predicates}
\PYG{n}{AtPose} \PYG{o}{=} \PYG{n}{Pred}\PYG{p}{(}\PYG{n}{BLOCK}\PYG{p}{,} \PYG{n}{POSE}\PYG{p}{)}
\PYG{n}{HandEmpty} \PYG{o}{=} \PYG{n}{Pred}\PYG{p}{()}
\PYG{n}{Holding} \PYG{o}{=} \PYG{n}{Pred}\PYG{p}{(}\PYG{n}{BLOCK}\PYG{p}{)}
\PYG{n}{Safe} \PYG{o}{=} \PYG{n}{Pred}\PYG{p}{(}\PYG{n}{BLOCK}\PYG{p}{,} \PYG{n}{BLOCK}\PYG{p}{,} \PYG{n}{POSE}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Derived predicates}
\PYG{n}{IsKin} \PYG{o}{=} \PYG{n}{Pred}\PYG{p}{(}\PYG{n}{POSE}\PYG{p}{,} \PYG{n}{CONF}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Static predicates}
\PYG{n}{IsCollisionFree} \PYG{o}{=} \PYG{n}{Pred}\PYG{p}{(}\PYG{n}{BLOCK}\PYG{p}{,} \PYG{n}{POSE}\PYG{p}{,} \PYG{n}{BLOCK}\PYG{p}{,} \PYG{n}{POSE}\PYG{p}{)}

\PYG{n}{actions} \PYG{o}{=} \PYG{p}{[}
  \PYG{n}{Action}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}pick\PYGZsq{}}\PYG{p}{,} \PYG{n}{parameters}\PYG{o}{=}\PYG{p}{[}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{,} \PYG{n}{Q1}\PYG{p}{],}
    \PYG{n}{condition}\PYG{o}{=}\PYG{n}{And}\PYG{p}{(}\PYG{n}{AtPose}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{),} \PYG{n}{HandEmpty}\PYG{p}{(),} \PYG{n}{AtConf}\PYG{p}{(}\PYG{n}{Q1}\PYG{p}{),} \PYG{n}{IsKin}\PYG{p}{(}\PYG{n}{P1}\PYG{p}{,} \PYG{n}{Q1}\PYG{p}{)),}
    \PYG{n}{effect}\PYG{o}{=}\PYG{n}{And}\PYG{p}{(}\PYG{n}{Holding}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{),} \PYG{n}{Not}\PYG{p}{(}\PYG{n}{AtPose}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{)),} \PYG{n}{Not}\PYG{p}{(}\PYG{n}{HandEmpty}\PYG{p}{()))),}
  \PYG{n}{Action}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}place\PYGZsq{}}\PYG{p}{,} \PYG{n}{parameters}\PYG{o}{=}\PYG{p}{[}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{,} \PYG{n}{Q1}\PYG{p}{],}
    \PYG{n}{condition}\PYG{o}{=}\PYG{n}{And}\PYG{p}{(}\PYG{n}{Holding}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{),} \PYG{n}{AtConf}\PYG{p}{(}\PYG{n}{Q1}\PYG{p}{),} \PYG{n}{IsKin}\PYG{p}{(}\PYG{n}{P1}\PYG{p}{,} \PYG{n}{Q1}\PYG{p}{),}
      \PYG{n}{ForAll}\PYG{p}{([}\PYG{n}{B2}\PYG{p}{],} \PYG{n}{Or}\PYG{p}{(}\PYG{n}{Equal}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{B2}\PYG{p}{),} \PYG{n}{Safe}\PYG{p}{(}\PYG{n}{B2}\PYG{p}{,} \PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{)))),}
    \PYG{n}{effect}\PYG{o}{=}\PYG{n}{And}\PYG{p}{(}\PYG{n}{AtPose}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{),} \PYG{n}{HandEmpty}\PYG{p}{(),} \PYG{n}{Not}\PYG{p}{(}\PYG{n}{Holding}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{)))),}
  \PYG{n}{Action}\PYG{p}{(}\PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}move\PYGZsq{}}\PYG{p}{,} \PYG{n}{parameters}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Q1}\PYG{p}{,} \PYG{n}{Q2}\PYG{p}{],}
    \PYG{n}{condition}\PYG{o}{=}\PYG{n}{AtConf}\PYG{p}{(}\PYG{n}{Q1}\PYG{p}{),}
    \PYG{n}{effect}\PYG{o}{=}\PYG{n}{And}\PYG{p}{(}\PYG{n}{AtConf}\PYG{p}{(}\PYG{n}{Q2}\PYG{p}{),} \PYG{n}{Not}\PYG{p}{(}\PYG{n}{AtConf}\PYG{p}{(}\PYG{n}{Q1}\PYG{p}{))))]}
\PYG{n}{axioms} \PYG{o}{=} \PYG{p}{[}
  \PYG{n}{Axiom}\PYG{p}{(}\PYG{n}{effect}\PYG{o}{=}\PYG{n}{Safe}\PYG{p}{(}\PYG{n}{B2}\PYG{p}{,} \PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{),} \PYG{c+c1}{\PYGZsh{} Infers B2 is at a safe pose wrt B1 at P1}
        \PYG{n}{condition}\PYG{o}{=}\PYG{n}{Exists}\PYG{p}{([}\PYG{n}{P2}\PYG{p}{],} \PYG{n}{And}\PYG{p}{(}\PYG{n}{AtPose}\PYG{p}{(}\PYG{n}{B2}\PYG{p}{,} \PYG{n}{P2}\PYG{p}{),} \PYG{n}{IsCollisionFree}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{,} \PYG{n}{B2}\PYG{p}{,} \PYG{n}{P2}\PYG{p}{))))]}

\PYG{n}{cond\PYGZus{}streams} \PYG{o}{=} \PYG{p}{[}
  \PYG{n}{GeneratorStream}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{p}{[],} \PYG{n}{outputs}\PYG{o}{=}\PYG{p}{[}\PYG{n}{P1}\PYG{p}{],} \PYG{n}{conditions}\PYG{o}{=}\PYG{p}{[],} \PYG{n}{effects}\PYG{o}{=}\PYG{p}{[],}
                  \PYG{n}{generator}\PYG{o}{=}\PYG{k}{lambda}\PYG{p}{:} \PYG{n+nb}{xrange}\PYG{p}{(}\PYG{n}{num\PYGZus{}poses}\PYG{p}{)),} \PYG{c+c1}{\PYGZsh{} Enumerates all the poses}
  \PYG{n}{GeneratorStream}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{p}{[}\PYG{n}{P1}\PYG{p}{],} \PYG{n}{outputs}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Q1}\PYG{p}{],} \PYG{n}{conditions}\PYG{o}{=}\PYG{p}{[],} \PYG{n}{effects}\PYG{o}{=}\PYG{p}{[}\PYG{n}{IsKin}\PYG{p}{(}\PYG{n}{P1}\PYG{p}{,} \PYG{n}{Q1}\PYG{p}{)],}
                  \PYG{n}{generator}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{p}\PYG{p}{:} \PYG{p}{[}\PYG{n}{p}\PYG{p}{]),} \PYG{c+c1}{\PYGZsh{} Inverse kinematics}
  \PYG{n}{TestStream}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{p}{[}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{,} \PYG{n}{B2}\PYG{p}{,} \PYG{n}{P2}\PYG{p}{],} \PYG{n}{conditions}\PYG{o}{=}\PYG{p}{[],} \PYG{n}{effects}\PYG{o}{=}\PYG{p}{[}\PYG{n}{IsCollisionFree}\PYG{p}{(}\PYG{n}{B1}\PYG{p}{,} \PYG{n}{P1}\PYG{p}{,} \PYG{n}{B2}\PYG{p}{,} \PYG{n}{P2}\PYG{p}{)],}
             \PYG{n}{test}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{b1}\PYG{p}{,} \PYG{n}{p1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{,} \PYG{n}{p2}\PYG{p}{:} \PYG{n}{p1} \PYG{o}{!=} \PYG{n}{p2}\PYG{p}{)]} \PYG{c+c1}{\PYGZsh{} Collision checking}

\PYG{n}{constants} \PYG{o}{=} \PYG{p}{[]}
\PYG{n}{initial\PYGZus{}atoms} \PYG{o}{=} \PYG{p}{[}\PYG{n}{AtConf}\PYG{p}{(}\PYG{n}{initial\PYGZus{}config}\PYG{p}{),} \PYG{n}{HandEmpty}\PYG{p}{()]} \PYG{o}{+} \PYGZbs{}
                \PYG{p}{[}\PYG{n}{AtPose}\PYG{p}{(}\PYG{n}{block}\PYG{p}{,} \PYG{n}{pose}\PYG{p}{)} \PYG{k}{for} \PYG{n}{block}\PYG{p}{,} \PYG{n}{pose} \PYG{o+ow}{in} \PYG{n}{initial\PYGZus{}poses}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{()]}
\PYG{n}{goal\PYGZus{}formula} \PYG{o}{=} \PYG{n}{And}\PYG{p}{(}\PYG{n}{AtPose}\PYG{p}{(}\PYG{n}{block}\PYG{p}{,} \PYG{n}{pose}\PYG{p}{)} \PYG{k}{for} \PYG{n}{block}\PYG{p}{,} \PYG{n}{pose} \PYG{o+ow}{in} \PYG{n}{goal\PYGZus{}poses}\PYG{o}{.}\PYG{n}{iteritems}\PYG{p}{())}
\PYG{k}{return} \PYG{n}{STRIPStreamProblem}\PYG{p}{(}\PYG{n}{initial\PYGZus{}atoms}\PYG{p}{,} \PYG{n}{goal\PYGZus{}formula}\PYG{p}{,} \PYG{n}{actions}\PYG{o}{+}\PYG{n}{axioms}\PYG{p}{,} \PYG{n}{cond\PYGZus{}streams}\PYG{p}{,} \PYG{n}{constants}\PYG{p}{)}
\end{Verbatim}

%%%%%

%\begin{minted}{python}
%from stripstream import Type, Param, Pred, Not, Or, And, Equal, Exists, \
%  ForAll, Action, Axiom, GeneratorStream, TestStream, STRIPStreamProblem
%
%blocks = ['block%i'%i for i in range(3)]
%num_poses = pow(10, 10) # a very large number of poses
%initial_config = 0 # initial robot configuration is 0
%initial_poses = {block: i for i, block in enumerate(blocks)} # initial pose for block i is i
%goal_poses = {block: i+1 for i, block in enumerate(blocks)} # goal pose for block i is i+1
%
%BLOCK, POSE, CONF = Type(), Type(), Type() # Object types
%B1, B2 = Param(BLOCK), Param(BLOCK) # Free parameters
%P1, P2 = Param(POSE), Param(POSE)
%Q1, Q2 = Param(CONF), Param(CONF)
%
%AtConf = Pred(CONF) # Fluent predicates
%AtPose = Pred(BLOCK, POSE)
%HandEmpty = Pred()
%Holding = Pred(BLOCK)
%Safe = Pred(BLOCK, BLOCK, POSE) # Derived predicates
%IsKin = Pred(POSE, CONF) # Static predicates
%IsCollisionFree = Pred(BLOCK, POSE, BLOCK, POSE)
%
%actions = [
%  Action(name='pick', parameters=[B1, P1, Q1],
%    condition=And(AtPose(B1, P1), HandEmpty(), AtConf(Q1), IsKin(P1, Q1)),
%    effect=And(Holding(B1), Not(AtPose(B1, P1)), Not(HandEmpty()))),
%  Action(name='place', parameters=[B1, P1, Q1],
%    condition=And(Holding(B1), AtConf(Q1), IsKin(P1, Q1),
%      ForAll([B2], Or(Equal(B1, B2), Safe(B2, B1, P1)))),
%    effect=And(AtPose(B1, P1), HandEmpty(), Not(Holding(B1)))),
%  Action(name='move', parameters=[Q1, Q2],
%    condition=AtConf(Q1),
%    effect=And(AtConf(Q2), Not(AtConf(Q1))))]
%axioms = [
%  Axiom(effect=Safe(B2, B1, P1), # Infers B2 is at a safe pose wrt B1 at P1
%        condition=Exists([P2], And(AtPose(B2, P2), IsCollisionFree(B1, P1, B2, P2))))]
%
%cond_streams = [
%  GeneratorStream(inputs=[], outputs=[P1], conditions=[], effects=[],
%                  generator=lambda: xrange(num_poses)), # Enumerates all the poses
%  GeneratorStream(inputs=[P1], outputs=[Q1], conditions=[], effects=[IsKin(P1, Q1)],
%                  generator=lambda p: [p]), # Inverse kinematics
%  TestStream(inputs=[B1, P1, B2, P2], conditions=[], effects=[IsCollisionFree(B1, P1, B2, P2)],
%             test=lambda b1, p1, b2, p2: p1 != p2)] # Collision checking
%
%constants = []
%initial_atoms = [AtConf(initial_config), HandEmpty()] + \
%                [AtPose(block, pose) for block, pose in initial_poses.iteritems()]
%goal_formula = And(AtPose(block, pose) for block, pose in goal_poses.iteritems())
%return STRIPStreamProblem(initial_atoms, goal_formula, actions+axioms, cond_streams, constants)
%\end{minted}
\end{footnotesize}
\caption{\algname{} Python code for the example discrete domain} \label{fig:python}
\end{figure*}

\end{document}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
