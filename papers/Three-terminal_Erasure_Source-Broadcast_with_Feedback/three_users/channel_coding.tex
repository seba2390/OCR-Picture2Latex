\subsection{Non-Instantly-Decodable, Distortion-Innovative Coding}
\label{subsec:non_instant_coding}

When we have exhausted the queues that allow us to transmit instantly decodable, distortion-innovative symbols, we are left with two possibilities for the types of queues remaining.  By assumption, we have that for all $i \in \mathcal{U}$, either $Q_i$ or $Q_{\mathcal{U} \setminus \{i\}}$ is empty, and there exists an $l \in \mathcal{U}$ such that $Q_l$ is empty.  Thus, after the stopping condition of the algorithm in Section~\ref{subsec:instantly_decodable} has been reached, we are either left with queues \Q{1,2}, \Q{1,3} and \Q{2,3}, or queues $Q_i$, \Q{i,j} and \Q{i,k} (we will often use the indices $i, j$ and $k$ to refer to unique elements in $\mathcal{U}$).   We assume that the latter is the case and propose two methods to address this.  Analogous methods (omitted for brevity) can be used for the former case.

The first method involves preprocessing the remaining queues before using a channel coding scheme to satisfy the users' remaining demands.    The second method is a ``chaining algorithm,'' which involves the transmitter using the algorithm in~\cite{TMKS_TIT20} to send instantly-decodable, distortion-innovative transmissions to two users as if they were the only users in the network.  Meanwhile, the third user simultaneously builds ``chains'' of symbols that he may at times be able to decode based on the channel conditions, or with the subsequent reception of additional symbols.  We begin by describing the queue preprocessing method for channel coding.

\subsubsection{Queue Preprocessing for Channel Coding}
\label{subsec:channel_coding}

The channel coding scheme we employ is based on~\cite{GGT}, which outlines a method of \emph{losslessly} communicating a set of messages to $n$ users when feedback is available at the transmitter.  As input, it takes a set of queues $\{Q_U \mid U \subseteq \mathcal{U}\}$ where $U$ is a subset of users each of whom must losslessly reconstruct \emph{all} symbols in $Q_U$.

We preprocess queues $Q_i$, \Q{i, j} and \Q{i,k} to determine queues \tQo{i}, \tQo{j}, \tQo{k}, \tQ{i,j}, \tQ{i,k} that will be passed as input to the channel coding algorithm.  Let $\myd{R}{T}$ denote the number of symbols taken from queue $Q_R$ and placed in \tQo{T}.  Thus, we have, for example, that $| \tQo{i}| = \myd{i}{i} + \myd{i,j}{i} + \myd{i,k}{i}$.  Given that user $i$ has received $r_i$ symbols so far, we determine all $\delta$'s by solving the linear program in~\eqref{eq:delta_min}.
\begin{figure}
\begin{equation}
\label{eq:delta_min}
%\begingroup
%\allowdisplaybreaks
\begin{aligned}
%	& \underset{\pmb{\delta}}{\text{min}}
%	&& \frac{\myd{i}{i} +  \myd{i,j}{i} + \myd{i,k}{i}}{1 - \epsilon_i} + \frac{\myd{i,k}{k}}{1 - \epsilon_{k}} +  \frac{\myd{i,j}{j}}{1 - \epsilon_{j}} \\
%	&&& \qquad + \frac{\myd{i,k}{i,k}}{1 - \epsilon_{\max(i, k)}} + \frac{\myd{i,j}{i,j}}{1 - \epsilon_{\max(i, j)}} 
	& \underset{\pmb{\delta}}{\text{min}}
	&& \frac{\myd{i}{i} +  \myd{i,j}{i} + \myd{i,k}{i}}{1 - \epsilon_i} + \frac{\myd{i,k}{k}}{1 - \epsilon_{k}} +  \frac{\myd{i,j}{j}}{1 - \epsilon_{j}} \\
	&&& \qquad + \frac{\myd{i,k}{i,k}}{1 - \max(\epsilon_i, \epsilon_k)} + \frac{\myd{i,j}{i,j}}{1 - \max(\epsilon_i, \epsilon_j)}
\end{aligned}
%\endgroup
\end{equation}
\[
%\begingroup
%\allowdisplaybreaks
\begin{aligned}
	& \text{subject to}
%	& & 0 \leq \kappa \leq 1/2 \\
%	& & 1 - H(D_{1}) \leq \theta \leq 1
	&& \pmb{\delta} \succeq 0 \\
	&&&  \myd{i}{i}  \leq | Q_i |, \\
	&&&  \myd{i,k}{i} +  \myd{i,k}{k} + \myd{i,k}{i,k} \leq | \Q{i, k} |, \\
	&&&  \myd{i,j}{i} +  \myd{i,j}{j} + \myd{i,j}{i,j} \leq | \Q{i, j} |, \\
	&&& \myd{i}{i} + \myd{i,j}{i} + \myd{i,k}{i} + \myd{i, j}{i, j} + \myd{i,k}{i,k} \geq 1 - d_i - r_i, \\
	&&&  \myd{i,j}{j} + \myd{i,j}{i,j}  \geq 1 - d_j - r_j, \\
	&&&  \myd{i,k}{k} + \myd{i,k}{i,k}  \geq 1 - d_k - r_k,
%	&&&\hspace*{2.2cm}\textnormal{for }i \in \{1,2\}, \\% \label{eq: constraint_n} \\
%	&&& \hat{a} \left( (1 - \epsilon_{i}) \sum_{j = 0}^{i - 1} x_{j} + \sum_{j = i}^{n} x_{j} \right) \geq 1 - d_{i} \\
%	&&& \qquad \textnormal{for } i = 1, 2, \ldots, n
\end{aligned}
%\endgroup
\]
\end{figure}
%
%where each term in the objective function represents the minimum time required to process its corresponding queue.
Here, each term in the objective function represents the minimum latency required to process its corresponding queue, i.e., the first term represents the latency required to process $Q_i$, the second is for $Q_k$, etc.  Furthermore, we have that user $i$ is able to decode  \myd{R}{T} symbols if $i \in T$, and so given that this user has already received~$r_i$ symbols, the distortion constraints in~\eqref{eq:delta_min} follow.  

After solving~\eqref{eq:delta_min}, we run the channel coding algorithm on the newly determined queues, after which, we have that the total transmission time is the sum of the time required for this algorithm as well as the one from Section~\ref{subsec:instantly_decodable}.  Finally, we mention that a generalization of this section's approach for $n$ users is an ongoing work.

\input{chaining_algorithm/chaining_algorithm}
