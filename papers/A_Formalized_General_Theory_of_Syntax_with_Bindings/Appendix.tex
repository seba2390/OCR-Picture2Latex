\appendix

\noindent
{\Large APPENDIX}

\ \\ 
This appendix is included for the reviewers' convenience. 
If the paper is accepted, we will replace the references to the appendix with 
references to a technical report made available online. 




%This applies to induction 
%and recursion as well, although the adaptation has some  specificities.   





\section{More on Fresh Induction} \label{app-moreInd}

Fresh induction is based on the possibility to 
rename bound variables in abstractions without loss of generality. 
Intuitively, this is correct since the ``skeleton'' of a term, i.e., the tree 
obtained from it by retaining only branching information and forgetting 
about the operation symbols and the leaf variables, remains the same. 

Namely, we define trees to be ``pure branching'' structures: 
%
$$
\textsf{datatype }(\alpha,\beta)\tre \;=\; 
\Branch\;((\alpha,\,(\alpha,\beta)\,\tre)\,\inputt)\;((\beta,\,(\alpha,\beta)\,\tre)\,\inputt)
$$ 

The skeleton functions,  
$\qSkel : \qterm \ra (\indexx,\bindexx)\,\tre$ and 
$\qSkelAbs : \qabs \ra (\indexx,\bindexx)\,\tre$, 
are first defined for quasiterms and quasiabstractions by usual structural recursion: 
%
$$
\begin{array}{rcl}
\qSkel\;(\qVar\;\xs\;x) &\;=\;&
   \Branch\;(\lambda i.\,\None)\;(\lambda i.\,\None)
\\
\qSkel\;(\qOp\;\delta\;\inp\;\binp) &\;=\;&
   \Branch\;(\lift\,\qSkel\;\inp)\;(\lift\,\qSkel\;\binp)
\\
\qSkelAbs\;(\qAbs\;\xs\;x\;X) &\;=\;&
    \Branch\;(\lambda i.\;\Some\,(\qSkel\;X))\;(\lambda i.\,\None)
\end{array}
$$

We show that the skeleton is invariant under alpha-equivalence, which allows 
us to lift these functions to terms and abstractions, 
$\skel : \term \ra (\indexx,\bindexx)\,\tre$ and 
$\skelAbs : \abs \ra (\indexx,\bindexx)\,\tre$. 

Thus, the skeleton gives a measure for terms that generalizes 
the standard depth for finitely branching datatypes. 
Importantly, the skeleton is also invariant under swapping and variable-for-variables substitution. 
This allows us to prove our fresh induction schema 
by standard structural induction on trees, using $\skel$ and $\skelAbs$ as measures.   



\section{More on Recursion} \label{app-moreInd}



\subsection{Many-Sorted Recursion}\label{app-RecDef}

As mentioned in the main paper, adapting the theorems from 
good items to well-sorted items is a routine process. 
For recursion, this is more bureaucratic, since it involves 
the sorting of the target domain as well.


A {\em sorted FS model} is an extension 
of the %unsorted
FS models from the main paper with
\begin{myitem}
\item the sorting predicates $\wls^{\T} : \sort \ra \T \ra \bool$ and 
$\wlsAbs^{\T} : \varsort \ra \sort \ra \A \ra \bool$
\item the assumption that all operators preserve sorting, 
e.g., 
\\$\wls^{\T}\,s\;X \wedge \wls^{\T}\;(\asSort\;\ys)\;Y 
\;\Lra\;
\wls^{\T}\,s\;X\ [Y / y]_{ys}$
\item the assumption that the sets of items corresponding to different 
sorts are disjoint
\end{myitem}

The recursion theorem is modified to take sorting into account: 

\begin{thm}\label{th-rec-sort} \rm
The sorted terms and abstractions form the initial sorted FS model. Namely, 
for any sorted FS model. % as above, 
there exist the functions $\f:\term \ra \T$ 
and $\fAbs : \abs \ra \A$ that satisfy the same properties as in Theorem~\ref{th-rec} 
and additionally preserve sorting:
\begin{myitem}
\item $\wls\;s\;X \;\Lra\; \wls^{\T}\,s\;(\f\;X)$
\item $\wls\;s\;X \;\Lra\; \wlsAbs^{\T}\,s\;(\fAbs\;X)$
\end{myitem}
\end{thm}


Similarly, for a sorted version of the semantic interpretation theorem, we define 
a {\em sorted semantic domain} to have the same components as a semantic domain 
from the main paper, plus sorting predicates $\wls^{\Dt}$ and $\wls^{\Da}$.  
Again, it is assumed that the semantic operators preserve sorting and the 
sets of items for different sorts are disjoint.
Then Theorem~\ref{th-sem} is adapted to sorted domains, additionally ensuring 
the sort preservation of $\sem$ and $\semAbs$. 


\subsection{Swapping-Based Recursion}

The main feature of our recursion theorem is the ability to define 
functions in a manner that is compatible with alpha-equivalence. 
A byproduct of the theorem is that the defined functions  
interacts well with freshness and substitution, in that 
it maps these concepts to corresponding concepts on the target domain.  
Michael Norrish has developed a similar principle that employs swapping instead 
of substitution \cite{norrish-MechanisingLambdaInFirstOrder}. We have formalized this 
as well:

A {\em fresh-swapping model} is a structure similar to our fresh-substitution models, 
just that instead of the substitution-like operators, $\_[\_/\_]_\_ : \T \ra \T \ra \var \ra \varsort \ra \T$ and 
$\_[\_/\_]_\_^{Abs} : \A \ra \T \ra \var \ra \varsort \ra \A$, 
it features swapping-like operators, 
$\_[\_\wedge\_]_\_ : \T \ra \var \ra \var \ra \varsort \ra \T$ and 
$\_[\_\wedge \_]_\_^{Abs} : \A \ra \var \ra \var \ra \varsort \ra \A$, assumed to 
satisfy rules corresponding to those for simplifying term swapping: 
%
\begin{myitem}
\item $(\VAR\;\xs\;x)\,[z_1 \wedge z_2]_{zs} \;=\; \VAR\;\xs\,(x\,[z_1 \wedge z_2]_{xs,zs})$
%
\item $(\OP\;\delta\;\inp\;\binp)\,[z_1 \wedge z_2]_{zs} = 
\Op\;\delta\;(\lift\,(\_[z_1 \wedge z_2]_{zs})\,\inp)\;(\lift\,(\_[z_1 \wedge z_2]_{zs})\,\binp)$ 
%
%where $\inp\,[Y/y]_{ys}$ denotes $\lambda i.\;
%\mbox{case $\inp\;i$ of $\None$ $\Ra$ $\None$ $\mid$ $\Some\;X$ $\Ra$ $X[Y/y]_{ys}$}$, and similarly for $\binp$
%
\item $(\Abs\;\xs\;x\;X)\,[z_1 \wedge z_2]_{zs} \,=\, \Abs\;\xs\,(x\,[z_1 \wedge z_2]_{xs,zs})$
\end{myitem}
%
and, instead of the substitution-based variable-renaming property, the following 
swapping-based alternative: $\FRESH\;\xs\;y\;X \;\Lra\; \Abs\;\xs\;x\;X = \Abs\;\xs\;y\;(X\,[y \wedge x]_{ys})$. 
%
Then a version of the recursion theorem holds, in that terms form the initial 
freshness-swapping model. 

In fact, we can combine both notions, obtaining 
freshness-substitution-swapping models, among which again terms form the initial 
model. Having formalized all these variants, the user can decide on the desired 
``contract:'' with more operators factored in, there are more proof obligations that 
need to be discharges for the definition to succeed, but then the 
defined functions satisfy more desirable properties. %, i.e., are known to commute with more operators. 


\subsection{Recursion versus Iteration}

What we presented so far was actually a simple version of primitive recursion 
called {\em iteration}. The difference between the two is illustrated by 
the following simple example:\footnote{This is a contrived example, where no ``real'' recursion 
occurs---but 
it illustrates the point.} 
The predecessor function $\pred : \nat \ra \nat$ 
is defined by $\pred\;0 = 0$ and $\pred\,(\Suc\;n) = n$.  
This does not fit the iteration scheme, where only the value of the function on 
smaller arguments, and not the arguments themselves, can be used. 
In the example, iteration would allow 
$\pred\;(\Suc\;n)$ to invoke recursively $\pred\;n$, but not $n$.  
Of course, we can simulate recursion by iteration if we are allowed an auxiliary 
output: defining $\pred' : \nat  \ra \nat \times \nat$ by iteration, 
$\pred'\;0 = (0,0)$ and $\pred'\,(\Suc\;n) = $ case $\pred'\;n$ of $(n_1,n_2) \Ra (n_1,\_)$, 
and then taking $\pred\;n$ to be the first component of $\pred'\;n$. 
(See also \cite[\S1.4.2]{pop-thesis}.) 

Initially, we had only developed the iteration theorems, but soon realized that 
several applications required full recursion (e.g., the complete development 
operator, the CPS transformation, etc.); and it was tedious to perform the above 
encoding over and over again. Consequently, we decided to formalize full recursion 
(for all three variants: substitution, swapping and substitution-swapping).  
We show here the full recursion variant of Theorem~\ref{th-rec}: 

A {\em full-recursion FS model} has the same components as an FS model, 
except that:
\begin{myitem}
\item $\OP$ takes term and abstraction inputs in addition to inputs from the model, i.e., 
has type $\opsym \ra \coll{(\indexx,\term)\;\inputt} \ra (\indexx,\T)\;\inputt 
\ra 
\coll{(\bindexx,\abs)\;\inputt} \allowbreak \ra 
(\bindexx,\A)\;\inputt \ra \T$
\item The freshness and substitution operators take additional term or abstraction arguments, 
e.g., $\FRESH : \varsort \ra \var \ra \coll{\term} \ra \T \ra \bool$
\end{myitem}


\begin{thm}\label{th-rec-full} \rm
The good terms and abstractions form the initial full-recursion FS model. Namely, 
for any full-recursion FS model as above, there exist the functions $\f:\term \ra \T$ 
and $\fAbs : \abs \ra \A$ that commute, on good terms, 
with the constructors and with substitution and preserve freshness in the same 
manner as in Theorem~\ref{th-rec}, mutatis mutandis. For example: 
\begin{myitem}
\item $\f\,(\Var\;\xs\;x) = \VAR\;\xs\;x$
\item $\f\,(\Op\;\delta\;\inp\;\binp) = 
\OP\;\delta\,\coll{\inp}\,(\lift\,\f\;\inp)\,\coll{\binp}\,(\lift\,\fAbs\;\binp)$
%, where $\lift\,f\;\inp$ and $\lift\,f^{Abs}\;\inp$ denote, as usual, the componentwise lifting of these operators 
%to free or bound inputs
\item $\fresh\;\xs\;x\;X \,\Lra\, \FRESH\;\xs\;x\,\coll{X}\,(\f\;X)$
\end{myitem}
\end{thm}

 

\section{Applications of the Framework} \label{sec-app}  


So far, we instantiated the binding signature to 
the syntaxes of the call-by-name and call-by-value
variants of the $\lambda$-calculus 
(the latter differing from the former by a separate syntactic category for values) 
and to that of many-sorted FOL---and applied it to results on these syntaxes. 
%
%We have employed the instantiated 
%theory in several case studies. 
%We have applied the instantiated theory in several results. 

The first application was developed in 2010, when we proved strong normalization 
for System F \cite{pop-HOASOnFOAS}. The two employed syntaxes, of System F's Curry-style terms and types, are two copies 
of the $\lambda$-calculus syntax. 
%\footnote{More precisely, 
%the proof of strong normalization for system F \cite{pop-HOASOnFOAS} required it. 
%In general, logical relation techniques \cite{} need this more general form of substitution.
The logical relation technique required in the proof made essential use of 
parallel substitution---and in fact was the incentive for us to go beyond unary 
substitution in the general theory. 
To streamline the development, on top of the first-order syntax we introduced 
HOAS-like definition and reasoning techniques, which were %heavily based on 
%inferred from 
based on the general-purpose first-order ones shown in Section~\ref{sec-reas}. 

In subsequent %unpublished 
work \cite{pop-recPrin}, we formalized several results about 
$\lambda$-calculus: 
the standardization and Church-Rosser theorems 
and the %mutual 
CPS translations between 
call-by-name and call-by-value calculi 
\cite{plotkin-CBNandCBVandLambda},  
an adequate HOAS representation of the calculus into itself, 
a sound interpretation via de Bruijn encodings \cite{cur-CategoricalCombinators}, and 
the isomorphism between different definitions of $\lambda$-terms: 
ours, the Nominal one \cite{UrbanTasson}, the 
locally named one \cite{pol-LocNamed2} and the Hybrid one \cite{momFelty-Hybrid4}. %Most of 
These results are centered 
around some translation/representation functions: CPS, HOAS, 
Church-Rosser complete development \cite{takahashi-CompleteDevelopment}, 
de Bruijn, etc.%translations between different representations. 
%(including the complete development operator used in the proof of Church-Rosser, the de Bruijn 
%interpretation and )
---%all 
these functions 
and their 
good properties (e.g., preservation of substitution, 
%which is central for HOAS adequancy 
crucial in HOAS \cite{har-fra}) 
were obtained as 
instances of our recursion Theorem~\ref{th-rec}.   

Finally, in the context of certifying Sledgehammer's HOL to FOL encodings \cite{DBLP:journals/corr/BlanchetteB0S16}, 
we formalized fundamental results in many-sorted FOL \cite{blanchette-frocos2013}, 
including the completeness, compactness, 
Skolemization and downward L\"{o}wenheim-Skolem theorems. Besides the ubiquitous 
employment of the properties of freshness of substitution from Section~\ref{subsec-termsTh}, 
we 
%again 
%had some essential uses of 
%our theory's support for defining functions modulo alpha: 
used the interpretation Theorem~\ref{th-sem} for the FOL semantics 
%to obtain a quick setup of the semantic interpretations of terms and formulas 
%and their basic properties w.r.t.\ freshness and substitution, while 
and the recursion Theorem~\ref{th-rec} for bootstraping quickly the (technically quite tricky) Skolemization 
function.  







 
  







