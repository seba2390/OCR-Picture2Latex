\section{Approach}
\label{sec:approach}

\subsection{Roles}
\label{sec:roles}

In both algorithms, we assume that the robots are initially deployed
in a fully connected cluster. Subsequently, the robots must form a
tree by dynamically assuming a specific role in the process.

In both tree-forming algorithms, the robots can have four possible
roles: \emph{root}, \emph{worker}, \emph{connector}, or
\emph{spare}. The \emph{root} robot corresponds to the tree
root, and at any time during the execution only one robot can assume
this role. The \emph{worker} robots are the tree leaves, and they
correspond to robots that must reach the target locations, forcing the
tree to grow progressively. The \emph{connector} robots dynamically
join the tree to support its growth, leaving the pool of available
\emph{spare} robots.

\subsection{High-Level Behavior Specification}
\label{sec:behaviorspec}

The algorithms can be formalized through a high-level state machine
that encodes the behavior of every robot, as depicted in
\fig{generalfsm}.
\begin{figure}[t]
  \centering
  \begin{tikzpicture}[
    state/.style={rounded rectangle,draw,very thick,minimum height=2em,text width=3em,align=center,font=\scriptsize\scshape},
    specstate/.style={state,fill=lightgray},
    barrier/.style={diamond,draw,fill=lightgray,very thick,minimum height=2em,text width=3em,align=center,font=\scriptsize\itshape},
    every on chain/.style={join=by {->,very thick}},
    start chain,
    node distance=1em
    ]
    \node(ii)[state,on chain]{Init};
    \node(it)[state,on chain]{Start Tree};
    \node(sp)[specstate,state,on chain]{Select Parent};
    \node(ps)[barrier,on chain]{parent selected?};
    \node(gt)[specstate,continue chain=going below,on chain]{Grow Tree};
    \node(tg)[barrier,continue chain=going left,on chain]{growth done?};
    \node(sr)[state,on chain]{Select Root};
    \node(rs)[barrier,on chain]{root selected?};
    \draw[->,very thick] (rs) -- (it);
  \end{tikzpicture}
  \caption{The high-level Finite State Machine that formalizes the
    individual robot behaviors in the two tree-formation
    algorithms. Rounded rectangles denote states, and diamonds denote
    \emph{barriers}, i.e., conditions that all robots must meet before
    proceeding to the next state. States filled in white are common
    among both algorithms; states and barriers filled in light gray
    differ across algorithms.}
  \label{fig:generalfsm}
\end{figure}

Every robot starts in state \textsc{Init}. We assume that a process
that assigns the role of \emph{worker} to the robots closest to the
targets has been already executed, through, e.g., a task allocation
algorithm or a gradient-based algorithm. In addition, a random robot
is assumed assigned the role of \emph{root}. The other robots are
initially \emph{spare}.

The \textsc{Start Tree} state is triggered by the root, which
propagates a signal throughout the robot network. This state signifies
that a new tree must be created. As the message propagates throughout
the network, the robots estimate their distance from the root. This is
possible because of situated communication---every robot can estimate
a relative vector to each of its immediate neighbors.

Robots receiving a ``start tree'' signal switch to \textsc{Select
  Parent}. In this state, each robot must identify a new parent to
attach to. The selection of a new parent aims to create the shortest
% Perhaps you say what a parent is/does
possible paths between the root robot and the \emph{worker} robots,
i.e., the leaf nodes in the tree. The specifics of this state are
different in the \emph{outwards} and \emph{inwards} algorithms, and
are explained in \sect{outwardsalg} and \sect{inwardsalg}. At the
end of this state, a robot is part of two trees---the one from the
previous iteration of the algorithm (excluding the very first
iteration), and a new one that reflects the new parent.

Once every robot has selected a new parent, the robots switch to the
\textsc{Grow Tree} state, in which the robots forget the tree from the
previous iteration and \emph{spare} robots are accepted to join an edge. 
The algorithms differ in the implementation of this state, and details
are reported in \sect{outwardsalg} and \sect{inwardsalg}.

Once the growth state is complete, the robots switch to the
\textsc{Select Root} state. As the tree grows, the initial choice of
the root robot (which is random) or an uneven distribution of target
locations might render the tree topology nonoptimal. By selecting a new
root, the swarm can balance the tree branches, thus fostering even
growth over time. The design of this state is illustrated in
\sect{rootselection}.

Finally, the new assigned root switches to state \textsc{Start Tree}
and broadcasts a new ``start tree'' signal.

In \fig{generalfsm}, certain state transitions are marked with
diamonds. These transitions, which we call \emph{barriers}, are
special in that they correspond to ``wait states'' in which the robots
must stay until a certain condition is verified for every robot. The
specific implementation of these conditions depends on the
algorithms. However, the general principle is that the root aggregates
the information necessary to evaluate a certain condition, and then
broadcasts a ``go'' signal throughout the tree. The ``go'' signal
triggers a state transition in the robots that receive it.

\subsection{Selection of a New Root}
\label{sec:rootselection}
The purpose selecting a new root is to balance the tree, which fosters
better growth and compensates for an uneven distribution of target
locations. In addition, balancing the tree has positive effects on the
scalability of our algorithms. Every state in our algorithms involves
some form of diffusion/aggregation process across the tree, with a
time complexity that is linear with the depth of the tree. By
balancing the tree, we also shorten its depth, thus lowering the time
for diffusion/aggregation processes to complete.

These considerations suggest that the best location for the root is as
close as possible to the centroid of the distribution of robots. The
selection of a new root occurs at the end of a tree configuration
loop, but the data upon which the process depends is collected in
state \textsc{Select Parent}, when the robots select a new parent.

The algorithm provides an estimate of the centroid in the root
reference frame by adding up each robot contribution from the leaves
to the root. The algorithm is formalized in \alg{centroid}. An
intuitive explanation of this algorithm proceeds as follows. Since
each robot only knows its relative position to other robots, it must
send to its parent an accumulation vector $ \mathbf{q}_i$ which
aggregates its contributions and that of all its descendants in the
tree, according to its own reference frame. \fig{centroid} reports an
example with three robots, where robot 0 is the root, robot 2 is a
\emph{worker}, and robot 1 is a \emph{connector}.

% We aim to calculate the centroid expressed in robot
% 0's reference frame. Calling $\mathbf{p}_i^j$ the vector that connects
% robots $i$ and $j$ in $i$'s reference frame, the centroid is
% $(\mathbf{q}_0=\mathbf{p}_0^0 + \mathbf{p}_0^1 + \mathbf{p}_0^2) / 3$,
% with $\mathbf{p}_0^0 = \mathbf{0}$. The computation starts at robot 2,
% which estimates the centroid to be in the middle between itself and
% robot 1 ($\mathbf{q}_2=\mathbf{p}_2^1/2$). According to
% \alg{centroid}, robot 1 calculates
% $\mathbf{q}_1= \mathbf{q}_2^1 + (1 \cdot 1+1) \cdot \mathbf{p}_i^0$
% where $\mathbf{q}_2^1$ is $\mathbf{q}_2$ as seen from robot 1's
% reference frame. Robot 0 performs an analogous calculation, and then
% divides the final result by the number of robots, thus obtaining the
% centroid.

To perform the final calculation of the centroid, \alg{centroid} needs
the number of robots in the swarm. A tree-based distributed algorithm
to count the number of robots currently committed in the tree is
reported in \alg{count}. This algorithm requires the robots to
aggregate a partial count, denoted with $c_i$, from the tree leaves to
the root.

In our implementation, both \alg{centroid} and \alg{count} are
executed in parallel in state \textsc{Select Parent}. In
\textsc{select root}, the current root compares its position and the
position of its neighbors to the centroid estimate (all are expressed
in its reference frame). If the current root is the closest to the
centroid, it remains the root and restarts a new tree loop. Otherwise,
it designates a new root and sends the centroid vector and the angle
to the new root. When the new root receives this message, it sends an
acknowledgement message to the old root, and then it expresses the
centroid in its own reference frame. The process is repeated until the
root is the closest robot to the centroid estimate.

\begin{algorithm} [t]
  \begin{algorithmic}[1]
    \State $\mathbf{a}_i = 0$
    \ForAll{child $j$}
    \State $\mathbf{q}_j^i$ = express $\mathbf{q}_j$ in $i$'s reference frame
    \State $\mathbf{a}_i = \mathbf{a}_i + \mathbf{q}_j^i$
    \EndFor
    \If{robot $i$ has a parent}
      \State $\mathbf{q}_i =  \mathbf{a}_i - (\underbrace{c_i - d_i}_{\text{nb descendants}} + 1) \cdot \mathbf{p}^{\text{parent}}_i$
    \EndIf
    \If{robot $i$ is the root}
      \State $\mathbf{q}_i =  \mathbf{a}_i / \underbrace{c_i}_{\text{robot count}}$
    \EndIf
  \end{algorithmic}
  \caption{Distributed centroid estimation algorithm executed by robot
    $i$: $\mathbf{a}_i$ denotes an accumulator value; $\mathbf{q}_i$
    denotes the contribution of robot $i$ to the estimation algorithm;
    $c_i$ and $d_i$ denote the number of robots in the swarm estimated
    by robot $i$ and the tree depth of robot $i$, respectively; and
    $\mathbf{p}^{\text{parent}}_i$ is the vector from robot $i$ to its
    parent.}
  \label{alg:centroid}
\end{algorithm}

\begin{algorithm} [t]
  \begin{algorithmic}[1]
    \Switch{number of children}
      \Case{0}
        \State \textbf{return} $d_i$
      \EndCase
      \Case{1}
        \State \textbf{return} $c_{\text{child}}$
      \EndCase
      \Default
        \State \textbf{return} $\sum_{\text{neighbors }j} (c_j - d_i) + d_i$
      \EndDefault
    \EndSwitch
  \end{algorithmic}
  \caption{Tree-based count algorithm for robot $i$. The depth of
    robot $i$ in the tree is denoted as $d_i$. The depth of the tree
    root is set to 1. The count calculated by robot $j$ is denoted as
    $c_j$.}
  \label{alg:count}
\end{algorithm}

\begin{figure}[t]
  \centering
  \includegraphics[height=5cm]{centroid}
  \caption{The red triangle represents robot 0 with the root reference
    frame. The blue square represents robot 1, which is a child of
    robot 0 and a parent of robot 2, in turn represented by the green
    circle.}
  \label{fig:centroid}
\end{figure}

\subsection{The Outwards Algorithm}
\label{sec:outwardsalg}
The intuition behind the outwards algorithm is to build a logical
spanning tree over the entire robot network. The process starts at the
root, and robots join the tree progressively.

In state \textsc{Select Parent}, robot $i$ considers its neighbors as
potential candidates. Viable candidates are non-\emph{workers} already
in the tree and at a distance smaller than the communication
range. Among these, the robot selects the closest robot. The robot
commits to the tree and starts broadcasting its parent id, which
indicates to the parent robot that robot $i$ is a child and that $i$
is a \emph{connector}. Each \emph{connector} maintains its list of
children and checks for obstructions of line-of-sight with respect to
its parent. If a robot can not receive data from its selected parent,
it selects another parent and updates its data.

In state \textsc{Grow Tree}, the robots undergo two main phases:
first, they discard the information about the old tree; second, they
prune tree branches that contain no \emph{workers}. To establish
whether a branch contains a \emph{worker}, when a \emph{worker}
selects a parent (state \textsc{Select Parent}), the latter propagates
this information upstream towards the root.

\begin{figure}[t]
  \centering
  \includegraphics[height=5cm]{spanningtree}
  \caption{Spare management in the \emph{outwards} algorithm. The
    useful tree edges (blue nodes) are extended by pruning useless
    tree branches (grey nodes).}
  \label{fig:outwardsspare}
\end{figure}
The branches not containing a \emph{worker} are considered ``useless''
and the robots that are part of them take the \emph{spare} role. To
disband a useless branch, \emph{spare} robots leave it starting from
the leaves. The leaves curl the branch back towards the root, and upon
entering in contact with another branch might decide to join it. The
logic for spares to join a branch is explained in
\sect{sparemanegement}

\subsection{The Inwards Algorithm}
\label{sec:inwardsalg}

The intuition behind the \emph{inwards} algorithm is that the robots
join the tree starting from the workers towards the root. Growth is
therefore directed, and the final topology is a \emph{sparse} tree, in
that only a subset of the robots takes part in it. The \emph{spare}
robots, in contrast to the \emph{outwards} algorithm, do not form
branches; rather, they disperse along the tree and select a robot to
use as reference.

\begin{figure}[t]
  \centering
  \includegraphics[height=5cm]{sparsetree}
  \caption{Spare management in the \emph{inwards} algorithm. Useful
    tree edges (blue nodes) are extended by adding \emph{spare} robots
    (purple nodes)}
  \label{fig:outwardsspare}
\end{figure}
In state \textsc{Select Parent}, viable candidates for parent
selection are non-workers in the tree or robots not in the tree which
are at a distance smaller than the communication range $C$. Among
these, a robot selects a neighbor with the smallest distance to the
root. When the robot $i$ commits to the tree, it broadcasts its parent
id, which indicates to the parent robot that robot $i$ is a child and
that $i$ is a \emph{connector}. In the \emph{inwards} algorithm, by
definition, all branches are useful because they all terminate with a
\emph{worker} as leaf node.

In state \textsc{Grow Tree}, \emph{spare} robots attempt to join a
branch. The logic for branch joining is the same as in the
\emph{outwards} algorithm, and it is explained in
\sect{sparemanegement}.

\subsection{Spare Management}
\label{sec:sparemanegement}
\begin{figure}[t]
  \centering
  \includegraphics[width=.48\textwidth]{sparerobot}
  \caption{Interaction between \emph{spare} and \emph{non-spare}
    robots.}
  \label{fig:sparerobot}
\end{figure}

The state machine diagram in \fig{sparerobot} describes the part of
the \textsc{Grow Tree} state that concerns the interaction between
\emph{spare} robots and non-\emph{spare} robots (i.e.,
\emph{connectors}, \emph{workers}, and \emph{root}).

Non-spare robots enter the \textsc{no need} state when they have no
need for a spare robot. They exit this state either if their distance
to their parent becomes smaller than the \emph{safe communication
  range} $S$, or if at least one of their children's state is the
\textsc{need} state.  In the \textsc{need} state, each robot
continuously checks if it is in an edge selected by a \emph{spare}
robot, or if their parent is in the \textsc{await} state. If one of
these conditions is fulfilled, the robot transitions to the
\textsc{await} state.  In the \textsc{await} state, the robot is
waiting the insertion of a spare robot either in one of its edges or
upstream in the tree.

\emph{Spare} robots enter the \textsc{wait} state and look for an edge
to extend. They transition to the \textsc{extend edge} state or the
\textsc{adjust position} state after performing a search for edges in
need among their neighbors.  In the \textsc{adjust position} state,
spare robots rotate around their parent if they are within the safe
radius or move towards their parent in a straight line otherwise.  In
the \textsc{extend edge} state, spare robots head for the middle of
the edge to be extended.

\subsection{Robot Motion}
\label{sec:robotmotion}

The integrity of the tree over time is ensured by constraining the
robots' motion. We enforce the constraints by expressing the robot
motion as a sum of virtual potential forces (we omit time dependency
for brevity of notation):
$$
u_i =
\begin{cases}
  u_i^{\text{tree,old}} + u_i^{\text{tree,new}} \\ \quad\quad\quad + f_i(d_i^{\text{parent}}) (u_i^{\text{target}} + u_i^{\text{avoid}}) & \text{if }d_{i,j} \le E\\
  \mathbf{p}_i^{\text{parent}} & \text{otherwise} \\
\end{cases}
$$
where $d_{i,j} = \parallel p_i - p_j \parallel$, $E < C$ is the
\emph{emergency} range beyond which a robot is dangerously distant
from its parent, and
\begin{itemize}
\item $u_i^{\text{tree,old}}$ and $u_i^{\text{tree,new}}$ indicate the
  interaction law between robots $(i,j)$ in a parent-child
  relationship, in either the old or the new tree. We use the control
  law
  $$
  u_i^{\text{tree}} =
  \frac{\epsilon}{d_{i,j}}
  \left(
    \left(
      \frac{\delta}{d_{i,j}}
    \right)^2
    -
    \left(
      \frac{\delta}{d_{i,j}}
    \right)^4
  \right)
  $$
  where $\delta = E$ and
  $\epsilon$ are parameters to set at design time.
\item $u_i^{\text{target}}$ is a control law that attracts a robot to a
  target, promoting tree growth. For workers, this is a force that
  points the assigned target location $l_i$ and calculated with
  $$
  u_i^{\text{target}} = \tau \frac{l_i - p_i}{\parallel l_i - p_i \parallel}
  $$
  where $\tau$ is a design parameter. Workers propagate to their
  parents the calculated $u_i^{\text{target}}$, and connectors apply it in turn.
\item $u_i^{\text{avoid}}$ is a repulsive force for obstacle avoidance
  between neighbors not in a parent-child relationship.
\item $f_i(d_i^{\text{parent}})$ is a function defined as follows:
  $$
  f_i(d_i^{\text{parent}}) =
  \begin{cases}
    1 & \text{if }d_i^{\text{parent}} \le S\\
    0 & \text{otherwise}
  \end{cases}
  $$
  where $d_i^{\text{parent}}$ is the distance between a robot and its
  parent and $S < E$ is the \emph{safe communication range}. Through
  this function, a robot can ignore navigation to target and obstacle
  avoidance to perform emergency maneuvers when the distance to its
  parent becomes unsafe.
\end{itemize}

% %%% Local Variables:
% %%% mode: latex
% %%% TeX-master: "main"
% %%% End:
