\section{Introduction}
\label{sec:introduction}

Swarm robotics~\cite{Brambilla2013} is a branch of collective robotics
that studies decentralized solutions for the problem of coordinating
large teams of robots. Robot swarms are a promising technology for
large-scale scenarios, in which performing spatially distributed tasks
would entail prohibitive costs for single-robot
solutions~\cite{Brambilla2013}. Typical examples include planetary
exploration~\cite{Goldsmith1999}, deep underground
mining~\cite{Rubio2012}, ocean restoration, and
agriculture.

A common aspect in these scenarios is the necessity to maintain a
coherent state across the swarm. Many basic coordination problems can
be solved assuming low-bandwidth, occasional communication or even no
communication. However, global connectivity is an asset when
information must be exchanged in a timely manner, either to optimize a
global performance function, or to aggregate data in a sink. Task
allocation scenarios with stringent space and time constraints, such
as warehouse organization and search-and-rescue
operations~\cite{stormont2005} are prime examples of this category of
problems. In these scenarios, it is desirable for the robot network to
allow both short-range and long-range information exchange.

In this paper, we tackle the problem of deploying a robot network in a
decentralized fashion, under the constraint that long-range
information exchange must be possible at any time during a mission.
We assume that the robots must reach a number of distant
locations. While navigating to these locations, the robots must spread
without splitting the network topology in disconnected components. The
robots must achieve a final configuration in which data can flow
between any two target locations, using the robots as relays.

It is important to notice that it is not required for all of the
robots to take part in the final topology. Rather, it is desirable
that as few robots as possible are engaged in connectivity
maintenance, as this would free any extra robot for others tasks or to
act as occasional replacement for damaged robot in the topology. In
contrast, the robots that are part of the final topology must form a
persistent communication backbone that can be used by any robot when
necessary.

This aspect sets apart our work from existing research on connectivity
maintenance, which generally requires \emph{all} robots to be part of
the connected topology. The literature on this topic can be broadly
divided in two classes: algorithms in which the robots must attain a
final, static structure to maximize coverage~\cite{Aragues2014}, and
algorithms in which global connectivity is enforced while navigating
to a specific location as a single unit
(flocking)~\cite{Nestmeyer2017}. Our work, in contrast, aims to create
a dynamic, decentralized communication infrastructure that connects
specific locations and uses as few robots as possible.

Our approach assumes that the robots are initially deployed in a
compact, connected cluster. The robots then form a logical \emph{tree}
over the physical network topology. By growing the tree over time, the
distribution of the robots progressively and dynamically extends to
reach the target locations. The final configuration is a star-like
topology, in which data can flow between any two target
locations.

The main contributions of this work are:
\begin{enumerate}
\item The formalization of two algorithms to form and grow logical
  tree topologies that connect multiple target locations;
\item A comparative study of the algorithms, based on extensive
  physics-based simulations;
\item The validation of our findings through a large set of real-robot
  experiments.
\end{enumerate}

The rest of this paper is organized as follows. In \sect{probstat} we
formalize the problem statement. In \sect{approach} we present our
methodology. In \sect{evaluation} we report an evaluation of the
algorithms. In \sect{relatedwork} we discuss related work. The paper
is concluded in \sect{conclusions}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
