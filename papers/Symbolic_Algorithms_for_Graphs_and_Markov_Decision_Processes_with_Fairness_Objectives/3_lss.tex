\vspace{-3mm}
\section{Symbolic Divide-and-Conquer with Lock-Step Search}\label{sec:lss}

\vspace{-1mm}
In this section we present a symbolic version of the lock-step
search for strongly connected subgraphs~\cite{HenzingerT96}. 
This symbolic version is used in all subsequent results, i.e., the
sub-quadratic symbolic algorithms for graphs and MDPs with Streett objectives,
and for MEC decomposition.

\vspace{-1mm}
\smallskip\noindent{\em Divide-and-Conquer.}
The common property of the algorithmic problems we consider in this work is
that the goal is to identify subgraphs of the input graph $G = (V, E)$
that are strongly connected and satisfy some additional properties. The difference between
the problems lies in the required additional properties. We 
describe and analyze the Procedure~\ref{proc:lockstep} that we use in all our improved 
algorithms to efficiently implement a divide-and-conquer approach based on the
requirement of strong connectivity, that is, we divide a subgraph~$G[S]$,
induced by a set of vertices~$S$, into 
two parts that are not strongly connected within $G[S]$ or detect that $G[S]$ is 
strongly connected. 

\vspace{-1mm}
\smallskip\noindent{\em Start Vertices of Searches.}
The input to Procedure~\ref{proc:lockstep} is a set of vertices~$S \subseteq V$ 
and two subsets of $S$ denoted by~$H_S$ and~$T_S$.
In the algorithms that call the procedure as a subroutine, vertices
contained in~$H_S$ have lost incoming edges (i.e., they were a  ``head'' of
a lost edge) and vertices contained in~$T_S$ have lost outgoing edges
(i.e., they were a  ``tail'' of a lost edge) since the last time a superset
of $S$ was identified as being strongly connected.
For each vertex~$h$ of $H_S$ the procedure
conducts a backward search (i.e., a sequence of $\pre$ operations) within~$G[S]$ to 
find the vertices of $S$ that can 
reach~$h$; and analogously a forward search (i.e., a sequence of $\post$ operations)
from each vertex~$t$ of $T_S$ is conducted.

\vspace{-1mm}
\smallskip\noindent{\em Intuition for the Choice of Start Vertices.}
If the subgraph~$G[S]$ is not strongly connected, then it contains at least 
one top SCC and at least one bottom SCC that are disjoint. Further, if for 
a superset $S' \supset S$ the subgraph~$G[S']$ was strongly connected, then 
each top SCC of $G[S]$ contains a vertex that had an additional 
incoming edge in $G[S']$ compared to $G[S]$, and analogously each bottom SCC of 
$G[S]$ contains a vertex that had an additional outgoing edge. Thus by keeping
track of the vertices that lost incoming or outgoing edges, the following invariant
will be maintained by all our improved algorithms.

\vspace{-1mm}
\begin{invariant}[Start Vertices Sufficient]\label{inv:HT} We have $H_S, T_S \subseteq S$.
	Either \upbr{a} $H_S \cup T_S = \emptyset$ and 
	$G[S]$ is strongly connected or \upbr{b} at least one vertex of
	each top SCC of $G[S]$ is contained in $H_S$ and
	at least one vertex of 
	each bottom SCC of $G[S]$ is contained in $T_S$.
\end{invariant}

\begin{procedure}
\caption{Lock-Step-Search($G$, $S$, $H_S$, $T_S$)}
\label{proc:lockstep}
		\tcc{$\pre$ and $\post$ defined w.r.t.\ to $G$}
		\lForEach{$v \in H_S \cup T_S$}{
			$C_v \gets \set{v}$\
		}
		\While{true}{
			$H'_S \gets H_S$, $T'_S \gets T_S$\;
			\ForEach(\tcc*[h]{search for top SCC}){$h \in H_S$}{
					$\scc'_h \gets (\scc_h \cup \pre(\scc_h)) \cap S$\;
					\lIf{$\lvert \scc'_h \cap H'_S \rvert > 1$}{
						$H'_S \gets H'_S \setminus \set{h}$
					}\Else{
						\lIf{$\scc'_h = \scc_h$}{
						\Return ($\scc_h$, $H'_S$, $T_S$)
						}
						$\scc_h \gets \scc'_h$\;
					}
			}
			\ForEach(\tcc*[h]{search for bottom SCC}){$t \in T_S$}{
				$\scc'_t \gets (\scc_t \cup \post(\scc_t)) \cap S$\;
				\lIf{$\lvert \scc'_t \cap T'_S \rvert > 1$}{
					$T'_S \gets T'_S \setminus \set{t}$
				}\Else{
					\lIf{$\scc'_t = \scc_t$}{
						\Return ($\scc_t$, $H'_S$, $T'_S$)
					}
					$\scc_t \gets \scc'_t$\;
				}
			}
			$H_S \gets H'_S$, $T_S \gets T'_S$\;
		}
\end{procedure}

\vspace{-1mm}
\smallskip\noindent{\em Lock-Step Search.}
The searches from the vertices of $H_S \cup T_S$
are performed in \emph{lock-step}, that is, (a) one step is performed
in each of the searches before the next step of any search is done and (b) all 
searches stop as soon as the first of the searches finishes. 
This is implemented in Procedure~\ref{proc:lockstep} as follows.
A step in the search from a vertex $t \in T_S$ 
(and analogously for $h \in H_S$)
corresponds to the execution of the iteration of the 
for-each loop for $t \in T_S$. In an iteration of a for-each loop 
we might discover that we do not need to consider this search further 
(see the paragraph on ensuring strong connectivity below)
and update the set $T_S$ (via $T'_S$) for future iterations accordingly.
Otherwise the set $C_t$ is either strictly increasing in this step of the 
search or the search for $t$ terminates and we return the set of vertices 
in $G[S]$ that are reachable from $t$.
So the two for-each loops over the vertices of $T_S$ and $H_S$ 
that are executed in an iteration of the while-loop perform
one step of each of the searches and the while-loop stops as 
soon as a search stops, i.e., a return statement is executed and hence 
this implements properties~(a) and~(b) of lock-step search.
Note that the while-loop terminates, i.e., a return statement is executed
eventually because for all $t \in T_S$ 
(and resp.\ for all $h \in H_S$) the sets $C_t$ are 
monotonically increasing over the iterations of the while-loop, 
we have $C_t \subseteq S$, and if some set $C_t$ does not increase 
in an iteration, then it is either removed from $T_S$ and thus not 
considered further or a return statement is executed. 
Note that when a search from a vertex $t \in T_S$ stops, it has discovered a 
maximal set of vertices~$\scc$ that can be reached from $t$; and analogously
for $h \in H_S$. Figure~\ref{fig:lssex} shows a small intuitive
example of a call to the procedure.

\begin{figure}
\begin{footnotesize}
\begin{center}
\begin{tikzpicture}[circle,minimum size=0.4cm,inner sep=0mm,fill=white,->]

	\node (0-BGh1) [draw,rectangle,rounded corners=8pt,fill=red!10,
    minimum height=0.6cm, minimum width=1.38cm] {};
	\node (0-a1) [draw,left=1cm of 0-BGh1] {};
    \node (0-a2) [draw,right=0.35cm of 0-a1] {};
    \node (0-a3) [draw,right=0.35cm of 0-a2,fill=white] {};
    \node (0-a4) [draw,right=0.35cm of 0-a3,fill=white,text=black!30!red] {$h_1$};
    \node (0-a5) [draw,right=0.35cm of 0-a4] {};
	\node (0-BGt1) [draw,rectangle,rounded corners=8pt,fill=blue!04,
    minimum height=1.46cm, minimum width=0.7cm, below=0.26cm of 0-a3] {};
    \node (0-BGt2) [draw,rectangle,rounded corners=8pt,fill=blue!10,
    minimum height=0.6cm, minimum width=1.54cm,
    below right=2.08cm and 0.58cm of 0-a1] {};
    \node (0-b1) [draw,below=0.4cm of 0-a3,text=black!30!blue,fill=white] {$t_1$};
    \node (0-c1) [draw,below=0.4cm of 0-b1,fill=white] {};
    \node (0-dd) [below=0.5cm of 0-c1] {};
    \node (0-d2) [draw,left=0.05cm of 0-dd,text=black!30!blue,fill=white] {$t_2$};
    \node (0-d1) [draw,left=0.55cm of 0-d2,fill=white] {};
    \node (0-d3) [draw,right=0.05cm of 0-dd,fill=white] {};
    \node (0-d4) [draw,right=0.55cm of 0-d3,fill=white] {};
    
    \draw [] (0-a1) to[] (0-a2);
    \draw [] (0-a2) to[] (0-a3);
    \draw [] (0-a3) to[] (0-a4);
    \draw [] (0-a4) to[] (0-a5);
    \draw [] (0-a5) to[bend right] (0-a1);
    \draw [] (0-a3) to[] (0-b1);
    \draw [] (0-b1) to[] (0-c1);
    \draw [] (0-c1) to[] (0-d1);
    \draw [] (0-c1) to[] (0-d2);
    \draw [] (0-c1) to[] (0-d3);
    \draw [] (0-c1) to[] (0-d4);
    \draw [] (0-d1) to[] (0-d2);
    \draw [] (0-d2) to[] (0-d3);
    \draw [] (0-d3) to[] (0-d4);
    \draw [] (0-d4) to[bend left] (0-d1);
    
	\node (1-BGh1) [draw,rectangle,rounded corners=8pt,fill=red!10,
    minimum height=0.6cm, minimum width=2.14cm,right=1.26cm of 0-a5] {};
	\node (1-a1) [draw,left=0.24cm of 1-BGh1] {};
    \node (1-a2) [draw,right=0.35cm of 1-a1,fill=white] {};
    \node (1-a3) [draw,right=0.35cm of 1-a2,fill=white] {};
    \node (1-a4) [draw,right=0.35cm of 1-a3,fill=white,text=black!30!red] {$h_1$};
    \node (1-a5) [draw,right=0.35cm of 1-a4] {};
    \draw[dashed,fill=blue!04,rounded corners=18pt]
        (1-BGh1.south)+(0,0.14) -- +(-2.06,-2.46) -- +(0,-2.9)
        -- +(2.06,-2.46) -- cycle;
    \node (1-BGt2) [draw,rectangle,rounded corners=8pt,fill=blue!10,
    minimum height=0.6cm, minimum width=2.5cm,
    right=2.54cm of 0-BGt2] {};
    \node (1-b1) [draw,below=0.4cm of 1-a3,text=black!30!blue,fill=white] {$t_1$};
    \node (1-c1) [draw,below=0.4cm of 1-b1,fill=white] {};
    \node (1-dd) [below=0.5cm of 1-c1] {};
    \node (1-d2) [draw,left=0.05cm of 1-dd,text=black!30!blue,fill=white] {$t_2$};
    \node (1-d1) [draw,left=0.55cm of 1-d2,fill=white] {};
    \node (1-d3) [draw,right=0.05cm of 1-dd,fill=white] {};
    \node (1-d4) [draw,right=0.55cm of 1-d3,fill=white] {};
    
    \draw [] (1-a1) to[] (1-a2);
    \draw [] (1-a2) to[] (1-a3);
    \draw [] (1-a3) to[] (1-a4);
    \draw [] (1-a4) to[] (1-a5);
    \draw [] (1-a5) to[bend right] (1-a1);
    \draw [] (1-a3) to[] (1-b1);
    \draw [] (1-b1) to[] (1-c1);
    \draw [] (1-c1) to[] (1-d1);
    \draw [] (1-c1) to[] (1-d2);
    \draw [] (1-c1) to[] (1-d3);
    \draw [] (1-c1) to[] (1-d4);
    \draw [] (1-d1) to[] (1-d2);
    \draw [] (1-d2) to[] (1-d3);
    \draw [] (1-d3) to[] (1-d4);
    \draw [] (1-d4) to[bend left] (1-d1);
    
	\node (2-BGh1) [draw,rectangle,rounded corners=8pt,fill=red!10,
    minimum height=0.6cm, minimum width=2.88cm,right=0.5cm of 1-a5] {};
	\node (2-a1) [draw,left=-0.5cm of 2-BGh1,fill=white] {};
    \node (2-a2) [draw,right=0.35cm of 2-a1,fill=white] {};
    \node (2-a3) [draw,right=0.35cm of 2-a2,fill=white] {};
    \node (2-a4) [draw,right=0.35cm of 2-a3,fill=white,text=black!30!red] {$h_1$};
    \node (2-a5) [draw,right=0.35cm of 2-a4] {};
    \node (2-b1) [draw,below=0.4cm of 2-a3] {};
    \node (2-c1) [draw,below=0.4cm of 2-b1] {};
    \node (2-BGt2) [draw,rectangle,rounded corners=12pt,fill=blue!10,
    minimum height=1.0cm, minimum width=3.5cm,
    below=0.24cm of 2-c1] {};
    \node (2-dd) [below=0.5cm of 2-c1] {};
    \node (2-d2) [draw,left=0.05cm of 2-dd,text=black!30!blue,fill=white] {$t_2$};
    \node (2-d1) [draw,left=0.55cm of 2-d2,fill=white] {};
    \node (2-d3) [draw,right=0.05cm of 2-dd,fill=white] {};
    \node (2-d4) [draw,right=0.55cm of 2-d3,fill=white] {};
    
    \draw [] (2-a1) to[] (2-a2);
    \draw [] (2-a2) to[] (2-a3);
    \draw [] (2-a3) to[] (2-a4);
    \draw [] (2-a4) to[] (2-a5);
    \draw [] (2-a5) to[bend right] (2-a1);
    \draw [] (2-a3) to[] (2-b1);
    \draw [] (2-b1) to[] (2-c1);
    \draw [] (2-c1) to[] (2-d1);
    \draw [] (2-c1) to[] (2-d2);
    \draw [] (2-c1) to[] (2-d3);
    \draw [] (2-c1) to[] (2-d4);
    \draw [] (2-d1) to[] (2-d2);
    \draw [] (2-d2) to[] (2-d3);
    \draw [] (2-d3) to[] (2-d4);
    \draw [] (2-d4) to[bend left] (2-d1);    
    
\end{tikzpicture}
\end{center}
\end{footnotesize}
\vspace{-6mm}
\caption{An example of symbolic lock-step search showing the first three
iterations of the main while-loop. Note that during the second iteration,
the search started from $t_1$ is disregarded since it collides with $t_2$.
In the subsequent fourth iteration, the search started from $t_2$ is
returned by the procedure.}
\label{fig:lssex}
\end{figure}

\vspace{-1mm}
\smallskip\noindent{\em Comparison to Explicit Algorithm.}
In the \emph{explicit} version of the algorithm~\cite{HenzingerT96,ChatterjeeDHL16} 
the search from vertex~$t \in T_S$ performs a depth-first search
that terminates exactly when every \emph{edge} reachable from $t$ is explored.
Since any search that starts outside of a bottom SCC but reaches the bottom SCC 
has to explore more edges than the search started inside of the bottom SCC, 
the first search from a vertex of $T_S$ that terminates has exactly explored 
(one of) the smallest (in the number of edges) bottom SCC(s) of $G[S]$. Thus on
explicit graphs the explicit lock-step search from the vertices of $H_S \cup T_S$
finds (one of) the smallest (in the number of edges) top or bottom 
SCC(s) of $G[S]$ in time proportional to the number of searches times the 
number of edges in the identified SCC. 
In \emph{symbolically} represented graphs it can happen (1) that
a search started outside of a bottom (resp.\ top) SCC terminates earlier than the 
search started within the bottom (resp.\ top) SCC and (2) that a search
started in a larger (in the number of vertices) top or bottom SCC terminates
before one in a smaller top or bottom SCC. We discuss next how we address these
two challenges.

\vspace{-1mm}
\smallskip\noindent{\em Ensuring Strong Connectivity.}
First, we would like the set returned by Procedure~\ref{proc:lockstep} 
to indeed be a top or bottom SCC of $G[S]$. For this we use the following observation
for bottom SCCs that can be applied to top SCCs analogously.
If a search starting from a vertex of $t_1 \in T_S$ encounters another
vertex $t_2 \in T_S$, $t_1 \ne t_2$, there are two possibilities: either (1)
both vertices are in the same SSC or (2) $t_1$ can reach 
$t_2$ but not vice versa. In Case~(1) the searches from both vertices can 
explore all vertices in the SCC and thus it is sufficient to only search from 
one of them. In Case~(2) the SCC of~$t_1$ has an outgoing
edge and thus cannot be a bottom SCC. Hence in both cases we can remove the vertex
$t_1$ from the set $T_S$ while still maintaining Invariant~\ref{inv:HT}.
By Invariant~\ref{inv:HT} we further have that each search from a vertex of $T_S$
that is not in a bottom SCC encounters another vertex of $T_S$ in its search and 
therefore is removed from the set $T_S$ during Procedure~\ref{proc:lockstep} (if no
top or bottom SCC is found earlier). This ensures that the returned set 
is either a top or a bottom SCC.\footnote{To improve the practical performance, we 
return the updated sets $H_S$ and $T_S$. By the above argument this preserves Invariant~\ref{inv:HT}.}

\vspace{-1mm}
\smallskip\noindent{\em Bound on Symbolic Steps.}
Second, observe that we can still bound the number of symbolic steps needed for 
the search that terminates first by the 
number of \emph{vertices} in the smallest top or bottom SCC of $G[S]$, since this 
is an upper bound on the symbolic steps needed for the search started 
in this SCC. Thus provided Invariant~\ref{inv:HT},
we can bound the number of symbolic steps in Procedure~\ref{proc:lockstep}
to identify a vertex set $\scc \subsetneq S$ such that $\scc$ and $S \setminus \scc$
are not strongly connected in $G[S]$
by $O((\lvert H_S \rvert + \lvert T_S \rvert) \cdot \min(\lvert \scc \rvert, \lvert S \setminus \scc \rvert))$.
In the algorithms that call Procedure~\ref{proc:lockstep} we charge the 
number of symbolic steps in the procedure to the vertices in the smaller 
set of $\scc$ and $S \setminus \scc$; this ensures that each 
vertex is charged at most $O(\log{n})$ times over the whole algorithm.
We obtain the following result (proof in Appendix~\ref{sec:applss}).

\vspace{-1mm}
\begin{thm}[Lock-Step Search]\label{thm:lss}
	Provided Invariant~\ref{inv:HT} holds, 
	Procedure~\ref{proc:lockstep}\upbr{$G$, $S$, $H_S$, $T_S$}
	returns a top or bottom SCC~$\scc$ of $G[S]$. It uses $O((\lvert H_S \rvert 
	+ \lvert T_S \rvert) \cdot \min(\lvert \scc \rvert, \lvert S \setminus \scc \rvert))$  symbolic steps
	if $\scc \ne S$ and $O((\lvert H_S \rvert + \lvert T_S \rvert) \cdot \lvert \scc \rvert)$ otherwise.
\end{thm}
