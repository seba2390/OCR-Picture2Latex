%%%%%%%%%%%%%%%%%%%   A
\section{Details of Section~\ref{sec:lss}: Symbolic Lock-Step Search}\label{sec:applss}

\begin{proof}[of Theorem~\ref{thm:lss}]

\smallskip\noindent{\bf Strong connectivity.}
We want to show that $C \gets $ \ref{proc:lockstep}($G$, $S$, $H_S$, $T_S$) is
a top or bottom SCC of $G[S]$ given Invariant~\ref{inv:HT} is satisfied. 
By the invariant at least one vertex of each top SCC of $G[S]$ is contained in~$H_S$
and at least one vertex of each bottom SCC of $G[S]$ is contained in~$T_S$.
Suppose $C$ is the set obtained from a search conducted by $\post$ operations 
that started from within a
bottom SCC $\tilde{C}$ of $G[S]$. Since $\tilde{C}$ is a bottom SCC
and we update the search by executing $\post$ operations (and moreover
intersect with $S$ at every update), we have $C \subseteq \tilde{C}$. Further,
since $\tilde{C}$ is an SCC, the updates
with $\post$ eventually cover all vertices of $\tilde{C}$, which gives
us $C = \tilde{C}$. A set~$C_t$ constructed with $\post$ operations whose start vertex~$t$
is not contained in a bottom SCC of $G[S]$ can not yield the set $C$ since
eventually it contains a bottom SCC of $G[S]$, and by
Invariant~\ref{inv:HT} this SCC contains a candidate in $T_S$; therefore 
$|C_t \cap T_S| > 1$ is satisfied at some point in the construction of $C_t$ and
then search is canceled by removing $t$ from $T_S$; note that a search starting 
from a bottom SCC can be canceled only if another vertex of the bottom SCC remains in $T_S$. By the
symmetric argument for searches conducted by $\pre$ operations that
started from a vertex of a top SCC we have that the returned set $C$ is either 
a top or a bottom SCC of $G[S]$.

\smallskip\noindent{\bf Bound on symbolic steps.}
Consider (one of) the smallest top or bottom SCCs $\tilde{C}$ of $G[S]$. Suppose
w.l.o.g.\ that $\tilde{C}$ is a bottom SCC. By
Invariant~\ref{inv:HT} there is a search, conducted by $\post$ operations, 
that starts from a vertex $t \in T_S$
within $\tilde{C}$ and that is not canceled, and
therefore this search terminates after at most $\lvert \tilde{C} \rvert$ many 
$\post$ operations. Other searches may terminate earlier but this gives an upper bound 
of $O((\lvert H_S \rvert + \lvert T_S \rvert) \cdot \lvert \tilde{C} \rvert)$ on 
the number of symbolic steps until the lock-step search terminates. 
Finally, consider the returned set
$C \gets $ \ref{proc:lockstep}($G$, $S$, $H_S$, $T_S$). 
There are two possible cases: either (i) $S = C$, which implies $C = \tilde{C}$ so the number of
symbolic steps can be bounded by $O((\lvert H_S \rvert + \lvert T_S \rvert) \cdot \lvert C \rvert)$, 
or (ii) $S \neq C$. In the second case, since $\tilde{C}$ is (some) smallest SCC, $C$ is an SCC,
and $S \setminus C$ contains at least one SCC, we have $\lvert \tilde{C} \rvert \le \lvert C \rvert$
and $\lvert \tilde{C} \rvert \le \lvert S \setminus C \rvert$, and hence we can bound the number
of symbolic steps in this case by $O((\lvert H_S \rvert + \lvert T_S \rvert) \cdot 
\min(\lvert \scc \rvert, \lvert S \setminus \scc \rvert))$.
\qed
\end{proof}


%%%%%%%%%%%%%%%%%%%   B
\section{Details of Section~\ref{sec:graphs}: Graphs with Streett Objectives}\label{sec:appgraphs}

\subsection{Basic Symbolic Algorithm for Graphs with Streett Objectives}

\begin{algorithm2e}
	\SetAlgoRefName{StreettGraphBasic}
	\caption{Basic Algorithm for Graphs with Streett Obj.}
	\label{alg:streettgraphbasic}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\BlankLine
	\Input{graph $G = (V, E)$ and Streett pairs 
	$\SP= \{(L_i, U_i) \mid 1 \le i \le k\}$
	}
	\Output
	{
	$\win{G, \Streett{\SP}}$
	}
	\BlankLine
	$\mathcal{\ec} \gets \sccalg(G)$; $\goodC \gets \emptyset$\;
	\While{$\mathcal{\ec} \ne \emptyset$}{
		remove some~$S \in \mathcal{\ec}$ from $\mathcal{\ec}$\;
		$\badv \gets \bigcup_{1 \le i \le k : U_i \cap S = \emptyset} (L_i \cap S)$\;
		\If{$\badv \ne \emptyset$}{
			$S \gets S \setminus \badv$\;
			$\mathcal{\ec} \gets \mathcal{\ec} \cup \sccalg(G[S])$\;
		}\Else{
			\If(\tcc*[h]{$G[S]$ contains at least one edge}\label{l:gbasic:edge})
			{$\post(S) \cap S \ne \emptyset$}{
				$\goodC \gets \goodC \cup \set{S}$\;
			}
		}
	}
	\Return{$\reachG{G}{\bigcup_{\scc \in \goodC} \scc}$}\;
\end{algorithm2e}

The pseudocode of the basic symbolic algorithm for graphs with Streett
objectives is given in Algorithm~\ref{alg:streettgraphbasic}.

The basic symbolic algorithm for Streett objectives on graphs finds good components as follows.
The algorithm maintains two sets of vertex sets: $\goodC$ contains identified 
good components and is initially empty; $\mathcal{\ec}$ contains candidates for 
good components and is initialized with the SCCs of the input graph~$G$. The sets 
in $\mathcal{\ec}$ are strongly connected subgraphs of~$G$ throughout the 
algorithm. In each iteration of the while-loop one of the candidate sets~$S$
maintained in $\mathcal{\ec}$ is considered. If the set~$S$ does not contain
bad vertices and contains at least one edge, then it is a good component and 
added to $\goodC$. Otherwise, the set of bad vertices~$\badv$ in~$S$ is removed from $S$; the
subgraph induced by $S' = S \setminus \badv$ might not be strongly connected
but every good component contained in $S'$ must still be strongly connected,
therefore the maximal strongly connected subgraphs of $G[S']$ are added 
to $\mathcal{\ec}$ as new candidates for good components. By Lemma~\ref{lem:eccontained} 
and Corollary~\ref{cor:geccontained} this procedure maintains the property that 
every good component of~$G$ is completely contained in one of the vertex sets of
$\goodC$ or $\mathcal{\ec}$. Further in each iteration either (a) 
vertices are removed or separated into different vertex sets or (b) a new good 
component is identified. Thus after at most $O(n)$ iterations the set $\mathcal{\ec}$
is empty and all good components of~$G$ are contained in $\goodC$.
Furthermore, whenever bad vertices are removed from a given candidate set,
the number of target pairs this candidate set intersects is reduced by one.
Thus each vertex is considered in at most $O(k)$ iterations of the main while-loop.
Finally, the set of vertices that can reach a good component is determined (by $O(n)$ 
$\pre$ operations) and output as the winning set.
Since computing SCCs can be done in $O(n)$ symbolic steps, the total number of
symbolic steps of the basic algorithm is bounded by $O(n \cdot \min(n, k))$.


\subsection{Improved Symbolic Algorithm for Graphs with Streett Objectives}

\begin{lemma}[Invariants of Improved Algorithm for Graphs]\label{lem:improvedgraphsinv}
Invariant~\ref{inv:HT} and Invariant~\ref{inv:gccontained} are preserved throughout
Algorithm~\ref{alg:streettgraphimpr}, i.e., they hold before the first iteration, after each
iteration, and after termination of the main while-loop. Further, Invariant~\ref{inv:HT}
is preserved during each iteration of the main while-loop.
\end{lemma}

\begin{proof}
\item
\smallskip\noindent{\bf Invariant~\ref{inv:HT}.}
Whenever a new candidate $S$ is added as a result from $\sccalg$, it is strongly
connected, and we set $H_S = T_S = \emptyset$; this in particular implies that 
the invariant is satisfied after the initialization of the algorithm. 

By induction and Theorem~\ref{thm:lss}, the invariant is satisfied whenever
Procedure~\ref{proc:lockstep} returns a candidate $C$ and we set
$H_C = T_C = \emptyset$.

Now consider an update of a candidate $S$ where some subset
$B$ is deleted from it and assume the invariant holds before the update. In these
cases we update $H_S$ and $T_S$ by setting $H_S \gets (H_S \cup \post(B)) \cap S$ 
and $T_S \gets (T_S \cup \pre(B)) \cap S$. This adds the vertices that remain 
in~$S$ and have an edge from a vertex of $B$ to $H_S$ and those with an edge 
to $B$ to $T_S$. Suppose a new
top (resp. bottom) SCC $\tilde{S} \subseteq S$ emerges in $S$ by the removal 
of $B$ from $S$. Then some vertex of $\tilde{S}$ had an outgoing edge to $B$ (resp.\ an incoming edge from $B$)
and thus is contained in the updated set $T_S$ (resp.\ $H_S$),
maintaining the invariant. 
This happens whenever we remove $\bad(S)$ from $S$, and whenever
we subtract a result from Procedure~$\ref{proc:lockstep}$ $C$ from $S$.

\smallskip\noindent{\bf Invariant~\ref{inv:gccontained} -- Disjointness.}
The sets in $\mathcal{\ec} \cup \goodC$ are pairwise disjoint at the
initialization since $\goodC$ is initialized as $\emptyset$. Furthermore,
whenever a set $S$ is added to $\goodC$ in an iteration of the main
while-loop, a superset $\tilde{S} \supseteq S$ is removed from
$\mathcal{\ec}$ in the same iteration of the while-loop. Therefore
by induction the disjointness of the sets in $\mathcal{\ec} \cup \goodC$
is preserved.

\smallskip\noindent{\bf Invariant~\ref{inv:gccontained} -- Containment of good components.}
At initialization, $\mathcal{\ec}$ contains all SCCs of the input graph $G$.
Each good component $C$ of $G$ is strongly connected, so there exists an SCC
$Y \supseteq C$ such that $Y \in \mathcal{\ec}$ for each good component $C$.

Consider a set $S \in \mathcal{\ec}$ that is removed from $\mathcal{\ec}$
at the beginning of an iteration of the main while-loop. Consider further
a good component $C$ of $G$ such that $C \subseteq S$. We require that a set
$Y \supseteq C$ is added to either
$\mathcal{\ec}$ or $\goodC$ in this iteration of the main while-loop.

First, whenever we remove $\bad(S)$ from $S$, by Corollary~\ref{cor:geccontained}
we maintain the fact that $C \subseteq S$. Second, $G[S]$ contains an edge since $C \subseteq S$.
Finally, one of the three cases happens:

\smallskip\noindent Case~(1): If $\lvert H_S \rvert + \lvert T_S \rvert = 0$, then the set
$S \supseteq C$ is added to $\goodC$.

\smallskip\noindent Case~(2): If $\lvert H_S \rvert + \lvert T_S \rvert \ge \sqrt{m / \log n}$,
then the algorithm computes the SCCs of $G[S]$. Since $C \subseteq S$ is strongly connected,
it is completely contained in some SCC $Y$ of $G[S]$, and $Y$ is added either to
$\mathcal{\ec}$ or to $\goodC$.

\smallskip\noindent Case~(3): If $0 < \lvert H_S \rvert + \lvert T_S \rvert < \sqrt{m / \log n}$,
then the algorithm either adds $S \supseteq C$ to $\goodC$, or partitions $S$
into $\tilde{S}$ and $S \setminus \tilde{S}$. Suppose the latter case happens, then by
Theorem~\ref{thm:lss} we have that $\tilde{S}$ is an SCC of $G[S]$. Further, since $C \subseteq S$
is strongly connected, it is completely contained in some SCC of $G[S]$.
Therefore either $C \subseteq \tilde{S}$ or $C \subseteq (S \setminus \tilde{S})$, and
both $\tilde{S}$ and $S \setminus \tilde{S}$ are added to $\mathcal{\ec}$.

\smallskip\noindent By the above case analysis we have that a set $Y \supseteq C$ is added
to either $\mathcal{\ec}$ or $\goodC$ in the iteration of the main while-loop, and thus
the invariant is preserved throughout the algorithm.
\qed

\end{proof}

\begin{proof}[of Theorem~\ref{thm:improvedgraphs}]

%We present the correctness argument and the analysis of symbolic steps bound below.
%\begin{itemize} \item
\smallskip\noindent{\bf Correctness.}
	Whenever a candidate set $S$ is added to $\goodC$, it contains an edge
    by the check at line~\ref{l:p1}, and $\bad(S) = \emptyset$ by the check at
    line~\ref{l:gimpr:innerw}. Furthermore, \upbr{a} at line~\ref{l:gimpr:good1}, $S$
    is strongly connected by Invariant~\ref{inv:HT}, \upbr{b} at line~\ref{l:gimpr:good2},
    $S$ is strongly connected by the result of~\sccalg, and \upbr{c} at
    line~\ref{l:gimpr:good3}, $S$ is strongly connected by Theorem~\ref{thm:lss}.
    Therefore we have that whenever a candidate set is added to $\goodC$,
    it is indeed a good component (soundness).

    Finally, by soundness, Invariant~\ref{inv:gccontained}, the termination of 
    the algorithm (shown below), and the fact that $\mathcal{\ec} = \emptyset$ at the
    termination of the algorithm, we have that $\goodC$ contains all good
    components of $G$ (completeness).

%\item
\smallskip\noindent{\bf Symbolic steps analysis.}
	By~\cite{GentiliniPP08}, the initialization with the SCCs of
	the input graph takes $O(n)$ symbolic steps.
	Furthermore, the reachability computation in the last step
	takes $O(n)$ $\pre$ operations.
	
	In each iteration of the outer while-loop, a set~$S$ is removed 
	from $\mathcal{\ec}$ and either \upbr{a} a set $S' \subseteq S$ is added
    to $\goodC$ and no set is added to $\mathcal{\ec}$ or \upbr{b} at least two
    sets that are (proper subsets of) a partition of $S$ are added to $\mathcal{\ec}$.
    Both can happen at most $O(n)$ times,
	thus there can be at most $O(n)$ iterations of the outer while-loop.
	The $\pre$ and $\post$ operations at lines~\ref{l:p1},~\ref{l:p2}, 
    and~\ref{l:p3} can be charged to the iterations of the outer while-loop.
    
	An iteration of the inner while-loop (lines~\ref{l:gimpr:innerw}-\ref{l:gimpr:badend})
	is executed only if some vertices~$\badv$
	are removed from $S$; the vertices of $\badv$
	are then not considered further. Thus there can, in total, be at most $O(n)$
	$\pre$ and $\post$ operations over all iterations of the inner while-loop.
	
    Note that every vertex in each
    of $H_S$ and $T_S$ can be attributed to at least one unique implicit edge deletion 
    since we only add vertices to $H_S$ resp.\ $T_S$ that are successors resp.\ 
    predecessors of vertices that were separated from $S$ 
    (or deleted from the maintained graph).
    Whenever the case $\lvert H_S \rvert + \lvert T_S \rvert \ge \sqrt{m / \log{n}}$
    occurs, for all subsets $C \subseteq S$ that are then added to
    $\mathcal{\ec}$, we initialize $H_C = T_C = \emptyset$. Therefore the
    case $\lvert H_S \rvert + \lvert T_S \rvert \ge \sqrt{m / \log{n}}$ can
    happen at most $O(\sqrt{m \log{n}})$ times throughout the algorithm since
    there are at most $m$ edges that can be deleted, and hence in total
    takes $O(n \cdot \sqrt{m \log{n}})$ symbolic steps.
	
	It remains to bound the number of symbolic steps in
	Procedure~\ref{proc:lockstep}. Let $\scc$ be the set returned by the procedure;
	we charge the symbolic steps in this call of the procedure to the vertices of 
	the smaller set of $\scc$ and $S \setminus \scc$.
	By Theorem~\ref{thm:lss} we have either \upbr{a}
	$\scc = S$, the number of symbolic steps in this call is 
	bounded by $O(\sqrt{m/\log{n}} \cdot \lvert \scc \rvert)$, and the set $S$ is added to $\goodC$ or
	\upbr{b} $\min(\lvert \scc \rvert, \lvert S \setminus 
	\scc \rvert) \le \lvert S \rvert / 2$ and the
	number of symbolic steps in this call is 
	bounded by $O(\sqrt{m/\log{n}} \cdot \min(\lvert \scc \rvert, \lvert S \setminus 
	\scc \rvert))$.
	Case~\upbr{a} can happen at most once for the vertices of $\scc$,
	and for case~\upbr{b} note that the size of a set containing a specific vertex 
	can be halved at most $O(\log{n})$ times; thus we charge each vertex at 
	most $O(\log{n})$ times. Hence we can bound the total number of symbolic
	steps in all calls to the procedure by $O(n \cdot \sqrt{m \log{n}})$.
    \qed
%\end{itemize}

\end{proof}


%%%%%%%%%%%%%%%%%%%   C
\section{Details of Section~\ref{sec:mecs}: Symbolic MEC Decomposition}\label{sec:appmecs}

\subsection{Basic Symbolic Algorithm for MEC decomposition}
Recall that an end-component is a set of vertices that (a) has no 
random edges to vertices not in the set and its induced sub-MDP
is (b) strongly connected and (c) contains at least one edge.

Algorithm~\ref{alg:mecbasic} computes all maximal end-components of
a given MDP and is formulated as to highlight the similarities to the algorithms
for graphs and MDPs with Streett objectives.
The algorithm maintains two sets, the set $\goodC$ of identified maximal 
end-components that is initially empty and the set $\mathcal{\ec}$ of candidates 
for maximal end-components that is initialized with the SCCs of 
the MDP. In each iteration of the while-loop one set $S$ is removed from 
$\mathcal{\ec}$ and either (1a) identified as a maximal end-component and added 
to $\goodC$ or (1b) removed because the induced sub-MDP does not contain an edge
or (2) it contains vertices with outgoing random edges. In the latter case 
these vertices $\rout$ are identified and their random attractor is removed from 
$S$. After this step the sub-MDP induced by the remaining vertices 
of $S$ might not be strongly connected any more. Therefore the SCCs of this 
sub-MDP are determined and added to $\mathcal{\ec}$ as new candidates 
for maximal end-components. Note that this maintains the invariants that 
(i) each set in $\mathcal{\ec}$ induces a strongly connected subgraph and 
(ii) each end-component is a subset of one set in either 
$\goodC$ or $\mathcal{\ec}$. By (i) a set in $\mathcal{\ec}$ is an end-component
if it does not have outgoing random edges and the induced sub-MDP contains an edge, 
i.e., in particular this holds for the sets added to $\goodC$ (soundness). By (ii) and 
$\mathcal{\ec} = \emptyset$ at termination of the while-loop
the algorithm identifies all maximal end-components of the MDP (completeness).
Since both (1) and (2) can happen at most $O(n)$ times, there are $O(n)$
iterations of the while-loop. 
In each iteration the most expensive operations are the computation
of a random attractor and of SCCs, which can both be done in $O(n)$ symbolic steps.
Thus Algorithm~\ref{alg:mecbasic} correctly computes all maximal end-components
of an MDP and takes $O(n^2)$ symbolic steps.

\begin{algorithm2e}[t]
	\SetAlgoRefName{MECBasic}
	\caption{Basic Algorithm for Maximal End-Components}
	\label{alg:mecbasic}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\BlankLine
	\Input{an MDP~$\mdp = (G = (V, E), (\vp, \vr))$
	}
	\Output
	{
	 the set of maximal end-components of $\mdp$
	}
	\BlankLine
	$\goodC \gets \emptyset$\;
	$\mathcal{\ec} \gets \sccalg(G)$\;
	\While{$\mathcal{\ec} \ne \emptyset$}{
		remove some $S \in \mathcal{\ec}$ from $\mathcal{\ec}$\;
		$\rout \gets S \cap \vr \cap \pre(V\setminus S) $\;
		\If{$\rout \ne \emptyset$}{
			$S \gets S \setminus \at{R}{G}{\rout}$\;
			$\mathcal{\ec} \gets \mathcal{\ec} \cup \sccalg(G[S])$\;
		}\Else{
			\If(\tcc*[h]{$G[S]$ contains at least one edge})
			{$\post(S) \cap S \ne \emptyset$}{
				$\goodC \gets \goodC \cup \set{S}$\;
			}
		}
	}
	\Return{$\goodC$}\;
\end{algorithm2e}

\subsection{Improved Symbolic Algorithm for MEC decomposition}

\smallskip\noindent{\em Informal description.}
We show how to determine all maximal end-components (MECs) of an MDP 
in $O(n \sqrt{m})$ symbolic operations. The difference to the basic algorithm  lies in the way strongly connected parts
of the MDP are identified after the deletion of vertices that cannot be contained
in a MEC. For this the symbolic lock-step search from Section~\ref{sec:lss} is used whenever
not too many edges have been deleted since the last re-computation of SCCs.

Let $\mdp$ be the given MDP and $G = (V, E)$ its underlying graph.
The algorithm maintains two sets of vertex sets: the set $\goodC$ of already
identified MECs that is initialized with the empty set and the set $\mathcal{\ec}$
that is initialized with the SCCs of $G$ and contains vertex sets that are
candidates for MECs. The algorithm preserves the 
following invariant for the $\goodC$ and $\mathcal{\ec}$ over the iterations 
of the while-loop and returns the set $\goodC$
when the set $\mathcal{\ec}$ is empty after an iteration of the while-loop.

\begin{invariant}[Maintained Sets]\label{inv:meccontained}
The sets in $\mathcal{\ec} \cup \goodC$ are pairwise disjoint and
for every maximal end-component~$\ec$ of $G$ there exists a set $Y \supseteq \ec$
such that either $Y \in \mathcal{\ec}$ or $Y \in \goodC$.
\end{invariant}

\begin{algorithm2e}
	\SetAlgoRefName{MECImpr}
	\caption{Improved Algorithm for Maximal End-Components}
	\label{alg:mecimpr}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\BlankLine
	\Input{an MDP~$\mdp = (G = (V, E), (\vp, \vr))$
	}
	\Output
	{
	 the set of maximal end-components of $\mdp$
	}
	\BlankLine
	$\mathcal{\ec} \gets \sccalg(G)$; $\goodC \gets \emptyset$\;
	\ForEach{$\scc \in \mathcal{\ec}$}{
		$T_\scc \gets \emptyset$\;
	}
	\While{$\mathcal{\ec} \ne \emptyset$}{
		remove some $S \in \mathcal{\ec}$ from $\mathcal{\ec}$\;
		$\rout \gets S \cap \vr \cap \pre(V\setminus S)$\label{l:mec:remb}\;
		$A \gets \at{R}{G}{\rout}$\label{l:mecimpr:remattr}\;
		$S \gets S \setminus A$\label{l:mecimpr:rem1}\;
		$T_S \gets (T_S \cup \pre(A)) \cap S$\label{l:mec:reme}\;
		\If(\tcc*[h]{$G[S]$ contains at least one edge}){$\post(S) \cap S \ne \emptyset$\label{l:mec:p1}}{ 
			\If{$\lvert T_S \rvert = 0$}{
				$\goodC \gets \goodC \cup \set{S}$\label{l:mec:good1}\;
			}\ElseIf{$\lvert T_S \rvert \ge \sqrt{m}$}{
				delete $T_S$\;
				$\mathcal{\scc} \gets \sccalg(G[S])$\;
				\If{$\lvert \mathcal{\scc} \rvert = 1$}{
					$\goodC \gets \goodC \cup \set{S}$\label{l:mec:good2}
				}\Else{
					\ForEach{$\scc \in \mathcal{\scc}$}{
								$T_\scc \gets \emptyset$\;}
					$\mathcal{\ec} \gets \mathcal{\ec} \cup \mathcal{\scc}$\;
				}
			}\Else{
				$\scc \gets $\ref{proc:lockstep}($G$, $S$, $\emptyset$, $T_S$)\;
				\If(\tcc*[h]{$G[\scc]$ contains at least one edge}){$\post(\scc) \cap \scc \ne \emptyset$\label{l:mec:p2}}{
					$\goodC \gets \goodC \cup \set{\scc}$\label{l:mec:good3}\;
				}
				$S \gets S \setminus \scc$\label{l:mecimpr:rem2}\;
				$T_S \gets (T_S \cup \pre(\scc)) \cap S$\label{l:mec:p3}\;
				$\mathcal{\ec} \gets \mathcal{\ec} \cup \set{S}$\;
			}
		}
	}
	\Return{$\goodC$}\;
\end{algorithm2e}

For each vertex set~$S$ in $\mathcal{\ec}$
additionally a subset $T_S$ of $S$ is maintained that contains vertices that
have lost outgoing edges since the last time a superset of $S$ was identified as 
strongly connected.
We use the following restrictions of Invariant~\ref{inv:HT} and Theorem~\ref{thm:lss}
(presented in Section~\ref{sec:lss}) to bottom SCCs only.

\begin{invariant}[Start Vertices BSCC]\label{inv:T}
	Either \upbr{a} $T_S$ is empty and 
	$G[S]$ is strongly connected or \upbr{b} at least one vertex of
	each bottom SCC of $G[S]$ is contained in $T_S$.
\end{invariant}

{
\begin{thm}[Lock-Step Search BSCC]\label{thm:lockstepbscc}
	Provided Invariant~\ref{inv:T} holds, 
	Procedure~\ref{proc:lockstep}\upbr{$G$, $S$, $\emptyset$, $T_S$}
	returns a bottom SCC~$\scc \subseteq S$ of
	$G[S]$ in $O(\lvert T_S \rvert \cdot \lvert \scc \rvert)$ symbolic steps.
\end{thm}

\begin{proof}
The proof of Theorem~\ref{thm:lockstepbscc} is a straightforward
simplification of the proof of Theorem~\ref{thm:lss} located in Appendix~\ref{sec:applss}.
\qed
\end{proof}
}

Initially the sets $T_S$ are empty.
The algorithm maintains Invariant~\ref{inv:T} for 
all $S \in \mathcal{\ec}$. 
This will ensure the correctness and the number of symbolic steps
of Procedure~\ref{proc:lockstep} (Section~\ref{sec:lss}) as called by the algorithm.

In each iteration of the while-loop one vertex set~$S$ is removed from $\mathcal{\ec}$ 
and processed. First the random vertices of $S$
with edges to vertices of $V \setminus S$ are identified and their random attractor
is removed from $S$.
After this step, there are no random vertices with edges 
from $S$ to $V \setminus S$. The predecessors of the removed vertices that are contained
in $S$ are added to $T_S$ and additionally $T_S$ is updated to only include 
vertices that are still in $S$. This preserves Invariant~\ref{inv:T} (see also 
\cite[Lemma 4.5.2]{Loitzenbauer16}).  The number of symbolic steps for the 
attractor computation can be charged to the removed vertices and is therefore bounded 
by $O(n)$ in total.

If afterwards $G[S]$ does not contain an edge anymore, 
then $S$ is not considered further and the algorithm continues with
the next iteration. Otherwise one of three cases happens.

\smallskip\noindent Case~(1): If $T_S$ is empty,
then by Invariant~\ref{inv:T} $G[S]$ is strongly connected, contains at least one 
edge and does not contain a random vertex with edges to $V \setminus S$, i.e.,
$S$ is an end-component, and by Invariant~\ref{inv:meccontained} it is a MEC.
In this case the algorithm adds the set $S$ to $\goodC$, which preserves 
both invariants and can happen at most $O(n)$ times.

\smallskip\noindent Case~(2): If there 
are at least $\sqrt{m}$ vertices in $T_S$, then the set $T_S$ is deleted and
as in the basic algorithm all SCCs of $G[S]$ are computed and add to $\mathcal{\ec}$
as new candidates for MECs. For each of the SCCs~$\scc$ a set $T_\scc$ is 
initialized with the empty set. As a vertex is added to a set $T_S$ only if one 
of its incoming edges is removed by the algorithm, Case~(2) can happen only $O(\sqrt{m})$
times over the whole algorithm. Thus the total number of symbolic steps 
for this case is $O(n \sqrt{m})$. Note that the Invariants~\ref{inv:T} 
and~\ref{inv:meccontained} are preserved.

\smallskip\noindent Case~(3): If $T_S$ contains less than $\sqrt{m}$ vertices, then 
Procedure~\ref{proc:lockstep}($G$, $S$, $\emptyset$, $T_S$) is called. 
By Invariant~\ref{inv:T} and Theorem~\ref{thm:lockstepbscc} the procedure
returns a bottom SCC~$\scc$ of $G[S]$ in $O(\lvert T_S \rvert \cdot \lvert \scc \rvert)$
many symbolic steps. Since there are no random edges between $S$ and $V\setminus S$
in $\mdp$ and $\scc$ has no outgoing edges in $G[S]$, we have that $\scc$ is 
an end-component if it contains at least one edge. By Invariant~\ref{inv:meccontained}
it is also a MEC and is correctly added to $\goodC$. 
As the sets in $\goodC$ are not considered further by the algorithm, we can 
charge the symbolic steps of Procedure~\ref{proc:lockstep} to the vertices
of $\scc$. Thus this part takes at most $O(n \sqrt{m})$ symbolic steps over the 
whole algorithm. The vertices of 
$S \setminus \scc$ are added back to $\mathcal{\ec}$, which preserves 
Invariant~\ref{inv:meccontained}. The predecessors of $\scc$ in
$S \setminus \scc$  are added to $T_{S \setminus \scc}$ and vertices of $\scc$ 
are removed from $T_{S \setminus \scc}$, which preserves Invariant~\ref{inv:T}.

By the above case analysis we have that each vertex set that is added to 
$\goodC$ is indeed a MEC (soundness). By Invariant~\ref{inv:meccontained}
and $\mathcal{\ec} = \emptyset$ at termination of the algorithm we
further have completeness.
In each iteration either $S$ does not contain an edge and is not considered further,
a set is added to $\goodC$ (and not contained in $\mathcal{\ec}$ after that) or 
case~(2) happens. Thus there are at most $O(n + \sqrt{m})$ iterations
of the algorithm. The symbolic operations we have not yet accounted for in 
the analysis of the number of symbolic steps are of $O(1)$ per iteration. Hence
Algorithm~\ref{alg:mecimpr} takes $O(n \sqrt{m})$ symbolic steps and correctly
computes the MECs of the given MDP~$\mdp$.

\begin{lemma}[Invariants of Improved Algorithm for MEC]\label{lem:improvedmecinv}
Invariant~\ref{inv:T} and Invariant~\ref{inv:meccontained} are preserved throughout
Algorithm~\ref{alg:mecimpr}, i.e., they hold before the
first iteration, after each iteration, and after termination of the main while-loop. Further,
Invariant~\ref{inv:T} is preserved during each iteration of the main while-loop.
\end{lemma}

\begin{proof}
\item 
\smallskip\noindent{\bf Invariant~\ref{inv:T}.}
The proof of maintaining Invariant~\ref{inv:T} in Algorithm~\ref{alg:mecimpr} is a
straightforward simplification of the proof of maintaining Invariant~\ref{inv:HT} in
Algorithm~\ref{alg:streettgraphimpr} (located in Appendix~\ref{sec:appgraphs}).

\smallskip\noindent{\bf Invariant~\ref{inv:meccontained} -- Disjointness.}
The sets in $\mathcal{\ec} \cup \goodC$ are pairwise disjoint at the
initialization since $\goodC$ is initialized as $\emptyset$. Furthermore,
whenever a set $S$ is added to $\goodC$ in an iteration of the main
while-loop, a superset $\tilde{S} \supseteq S$ is removed from
$\mathcal{\ec}$ in the same iteration of the while-loop. Therefore
by induction the disjointness of the sets in $\mathcal{\ec} \cup \goodC$
is preserved.

\smallskip\noindent{\bf Invariant~\ref{inv:meccontained} -- Containment of maximal end-components.}
At initialization, $\mathcal{\ec}$ contains all SCCs of $G$.
Each maximal end-component $X$ of $\mdp = (G = (V, E), \allowbreak(\vp, \vr), \allowbreak\trans)$
is strongly connected, so there exists an SCC $Y \supseteq X$ of $G$
such that $Y \in \mathcal{\ec}$.

Consider a set $S \in \mathcal{\ec}$ that is removed from $\mathcal{\ec}$
at the beginning of an iteration of the main while-loop. Consider further
a maximal end-component $X$ of $\mdp$ such that $X \subseteq S$. We require
that a set $Y \supseteq X$ is added to either
$\mathcal{\ec}$ or $\goodC$ in this iteration of the main while-loop.

First, after we remove $\at{R}{G}{S \cap \vr \cap \pre(V\setminus S)}$ from $S$, we maintain the fact
that $X \subseteq S$ by Lemma~\ref{lem:eccontained}. Second, $G[S]$ contains an edge
since $X \subseteq S$. Finally, one of the three cases happens:

\smallskip\noindent Case~(1): If $\lvert T_S \rvert = 0$, then the set
$S \supseteq X$ is added to $\goodC$.

\smallskip\noindent Case~(2): If $\lvert T_S \rvert \ge \sqrt{m}$,
then the algorithm computes the SCCs of $G[S]$. Since $X \subseteq S$ is strongly connected,
it is completely contained in some SCC $Y$ of $G[S]$, and $Y$ is added to~$\mathcal{\ec}$.

\smallskip\noindent Case~(3): If $0 < \lvert T_S \rvert < \sqrt{m}$,
then the algorithm partitions $S$ into $C$ and $S \setminus C$. By Theorem~\ref{thm:lockstepbscc} we
have that $C$ is a (bottom) SCC of $G[S]$. Since $X \subseteq S$ is strongly connected, it is completely
contained in some SCC of $G[S]$. Therefore either $X \subseteq C$ or $X \subseteq (S \setminus C)$.
The set $S \setminus C$ is added to $\mathcal{\ec}$. If $X \subseteq C$, then in particular
$G[C]$ contains an edge, and $C$ is added to $\goodC$.

\smallskip\noindent By the above case analysis we have that a set $Y \supseteq X$ is added
to either $\mathcal{\ec}$ or $\goodC$ in the iteration of the main while-loop.
\qed
\end{proof}

\begin{proof}[of Theorem~\ref{thm:improvedmecs}]

\smallskip\noindent{\bf Correctness.}
A candidate set can be added to $\goodC$ in three cases. When $S$ is added to $\goodC$
at line~\ref{l:mec:good1} (resp. at line~\ref{l:mec:good2}), then it contains an edge by the check at line~\ref{l:mec:p1},
it is strongly connected by $\lvert T_S \rvert = 0$ and Invariant~\ref{inv:T} (resp. by the result of $\sccalg$), and it has no
random vertices with edges to $V \setminus S$ by the random attractor removal at lines~\ref{l:mec:remb}-\ref{l:mec:reme}.
When $C$ is added at line~\ref{l:mec:good3}, then it contains an edge by the check at line~\ref{l:mec:p2},
it is strongly connected by Theorem~\ref{thm:lockstepbscc}, it contains no random vertices with edges to
$V \setminus S$ by the random attractor removal at lines~\ref{l:mec:remb}-\ref{l:mec:reme}, and it
contains no random vertices with edges to $S \setminus C$ by the fact that $C$ is a bottom SCC of $G[S]$
(see Theorem~\ref{thm:lockstepbscc}). Therefore we have that whenever a candidate set is added to $\goodC$,
it is an end-component, and by induction and Invariant~\ref{inv:meccontained} we have that
it is a maximal end-component (soundness).

Finally, by soundness, Invariant~\ref{inv:meccontained}, the termination of the algorithm
(shown below), and the fact that $\mathcal{\ec} = \emptyset$ at the
termination of the algorithm, we have that $\goodC$ contains all the maximal
end-components of $\mdp$ (completeness).

\smallskip\noindent{\bf Symbolic steps analysis.}
By~\cite{GentiliniPP08}, the initialization with the SCCs of
a given MDP takes $O(n)$ symbolic steps.

In each iteration of the outer while-loop, a set~$S$ is removed 
from $\mathcal{\ec}$ and \upbr{a} $S$ is added to $\goodC$, or
\upbr{b} at least two sets that are (subsets of) a partition of $S$ are added
to $\mathcal{\ec}$, or \upbr{c} $S$ is partitioned into two sets, one
of them may be added to $\goodC$ and the other is added to $\mathcal{\ec}$.
All three cases can happen at most $O(n)$ times, so there can be at most
$O(n)$ iterations of the outer while-loop. The $\pre$ and $\post$ operations
at lines~\ref{l:mec:remb},~\ref{l:mec:reme},~\ref{l:mec:p1},~\ref{l:mec:p2},
and~\ref{l:mec:p3} can be charged to the iterations of the outer while-loop.

Each $\cpre{R}$ operation executed as a part of the random attractor computation
at line~\ref{l:mecimpr:remattr} adds at least one vertex to $A$, and the vertices
of $A$ are then not considered any further in the algorithm. Therefore there
can, in total, be at most $O(n)$ $\cpre{R}$ operations over all attractor computations
at line~\ref{l:mecimpr:remattr}.

Note that every vertex in each of $T_S$ can be attributed to at least one unique implicit edge deletion 
since we only add vertices to $T_S$ that are predecessors of the vertices that were separated from $S$ 
(or deleted from the maintained graph). Whenever the case $\lvert T_S \rvert \ge \sqrt{m}$
occurs, for all subsets $C \subseteq S$ that are then added to $\mathcal{\ec}$, we initialize $T_C = \emptyset$.
Therefore, the case $\lvert T_S \rvert \ge \sqrt{m}$ can happen at most $O(\sqrt{m})$ times throughout
the algorithm since there are at most $m$ edges that can be deleted. By~\cite{GentiliniPP08} we have a bound
$O(n)$ for one iteration, so we can bound the total number of symbolic steps in all iterations of this
case by $O(n \cdot \sqrt{m})$.

It remains to bound the number of symbolic steps in Procedure~\ref{proc:lockstep}. Let $\scc$ be the set
returned by $\ref{proc:lockstep}$($G$, $S$, $\emptyset$, $T_S$). By Theorem~\ref{thm:lockstepbscc} and the fact that
$\lvert T_S \rvert < \sqrt{m}$, the number of symbolic steps in this call is bounded by $O(\sqrt{m} \cdot \lvert \scc \rvert)$,
and the set $\scc$ is not considered further in the algorithm after this call. Hence we can bound the total number of
symbolic steps in all calls of the procedure by $O(n \cdot \sqrt{m})$.
\qed
\end{proof}


%%%%%%%%%%%%%%%%%%%   D
\section{Details of Section~\ref{sec:mdps}: MDPs with Streett Objectives}\label{sec:appmdps}

\subsection{Basic Symbolic Algorithm for MDPs with Streett Objectives}

\begin{algorithm2e}
	\SetAlgoRefName{StreettMDPbasic}
	\caption{Basic Algorithm for MDPs with Streett Obj.}
	\label{alg:streettmdpbasic}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\BlankLine
	\Input{MDP $\mdp = ((V, E), (\vp, \vr), \trans)$ and pairs $\SP= \{(L_i, U_i) \mid 1 \le i \le k\}$
	}
	\Output
	{
	$\as{\mdp, \Streett{\SP}}$
	}
	\BlankLine
	$\mathcal{\ec} \gets \mecalg(\mdp)$; $\good \gets \emptyset$\;
	\While{$\mathcal{\ec} \ne \emptyset$}{
		remove some $S \in \mathcal{\ec}$ from $\mathcal{\ec}$\;
		$\badv \gets \bigcup_{1 \le i \le k : U_i \cap S = \emptyset} (L_i \cap S)$\;
		\If{$\badv \ne \emptyset$}{
			$S \gets S \setminus \at{R}{\mdp[S]}{\badv}$\;
			$\mathcal{\ec} \gets \mathcal{\ec} \cup \mecalg(\mdp[S])$\;
		}\lElse{
			$\good \gets \good \cup \set{S}$
		}
	}
	\Return{$\as{\mdp, \Reach{\bigcup_{\ec \in \good} \ec}}$}\;
\end{algorithm2e}

The pseudocode of the basic symbolic algorithm for MDPs with Streett objectives
is given in Algorithm~\ref{alg:streettmdpbasic}. The key differences
compared to Algorithm~\ref{alg:streettgraphbasic} are as follows: 
(a)~SCC computation is replaced by MEC computation;
(b)~along with the removal of bad vertices, their random attractor is also removed;
and (c)~removing the attractor ensures that the check required for trivial SCCs
for graphs (line~\ref{l:gbasic:edge})
is not required any further.

To compute the almost-sure winning set for MDPs with Streett objectives,
we first find all (maximal) good end-components and then solve almost-sure
reachability with the union of the good end-components as target set as the last 
step of the algorithm. This is correct by Lemma~\ref{lem:gec}. Towards finding 
all good end-components, the algorithm maintains two sets, the set $\good$ of
identified good end-components that is initially empty and the set $\mathcal{\ec}$ 
of end-components that are candidates for good end-components that is 
initialized with the MECs of the MDP.
In each iteration of the while-loop one set $S$ is removed from the set of 
candidates $\mathcal{\ec}$ and the set of bad vertices $\bad(S)$ of $S$
is determined. If $\bad(S)$ is empty, then $S$ is a good end-component and 
added to $\good$. Otherwise the random attractor of $\bad(S)$ in $\mdp[S]$
is removed from $S$, which by Corollary~\ref{cor:geccontained} does not 
remove any vertices that are in a good end-component. The remaining vertices of 
$S$ have no outgoing random edges and thus still induce a sub-MDP but the 
sub-MDP might not be strongly connected any more. Then the MECs
of this sub-MDP are added to $\mathcal{\ec}$.
These operations maintain the invariants that (i) each set in $\mathcal{\ec}$
is an end-component and (ii) each good end-component is a subset of one set 
in either $\good$ or $\mathcal{\ec}$. By (i) a set in $\mathcal{\ec}$ is a (maximal) 
good end-component if it does not contain any bad vertices, i.e., in particular
this holds for the sets added to $\good$ (soundness). By (ii) and 
$\mathcal{\ec} = \emptyset$ at termination of the while-loop the algorithm
identifies all (maximal) good end-components of the MDP (completeness).
Since in each iteration of the while-loop either (1) a set is removed from $\mathcal{\ec}$
and added to $\good$ or (2) bad vertices are removed from a set and not considered 
further by the algorithm, there can be at most $O(n)$ iterations of the while-loop. 
Furthermore, whenever bad vertices are removed, then the number of target pairs
a given candidate set intersects is reduced by one. Thus each vertex %and each edge
is considered in at most $O(k)$ iterations of the while-loop.
The most expensive operation in the while-loop is the computation of the MECs. 
Denoting the number of symbolic steps for the MEC computation with $O(\mectime)$,
the number of symbolic steps of Algorithm~\ref{alg:streettmdpbasic} 
is $O(\min(n, k) \cdot \mectime)$ (assuming that the number of symbolic steps 
for the almost-sure reachability computation is lower than that).


\subsection{Improved Symbolic Algorithm for MDPs with Streett Objectives}

We present the technical details regarding the improved symbolic algorithm
for MDPs with Streett objectives. The main ideas of the algorithm are presented
in Section~\ref{sec:mdps}. The pseudocode is given in Algorithm~\ref{alg:streettmdpimpr}.

%\paragraph{Algorithm~\ref{alg:streettmdpimpr}.}
%The pseudocode of the improved symbolic algorithm for MDPs with Streett
%objectives is given in Algorithm~\ref{alg:streettmdpimpr}. The key differences
%compared to Algorithm~\ref{alg:streettgraphimpr} are as follows:
%First, the set of candidates for good end-components is initialized with the MECs of
%the input graph instead of the SCCs. Second, whenever bad vertices are removed
%from a candidate, also their random attractor is removed (line~\ref{l:mimpr:rem1}).
%Further, whenever a candidate is partitioned into its SCCs, for each SCC, the
%random attractor of the vertices with outgoing random edges is removed
%(line~\ref{l:mimpr:rem3}). Finally, whenever a candidate $S$ is separated into
%$C$ and $S \setminus C$ via symbolic lock-step search, the random attractor of
%the vertices with outgoing random edges is removed from $C$
%(line~\ref{l:mimpr:rem4}), and the random attractor of $C$ is removed
%from $S$ (line~\ref{l:mimpr:rem2}).
%The formal details of the algorithm and proofs can be found in Appendix~\ref{sec:appmdps}.

\begin{algorithm2e}
	\SetAlgoRefName{StreettMDPimpr}
	\caption{Improved Alg. for MDPs with Streett Obj.}
	\label{alg:streettmdpimpr}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\BlankLine
    \Input{MDP $\mdp = ((V, E), (\vp, \vr), \trans)$ and pairs $\SP= \{(L_i, U_i) \mid 1 \le i \le k\}$
    }
	\Output
	{
	$\as{\mdp, \Streett{\SP}}$
	}
	\BlankLine
	$\mathcal{\ec} \gets \mecalg(\mdp)$; $\good \gets \emptyset$\;
	\lForEach{$\scc \in \mathcal{\ec}$}{
		$H_\scc \gets \emptyset$; $T_\scc \gets \emptyset$
	}
	\While{$\mathcal{\ec} \ne \emptyset$}{
		remove some $S \in \mathcal{\ec}$ from $\mathcal{\ec}$\;
		$\badv \gets \bigcup_{1 \le i \le k : U_i \cap S = \emptyset} (L_i \cap S)$\;
		\While{$\badv \ne \emptyset$\label{l:imdp:innerw}}{
			$A \gets \at{R}{\mdp[S]}{\badv}$\label{l:imdp:attr1}\;
			$S \gets S \setminus A$\label{l:mimpr:rem1}\;
			$H_S \gets (H_S \cup \post(A)) \cap S$\label{l:imdp:bh}\;
			$T_S \gets (T_S \cup \pre(A)) \cap S$\label{l:imdp:bt}\;
			$\badv \gets \bigcup_{1 \le i \le k : U_i \cap S = \emptyset} (L_i \cap S)$\;
		}
		\If(\tcc*[h]{$\mdp[S]$ contains at least one edge}){$\post(S) \cap S \ne \emptyset$\label{l:imdp:edge}}{
			\lIf{$\lvert H_S \rvert + \lvert T_S \rvert = 0$}{
				$\good \gets \good \cup \set{S}$\label{l:imdp:good1}
			}\ElseIf{$\lvert H_S \rvert + \lvert T_S \rvert \ge \sqrt{m / \log n}$}{
				delete $H_S$ and $T_S$\;
				$\mathcal{\scc} \gets \sccalg(\mdp[S])$\;
				\lIf{$\lvert \mathcal{\scc} \rvert = 1$}{
					$\good \gets \good \cup \set{S}$\label{l:imdp:good2}
				}\Else{
					\ForEach{$\scc \in \mathcal{\scc}$}{
						$\rout \gets \scc \cap \vr \cap \pre(S \setminus \scc)$\label{l:imdp:sccrout}\;
						$A \gets \at{R}{\mdp[\scc]}{\rout}$\label{l:imdp:attr2}\;
						$\scc \gets \scc \setminus A$\label{l:mimpr:rem3}\;
						$H_\scc \gets \post(A) \cap \scc$\label{l:imdp:scch}\;
						$T_\scc \gets \pre(A) \cap \scc$\label{l:imdp:scct}\;
						$\mathcal{\ec} \gets \mathcal{\ec} \cup \set{\scc}$\;
					}
				}
			}\Else{
				($\scc$, $H_S$, $T_S$) $\gets $\ref{proc:lockstep}($G$, $S$, $H_S$, $T_S$)\;
				\lIf{$\scc = S$}{
					$\good \gets \good \cup \set{S}$\label{l:imdp:good3}
				}\Else(\tcc*[h]{separate $\scc$ and $S \setminus \scc$}){
				%%correct but may be not obvious why, so replaced by version below
% 					$A_\scc \gets \at{R}{\mdp[S]}{S \setminus \scc}$\;
% 					$A_S \gets \at{R}{\mdp[S]}{\scc}$\;
% 					$\scc \gets \scc \setminus A_\scc$ \tcc*[h]{$\scc$ not changing if $\scc$ bottom SCC}\;
% 					$S \gets S \setminus A_S$ \tcc*[h]{$S$ not changing if $\scc$ top SCC}\;
				%%
					$\rout_\scc \gets \scc \cap \vr \cap \pre(S \setminus \scc)$\label{l:mimpr:lssrout}\tcc*[h]{empty if $\scc$ bottom SCC}
					$A_\scc \gets \at{R}{\mdp[\scc]}{\rout_\scc}$\label{l:imdp:attr3}\tcc*[h]{$=\at{R}{\mdp[S]}{S \setminus \scc} \cap \scc$}
					$A_S \gets \at{R}{\mdp[S]}{\scc}$\label{l:imdp:attr4}\;
					$\scc \gets \scc \setminus A_\scc$\label{l:mimpr:rem4}\;
					$S \gets S \setminus A_S$\label{l:mimpr:rem2}\;
					$H_\scc \gets \post(A_\scc) \cap \scc$\label{l:imdp:lsshc}\;
					$T_\scc \gets \pre(A_\scc) \cap \scc$\label{l:imdp:lsstc}\;
					$H_S \gets (H_S \cup \post(A_S)) \cap S$\label{l:imdp:lsshs}\;
					$T_S \gets (T_S \cup \pre(A_S)) \cap S$\label{l:imdp:lssts}\;
					$\mathcal{\ec} \gets \mathcal{\ec} \cup \set{S} \cup 
					\set{\scc}$\;
				}
			}
		}
	}
	\Return{$\as{\mdp, \Reach{\bigcup_{\scc \in \good} \scc}}$}\;
\end{algorithm2e}

The following invariant is maintained throughout Algorithm~\ref{alg:streettmdpimpr}
for the sets in $\good$ and $\mathcal{\ec}$.

\begin{invariant}[Maintained Sets]\label{inv:gecontained}
The sets in $\mathcal{\ec} \cup \good$ are pairwise disjoint and for every good 
end-component~$\scc$ of $G$ there exists a set $Y \supseteq \scc$
such that either $Y \in \mathcal{\ec}$ or $Y \in \good$.
\end{invariant}

Furthermore, the algorithm maintains the invariant
that each candidate for a good end-component $S \in \mathcal{\ec}$
contains no random edges to vertices not in $S$.

\begin{invariant}[No Random Outgoing Edges]\label{inv:mdprout}
Given an MDP~$\mdp$ and its underlying graph $G = (V, E)$, for each
set $S \in \mathcal{\ec}$ there are no random vertices in $S$ with edges
to vertices in~$V \setminus S$.
\end{invariant}

Finally, for each candidate set $S \in \mathcal{\ec}$ the algorithm remembers
sets $H_S$ and $T_S$ of vertices that have lost incoming resp. outgoing
edges since the last time a superset of $S$ was identified as being strongly connected.
The algorithm maintains Invariant~\ref{inv:HT} and therefore it can use
Procedure~\ref{proc:lockstep} together with its correctness guarantee and bound
on symbolic steps provided by Theorem~\ref{thm:lss}.

\begin{lemma}[Invariants of Improved Algorithm for MDPs]\label{lem:improvedmdpsinv}
Invariant~\ref{inv:HT}, Invariant~\ref{inv:gecontained}, and Invariant~\ref{inv:mdprout}
are preserved throughout Algorithm~\ref{alg:streettmdpimpr}, i.e., they hold before the
first iteration, after each iteration, and after termination of the main while-loop. Further,
Invariant~\ref{inv:HT} is preserved during each iteration of the main while-loop.
\end{lemma}

\begin{proof}
\item 
\smallskip\noindent{\bf Invariant~\ref{inv:HT}.}
The proof is a minor extension of the maintenance proof for Algorithm~\ref{alg:streettgraphimpr}
that is given in Appendix~\ref{sec:appgraphs}. In terms of strong connectivity of a candidate $S$
and the maintenance of the sets $H_S$ and $T_S$, the only difference to the graph case is that
after an SCC~$C$ is computed by $\sccalg$ or Procedure~\ref{proc:lockstep}, another subset
of vertices~$A$ (vertices with outgoing random edges and their random attractor) is removed
from $C$. In this case the invariant is maintained by initializing $H_C$ resp.\ $T_C$ with 
the vertices of $C \setminus A$ with edges from resp.\ to vertices of $A$, i.e., 
$H_C \gets \post(A) \cap C$ and $T_C \gets \pre(A) \cap C$.

\smallskip\noindent{\bf Invariant~\ref{inv:gecontained} -- Disjointness.}
The sets in $\mathcal{\ec} \cup \good$ are pairwise disjoint at the
initialization since $\good$ is initialized as $\emptyset$. Furthermore,
whenever a set $S$ is added to $\good$ in an iteration of the main
while-loop, a superset $\tilde{S} \supseteq S$ is removed from
$\mathcal{\ec}$ in the same iteration of the while-loop. Therefore
by induction the disjointness of the sets in $\mathcal{\ec} \cup \good$
is preserved.

\smallskip\noindent{\bf Invariant~\ref{inv:gecontained} -- Containment of good end-components.}
At initialization, $\mathcal{\ec}$ contains all MECs of the input MDP
$\mdp = (G = (V, E), \allowbreak(\vp, \vr), \allowbreak\trans)$.
Each good end-component $C$ of $P$ is an end-component, 
so there exists a MEC $Y \supseteq C$ such that $Y \in \mathcal{\ec}$
for each good end-component $C$.

Consider a set $S \in \mathcal{\ec}$ that is removed from $\mathcal{\ec}$
at the beginning of an iteration of the main while-loop. Consider further
a good end-component $C$ of $P$ such that $C \subseteq S$. We require that a set
$Y \supseteq C$ is added to either
$\mathcal{\ec}$ or $\good$ in this iteration of the main while-loop.

First, whenever we remove $\at{R}{\mdp[S]}{\bad(S)}$ from $S$, by Corollary~\ref{cor:geccontained},
we maintain the fact that $C \subseteq S$. Second, $P[S]$ contains an edge since $C \subseteq S$.
Finally, one of the three cases happens:

\smallskip\noindent Case~(1): If $\lvert H_S \rvert + \lvert T_S \rvert = 0$, then the set
$S \supseteq C$ is added to $\good$.

\smallskip\noindent Case~(2): If $\lvert H_S \rvert + \lvert T_S \rvert \ge \sqrt{m / \log n}$,
then the algorithm computes the SCCs of $\mdp[S]$. If $S$ itself is the (sole) SCC of $\mdp[S]$, then it
is added to $\good$. Otherwise, since $C \subseteq S$ is strongly connected,
it is completely contained in some SCC $Y$ of $\mdp[S]$. Furthermore, since $C$ has no outgoing
random edges, by Lemma~\ref{lem:eccontained} it is contained in $Y$ even after we remove
$\at{R}{\mdp[Y]}{ Y \cap \vr \cap \pre(S \setminus Y) }$ from it. Finally, $Y$ is added to $\mathcal{\ec}$.

\smallskip\noindent Case~(3): If $0 < \lvert H_S \rvert + \lvert T_S \rvert < \sqrt{m / \log n}$,
then the algorithm either adds $S \supseteq C$ to $\good$, or partitions $S$
into $\tilde{S}$ and $S \setminus \tilde{S}$. Suppose the latter case happens, then by
Theorem~\ref{thm:lss} we have that $\tilde{S}$ is an SCC of $\mdp[S]$. Further, since $C \subseteq S$
is strongly connected, it is completely contained in some SCC of $\mdp[S]$.
Therefore either $C \subseteq \tilde{S}$ or $C \subseteq (S \setminus \tilde{S})$.
If $C \subseteq \tilde{S}$, then by Lemma~\ref{lem:eccontained} after the removal
of $\at{R}{\mdp[\tilde{S}]}{ \tilde{S} \cap \vr \cap \pre(S \setminus \tilde{S}) }$ from
$\tilde{S}$ we maintain that $C \subseteq \tilde{S}$.
If $C \subseteq (S \setminus \tilde{S})$, then by Lemma~\ref{lem:eccontained} after the removal
of $\at{R}{\mdp[S]}{ \tilde{S} }$ from $(S \setminus \tilde{S})$ we maintain that $C \subseteq (S \setminus \tilde{S})$.
Finally, both $\tilde{S}$ and $S \setminus \tilde{S}$ are added to $\mathcal{\ec}$.

\smallskip\noindent By the above case analysis we have that a set $Y \supseteq C$ is added
to either $\mathcal{\ec}$ or $\good$ in the iteration of the main while-loop.

\smallskip\noindent{\bf Invariant~\ref{inv:mdprout}.}
Given an MDP, the set $\mathcal{\ec}$ is initialized with the MECs of the MDP, and
by definition they have no random outgoing edges. Therefore the invariant holds
before the first iteration of the main while-loop.

Consider a candidate set $S \in \mathcal{\ec}$ in a given iteration of the main
while-loop. By the induction hypothesis, $S$ has no random vertices with edges to $V \setminus S$.
First, some bad vertices can be iteratively removed from $S$. At each such removal,
the random attractor to these vertices is removed from $S$ as well. After the removal,
by the definition of a random attractor, $S$ has no random outgoing edges to the attractor,
and therefore by induction has no random outgoing edges to $V \setminus S$.
Second, $S$ may be partitioned into at least two proper subsets. Then for each
such subset $C$, the random attractor to random vertices in $C$ with edges
to $S \setminus C$ is removed from $C$. By induction and the definition of a random attractor,
after the removal $C$ contains no random outgoing edges to $V \setminus C$ and 
adding it to $\mathcal{\ec}$ preserves the invariant.

\qed
\end{proof}

\begin{proof}[of Theorem~\ref{thm:improvedmdps}]

\smallskip\noindent{\bf Correctness.}
Whenever a candidate set $S$ is added to $\good$, it contains an edge
by the check at line~\ref{l:imdp:edge}, $\bad(S) = \emptyset$ by the check
at line~\ref{l:imdp:innerw}, and it has no outgoing random edges
by Invariant~\ref{inv:mdprout} and the random attractor
removal at line~\ref{l:mimpr:rem1}.
Furthermore, \upbr{a} at line~\ref{l:imdp:good1}, $S$ is strongly connected by Invariant~\ref{inv:HT},
\upbr{b} at line~\ref{l:imdp:good2}, $S$ is strongly connected by the result of~\sccalg, and \upbr{c}
at line~\ref{l:imdp:good3}, $S$ is strongly connected by Theorem~\ref{thm:lss}.
Therefore we have that whenever a candidate set is added to $\good$,
it is indeed a good end-component (soundness).

Finally, by soundness, Invariant~\ref{inv:gecontained}, the termination of the
algorithm (shown below), and the fact that $\mathcal{\ec} = \emptyset$ at the
termination of the algorithm, we have that $\good$ contains all good
end-components of $G$ (completeness).

\smallskip\noindent{\bf Symbolic steps analysis.}
When using our improved symbolic algorithm for MEC decomposition,
the initialization takes $O(n\cdot \sqrt{m})$ symbolic steps by Theorem~\ref{thm:improvedmecs}.

In each iteration of the outer while-loop, a set~$S$ is removed
from $\mathcal{\ec}$ and either \upbr{a} a set $S' \subseteq S$ is added
to $\good$ and no set is added to $\mathcal{\ec}$ or \upbr{b} at least two
sets that are (subsets of) a partition of $S$ are added to $\mathcal{\ec}$.
Both can happen at most $O(n)$ times, thus there can be at most $O(n)$ iterations
of the outer while-loop. The $\pre$ and $\post$ operations at
lines~\ref{l:imdp:edge},~\ref{l:mimpr:lssrout},~\ref{l:imdp:lsshc},~\ref{l:imdp:lsstc},~\ref{l:imdp:lsshs},
and~\ref{l:imdp:lssts} can be charged to the iterations of the outer while-loop.

An iteration of the inner while-loop (line~\ref{l:imdp:innerw}) is executed
only if some vertices~$\badv$ are removed from $S$; the vertices of $\badv$
are then not considered further. Thus there can, in total, be at most $O(n)$
$\post$ operations at line~\ref{l:imdp:bh} and $\pre$ operations at line~\ref{l:imdp:bt}
over all iterations of the inner while-loop.

Similarly, each $\cpre{R}$ operation executed as a part of a random attractor computation
adds at least one vertex to the attractor, and the vertices of the attractor are then not
considered any further in the algorithm. Therefore there can, in total, be at most
$O(n)$ $\cpre{R}$ operations over all attractor computations at
lines~\ref{l:imdp:attr1},~\ref{l:imdp:attr2},~\ref{l:imdp:attr3}, and~\ref{l:imdp:attr4}.
 
 	
Note that every vertex in each of $H_S$ and $T_S$ can be attributed to at least one unique
implicit edge deletion since we only add vertices to $H_S$ resp.\ $T_S$ that are successors
resp.\ predecessors of vertices that were separated from $S$ (or deleted from the
maintained graph). Whenever the case $\lvert H_S \rvert + \lvert T_S \rvert \ge \sqrt{m / \log{n}}$
occurs, for all subsets $C \subseteq S$ that are then added to $\mathcal{\ec}$, we initialize
$H_C = T_C = \emptyset$. Therefore, the case $\lvert H_S \rvert + \lvert T_S \rvert \ge \sqrt{m / \log{n}}$
can happen at most $O(\sqrt{m \log{n}})$ times throughout the algorithm since
there are at most $m$ edges that can be deleted. In one iteration of this case, the number
of symbolic steps executed by $\sccalg$ together with symbolic steps executed at
lines~\ref{l:imdp:sccrout},~\ref{l:imdp:scch}, and~\ref{l:imdp:scct}, is bounded by $O(n)$~\cite{GentiliniPP08}.

It remains to bound the number of symbolic steps in Procedure~\ref{proc:lockstep}. Let $\scc$ be the set
returned by the procedure; we charge the symbolic steps in this call of the procedure to the vertices of 
the smaller set of $\scc$ and $S \setminus \scc$. By Theorem~\ref{thm:lss} we have either \upbr{a}
$\scc = S$, the number of symbolic steps in this call is bounded by $O(\sqrt{m/\log{n}} \cdot \lvert \scc \rvert)$,
and the set $S$ is added to $\good$ or \upbr{b}
$\min(\lvert \scc \rvert, \lvert S \setminus \scc \rvert) \le \lvert S \rvert / 2$ and the number of symbolic steps
in this call is bounded by $O(\sqrt{m/\log{n}} \cdot \min(\lvert \scc \rvert, \lvert S \setminus \scc \rvert))$.
Case~\upbr{a} can happen at most once for the vertices of $\scc$, and for case~\upbr{b} note that the size
of a set containing a specific vertex can be halved at most $O(\log{n})$ times; thus we charge each vertex at 
most $O(\log{n})$ times. Hence we can bound the total number of symbolic steps in all calls to the procedure
by $O(n \cdot \sqrt{m \log{n}})$.
\qed
\end{proof}


%%%%%%%%%%%%%%%%%%%   E
\section{Details of Section~\ref{sec:exper}: Experiments}\label{sec:appexper}

We present the results of the experimental evaluation when comparing based on the time.
In all the figures, both axes plot the amount of seconds spent on the execution. Similar
to the case of symbolic steps, we begin the measurement after the initial preprocessing
step (computing all SCCs for graphs and all MECs for MDPs) is finished. The results for
graphs are shown in Figure~\ref{fig:graphsT} and the results for MDPs are shown in 
Figure~\ref{fig:mdpsT}.

\newpage

\setlength{\abovecaptionskip}{2pt}

\begin{figure}[t]
\centering
\includegraphics[width=0.7\textwidth]{fig/Tgraph}
\caption{Comparison of time for graphs with Streett objectives.}
\label{fig:graphsT}
\end{figure}

\setlength{\abovecaptionskip}{4pt}

\begin{figure}
\begin{center}
     \subfloat[10\% random vertices\label{fig:mdp10T}]{%
       \includegraphics[width=0.5\textwidth]{fig/Tmdp10}%0.335
     }
     %\hfill
     \subfloat[20\% random vertices\label{fig:mdp20T}]{%
       \includegraphics[width=0.5\textwidth]{fig/Tmdp20}
     }
     \hfill
     \subfloat[50\% random vertices\label{fig:mdp50T}]{%
       \includegraphics[width=0.5\textwidth]{fig/Tmdp50}
     }
\caption{Comparison of time for MDPs with Streett objectives.}
\label{fig:mdpsT}
\end{center}
\end{figure}
