\section{Related work}\label{sect:related}

\paragraph{{Recovery}} {The works most closely most closely related to ours are those based on the \emph{recovery} notion, that is, the type system of Gordon et al. \cite{GordonEtAl12} and the Pony language  \cite{ClebschEtAl15}.} Indeed, the capsule property has many variants in the literature, such as \emph{isolated} \cite{GordonEtAl12}, \emph{uniqueness} \cite{Boyland10} and \emph{external uniqueness}~\cite{ClarkeWrigstad03}, \emph{balloon} \cite{Almeida97,ServettoEtAl13a}, \emph{island} \cite{DietlEtAl07}. 
%The fact that aliasing can be controlled by using \emph{lent} (\emph{borrowed}) references is well-known~\cite{Boyland01,NadenEtAl12}.
However, before the work of Gordon et al. \cite{GordonEtAl12}, the capsule property was only ensured in simple situations, such as using a primitive deep clone operator, or composing subexpressions with the same property.

The important novelty of the type system of Gordon et al. \cite{GordonEtAl12} has been \emph{recovery}, that is, the ability to ensure properties (e.g., capsule or immutability) by keeping into account not only the expression itself but the way the surrounding context is used. {Notably,} an expression which does not use external mutable references is recognized to be a capsule. 
{In the Pony language \cite{ClebschEtAl15}  the ideas of Gordon et al. \cite{GordonEtAl12} are extended to a richer set of reference immutability permissions. In their terminology \texttt{value} is immutable, \texttt{ref} is mutable, \texttt{box} is similar to \emph{readonly} as often found in literature, different from our $\readable$ since it can be aliased. An ephemeral isolated reference \lstinline{iso^} is similar to a $\capsule$ reference in our calculus, whereas non ephemeral \texttt{iso} references offer destructive reads and are more
similar to isolated fields \cite{GordonEtAl12}. Finally, \texttt{tag} only allows object identity checks and \texttt{trn} (transition) is a subtype of \texttt{box} that can be converted to \texttt{value}, providing a way to create values without using isolated references. The last two qualifiers have no equivalent in our
work or in  \cite{GordonEtAl12}.}

Our {type system greatly enhances the recovery mechanism used in such previous work \cite{GordonEtAl12,ClebschEtAl15} by using lent references, and rules \rn{t-swap} and \rn{t-unrst}.} For instance, the examples in \refToFigure{TypingOne} and \refToFigure{TypingTwo} would be ill-typed in \cite{GordonEtAl12}. 

{A minor difference with the type systems of Gordon et al. \cite{GordonEtAl12} and Pony \cite{GordonEtAl12,ClebschEtAl15} is that we only allow fields to be $\mutable$ or $\imm$.
Allowing \emph{readonly} fields means holding a reference that is useful for observing but non making remote modifications. However, our type system supports the $\readable$ modifier rather than the \emph{readonly}, and the $\readable$ qualifier includes the $\lent$ restriction. Since something which is $\lent$ cannot be saved as part of a $\mutable$ object, $\lent$ fields are not compatible with the current design where objects are born $\mutable$. The motivation for supporting $\readable$ rather than \emph{readonly} is discussed in a specific point later.
Allowing $\capsule$ fields means that programs can store an externally unique object graph into the heap and decide later whether to unpack
 permanently or freeze the reachable objects.  This can be useful, but, as for $\readable$ versus \emph{readonly}, our opinion is that this power is hard to use for good, since
it requires destructive reads, as discussed in a specific point later. 
In most cases, the same expressive power can be achieved by having the
field as $\mutable$ and recovering the $\capsule$ property for the outer object.}

\paragraph{Capabilities}
 {In other proposals \cite{HallerOdersky10,CastegrenWrigstad16} types are compositions of one or more \emph{capabilities}. The modes of the capabilities in a type control how resources of that
type can be aliased. The compositional aspect of capabilities is an important difference
from type qualifiers, as accessing different parts of an object through different capabilities in the same type gives different properties. 
By using capabilities it is possible to obtain an expressivity which looks similar to our type system, even though with different sharing notions and syntactic constructs. For instance, the \emph{full encapsulation} notion in \cite{HallerOdersky10}\footnote{{This paper includes a very good survey of work in this area, notably explaining the difference between \emph{external uniqueness}~\cite{ClarkeWrigstad03} and \emph{full encapsulation}.}}, apart from the fact that sharing of immutable objects is not allowed, is equivalent to the guarantee of our $\capsule$ qualifier, while
our $\lent$ and their \Q|@transient| achieve similar results in different ways.}
Their model has a higher syntactic/logic overhead to explicitly  track regions.
As for all work before~\cite{GordonEtAl12}, objects need to be born \Q|@unique| and the type system 
permits to manipulate data preserving their uniqueness. With recovery~\cite{GordonEtAl12},
instead, we can forget about uniqueness, use normal code designed to work on conventional shared data, and then
recover the aliasing encapsulation property.

\paragraph{Destructive reads} Uniqueness can be enforced by destructive reads, i.e., assigning a copy of 
the unique reference to a variable an destroying the original reference, see
\cite{GordonEtAl12,Boyland10}. Traditionally, borrowing/fractional permissions~\cite{NadenEtAl12} are related to uniqueness  in the opposite way: a unique reference can be borrowed,
it is possible to track when all borrowed aliases are buried~\cite{Boyland01}, and then uniqueness can be recovered.
These techniques offers a sophisticate alternative to destructive reads. 
We also wish to avoid destructive reads. In our work, we ensure uniqueness by linearity, that is, by allowing at most
one use of a $\capsule$ reference.

In our opinion, programming with destructive reads is involved and hurts the correctness of the program, since it leads to the style of programming outlined below, where \Q@a.f@ is a unique/isolated field with destructive read.
\begin{lstlisting}
a.f=c.doStuff(a.f)//style suggested by destructive reads
\end{lstlisting}
The object referenced by \lstinline{a}{} has an \emph{unique/isolated} field \lstinline{f} containing an object \lstinline{b}.
This object \lstinline{b}{} is passed to a client \lstinline{c}{}, which can use (potentially modifying) it. A typical pattern is that the result of such computation is a reference to \lstinline{b}{}, which \lstinline{a}{} can then recover. This approach allows \emph{isolated} fields, as shown above, but has  a serious drawback:
an \emph{isolated} field can become unexpectedly not available (in the example, during execution of \lstinline{doStuff}{}), hence any object contract
involving such field can be broken.
{This can cause {subtle} bugs if \Q@a@ is in the reachable object graph of \Q@c@.}

In our approach, the  $\capsule$ qualifier cannot be applied to fields. Indeed, the ``only once'' use of capsule variables 
makes no sense on fields.
{However, we support the same level of control of the reachable object graph by passing mutable objects to clients as $\lent$, in order to control aliasing behaviour.
That is, the previous code can be rewritten} as follows:
\begin{lstlisting}
c.doStuff(a.f())//our suggested style
\end{lstlisting}
{where \Q@a.f()@ is a getter returning the field as $\lent$.
Note how, during the execution of \Q@doStuff@, \Q@a.f()@ is still available, and,} after the execution of \Q@doStuff@, the aliasing relation {for this field is the same as it was
before \Q@doStuff@ was called.}

\paragraph{Ownership} A {closely related} stream of research is that on \emph{ownership} (see an overview in~\cite{ClarkeEtAl13}) which, however, offers an {opposite} approach. In the ownership approach, it is provided a way to express and prove the ownership invariant\footnote{{Ownership invariant (owner-as-dominator):
Object $o_1$ is owned by object  $o_2$ if in the object graph $o_2$
is a dominator node for $o_1$;
that is, all paths from the roots of the graph (the stack variables)
to $o_1$ pass throw $o_2$.
Ownership invariant (owner-as-modifier):
Object $o_1$ is owned by object  $o_2$ if any field update over $o_1$
is initiated by $o_2$, that is, a call of a method of $o_2$ is present
in the stack trace.}}, which, however, is expected to be guaranteed by defensive cloning, as explained below. In our approach, instead, the capsule concept models an efficient \emph{ownership transfer}. In other words, when an object $\x$ is ``owned'' by another object $\y$, it remains always true that $\y$ can be only accessed only through $\x$, whereas the capsule notion is more dynamic: a capsule can be ``opened'', that is, assigned to a standard reference and modified, and then we can recover the original capsule guarantee. 

For example, assuming a graph with a list of nodes, and a constructor taking in input such list,
the following code establishes the ownership invariant using $\capsule$, and ensures that it cannot be violated using $\lent$.
\begin{lstlisting}
class Graph{
  private final NodeList nodes;
  private Graph(NodeList nodes){this.nodes=nodes; }

  static Graph factory(capsule NodeList nodes){
    return new Graph(nodes);
    }
  
  lent NodeList borrowNodes(mut){return nodes;}
}
\end{lstlisting}
Requiring the parameter of the \lstinline{factory}{} method to be a $\capsule$ guarantees that the list of nodes provided as argument is not referred from the external environment. 
The factory \emph{moves} an isolated portion of store as local store of the newly created object. 
Cloning, if needed, becomes responsibility of the client which provides the list of nodes to the graph. The getter tailors the exposure level of the private store. 

Without aliasing control ($\capsule$ qualifier),  in order to ensure ownership of its list of nodes, the {factory method} should clone the argument, since it comes from an external client environment.
This solution, called  \label{cloning} \emph{defensive cloning}~\cite{Bloch08}, is very popular in the Java community, but inefficient,
since it requires to duplicate the reachable object
graph of the parameter, until immutable nodes are
reached.\footnote{{In most languages, for owner-as-modifier defensive cloning is needed
only when new data is saved inside of an object, while for owner-as-dominator it is needed also when internal data are exposed.}}
Indeed, many programmers prefer to write {unsafe}
 code instead of using defensive cloning for efficiency reasons.
However, this unsafe approach is only possible when programmers have control of the client code, that is, they are not 
working in a library setting.
Indeed many important Java libraries (including the standard Java libraries) today
use defensive cloning to ensure ownership of their internal state.

As mentioned above, our approach is the opposite of the one offered by many ownership approaches, which provide a formal way to express  and prove the ownership invariant that, however, are expected to be guaranteed by defensive cloning. 
We, instead, model an efficient \emph{ownership transfer} through the capsule concept, then, 
duplication of memory, if needed, is performed on the client side\footnote{
Other work in literature supports ownership transfer, see for example~\cite{MullerRudich07, ClarkeWrigstad03}.
In literature it is however applied to uniquess/external uniqueness, thus not {the whole} reachable object graph is transfered.
}.

Moreover, depending on how we expose the owned data, we can closely model
both \emph{owners-as-dominators} (by providing no getter)
and \emph{owners-as-qualifiers} (by providing a \Q@read@ getter). In the example, the method \lstinline{borrowNodes}{} is an example of a $\lent$ getter, a third variant besides the two described on page \pageref{exposer}.  This variant is particularly useful in the case of a field which is owned, indeed, \Q@Graph@ instances can release the mutation control of their nodes without permanently {losing} the aliasing control.

In our approach all properties are deep. On the opposite side, most ownership approaches allows one to distinguish
subparts of the reachable object graph that are referred but not logically owned. This viewpoint has many advantages, for example the Rust language\footnote{\texttt{rust-lang.org}} leverages on ownership to control object deallocation without a garbage collector.
Rust employs a form of uniqueness that can be seen as a restricted ``owners-as-dominators" discipline.  
Rust lifetime parameters behave like additional ownership parameters~\cite{OstlundEtAl08}.

However, in most ownership based approaches 
it is not trivial to encode the concept of full encapsulation, while supporting (open) sub-typing and avoiding defensive cloning.
This depends on how any specific ownership approach entangles subtyping with 
 gaining extra ownership parameters
and extra references to global ownership domains.

\paragraph{Readable notion} Our $\readable$ qualifier is different from \emph{readonly} as used, e.g., in \cite{BirkaErnst04}.
 An object cannot be modified through a readable/readonly reference. However, 
$\readable$ also prevents aliasing.
As discussed in \cite{Boyland06}, readonly semantics can be easily misunderstood by
programmers. Indeed, some wrongly believe it means immutable, whereas the object denoted by a readonly reference can be modified through other references, while others do not realize that readonly data can still be saved in fields, and thus used as a secondary window to observe the change in the object state.
Our proposal addresses both problems, since we explicitly support the $\imm$ qualifier, hence it is more difficult for programmers to confuse the two concepts, and our $\readable$ (readonly + lent) data  cannot be saved in client's fields.

Javari~\cite{TschantzErnst05} also supports the \emph{readonly} type qualifier, and makes a huge design effort to support \emph{assignable} and \emph{mutable} fields, to have fine-grained readonly constraints.  The need of such flexibility is motivated by performance reasons.
In our design philosophy, we do not offer any way of breaking the invariants enforced by the type system. Since our invariants are very strong, we expect compilers to be able to perform optimization, thus recovering most of the efficiency lost to properly use immutable and readable objects.


