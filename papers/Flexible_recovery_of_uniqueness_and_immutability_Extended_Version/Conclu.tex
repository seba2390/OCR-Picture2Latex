\section{Conclusion}\label{sect:conclu}
The key contributions of the paper are:
\begin{itemize}
\item A powerful type system for control of mutation and aliasing in class-based imperative languages, providing: type qualifiers for restricting the use of references;  rules for {recovering} a less restrictive type at the price of {constraining} the use of other references; rules for temporarily {unconstrain such} references for typing subexpressions. 
\item A non standard operational model of the language, relying on the language's ability to represent {store}.
\end{itemize}

{We have extensively illustrated the former feature in \refToSection{examples}, here we briefly discuss the latter.}

{In our operational model, aliasing properties are directly expressed at the syntactic level. Notably, in a subterm $\e$ of a program, objects reachable from other parts of the program are simply those denoted by free variables in $\e$, whereas local objects are those denoted by local variables declared in $\e$. In other terms, \emph{the portion of memory only reachable from $\e$ is encoded in $\e$ itself}.  For instance, in}
\begin{lstlisting}
mut D y=new D(0); 
capsule C z = {mut D x = new D(1); new C(x,x)}
\end{lstlisting}
{it is immediately clear that the reference $\z$ denotes an isolated portion of memory, since its right-value is a closed expression.
In the conventional model, instead, memory is flat. For instance, the previous example would be modeled having three locations, say $\iota_y$, $\iota_z$, and $\iota_x$, all at the top-level, hence the fact that $\iota_x$ is not reachable from $\iota_y$ should be reconstructed inspecting the store.}

{In our opinion, this offers a very intuitive and simple understanding of when a subterm of a program can be safely typed $\capsule$, as we have exploited in the examples in \refToSection{typesystem}. More generally, we argue that our model is more adequate for didactic purposes since it does not rely on run-time structures that do not exist in the source program, see \cite{ServettoLindsay13} for an extended discussion on this. Another advantage is that, being the store encoded in terms, proofs can be done by structural induction, whereas in the traditional model invariants on the memory should be proved showing that \emph{all} locations satisfy a given property. This is especially important when using a proof assistant, such as Coq, which we plan as further work. }

{On the opposite side, a disadvantage of our model is the fact that it is possibly more esoteric for people used to the other one. Moreover, since isolation is encoded by scoping, some care is needed to avoid scope extrusion during reduction. Notably, a field access on a reference which points to an isolated portion of store (a block) cannot produce just a reference.}

{As mentioned in \refToSection{typesystem}, the type system presented in this paper, as those in previous work on recovery \cite{GordonEtAl12,ClebschEtAl15}, uses rules which are not syntax-directed, hence \emph{transparent} to the programmer, in the sense that they are applied when needed.  The programmer can simply rely on the fact that expressions are $\capsule$ or $\imm$, respectively, in situations where this is intuitively expected. Of course, the negative counterpart is that the type system is not algorithmic. This is due, as said above, to the presence of non structural rules, which are, besides standard subsumption, recovery rules \rn{t-capsule} and \rn{t-imm}, rules \rn{t-swap} and \rn{t-unrst} for swapping and unrestricting, and of the rule \rn{t-block} for blocks, where variables declared $\lent$ are assigned to groups in an arbitrary way.}

{We considered two different ways to provide an algorithmic version of the type system.}

{The first way is to modify the type system as it is usually done for the subsumption rule, so that non structural rules are applied, roughly, only when needed. We did not formally develop this solution, but the technique is applied in the prototype of L42, a novel programming language designed to support massive use of libraries\footnote{Description and prototype for the full language (in progress)  can be found at \texttt{L42.is}. For testing purposes a small step reduction closely resembling the one presented in this paper is also implemented.}. The current L42 prototype  is important as proof-of-evidence that the type system presented in this paper not only can be implemented, but also smoothly integrated with other features of a realistic language. 
For testing purposes a small step reduction closely resembling the one presented in this paper is also implemented.}

{The other way is a different design of the type system based on type inference. The basic idea is to compute the sharing relations possibly introduced by the evaluation of an expression. A preliminary version of this approach is in \cite{GianniniEtAl17}.}

A  first, informal, presentation of the type modifiers in this paper has been given in \cite{ServettoEtAl13a}.
In \cite{ServettoZucca15} we have provided a formal type system including the $\capsule$ and $\lent$ modifiers, and a preliminary version of 
capsule {recovery}. In \cite{GianniniEtAl16} we have added  the immutable and readable modifiers, and the {immutability recovery}. This paper largely extends \cite{GianniniEtAl16}. The novel contributions include reduction rules, more examples, theorems about the behaviour of modifiers, and proofs of results. 
Imperative calculi where the block construct models store have been introduced  in \cite{ServettoLindsay13,CapriccioliEtAl15}, and used in \cite{ServettoZucca15,GianniniEtAl16}.

{Concerning further work, it would be interesting to investigate how to extend mainstream languages, such as, e.g., Java, with our type qualifiers, and to develop implementations of the calculus presented in this paper, possibly using, e.g., Coq, to also be able to formalize and prove properties.}

{On the more theoretical side, the first direction we plan to explore is the relation between the non-algorithmic type system presented in this paper and the previously mentioned type system based on inference of sharing relations \cite{GianniniEtAl17}}. {We also plan to formally state and prove behavioural equivalence of the calculus with the conventional imperative model.} 

{The fact that our type system tracks requirements on the type context makes it a form of \emph{coeffect type system} in the sense of \cite{PetricekEtAl14}. We plan to investigate better the relation.}
We believe that the novel operational model presented in this paper has the potential of  achieving a better understanding of aliasing.   

As a long term goal, we also plan to investigate (a form of) Hoare logic on top of our model. We believe that the hierarchical structure of our memory representation should help local reasoning, allowing specifications and proofs to mention only the relevant portion of the memory, analogously to what is achieved by separation logic \cite{Reynolds02}.
Finally, it should be possible to use our approach to enforce safe parallelism, on the lines of~\cite{GordonEtAl12,ServettoEtAl13a}.

{\paragraph{Acknowledgement} 
{We are indebted to the anonymous TCS referees for the thorough job they did reviewing our paper and for their valuable suggestions which improved it greatly.}  We also thank the ICTCS'16 referees for their helpful comments on the preliminary version of the paper.

