\section{Calculus}\label{sect:calculus}
{The calculus has a simplified syntax where we assume that, except from right-hand sides of declarations, subterms of a compound expression are only {values}. This simplification can be easily obtained by a (type-driven) translation of the syntax of \refToFigure{syntax} generating for each subterm {which is not a value} a local declaration of the appropriate type.} 

Simplified syntax and values are defined in \refToFigure{calculus}. 
\begin{figure*}
\framebox{
{\small \begin{grammatica}
\produzione{\e}{\x\mid\FieldAccess{{\val}}{\f}\mid\MethCall{{\val}}{\m}{{\vals}}\mid\FieldAssign{{\val}}{\f}{{\val}}
\mid\ConstrCall{\C}{{\vals}}\mid\Block{\decs}{\val}
}{expression}\\*
\produzione{\dec}{\Dec{\T}{\x}{\e}}{variable declaration}\\*
\\
\produzione{\T}{\Type{\mu}{\C}}{type}\\*
\produzione{\mu}{\mutable\mid\imm\mid\capsule\mid\lent\mid\readable}{type qualifier}\\*
\\
\produzione{{\valPrime,}\val}{{\x\mid\ConstrCall{\C}{\vals}\mid\Block{\dvs}{\val}}}{{value}}\\*
\\
\produzione{\dv}{\Dec{\T}{\x}{\stVal}}{evaluated declaration}\\
%\produzione{{\valPrime,}\val}{{\x\mid\ConstrCall{\C}{\vals}\mid\Block{\dvs}{\val}}}{value}\\*
\produzione{\stVal}{\ConstrCall{\C}{\xs}\mid\Block{\dvs}{\x}\mid\Block{\dvs}{\ConstrCall{\C}{\xs}}}{\storableVal}
%\produzione{\bv}{}{block value}\\
\end{grammatica} }
}
\caption{Simplified syntax and values}\label{fig:calculus}
\end{figure*}
{Syntax of evaluated declarations and right-values from \refToFigure{syntax} is reported for reader's convenience.}

A {\it value} is either a variable (reference), {or a constructor invocation}, or a {value} enclosed in a local store.

{We denote by $\FV{\e}$ the set of the free variables of expression $\e$ (the standard formal definition is in Appendix A).}

We assume the following well-formedness constraints on expressions:
\begin{enumerate}
\item In a block $\Block{\Dec{\T_1}{\x_1}{\e_1}\ldots\Dec{\T_n}{\x_n}{\e_n}}{\val}$, mutual recursion, that is, $\x_j\in\FV{\e_i}$ and $\x_i\in\FV{\e_j}$, is only allowed if both declarations are {evaluated declarations, formally defined in \refToFigure{calculus}}. Hence, as expected, cyclic stores are allowed, such as
\begin{lstlisting}
{mut C y=new C(x); mut C x=new C(y); x}
{mut C x=new C(x); x}
\end{lstlisting}
whereas cyclic expressions such as
\begin{lstlisting}
{mut C y=x.f; mut C x=new C(y); x}, 
{mut C x= x.f; x}
{mut C x=y; mut C y = x; x}
\end{lstlisting}
are ill-formed. Allowing general recursion would require a sophisticated type system, 
as in \cite{ServettoEtAl13}, but this is not the focus of this paper.
\item As already mentioned in \refToSection{typesystem}, variables of $\capsule$ types can occur at most once in their scope. \label{linearity}
This is simply a \emph{syntactic} constraint, that is, we do not 
deal with linear types and the resultant context splitting, or flow-sensitive typing judgments. For instance, the following expression, which clearly
violates the intent of the capsule and immutable qualifiers, is ill-formed:
\begin{lstlisting}
capsule C c= {new C(0)}; 
capsule D d1= {new D(c)}; 
imm D d2 = {new D(c)}; 
...
\end{lstlisting}
Note that a capsule variable is not yet determined to
become mutable or immutable when it is declared, and that determination is made at the time of its unique occurrence.
\end{enumerate}

{Evaluated declarations associate a \emph{right-value} to a variable, which plays the role of a \emph{reference}.
{Hence, they correspond to} the \emph{store} in conventional models of imperative languages.}
%{We recall that a \emph{store} is a sequence $\dvs$ of evaluated declarations, since it plays the role of the store in conventional models of imperative languages. Indeed, each $\dv$ associates a right-}value to a variable, which plays the role of a \emph{reference}. 
In \refToFigure{wellformed} we define {\em {well-formed} right-values and store}. 
\begin{figure}[ht]
\framebox{
\begin{small}
\begin{math}
\begin{array}{c}
\Rule{}{\WFrv{\ConstrCall{\C}{\xs}}}{}\Space\Space
\Rule
{\forall \Dec{\T}{\y}{\stVal}\in\dvs\ \ \WFrv{\stVal}\ }
{{\WFrv{\Block{\dvs}{{\val}}}}}
{\begin{array}{l}
\dvs\neq\epsilon\\
%\cOrx=\x\ \vee\ \cOrx=\ConstrCall{\C}{\xs}\\ 
\dvs=\Reduct{\dvs}{{\FV{{\val}}}}
\end{array}}
%\Rule{\forall \Dec{\T}{\y}{\stVal}\in\dvs\ \ \WFrv{\stVal}\ }{\WFrv{\Block{\dvs}{\x}}}{\begin{array}{l}\dvs\neq\epsilon\\ \dvs=\Reduct{\dvs}{\x}\end{array}}
%\Space\Space\Rule{\forall \Dec{\T}{\y}{\stVal}\in\dvs\ \ \WFrv{\stVal}\ }{\WFrv{\Block{\dvs}{\ConstrCall{\C}{\xs}}}}{\begin{array}{l}\dvs\neq\epsilon\\ \dvs=\Reduct{\dvs}{\xs}\end{array}}\\
\\ \\
\Rule{}{\WFdv{\Dec{\Type{\mu}{\C}}{\x}{\ConstrCall{\C}{\xs}}}}{\mu\neq\capsule}
\Space\Space\Space\Space\Space
\Rule{\WFrv{\Block{\dvs}{{\val}}}\ \ \WFdv{\dvs}}
{\WFdv{\Dec{\Type{\imm}{\C}}{\x}{\Block{\dvs}{{\val}}}}}
{\begin{array}{c}
%\dvs=\Reduct{\dvs}{\y}{\neq\emptyDvs}\\
{\allMut{\dvs}}
\end{array}
}
%\\
%\\
%\Rule{\WFdv{\dvs}}{\WFdv{\Dec{\Type{\imm}{\C}}{\x}{\Block{\dvs}{\ConstrCall{\C}{\xs}}}}}
%{\begin{array}{c}
%%\dvs=\Reduct{\dvs}{\xs}{\neq\emptyDvs}\\
%{\allMut{\dvs}}
%\end{array}
%}
\\ \\
\Rule{\WFdv{\dv}\Space\Space\WFdv{\dvs}}{\WFdv{\dv\ \dvs}}{}
\end{array}
\end{math}
\end{small}
}
\caption{Well-formed right-values and store}\label{fig:wellformed}
\end{figure}

{For a sequence of declarations $\decs=\Dec{\T_1}{\x_1}{\e_1}\ldots\Dec{\T_n}{\x_n}{\e_n}$, and a set of variables $\X$, we write $\connected{\decs}{\X}{\x}$ if $\x$ is (transitively) connected to $\X$ through $\decs$. This relation  is inductively defined as follows:
\begin{center}
$\connected{\decs}{\X}{\x}$ if $\x\in\X$\\
$\connected{\decs}{\X}{\x}$ if $\x\in\FV{\e_i}$, for some $i\in 1..n$, and $\connected{\decs}{\X}{\x_i}$.
\end{center}
The subsequence $\Reduct{\decs}{\X}$ of the declarations that are (transitively) used by $\X$ is defined by: for all $i\in 1..n$, $\Dec{\T_i}{\x_i}{\e_i}\in\Reduct{\decs}{\X}$ if  $\connected{\decs}{\X}{\x_i}$.
}
\\
We write $\allMut{\dvs}$ if, for each $\Dec{\Type{\mu}{\C}}{\x}{{\stVal}}\in\dvs$, $\mu\geq\mutable$, and $\allImm{\dvs}$ if, for each $\Dec{\Type{\mu}{\C}}{\x}{{\stVal}}\in\dvs$, $\mu=\imm$. 

Rules in the first line define well-formed right-values. 
They state that a right-value should not contain garbage and useless blocks, and that, in case it is a block, 
{the right-hand sides of declarations are, in turn, well-formed right-values.}

Rules in the second and third line define {well-formed}  evaluated declarations or stores. The first rule {states} that
a right-value which is an object state can be associated to any reference which is not $\capsule$.
The second rule {states} that a right-value which is a block can only be associated to an $\imm$ reference,
its local store should not contain $\imm$ references, and, in addition to be a well-formed
right-value, the block should contain a well-formed local store.    
The last rule states that a (non empty) sequence of evaluated declarations is a well-formed store if each one is a well-formed. 

These rules {altogether} imply that in a well-formed store:
\begin{itemize}
\item There are no $\capsule$ references. Indeed, $\capsule$ declarations are ``temporary'', that is, are expected to be consumed as soon as their right-hand side has been evaluated, as will be formalized by reduction rule \rn{capsule-elim} in \refToFigure{reduction}.
\item  There are at most \emph{two} levels, that is, the right-value of an $\imm$ reference can contain in turn a local store of non $\imm$ references. Indeed, additional levels can safely be ``flattened'', as will be formalized by reduction rules \rn{mut-move} and \rn{imm-move} in \refToFigure{reduction}.
\end{itemize}
For instance, assuming that class \lstinline{C} has two $\mutable$  fields of class \lstinline{D} and one $\imm$ of class \lstinline{C}{}, and class  \lstinline{D} has an integer field, the following is a store:
\begin{small}
\begin{lstlisting}
mut D x = new D(0);
imm D y = new D(1);
imm C z = { 
  mut D x = new D(0);
  mut D y = new D(1);
  new C(x,y,z) 
  };
\end{lstlisting}
\end{small}
Note that mutable variables in the local store of \lstinline{z}{} are not visible from the outside. 
This models in a natural way the fact that the portion of store denoted by  \lstinline{z}{} is indeed immutable

Expressions are equivalent modulo the congruence $\cong$ defined by the rules of \refToFigure{congruence}. 
\begin{center}
\begin{figure}[ht]
\framebox{
\begin{small}
\begin{math}
\begin{array}{l}
\\
\Space\Space\Space{\NamedRuleOL{alpha}{\congruence{\Block{\decs\ \Dec{\T}{\x}{\e}\ \decs'}{\val}}{{\Block{\Subst{\decs}{\y}{\x}\ \Dec{\T}{\y}{\Subst{\e}{\y}{\x}}\ \Subst{\decs'}{\y}{\x}}{\Subst{\val}{\y}{\x}}}}}{}}\Space\Space\Space
\\ \\
\Space\Space\Space\Space\Space\NamedRuleOL{reorder}{\congruence{
\Block{
\decs\ {\dv}\ \decs'
}{\val}
}{
\Block{
{\dv}\ \decs\ \decs'\ 
}{\val}
} }{}\Space\Space\Space
\\
\end{array}
\end{math}
\end{small}
}
\caption{Congruence on expressions}
\label{fig:congruence}
\end{figure}
\end{center}
Rule \rn{alpha} is the usual $\alpha$-conversion. We write $\Subst{\e}{\e'}{\x}$
for the expression obtained by replacing all (free)
occurrences of $\x$ in $\e$ by $\e'$ {(the standard formal definition is in the Appendix)}. The condition $\x,\y\not\in\dom{\decs\,\decs'}$ is implicit by well-formedness of blocks. Rule \rn{reorder} states that we can move evaluated declarations in an arbitrary order.  
On the other hand, $\decs$ and $\decs'$ cannot be swapped, since this could change 
the order of side effects. 

Values are equivalent modulo the congruence $\cong$ defined by the rules of \refToFigure{congruenceVal}. 
\begin{figure}[ht]
\framebox{
\begin{small}
\begin{math}
\begin{array}{l}
\NamedRuleOL{new}
{
\begin{array}{l}
{\ConstrCall{\C}{
  \val_1,.., \val_{i-1},\val_i,\val_{i+1},..,\val_n}}\\
  \cong{\Block{\Dec{\T_i}{\x}{{\val_i}}}{\ConstrCall{\C}{\val_1,.., \val_{i-1},\x,\val_{i+1},..,\val_n}}}
\end{array}
}
{\begin{array}{l}
\fields{\C}{=}\Field{\T_1}{\f_1}..\Field{\T_n}{\f_n}\\
\notRef{\val_i}\\
\x\not\in\FV{\val_j}\ \ (1\leq j\leq n)
\end{array}}
\\[3ex]
\NamedRuleOL{body}{\congruence{\Block{\dvs}{\Block{\dvs'\ \dvs''}{\val}}}{\Block{\dvs\ \dvs'}{\Block{\dvs''}{\val}}}}
{\begin{array}{l}
{\noCapture{\dvs}{\dom{\dvs'}}}\\
%\FV{\dvs'}\cap\dom{\dvs}=\emptyset\\
{\noCapture{\dvs'}{\dom{\dvs''}}}
%\FV{\dvs}\cap\dom{\decs}=\emptyset
\end{array}
}
\\[3ex]
{\NamedRuleOL{garbage}{\congruence{\Block{\dvs\ \dvs' }{\val}}{\Block{\dvs'}{{\val}}}}
{\noCapture{\Block{\dvs'}{\val}}{\dom{\dvs}}}}
%\FV{\Block{\decs}{\val}}\cap\dom{\dvs}=\emptyset}
\\[3ex]
\NamedRuleOL{block-elim}{\congruence{\Block{}{{\val}}}{\val}}{}
\end{array}
\end{math}
\end{small}
}
\caption{Congruence on values}
\label{fig:congruenceVal}
\end{figure}
By rule \rn{new} we can assume that arguments of a constructor invocation are references, by introducing local declarations of the appropriate type. The notation $\notRef{\val}$ means that $\val$ is not a variable. 
The following three rules deal with block values.
By rule \rn{body} we can move a sequence of evaluated declarations
from a block to the directly enclosing block, and conversely. The notation $\noCapture{\e}{\xs}$ means that free variables in $\e$ are not captured by $\xs$, formally: $\FV{\e}\cap\xs=\emptyset$, and analogously for $\noCapture{\dvs}{\xs}$. 
The two side conditions ensure that moving the declarations {$\dvs'$} does not cause either scope extrusion 
or capture of free variables. More precisely: the first condition prevents capturing with $\dvs'$ some free 
variables of the enclosing block, whereas the second prevents moving outside a declaration in $\dvs'$ which 
depends on local variables of the inner block (declared in $\dvs''$). The first side condition can be 
satisfied by $\alpha$-conversion of the inner block, whereas the second cannot. 
By rule \rn{garbage} we can remove useless local store from a block.
Finally, rule \rn{block-elim} states the obvious fact that a block with no declarations is equivalent 
to its body.

{Congruence preserves types. We have to assume that the congruent expressions be typable, since rule
\rn{garbage} eliminates declarations from blocks that without this assumption could be not typable.
\begin{proposition}\label{lemma:congruenceTypes}
Let $\TypeCheck{\Gamma}{\LentLocked}{\StronglyLocked}{\e}{{\T}}$. If $\e\cong\e'$ and for some $\Gamma'$, $\LentLocked'$, $\StronglyLocked'$ and $\T'$ we have  that $\TypeCheck{\Gamma'}{\LentLocked'}{\StronglyLocked'}{\e'}{{\T'}}$, then $\TypeCheck{\Gamma}{\LentLocked}{\StronglyLocked}{\e'}{{\T}}$
\end{proposition}
\begin{proof}
By cases on the congruence rule used. \qed
\end{proof}}

Let a {\em  well-formed value} be either a variable or a well-formed right-value.
We can show that any value is congruent to a well-formed value.
\begin{proposition}\label{lemma:congruenceValue}
Let $\val$ be a value, then either $\congruence{\val}{\x}$ for some variable $\x$, or $\congruence{\val}{\stVal}$ for some 
\storableVal\  $\stVal$ {such that $\WFrv{\stVal}$}. 
\end{proposition}
\begin{proof}
By induction on values using the congruence rule of \refToFigure{congruenceVal}.\qed
\end{proof}

The reduction relation is defined by the rules in \refToFigure{reduction}, where $\ctx$ is an {\em evaluation context} 
defined by:
\begin{center}
$\ctx ::=\emptyctx\mid\Block{\dvs\ \Dec{\T}{\x}{\ctx}\ \decs}{\val}
$
\end{center}
{In this definition, and in the following we assume that the metavariables $\val$, $\stVal$, $\dv$ and $\dvs$ denote values,  right-values, evaluated declarations, and stores which are well-formed. The assumption on $\val$ and $\stVal$ can be achieved by Proposition~\ref{lemma:congruenceValue}.}

To lighten notations, here and in what follows we sometimes use the wildcard $\_$ when a metavariable 
is not significant.

\begin{figure}[ht]
\framebox{
\begin{small}
\begin{math}
\begin{array}{l}
%\NamedRule{ctx}{\reduce{\e}{\e'}}{\reduce{\Ctx{\e}}{\Ctx{\e'}}}{}
%\Space
\NamedRuleOL{field-access}{\reduce{\Ctx{\FieldAccess{{\val}}{\f}}}
{\Ctx{\extractField{\ctx}{\val}{i}}}}{
\begin{array}{l}
{\extractType{\ctx}{\val}=\Type{\mu}{\C}}\\
\fields{\C}=\Field{\T_1}{\f_1}\ldots\Field{\T_n}{\f_n}\ \mbox{and}\  \f=\f_i
%\\ \mu=\imm\implies\isCapsule{\ctx}{\val}
\end{array}
}
\\[4ex]
\NamedRuleOL{invk}
{
\begin{array}{l}
\Ctx{\MethCall{\val}{\m}{\val_1,\ldots,\val_n}}\\
\longrightarrow
\Ctx{
\Block{
\Dec{\Type{\mu}{\C}}{\,\this}{\val}\
\Dec{\T_1}{\x_1}{\val_1}
\ldots
\Dec{\T_n}{\x_n}{\val_n}\
\Dec{\T}{\z}{\e}
}{\z}
}
\end{array}
}
{
\begin{array}{l}
{\extractType{\ctx}{\val}=\Type{\_}{\C}}\\
\method{\C}{\m}=\\
\Space \FourTuple{\T}{\mu}{\Param{\T_1}{\x_1}\ldots\Param{\T_n}{\x_n}}{\e}
\end{array}
}
\\[4ex]
{\NamedRuleOL{field-assign-prop}{\reduce{\Ctx{\FieldAssign{{\val}}{\f}{\valPrime}}}{\Ctx{\Block{\Dec{\Type{\mu}{\C}}{\x}{{\val}}\
\Dec{\T_i}{\z}{(\FieldAssign{\x}{\f}{\valPrime})}}{\z}}}}
{
\begin{array}{l}
{\notRef{\val}}, 
\typeOf{\val}=\Type{\mu}{\C}\\
\fields{\C}=\Field{\T_1}{\f_1}\ldots\Field{\T_n}{\f_n}\\
\f=\f_i
\end{array}
}}
\\[4ex]
\NamedRuleOL{field-assign}{
\begin{array}{l}
{
\Ctx{\Block{\dvs\ \Dec{\T}{\z}{\CtxP{\FieldAssign{\x}{\f}{{\valPrime}}}}\ \decs}{\val}}
}\\
\longrightarrow
{
\Ctx{\Block{{\Update{\dvs}{\x}{i}{{\valPrime}}}\ \Dec{\T}{\z}{\CtxP{{\valPrime}}}\ \decs}{\val}}
}
\end{array}
}
{
\begin{array}{l}
\dvs(\x)=\Dec{\mu}{\x}{\ConstrCall{\C}{\_}},{\mu\geq\mutable}\\
{\noCapture{\x}{\HB{\ctxP}},\noCapture{\valPrime}{\HB{\ctxP}}}\\
%(\{\x\}\cup\FV{\valPrime})\cap\HB{\ctx}=\emptyset}\\
\fields{\C}=\Field{\T_1}{\f_1}\ldots\Field{\T_n}{\f_n}\ \mbox{and}\  \f=\f_i
\end{array}
}
\\[4ex]
\NamedRuleOL{field-assign-move}
{
\begin{array}{l}
\Ctx{\Block
	{\dvs'\
		\Dec{\T'}{\z'}
		{\Block
			{\dvs\
			\Dec{\T}{\z}
			{\CtxP{\x.\f{=}{\valPrime}}
			}\
			\decs
			}
			{\val}
		}\
		\decs'
	}
	{\val'}}\\
{\longrightarrow}
	\Ctx{\Block{\dvs'\
		\dvs\
		\Dec{\T'}{\z'}
		{
		\Block{
			\Dec{\T}{\z}
			{\CtxP{\x.\f{=}{\valPrime}}
			}\
			\decs
		}
		{\val}
		}\ 
		\decs'
	}
	{\val'}	}
\end{array}
}{
\begin{array}{l}
\hspace{-.2cm}\FV{\valPrime}{\cap}\dom{\dvs}{=}\xs{\neq}\emptyset\\
\hspace{-.2cm}\noCapture{\x}{\HB{\ctxP}\cup\dom{\dvs}}\\
\hspace{-.2cm}\noCapture{\valPrime}{\HB{\ctxP}}\\
\hspace{-.2cm}{\noCapture{\Block{\dvs'\ \decs'}{\val'}}{\dom{\dvs}}}\\
\hspace{-.2cm}{\Reduct{(\dvs\ \decs)}{{\xs}}=\dvs}
\end{array}
}
\\[4ex]
\NamedRuleOL{alias-elim}{\reduce{\Ctx{\Block{\dvs\ \Dec{\T}{\x}{\y}\ \decs }{\val}}}{\Ctx{\Subst{\Block{\dvs\ \decs}{\val}}{\y}{\x}}}}
{}
\\[4ex]
\NamedRuleOL{capsule-elim}{
\begin{array}{l}
{\Ctx{\Block{\dvs\ \Dec{\Type{\capsule}
{\C}}{\x}{{\val}}\ \decs }{\val'}}}
\\ \longrightarrow
{\Ctx{\Subst{\Block{\dvs\ \decs}{\val'}}{{\val}}{\x}}}
\end{array}
}
{%\isCapsule{\Ctx{\Block{\dvs\ \Dec{\Type{\capsule}{\C}}{\x}{{\emptyctx}}\ \decs }{\val'}}}{{\val}}
}
\\[4ex]
%\NamedRuleOL{imm-right}{
%\begin{array}{l}
%\Ctx{\Block{\dvs'\ \Dec{\Type{\imm}{\C}}{\x}{\Block{\dvs}{\y}}\ \decs}{\val}}
%\\ \longrightarrow
%
%\Ctx{\Block{\dvs'\ \Dec{\Type{\imm}{\C}}{\x}{\Block{\dvs}{{\ConstrCall{\D}{\xs}}}}\ \decs}{\val}}
%\end{array}
%}
%{\dvs(\y)=\Dec{\T}{\y}{\ConstrCall{\D}{\xs}}}
%\\[4ex]
\NamedRuleOL{mut-move}{
\begin{array}{l}
{
\Ctx{\Block{\dvs'\ \Dec{\Type{\mu}{\C}}{\x}{\Block{\dvs\ \dvs''}{\val}}\ \decs'}{\val'}}
}
\\ \longrightarrow
{
\Ctx{\Block{\dvs'\ \dvs\ \Dec{\Type{\mu}{\C}}{\x}{\Block{\dvs''}{\val}}\ \decs'}{\val'}}
}
\end{array}
}{\begin{array}{l}
\mu \geq \mutable\\
{\noCapture{\Block{\dvs'\ \decs'}{\val'}}{\dom{\dvs}}}\\
%\FV{\Block{\dvs'\ \decs'}{\val'}}\cap\dom{\dvs}=\emptyset\\
{\noCapture{\dvs}{\dom{\dvs''}}}
%\FV{\dvs}\cap\dom{\decs}=\emptyset
\end{array}}
\\[4ex]
\NamedRuleOL{imm-move}{
\begin{array}{l}
{
\Ctx{\Block{\dvs'\ \Dec{\Type{\mu}{\C}}{\x}{\Block{\dvs\ \dvs''}{\val}}\ \decs'}{\val'}}
}
\\ \longrightarrow
{
\Ctx{\Block{\dvs'\ \dvs\ \Dec{\Type{\mu}{\C}}{\x}{\Block{\dvs''}{\val}}\ \decs'}{\val'}}
}
\end{array}
}{\begin{array}{l}
\mu \leq \imm, {\allImm{\dvs}}\\
%\extractMod{\dv}=\imm\ \forall \dv\in\dvs\\
{\noCapture{\Block{\dvs'\ \decs'}{\val'}}{\dom{\dvs}}}\\
%\FV{\Block{\dvs'\ \decs'}{\val'}}\cap\dom{\dvs}=\emptyset\\
{\noCapture{\dvs}{\dom{\dvs''}}}
%\FV{\dvs}\cap\dom{\decs}=\emptyset
\end{array}}
\end{array}
\end{math}
\end{small}
}
\caption{Reduction rules}
\label{fig:reduction}
\end{figure}
In rule \rn{field-access}, the type $\Type{\mu}{\C}$ of the receiver $\val$ in the context is found, fields of the class $\C$ are retrieved from the class table, it is checked that $\f$ is actually the name of a field of $\C$, say, the $i$-th field, and the field access is reduced to the $i$-th field of the receiver.
%If the qualifier $\mu$ is $\imm$, then it is checked that the receiver is a $\capsule$. 
%\MSComm{it seams disaligned with the rule, where there is no capsule checking}
%The judgment $\isCapsule{\ctx}{\val}$ holds if, for all $\x\in\FV{\val}$, {$\extractDec{\ctx}{\x}=\Dec{\Type{\imm}{\_}}{\x}{\_}$}

The auxiliary functions $\aux{type}$ and $\aux{get}$ extract the type, and the $i$-th field, respectively, of a value in a context (only needed when the value is a reference). In the definitions, by Proposition~\ref{lemma:congruenceValue}, we assume that values are either references or \storableVals.
{\begin{small}
\begin{quote}
$\extractType{\ctx}{\x}=\T$ if $\extractDec{\ctx}{\x}=\Dec{\T}{\x}{{\_}}$ \\
$\extractType{\ctx}{\stVal}=\typeOf{\stVal}$\\
$\typeOf{\ConstrCall{\C}{\xs}}=\typeOf{\Block{\dvs}{\ConstrCall{\C}{\xs}}}=\Type{\mutable}{\C}$\\
$\typeOf{\Block{\dvs}{\x}}=\T$ if $\dvs(\x)=\Dec{\T}{\x}{{\_}}$\\
\\
$\extractField{\ctx}{\x}{i}=\fieldOf{{\stVal}}{i}$ if $\extractDec{\ctx}{\x}=\Dec{\_}{\x}{{\stVal}}$\\
$\extractField{\ctx}{\stVal}{i}=\fieldOf{\stVal}{i}$\\
{$\fieldOf{\ConstrCall{\C}{\x_1,\ldots,\x_n}}{i}=\x_i$}\\
{$\fieldOf{\Block{\dvs}{\ConstrCall{\C}{\x_1,\ldots,\x_n}}}{i}=\Block{\dvs}{\x_i}$}\\
{$\fieldOf{\Block{\dvs}{\x}}{i}=\Block{\dvs}{\val}$ if $\dvs(\x)=\Dec{\_}{\x}{\stVal}$ and $\fieldOf{\stVal}{i}=\val$}
\\
$\extractDec{\Block{\dvs\ \Dec{\T}{\_}{\ctx}\ \decs}{\val}}{\x}=\begin{cases}
\extractDec{\ctx}{\x}&\mbox{if}\ \extractDec{\ctx}{\x}\ \mbox{defined, otherwise}\\
\dvs(\x)&\mbox{if}\ \dvs(\x)\ \mbox{defined}
\end{cases}$
\end{quote}
\end{small}}
Note that a field access $\FieldAccess{\x}{\f}$, if $\x$ has qualifier $\geq\mutable$,  always returns a reference, since the right-value of $\x$ is necessarily an object state.
If $\x$ is immutable, instead, the field access could return a (copy of) the value stored in the field. This duplication preserves the expected semantics in the case of an immutable reference $\x$, whereas it would be wrong for a mutable reference, since a modification of the object denoted by $\x$ is expected to affect $\FieldAccess{\x}{\f}$ as well, and conversely.

For instance, given the value:
\begin{quote}
$\val=$
\Q@{mut C x=new C(x,y,z); mut D y=new D(0); new C(x,y,z) }@
\end{quote}
we have:
\begin{enumerate}
\item $\fieldOf{\val}{1}=$
\Q@{mut C x=new C(x,y,z); mut D y=new D(0); x }@
\item $\fieldOf{\val}{2}=$
\Q@{mut C x=new C(x,y,z); mut D y=new D(0); y}@
\item $\fieldOf{\val}{3}=$
\Q@{mut C x=new C(x,y,z); mut D y=new D(0); z}@
\end{enumerate}
where 1 is a well-formed value, 2 is congruent by rule \rn{garbage} to the  well-formed value
\Q@{mut D y=new D(0)   y}@, and 3 is congruent by rules \rn{garbage} and \rn{block-elim}, to the well-formed value \Q@z@.

If the value $\val$ above is the right-value of a reference, then such reference is necessarily $\imm$. In this case, $\val$ 
was expected to be a capsule, the variable $\z$ should be declared $\imm$ in the enclosing context.


In rule \rn{invk}, the class $\C$ of the receiver $\val$ is found, and method $\m$ of $\C$ is retrieved from the class table. The call is reduced to a block where declarations of the appropriate type for $\this$, the parameters, and the result are initialized with the receiver, the arguments, and the method body, respectively. The last declaration, variable $\z$, is
 needed to preserve the simplified syntax.

Rule \rn{field-assign-prop} handles the case of a field assignment where the receiver is not a reference (denoted $\notRef{\val}$). In this case, a local reference initialized with the receiver is introduced, and the field access is propagated to such reference. 

In rule \rn{field-assign}, given a field assignment where the receiver is a reference $\x$, the first enclosing declaration for $\x$ is found (the side condition {$\noCapture{\x}{\HB{\ctxP}}$} ensures that it is actually the first), it is checked that the qualifier of the type of $\x$ is $\geq\mutable$, and fields of the class $\C$ of $\x$ are retrieved from the class table. If $\f$ is the name of a field of $\C$, say, the $i$-th, then the $i$-th field of the right-value of $\x$ is updated to $\valPrime$, which is also the result of the field assignment. 
We write $\HB{\ctx}$ for the \emph{hole binders} of $\ctx$, that is, the variables declared in blocks enclosing the
context hole (the standard formal definition is in the Appendix) and $\Update{\dvs}{\x}{i}{{\valPrime}}$ for the sequence of evaluated declarations obtained from $\dvs$ by replacing the $i$-th field of the right-value of $\x$ with ${\valPrime}$ (the obvious formal definition is omitted).

The side condition {$\noCapture{\valPrime}{\HB{\ctxP}}$}, requiring that there are no inner declarations for some free variable in $\valPrime$, prevents scope extrusion. For instance, without this side condition, the term

\begin{small}
\begin{lstlisting}
mut C x= new C(...);
imm C z= { 
  mut D y1= new D(0);
  mut D y2= ( x.f = y1);
  mut D y3= new D(1);
  new C(y3) };
x
\end{lstlisting}
\end{small}

would erroneously reduce to 

\begin{small}
\begin{lstlisting}
mut C x= new C(y1); 
imm C z= { 
  mut D y = new D(0);
  mut D y2= y1;
  mut D y3= new D(1);
  new C(y3) };
x
\end{lstlisting}
\end{small}
Thanks to the side condition, instead, rule \rn{field-assign} is not applicable. However, 
rule \rn{field-assign-move} can be applied.

Rule \rn{field-assign-move} moves store out of a block when this is needed to safely perform field-assignment (that is, to avoid scope extrusion).
In this rule,  given a field assignment of shape $\FieldAssign{\x}{\f}{\valPrime}$, the first enclosing block containing (evaluated) declarations for some free variables $\xs$  of $\valPrime$ is found (the side condition {$\noCapture{\valPrime}{\HB{\ctxP}}$} ensures that it is actually the first). If a declaration for $\x$ can only be found in an outer scope (side condition {$\noCapture{\x}{\HB{\ctxP}\cup\dom{\dvs}}$}), then the store formed by the $\xs$ references, together with all the other references they (recursively) depend on (last side condition) is moved to the directly enclosing block.

For the example above, by applying rule \rn{field-assign-move} we get:

\begin{small}
\begin{lstlisting}
mut C x = new C(...)  
mut D y1 = new D(0)
imm C z = { 
  mut D y2 = ( x.f = y1)
  mut D y3 = new D(1)
  new C(y3) }  
x
\end{lstlisting}
\end{small}
Now, rule \rn{field-assign} can be safely applied to the term.
In general, we may need to apply rule \rn{field-assign-move} many times before reaching the declaration of $\x$. 


The remaining rules handle blocks.

The first two rules eliminate a single declaration of shape $\Dec{\T}{\x}{\val}$ which is \emph{not} well-formed store. 

 In rule \rn{alias-elim}, a reference $\x$ which is initialized as an alias\footnote{{An analogous rule would handle variables of primitive types in an extension of the calculus including such types.}} of another reference $\y$ is eliminated by replacing all its occurrences.
 
In rule \rn{capsule-elim}, a $\capsule$ reference $\x$ is eliminated by replacing the occurrence of $\x$ (unique by the well-formedness constraint) by its value. %, which is checked to be a capsule.
Note that, in rule \rn{alias-elim}, $\y$ cannot be a $\capsule$ reference (since we would have applied rule \rn{capsule-elim} before), hence  duplication of $\capsule$ references cannot be introduced{, and well-formedness is preserved.} 

Rule \rn{mut-move} moves store out of a block associated to a {reference with qualifier $\geq\mutable$}. 
This is always safe, provided that no variables of the outer scope are captured (second side condition, which can be obtained by $\alpha$-renaming), and that the moved declarations do not refer to other declarations of the inner block (last side condition). 

Rule \rn{imm-move} moves store out of a block associated to a {reference with qualifier $\leq\imm$}. In this case, this is only safe for a store of $\imm$ references. The same side conditions of the previous rule are needed.









