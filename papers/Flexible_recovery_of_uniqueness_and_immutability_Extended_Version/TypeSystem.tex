\section{Type system}\label{sect:typesystem}
Type contexts are defined by:
\begin{center}
\begin{grammatica}
\produzione{\Delta}{\Gamma;\LentLocked;\StronglyLocked}{type context}\\*
\produzione{\Gamma}{\TypeDec{\T_1}{\x_1},\ldots,\TypeDec{\T_n}{\x_n}}{type assignment}
\end{grammatica}
\end{center} 
{In a type context $\Delta=\Gamma;\LentLocked;\StronglyLocked$, $\Gamma$ is a usual {\em assignment of types} to variables. We write $\dom{\Gamma}$ for the set of variables in $\Gamma$, and  $\SubstFun{\Gamma}{\Gamma'}$ for the concatenation of $\Gamma$ and $\Gamma'$ where, for the variables occurring in both domains, $\Gamma'$ takes precedence.  We will also use $\domMut{\Gamma}$ for the set of mutable variables in $\Gamma$, and other analogous notations.}

{According to our convention, $\LentLocked$ is a sequence $\xs_1\ldots\xs_n$ of sequences of variables, and $\StronglyLocked$ is a sequence of variables. All such sequences are assumed to be sets (that is, order and repetitions are immaterial). The sets  $\xs_1\ldots\xs_n$ are assumed to be pairwise disjoint, and are called \emph{{lent group}s}, whereas the $\mutable$ variables in $\Gamma$ which do not belong to any lent group form the \emph{{mutable group}}. Finally, variables in $\ys$ are called \emph{restricted} variables.}

{Lent groups and restricted variables are the key novelty of our type system.
%, hence we roughly explain their role, which will be formally detailed in the following. 
The property they ensure is that, if $\TypeCheck{\Gamma}{\LentLocked}{\StronglyLocked}{\e}{\T}$, then the final result of $\e$ will be not connected to variables which are in $\LentLocked$ or $\StronglyLocked$. In this way, to ensure that the final result of $\e$ is an isolated portion of store, it is enough to typecheck $\e$ in a type context where all its free mutable variables are in a {lent group} or restricted.  This is a crucial improvement with respect to previous mechanisms of recovery \cite{GordonEtAl12,ClebschEtAl15}, where this could be only ensured if  $\e$ had \emph{only} immutable or isolated ($\capsule$ in our teminology) free variables. 
We have distinct {lent group}s $\xs_1\ldots\xs_n$ since there can be nested recoveries, hence, to ensure that all are safe, we need also the auxiliary property that no aliasing is introduced between different groups, as will be illustrated in detail by the last example of \refToSection{examples}. That is, if the reachable graphs of $\xs_i$ and $\xs_j$ were disjoint before the evaluation of the expression, then after the evaluation they should be still disjoint.\footnote{Note that this is different from \emph{regions} as in, e.g., \cite{BocchinoEtAl09,HallerOdersky10}, which are sets of references \emph{assumed} to be disjoint.}} 

{The type system ensures the above properties by imposing that variables in $\LentLocked$ and $\StronglyLocked$ are used in controlled way:
\begin{itemize}
\item A $\mutable$ variable in $\Gamma$ which belongs to a {lent group} $\xs_i$ can only be used as $\lent$. Notably, write access is not directly allowed since it could introduce aliasing.
\item A $\readable$, $\lent$ or $\mutable$ variable in $\Gamma$ which is restricted cannot be used at all, that is, is hidden.\footnote{{However, we use the terminology ``restricted'' since this hiding is non permanent.}}
\end{itemize}
The important point is that such constraints are not imposed once and for all when typechecking an expression. That is, a subexpression can be typechecked with different {lent group}s and restricted variables, more precisely:
\begin{itemize}
\item In a subexpression we can \emph{swap} one of the {lent group}s $\xs_i$ with the {mutable group}, weakening to $\lent$ the type of the subexpression if it was mutable. 
In this way, write access to variables in $\xs_i$ is allowed, but this is safe since the result of the subexpression is in turn $\lent$, so no aliasing can be introduced with the result of the main expression. 
\item In a subexpression we can \emph{unrestrict} variables in $\ys$, that is, freely use such variables, provided that the type of the subexpression is $\imm$ or $\capsule$.  Again this guarantees that no aliasing can be introduced with the result of the main expression.
\end{itemize} }

Lent groups and restricted variables are introduced as an effect of applying \emph{recovery} rules \rn{t-capsule} and \rn{t-imm}, whereas swapping and unrestricting are obtained by applying rules \rn{{t-swap}} and \rn{t-unrst} rules, as will be explained in detail later. 


Contexts $\Delta=\Gamma;\LentLocked;\StronglyLocked$ are \emph{well-formed}, written $\WellFormedTypeCtx{\Delta}$, 
if, for $\LentLocked=\xs_1\ldots\xs_n$, the following conditions hold:
\begin{itemize}
\item no variable is $\lent$  in $\Gamma$
\item if  $\x\in\xs_i$ for some $i\in 1..n$,  then $\x$ is $\mutable$ in $\Gamma$
\item if $\y\in\StronglyLocked$, then  $\y$ is $\mutable$ or $\readable$  in $\Gamma$
\item if $\y\in\StronglyLocked$ and is $\mutable$ in $\Gamma$, then $\y\in\xs_i$ for some $i\in 1..n$.
%and, for all $\x\in\xs_i$, $\x\in\StronglyLocked$
\end{itemize}
We do not consider $\lent$ variables in $\Gamma$ since assigning the type $\Type{\lent}{\C}$ to a variable $\x$  is encoded by assigning to $\x$ the type $\Type{\mutable}{\C}$ and having $\x$ in a lent group in $\LentLocked$ (see the explanation of rule \rn{t-block} in the following). The  last condition requires \emph{coherency} between $\LentLocked$ and $\StronglyLocked$, that is, restricted mutable variable are in a lent group. It is easy to check that well-formedness of contexts is preserved in type derivations. That is, if $\Delta\TypeCheckGround{\e}{\T}$ and ${\Delta}$ is well-formed, then in all sub-derivations the contexts are well-formed. In the following when we write 
$\Delta\TypeCheckGround{\e}{\T}$ we assume that ${\Delta}$ is well-formed.

In the rules we use information extracted from the class table, which is modelled, as usual, by the following functions:{
\begin{itemize}
\item $\fields{\C}$ gives, for each declared class $\C$, the sequence of its fields declarations
\item {$\method{\C}{\m}$ gives, for each method $\m$ declared in class $\C$, the tuple\\
 $\FourTuple{\T}{\mu}{\Param{\T_1}{\x_1}\ldots\Param{\T_n}{\x_n}}{\e}$ consisting of its return type, type qualifier for $\this$, parameters, and body. }
\end{itemize}
We assume method bodies to be well-typed w.r.t.\ {the type annotations in the method declaration}. More precisely, if
%\begin{quote}
%$\method{\C}{\m}=\FourTuple{\T}{\mu}{\Param{\T_1}{\x_1}\ldots\Param{\T_n}{\x_n}}{\e}$
%\end{quote}
%then $\e$ should be well-typed in a type context where parameters declared $\lent$, including the implicit parameter $\this$, have been encoded by singleton lent groups, expressing the requirement that they should not be aliased by the method. Formally, it should be
%\begin{quote}
%$\TypeCheck{\Gamma}{\{\x_i\mid T_i=\Type{\lent}{\C_i}\}\cup\{\this\mid\mu=\lent\}}{\emptyset}{\e}{\T}$
%\end{quote}
%with $\Gamma=\TypeDec{\Type{\mu'}{\C}}{\this}, \TypeDec{\T'_1}{\x_1},\ldots,\TypeDec{\T'_n}{\x_n}$, where $\T_i=\Type{\mutable}{\C_i}$ if $\T_i=\Type{\lent}{\C_i}$, $\T'_i=\T_i$ otherwise, and $\mu'=\mutable$ if $\mu=\lent$, $\mu'=\mu$ otherwise. 
{\begin{quote}
$\method{\C}{\m}=\FourTuple{\T}{\mu}{\Param{\T_1}{\x_1}\ldots\Param{\T_n}{\x_n}}{\e}$
\end{quote}
then 
\begin{quote}
$\TypeCheck{\Gamma}{\LentLocked}{\emptyset}{\e}{\T}$
\end{quote}
where $\LentLocked$ {consists of} the singletons of the parameters declared $\lent$, including the implicit parameter $\this$, expressing the requirement that they should not be aliased by the method, and $\Gamma=\TypeDec{\Type{\mu'}{\C}}{\this}, \TypeDec{\T'_1}{\x_1},\ldots,\TypeDec{\T'_n}{\x_n}$, where $\T_i=\Type{\mutable}{\C_i}$ if $\T_i=\Type{\lent}{\C_i}$, $\T'_i=\T_i$ otherwise, and $\mu'=\mutable$ if $\mu=\lent$, $\mu'=\mu$ otherwise. 
}

Typing rules are given in \refToFigure{typing}. {In the typing rules, when we need to make explicit the mutable group, we use the  auxiliary judgment $\AuxTypeCheck{\Gamma}{\LentLocked}{\MutGroup}{\StronglyLocked}{\e}{\T}$, which stands for the judgment 
$\TypeCheck{\Gamma}{\LentLocked}{\StronglyLocked}{\e}{\T}$ with the side condition $\MutGroup=\domMut{\Gamma}{\setminus}\LentLocked$, meaning that $\MutGroup$ are the $\mutable$ variables in $\Gamma$ which do not belong to {any lent} group in $\LentLocked$.}

\begin{figure}[ht!]
\framebox{
\begin{footnotesize}
\begin{math}
\begin{array}{l}
\NamedRule{t-capsule}{\AuxTypeCheck{\Gamma}{\LentLocked\ {\xs}}{{\emptyset}}{\StronglyLocked}{\e}{\Type{\mutable}{\C}}}{{\AuxTypeCheck{\Gamma}{\LentLocked}{\MutGroup}{\StronglyLocked}{\e}{\Type{\capsule}{\C}}}}\\
\Space
%{\xs=\domMut{\Gamma}{\setminus}\LentLocked}
\NamedRule{t-imm}{
\AuxTypeCheck{\Gamma}{\LentLocked\ \xs}{{\emptyset}}{\domGeqMut(\Gamma) }{\e}{\Type{\readable}{\C}}
}{
{\AuxTypeCheck{\Gamma}{\LentLocked}{\xs}{\StronglyLocked}{\e}{\Type{\imm}{\C}}}
}{
%{\xs=\domMut{\Gamma}{\setminus}\LentLocked}
}
\\[5ex]
\NamedRule{{t-swap}}{\AuxTypeCheck{\Gamma}{\LentLocked\ \xs'}{\xs}{\StronglyLocked}{\e}{{\T}}}{{\AuxTypeCheck{\Gamma}{\LentLocked\ \xs}{\xs'}{\StronglyLocked}{\e}{{\TPrime}}}}{
%{\xs'=\domMut{\Gamma}{\setminus}(\LentLocked\ \xs)}\\
{\xs\cap\ys}=\emptyset\\
{\TPrime=
\begin{cases}
\Type{\lent}{\C}&\mbox{if}\ \T=\Type{\mutable}{\C}\\
\T&\mbox{otherwise}
\end{cases}}
}
\\[5ex]
\NamedRule{t-{unrst}}{
\TypeCheck{\Gamma}{\LentLocked}{\emptyset}{\e}{{\T}}
}{
\TypeCheck{\Gamma}{\LentLocked}{\StronglyLocked}{\e}{{\T}}
}{{\T=\Type{\mu}{\C}\Longrightarrow\mu\leq\imm}}
\Space
\NamedRule{t-sub}{\TypeCheckShort{\Delta}{\e}{\T}
}{
\TypeCheckShort{\Delta}{\e}{\TPrime}}{
\T\leq\TPrime
}
\\[5ex]
{\NamedRule{t-var}{}{\TypeCheck{\Gamma}{\LentLocked}{\StronglyLocked}{\x}{\TPrime}}{
\Gamma(\x)=\T\ \wedge \ 
\x\notin\StronglyLocked\\
\TPrime=
\begin{cases}
\Type{\lent}{\C}&\mbox{if}\ \T{=}\Type{\mutable}{\C}\,\wedge\,\x\in\LentLocked\\
\T&\mbox{otherwise}
\end{cases}
}}
\\[6ex]
{\NamedRule{t-field-access}{\TypeCheckShort{\Delta}{\e}{\Type{\mu}{\C}}}{\TypeCheckShort{\Delta}{\FieldAccess{\e}{\f_i}}{\TPrime_i}}{
\fields{\C}=\Field{\T_1}{\f_1}\ldots\Field{\T_n}{\f_n}\\
\TPrime_i=\begin{cases}
\Type{\mu}{\C_i}\ \mbox{if}\ \T_i=\Type{\mutable}{\C_i}\\
\T_i\ \mbox{otherwise}
\end{cases}
}}
\\[5ex]
\NamedRule{t-meth-call}{\TypeCheckShort{\Delta}{\e_i}{\T_i}\Space\forall i\in 0..n}{\TypeCheckShort{\Delta}{\MethCall{\e_0}{\m}{\e_1,\ldots,\e_n}}{\T}}{
\begin{array}{l}
\T_0=\Type\mu\C\\
\method{\C}{\m}=\FourTuple{\T}{\mu}{\Param{\T_1}{\x_1}\ldots\Param{\T_n}{\x_n}}{\e}
\end{array}
}
\\[5ex]
\NamedRule{t-field-assign}{
  \TypeCheckShort{\Delta}{\e}{\Type{\mutable}{\C}}
  \Space
  \TypeCheckShort{\Delta}{\e'}{\T_i}
  }{
  \TypeCheckShort{\Delta}{\FieldAssign{\e}{\f_i}{\e'}
  }{\T_i}
  }{
  {\fields{\C}=\Field{\T_1}{\f_1}\ldots\Field{\T_n}{\f_n}}
  }
\\[5ex]
\NamedRule{t-new}{\TypeCheckShort{\Delta}{\e_i}{\T_i}\Space\forall i\in 1..n}{\TypeCheckShort{\Delta}{\ConstrCall{\C}{\e_1,\ldots,\e_n}}{\Type{\mutable}{\C}}}{
\fields{\C}=\Field{\T_1}{\f_1}\ldots\Field{\T_n}{\f_n}\\
}
\\[5ex]
{\NamedRule{t-block}{
{\AuxTypeCheck{\SubstFun{\Gamma}{\TypeEnv{\decs}}}{\LentLocked_i}{\MutGroup_i}{\StronglyLocked'}{\e_i}{\TypeEnv{\decs}(\x_i)}\ \ {\forall i\in 1..n}}\\
\AuxTypeCheck{\SubstFun{\Gamma}{\TypeEnv{\decs}}}{\LentLocked'}{{\MutGroup'}}{\StronglyLocked'}{\e}{\T}}
{\AuxTypeCheck{\Gamma}{\LentLocked}{\MutGroup}{\StronglyLocked}{\Block{\decs}{\e}}{\T}}{
\begin{array}{l}
\decs=\Dec{\T_1}{\x_1}{\e_1}\ldots\Dec{\T_n}{\x_n}{\e_n}\\
\LessEq{(\LentLocked{\setminus}\dom{\decs})}{\LentLocked'}\\
(\MutGroup{\setminus}\dom{\decs})\subseteq\MutGroup'\\
\forall i\in 1..n\ \LentLocked_i\ \MutGroup_i = \LentLocked'\ \MutGroup'\\
\Space \mbox{and}\ \x_i\in\domMut{\TypeEnv{\decs}}\Rightarrow\x_i\in \MutGroup_i\\
\StronglyLocked'={\StronglyLocked}{\setminus}{\dom{\decs}}
\end{array}}}
\end{array}
\end{math}
\end{footnotesize}
}
\caption{Typing rules}\label{fig:typing}
\end{figure}
 
Rules \rn{t-{capsule}} and \rn{t-{imm}} 
 model \emph{recovery},
 that is, can be used to recover a more specific type for an expression,
 under the conditions that the use of some free variables in the expression is} {controlled}.
There are two kinds of recovery:
\begin{itemize}
\item $\mutable\Rightarrow\capsule$
\\* As shown in rule \rn{t-{capsule}}, an expression can be typed $\capsule$ in $\Gamma;\LentLocked;\StronglyLocked$ if it can be typed $\mutable$ by turning in lent the mutable group ($\xs$), which becomes empty.
Formally, this group is added to $\LentLocked$.  
\item $\readable\Rightarrow\imm$ 
\\*As shown in rule \rn{t-{imm}}, an expression can be typed $\imm$ in $\Gamma;\LentLocked;\StronglyLocked$  if it can be typed $\readable$ by {turning in lent the mutable group ($\xs$)}, as in the {recovery} above, and, moreover, restricting currently available mutable, lent, and readable variables ($\domGeqMut(\Gamma)$).
\end{itemize}

Along with {recovery} rules which introduce {lent group}s and restricted variables, we have two corresponding elimination rules.
In the detail:
\begin{itemize}
\item\rn{{t-swap}}
\\* An expression can be typed in $\Gamma;\LentLocked\ \xs;\StronglyLocked$ if it can be typed by turning into mutable 
some {lent group} {($\xs$)}, by swapping this group with the {current mutable group}  ($\xs'$). {The side condition $\xs\cap\ys=\emptyset$ prevents to swap a lent group including restricted variables.}
The type obtained in this way is weakened to $\lent$, if it was $\mutable$.
\item
\rn{t-unrst} 
\\* An expression can be typed in $\Gamma;\LentLocked;\StronglyLocked$ if it can be typed by unrestricting all restricted variables {$\StronglyLocked$}, provided that the type obtained in this way is $\capsule$ or $\imm$ {or a primitive type}.
\end{itemize}

{Note that, without these last two rules, recovery rules would be essentially equivalent to those in prior work \cite{GordonEtAl12,ClebschEtAl15}. Rules \rn{t-swap} and \rn{t-unrst}  add power to the type system, and they are also the reason {it} requires the $\LentLocked$ and $\StronglyLocked$ information during typechecking.
Prior work \cite{GordonEtAl12,ClebschEtAl15} can afford to simply locally using weakening and subtyping to make references inaccessible
or convert $\mutable$ references to $\lent$.}

{Note also that recovery rules, \rn{t-swap}, and \rn{t-unrst}  are not syntax-directed, analogously to the subsumption rule. 
In other words, their functionality does not  restrict how code is written: they are \emph{transparent} to the programmer, in the sense that they are applied when needed.  The programmer can simply rely on the fact that expressions are $\capsule$ or $\imm$, respectively, in situations where this is intuitively expected, as we illustrate by the following examples (other will be provided in next section).}

{We explain now in detail how recovery, swapping and unrestricting work, then comment the other rules.}

\paragraph{Capsule {recovery}} Let us discuss, first, when an expression can be safely typed $\capsule$. {The evaluation of the expression should produce a portion of store which is isolated, apart from external immutable references, formally a right-value where all free variables are immutable. Obviously, this is safe for an expression which has itself no free variables, or where all the free variables are {$\imm$ or $\capsule$}, and, indeed, this was the requirement needed for obtaining {recovery} in previous work \cite{GordonEtAl12}.} However, this requirement is too strong. 
Consider the following sequence of declarations:\label{capsule-example-2}

\begin{lstlisting}
mut D y=new D(0); 
capsule C z={mut D x=new D(y.f); new C(x,x)};  
\end{lstlisting}

The inner block (right-hand side of the declaration of \Q@z@) {can} be typed $\capsule$, even though there is a mutable free variable \Q@y@, since this variable is only used in a field access, hence, intuitively, no aliasing is introduced between \lstinline{y}{} and the final result of the block. 
Indeed, the block reduces\footnote{As formalized in \refToSection{calculus}.} to 
\begin{lstlisting} 
{mut D x=new D(0); new C(x,x)};  
\end{lstlisting}
which is closed.
%, that is, has no free variables. 
To allow such typing, the inner block is {typed} applying rule \rn{t-capsule}, since it can be typechecked $\mutable$ in a type context where variable \lstinline{y}{} is $\lent$. In \refToFigure{TypingOne} we show the type derivation for this example,
{where, for clarity, we always write the mutable group even when it is empty.}
%We use $\deriv$ as a metavariable to denote derivations.
\begin{figure}[t]
\framebox{
\begin{footnotesize}
\begin{math}
\begin{array}{l}
\\
\infer[\scriptstyle{\textsc{(t-capsule)}}]
{\TypeCheck{\Gamma}{\emptyset\ [\texttt{y}]}{\emptyset}{\texttt{\{mut D x=new D(y.f); new C(x,x)\}}}{\Type{\capsule}{\C}}}
{
\infer[\scriptstyle{\textsc{(t-block)}}]
{\TypeCheck{\Gamma}{\texttt{y}\ [\emptyset]}{\emptyset}{\texttt{\{mut D x=new D(y.f); new C(x,x)\}}}{\Type{\mutable}{\C}}}
{
%\infer[\scriptstyle{\textsc{(t-sub)}}]
%{ \TypeCheck{\Gamma'}{\texttt{y}}{\emptyset}{\texttt{new D(y.f)}}{\Type{\lent}{\texttt{D}}}      }
{
\infer[\scriptstyle{\textsc{(t-new)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{new D(y.f)}}{\Type{\mutable}{\texttt{D}}}}
{
\infer[\scriptstyle{\textsc{(t-field-access)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{y.f}}{\intType}}
{
\infer[\scriptstyle{\textsc{(T-var)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{y}}{\Type{\lent}{\texttt{D}}}}{} 
}
}
}
&
\infer[\scriptstyle{\textsc{(T-New)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{new C(x,x)}}{\Type{\mutable}{\texttt{C}}}}
{
\infer[\scriptstyle{\textsc{(T-var)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{x}}{\Type{\mutable}{\texttt{D}}}}
{} 
}
}
}
\\
\\
\Gamma=\texttt{y}{:}\Type{\mutable}{\texttt{D}},\texttt{z}{:}\Type{\capsule}{\texttt{C}}\\
\Gamma'=\SubstFun{\Gamma}{\texttt{x}{:}\Type{\mutable}{\texttt{D}}}=\texttt{y}{:}\Type{\mutable}{\texttt{D}},\texttt{z}{:}\Type{\capsule}{\texttt{C}},\texttt{x}{:}\Type{\mutable}{\texttt{D}}
\end{array}
\end{math}
\end{footnotesize}
}
\caption{Example of type derivation (1)}\label{fig:TypingOne}
\end{figure}

{Note that in an analogous example where the field of class \lstinline{D} has a non primitive type, e.g., \lstinline{String}:}
\begin{lstlisting}
mut D y=new D("hello"); 
capsule C z={mut D x=new D(y.f); new C(x,x)};  
\end{lstlisting}
{the qualifier of the field should be $\imm$, since, otherwise, by introducing a singleton {lent group} \lstinline{y} we would get a $\lent$ type for \lstinline{y.f} as well, see rule \rn{t-field-access}, and a $\lent$ type is not accepted for a constructor argument.}

As a counterexample, consider the following sequence of declarations:
\begin{lstlisting}
mut D y=new D(0); 
capsule C z={mut D x=y; new C(x,x)};  
\end{lstlisting}
Here the inner block cannot be typed $\capsule$, since \Q@y@ is internally aliased. Indeed, the block reduces to \Q@new C(y,y)@ which contains a free mutable variable.
Formally, we cannot apply rule \rn{t-capsule} on the block, since
we should typecheck the block with \Q@y@ in a singleton {lent group}, while the initialization expression of \lstinline{x} should be mutable, see rule \rn{t-block}.

Rule \rn{t-field-assign} requires a mutable type for the receiver.
So, how is it possible to modify (the portion of store denoted by) a $\lent$ reference?
Consider the following simple example:
\begin{lstlisting}
lent D y= new D(0);
y.f=y.f+1;
\end{lstlisting}

This code should be well-typed, since the assignment does not introduce any alias. {To get such typing, we use rule \rn{t-swap} to type the expression
\Q@y.f=y.f+1@. {Indeed, we can} swap the singleton {lent group} \Q@y@ with the empty set.

Moreover, swapping can be applied to achieve {recovery}. Take
the example already considered at page \pageref{capsule-example-1}:
\begin{lstlisting}
mut D y=new D(0); 
capsule C z={mut D x=new D(y.f=y.f+1); new C(x,x)}
\end{lstlisting}
Let $\e$ be the inner block (right-hand side of the declaration of \Q@z@). As in the first example, $\e$ can be typed $\capsule$ if it can be typed \Q@mut@ in a context with type assignment $\texttt{y}{:}\Type{\mutable}{\texttt{D}},\texttt{z}{:}\Type{\capsule}{\texttt{C}}$ and
the {lent group} \Q@y@. However, the assignment \Q@y.f=y.f+1@
is not well-typed in this type context, since the variable \Q@y@ has type \Q@lent D@. However, intuitively, we can see that the assignment does not introduce any alias between \Q@y@ and the final result of $\e$, since it involves only variables which are in the same group (the
singleton \Q@y@), and produces {a result which is not mutable}. {In other words, the result of the evaluation of $\e$ is a capsule, as it has been shown in \refToFigure{esRed2}, so it should be possible to
{type} the expression $\e$ {as} $\capsule$.} 

To {get} such typing, we can apply rule \rn{t-swap} when deriving the type for the subexpression \Q@y.f=y.f+1@, by swapping the group \Q@y@ with the group \Q@x@. 
This ensures that the evaluation of the subexpression typed by this rule will not introduce any alias between the
variables in the swapped group and the mutable group. {The type derivation for the example is given in \refToFigure{TypingTwo}.}
 \begin{figure}[t]
 \framebox{
\begin{footnotesize}
\begin{math}
\begin{array}{l}
\infer[\scriptstyle{\textsc{(t-capsule)}}]
{\TypeCheck{\Gamma}{\emptyset\ [\texttt{y}]}{\emptyset}{\texttt{\{mut D x=new D(y.f=y.f+1); new C(x,x)\}}}{\Type{\capsule}{\texttt{C}}}}
{
\infer[\scriptstyle{\textsc{(t-block)}}]
{\TypeCheck{\Gamma}{\texttt{y}\ [\emptyset]}{\emptyset}{\texttt{\{mut D x=new D(y.f=y.f+1); new C(x,x)\}}}{\Type{\mutable}{\texttt{C}}}
}
{
\infer[\scriptstyle{\textsc{(T-New)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{new C(x,x)}}{\Type{\mutable}{\texttt{C}}}}
{
\infer[\scriptstyle{\textsc{(T-var)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{x}}{\Type{\mutable}{\texttt{D}}}}{}
}
&
\hspace{-1cm}
\infer[\scriptstyle{\textsc{(T-New)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{new D(y.f=y.f+1)}}{\Type{\mutable}{\texttt{D}}}}
{
\infer[\scriptstyle{\textsc{(t-swap)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\emptyset}{\texttt{y.f=y.f+1}}{\intType}}
{
\infer[\scriptstyle{\textsc{(t-fld-ass)}}]
{\TypeCheck{\Gamma'}{\texttt{x}\ [\texttt{y}]}{\emptyset}{\texttt{y.f=y.f+1}}{\intType}}
{
\infer[\scriptstyle{\textsc{(T-var)}}]
{\TypeCheck{\Gamma'}{\texttt{x}\ [\texttt{y}]}{\emptyset}{\texttt{y}}{\Type{\mutable}{\texttt{D}}}}{}
&
\deduce{\TypeCheck{\Gamma'}{\texttt{x}\ [\texttt{y}]}{\emptyset}{\texttt{y.f+1}}{\intType}}{\vdots}
}
}
}
}
}\\
\\
\Gamma=\texttt{y}{:}\Type{\mutable}{\texttt{D}},\texttt{z}{:}\Type{\capsule}{\texttt{C}}\\
\Gamma'=\SubstFun{\Gamma}{\texttt{x}{:}\Type{\mutable}{\texttt{D}}}=\texttt{y}{:}\Type{\mutable}{\texttt{D}},\texttt{z}{:}\Type{\capsule}{\texttt{C}},\texttt{x}{:}\Type{\mutable}{\texttt{D}}
\end{array}
\end{math}
\end{footnotesize}
}
\caption{Example of type derivation (2)}\label{fig:TypingTwo}
\end{figure}

Note that, when using rule \rn{t-swap} to typecheck a subexpression of an expression {for which we want the capsule or immutability property}, no alias should be introduced between the variables in the group $\xs$ and the result of the expression.  Indeed, in this case the result of the subexpression could contain references to the variables in group $\xs$, which was lent in the original context.To ensure this, the type obtained in this way is weakened to $\lent$, if it was $\mutable$. 
 This is shown by the following example:
\begin{lstlisting}
mut D y=new D(x1,x2);  
mut x1=new A(0); 
mut x2=new A(1);
capsule C z={mut A x=(y.f1=y.f2); new C(x,x)};
\end{lstlisting}
If we apply rule \rn{{t-swap}} when deriving the
type for \Q@y.f1=y.f2@, therefore swapping the group \Q@y@ with \Q@x@, then we derive type
\Q@mut A@, and rule \rn{{t-swap}} would assign type \Q@lent A@ to the expression.
Therefore, the declaration \Q@mut A x=(y.f1=y.f2)@ and the whole expression would be ill-typed.
Indeed, the expression reduces to
\begin{lstlisting}
mut D y=new D(x2,x2);  
mut x1=new A(0); 
mut x2=new A(1);
capsule C z=new C(x2,x2);
\end{lstlisting}
in which the value of \Q@z@ is not a capsule.

\paragraph{{Immutability recovery}} 
{Note that $\capsule$ recovery can only happen for $\mutable$ expressions. In other words, $\mutable$ expressions which reduce to a portion of store with no external mutable references can be safely used where (either a mutable or) an immutable is required. Indeed, every expression which can be typed $\capsule$ can be typed $\imm$ by subtyping. }

{Consider now an expression for which $\capsule$ recovery cannot happen, that is, which can be typed $\lent$ or $\readable$, but cannot be typed $\mutable$, hence should not be used where a $\mutable$ is required. We can \emph{directly}\footnote{That is, not by subtyping.} recover immutability for such an expression, if we can guarantee that the result of the expression will be not connected to external mutable references.   This can be ensured as for the case of $\capsule$ recovery, with one difference. For $\capsule$ recovery, $\lent$ and $\readable$ references can be freely used, since in any case they will be not connected to the final result of the expression. However, if the expression is in turn $\lent$ or $\readable$, its result \emph{could} be connected to $\lent$ or $\readable$ references, hence this should be explicitly prevented by the type system. This is achieved by \emph{restricting} such references, that is, allowing their use only to typecheck subexpressions of $\imm$ $\capsule$ or primitive type.}

Consider the following variant of the first example of capsule {recovery}:
\begin{lstlisting}
mut D y=new D(0); 
imm C z={lent D x=new D(y.f); new C(x,x)};  
\end{lstlisting}
As in the original version, the inner block (right-hand side of the declaration of \lstinline{z}) uses the mutable free variable \lstinline{y} only in a field access, and indeed reduces to the block \Q@{lent D x= new D(0);  new C(x,x)}@ which is closed. However, this block {cannot be typed $\capsule$}, since it cannot be safely assigned to a mutable reference. On the other hand, the block can be safely typed  $\imm$, since, intuitively, it reduces to a portion of store which cannot be modified through any other reference. Formally, the inner block can be {typed $\imm$} by rule \rn{t-imm}, since it can be typechecked $\lent$ in a type context where variable \lstinline{y}{} is in  singleton {lent group} and, moreover, restricted, that is, can be only used to typecheck subexpressions which are $\imm$, $\capsule$, or of a primitive type. 
The type derivation for the example is given in \refToFigure{TypingThree}. 
{Note that, instead of putting \texttt{x} is a sigleton group we could have put \texttt{x} and \texttt{y} in the same 
group in the typing of \lstinline{new C(x,x)}{} and \lstinline{new D(y.f)}{}. That is, replacing}
\verb!{x} {y}! with \verb!{x,y}!  the derivation would still be correct. (Clearly the rule \rn{T-Swap} would swap \verb!{x,y}!
with the empty mutable group.)

\begin{figure}[th]
\framebox{
\begin{footnotesize}
\begin{math}
\begin{array}{l}
\\
\infer[\scriptstyle{\textsc{(t-imm)}}]
{\TypeCheck{\Gamma}{\emptyset\ [\texttt{y}]}{\emptyset}{\texttt{\{lent D x=new D(y.f); new C(x,x)\}}}{\Type{\imm}{\texttt{C}}}}
{
\infer[\scriptstyle{\textsc{(t-block)}}]
{\TypeCheck{\Gamma}{\texttt{y}\ [\emptyset]}{\texttt{y}}{\texttt{\{lent D x=new D(y.f); new C(x,x)\}}}{\Type{\lent}{\texttt{C}}}
}
{
\infer[\scriptstyle{\textsc{(t-new)}}]
{
\TypeCheck{\Gamma'}{\{\texttt{y}\}\ \{\texttt{x}\}\ [\emptyset]}{\texttt{y}}{\texttt{new D(y.f)}}{\Type{\mutable}{\texttt{D}}}
}
{
\infer[\scriptstyle{\textsc{(t-unrst)}}]
{\TypeCheck{\Gamma'}{\{\texttt{y}\}\ \{\texttt{x}\}\ [\emptyset]}{\texttt{y}}{\texttt{y.f}}{\intType}}
{
\infer[\scriptstyle{\textsc{(t-field-access)}}]
{\TypeCheck{\Gamma'}{\{\texttt{y}\}\ \{\texttt{x}\}\ [\emptyset]}{\emptyset}{\texttt{y.f}}{\intType}}
{
\infer[\scriptstyle{\textsc{(T-var)}}]
{\TypeCheck{\Gamma'}{\{\texttt{y}\}\ \{\texttt{x}\}\ [\emptyset]}{\emptyset}{\texttt{y}}{\Type{\lent}{\texttt{D}}}}{} 
}
}
}
&
\infer[\scriptstyle{\textsc{(t-swap)}}]
{\TypeCheck{\Gamma'}{\{\texttt{y}\}\ \{\texttt{x}\}\ [\emptyset]}{\texttt{y}}{\texttt{new C(x,x)}}{\Type{\lent}{\texttt{C}}}}
{
\infer[\scriptstyle{\textsc{(t-new)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\texttt{y}}{\texttt{new C(x,x)}}{\Type{\mutable}{\texttt{C}}}}
{
\infer[\scriptstyle{\textsc{(T-var)}}]
{\TypeCheck{\Gamma'}{\texttt{y}\ [\texttt{x}]}{\texttt{y}}{\texttt{x}}{\Type{\mutable}{\texttt{D}}}}{}
}
}
}
}
\\  \\
\Gamma=\texttt{y}{:}\Type{\mutable}{\texttt{D}},\texttt{z}{:}\Type{\imm}{\texttt{C}}\\
\Gamma'=\SubstFun{\Gamma}{\texttt{x}{:}\Type{\mutable}{\texttt{D}}}=\texttt{y}{:}\Type{\mutable}{\texttt{D}},\texttt{z}{:}\Type{\imm}{\texttt{C}},\texttt{x}{:}\Type{\mutable}{\texttt{D}}
\end{array}
\end{math}
\end{footnotesize}
}
\caption{Example of type derivation (3)}\label{fig:TypingThree}
\end{figure}

{Restricting $\y$} prevents typechecking examples like the following:
\begin{lstlisting}
mut D y=new D(0); 
imm C z={lent D x=y; new C(x,x)};  
\end{lstlisting}

The significance of the {immutability recovery} is more clearly shown by considering method calls, as will be illustrated in \refToSection{examples}.

\paragraph{Blocks}
{A block $\Block{\decs}{\e}$, where $\decs=\Dec{\T_1}{\x_1}{\e_1}\ldots\Dec{\T_n}{\x_n}{\e_n}$, is well-typed if the right-hand sides of declarations and the body are well-typed, as detailed below.
\begin{itemize}
\item All the expressions are typechecked w.r.t.\ the type assignment $\SubstFun{\Gamma}{\TypeEnv{\decs}}$ where $\TypeEnv{\decs}$  is the same of $\TypeDec{\T_1}{\x_1},\ldots,\TypeDec{\T_n}{\x_n}$, apart that local variables declared $\lent$ have type $\mutable$ (indeed the fact that they are $\lent$ is encoded by  including them in lent groups, see next point).
\item The body is typechecked w.r.t.\ lent groups $\LentLocked'$ and mutable group $\MutGroup'$ which extend those of the enclosing scope, modulo hiding (second and third side conditions). More precisely: variables which are $\mutable$ in $\TypeEnv{\decs}$ can be possibly added to a lent group of the enclosing scope, or can form a new lent group, or can be added to the mutable group $\xs$ of the enclosing scope.
\item The right-hand side of each declaration $\e_i$ is typechecked w.r.t.\ to lent groups $\LentLocked_i$ and mutable group $\xs_i$ obtained from those of the body by swapping $\xs'$ with the group which contains $\x_i$, if $\x_i$ is $\mutable$ in $\TypeEnv{\decs}$ (fourth side condition). Recall that sequences of groups are considered as sets, hence the notation $\LentLocked_i\ \MutGroup_i = \LentLocked'\ \MutGroup'$ means that the two sides are the same set of groups.  This swapping models the fact that the initialization expression of a variable $\x_i$ in a lent group is typechecked considering as mutable group that containing $\x_i$.
For variables in the mutable group, or declared with other modifiers, no swapping is needed.
\item All the expressions are typechecked w.r.t.\ restricted variables which are exactly those of the enclosing scope (modulo hiding).
\end{itemize}
We use the following auxiliary notations.
\begin{itemize}
\item {The {\em type assignment extracted} from a sequence of declarations $\decs$, denoted $\TypeEnv{\decs}$, is defined by: $\TypeEnv{\Dec{\T_1}{\x_1}{\e_1}\ldots\Dec{\T_n}{\x_n}{\e_n}}=\TypeDec{\T'_1}{\x_1},\ldots,\TypeDec{\T'_n}{\x_n}$ where $\T'_i=\Type{\mutable}{\C}$ if  $\T_i=\Type{\lent}{\C}$, $\T'_i=\T_i$ otherwise.}
\item $(\xs_1\ldots\xs_n){\setminus}\xs=(\xs_1{\setminus}\xs)\ldots(\xs_n{\setminus}\xs)$  
\item $\dom{\xs_1\ldots\xs_n}=\{\x\mid \x\in\xs_i\mbox{ for some}\ i\}$
\item $\LessEq{\xs_1\ldots\xs_n}{\ys_1\ldots\ys_m}$ if $\dom{\xs_1\ldots\xs_n}\subseteq\dom{\ys_1\ldots\ys_m}$, and {for all $\x,\y\in\dom{\xs_1\ldots\xs_n}$, $\x,\y\in\xs_i$ if and only if 
$\x,\y\in\ys_j$.}
%\item $\LessEq{\LentLocked}{\LentLocked'}$ if $\dom{\LentLocked}\subseteq\dom{\LentLocked'}$, and {for all $\x,\y\in\dom{\LentLocked}$, $\x\in\xs\in\LentLocked$  and $\y\in\xs\in\LentLocked$ if and only if 
%$\x\in\xs'\in\LentLocked'$ and $\y\in\xs'\in\LentLocked'$.}
%\item $\Extends{\LentLocked}{\zs}{\LentLocked'}$ if $\LessEq{\LentLocked}{\LentLocked'}$ holds, and, moreover, $\dom{\LentLocked'}=\dom{\LentLocked}\cup\zs$.
\end{itemize} }

{Note that local variables declared $\lent$ can be arbitrarily assigned to {lent group}s, to improve expressivity. For instance, it can be necessary to assign a $\lent$ local variable to the same {lent group} {as} some variables of the enclosing scope. This is shown by the following example, where the local variable \lstinline{z1} is used to modify the external reference \lstinline{x}, rather than to construct the block result.}
\begin{lstlisting}
mut D z=new D(0);  
mut C x=new C(z,z);
capsule C y= {
  lent D z1=new D(1); 
  lent D z2=(x.f1=z1);  
  mut D z3 = new D(2);
  new C(z3,z3)
};
\end{lstlisting}
Since 
we need to {recover the capsule property for} the
block on the right-hand side of the declaration of \Q@y@, applying rule \rn{T-capsule} to the block, the context of the typing of such block 
must be \\
{\small $\ \ \ \ {\tt z:\mutable\ D,x:\mutable\ C,y:\capsule\ C; {\{z, x\}}; \emptyset}$}\\
that is, the variables
\Q@z@ and \Q@x@ must be in the same {lent group}. However, assuming that field \lstinline{f1}{} is mutable, to apply rule \rn{t-field-assign} to the expression \Q@x.f1=z1@,  both \Q@x@ and \Q@z1@ have to be mutable. Therefore, we have to apply rule
\rn{t-swap}, and it must be the case that  \Q@x@ and \Q@z1@ are in the same {lent group}. This is possible, with rule \rn{t-block}, by adding \Q@z1@ to the group \verb!{z,x}! in typing the right-hand sides of the declarations and the body.

Note that the following variant of the example, where the result of the block is connected to \lstinline{z1} instead,}
\begin{lstlisting}
mut D z=new D(0);  
mut C x=new C(z,z);
capsule D y= {
  lent D z1=new D(1); 
  lent D z2=(x.f1=z1);  
  new C(z1,z1)
};
\end{lstlisting}
is ill-typed.  Indeed, as before, \Q@z1@ must be in the same group {as} \Q@x@ in order to {recover the $\capsule$ property of} the block, but in this case \Q@z1@ would be $\lent$, hence the whole block.

\paragraph{Other typing rules} 
Other rules are mostly standard, except that they model the expected behaviour of type qualifiers.

{In} rule \rn{t-var}, a variable is weakened to $\lent$ if it belongs to some group in $\LentLocked$, and cannot be used at all if it belongs to $\StronglyLocked$. 

In rule \rn{t-field-access}, in case the field is $\mutable$, the type qualifier of the receiver is propagated to the field. For instance, {mutable} fields referred through a $\lent$ reference are $\lent$ as well. If the field is immutable {(or of a primitive type), instead, then the expression has the field type,} regardless of the receiver type.  

In rule \rn{t-field-assign}, the receiver should be mutable, and the right-hand side must have the field type. Note that this implies the right-hand side to be either $\mutable$ or $\imm$ {(or of a primitive type)}. Hence, neither the left-hand nor the right-hand sides can be $\lent$ or $\readable$. {This prevents the introduction of aliases for such references. However, recall that for $\lent$ references the constraint can be escaped by using, before this rule, rule \rn{t-swap}, at the price of weakening to $\lent$ the type of the expression. }
  
In rule \rn{t-new}, expressions assigned to fields should be either $\mutable$ or $\imm$ (or of a primitive type).  {Again, for $\lent$ references the constraint can be escaped by swapping, getting a $\lent$ expression. }
 Note that an object is created with no restrictions, that is, as $\mutable$.

Finally, note that primitive types are used in the standard way. For instance, in the premise of rule \rn{t-new} the types of constructor arguments could be primitive types, whereas in rule \rn{t-meth-call} the type of receiver could not.  









