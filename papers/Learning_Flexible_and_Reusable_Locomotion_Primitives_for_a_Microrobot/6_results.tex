%
\begin{figure}[t]
  \centering
  \begin{subfigure}{0.49\linewidth}
	  \includegraphics[width=0.98\linewidth]{fig/tripod_normal.pdf}
	  \caption{Dual Tripod}
	  \label{fig:soo:1}
  \end{subfigure}
  \hfill  
  \begin{subfigure}{0.49\linewidth}
	  \includegraphics[width=0.98\linewidth]{fig/ripple_normal.pdf}
	  \caption{Ripple}
	  \label{fig:soo:2}
  \end{subfigure}
  \\
  \begin{subfigure}{0.49\linewidth}
	  \includegraphics[width=0.98\linewidth]{fig/wave_normal.pdf}
	  \caption{Wave}
	  \label{fig:soo:3}
  \end{subfigure}
  \hfill
  \begin{subfigure}{0.49\linewidth}
	  \includegraphics[width=0.98\linewidth]{fig/fourtwo_normal.pdf}
	  \caption{Four-Two}
	  \label{fig:soo:4}
  \end{subfigure}
  \caption{Learning curve for the four gaits (median and 65th percentile). We can see how, for all the gaits, BO learns to walk from scratch within 50 iterations. After the optimization, Dual Tripod and Ripple are the fastest gaits at $\sim \SI[per-mode=symbol]{1.1}{\centi\meter\per\second}$ and $\sim \SI[per-mode=symbol]{1.2}{\centi\meter\per\second}$ respectively.}
  \label{fig:soo}
\end{figure}
%
In this section, we discuss our controller implementation as well as the performance of our simulated microrobot on various locomotion tasks.
The code used for performing the simulation and videos of the various locomotion tasks are available online at \url{https://sites.google.com/view/learning-locomotion-primitives}.

\subsection{Controller Implementation}
	We built our controller following the setup described in \sec{sec:bg:cpg}, using a network of 12 coupled phase oscillators (one per motor).
	In order to translate the output of each of the oscillators into motor actuation, we calculate the oscillator outputs for each vertical-horizontal motor pair using the piecewise function
	%
	\begin{align}
		    \begin{cases}
			    x_{i} + r_{i}cos(\phi_{i}), x_{j} + r_{j}cos(\phi_{j}) &\text{if }\phi_{i}>\pi,\phi_{j}>\pi\,,\\
			    x_{i} + r_{i}, x_{j} + r_{j}cos(\phi_{j}) &\text{if }\phi_{i}\leq\pi,\phi_{j}>\pi\,,\\
			    x_{i} + r_{i}, x_{j} + r_{j} &\text{if }\phi_{i}\leq\pi,\phi_{j}\leq\pi\,,\\
			    x_{i} + r_{i}cos(\phi_{i}), x_{j} - r_{j} &\text{if }\phi_{i}\leq\pi,\phi_{j}>\pi\,,
		    \end{cases}
	\end{align}
	%
	where the $i$th oscillator outputs to its respective vertical motor and the $j$th oscillator outputs to its respective horizontal motor. 
	This allows us to discard the parts of the oscillator output that are not consistent with the physical constraints of the physical robot, since the actual leg actuators cannot partially retract (see \fig{fig:cpg}).
	We choose to mutually couple all six of the vertical oscillators (with a coupling weight of 4 to ensure quick convergence on stable limit cycles).
	We refer the reader to \cite{Crespi_2007} for a more comprehensive discussion of oscillator coupling in CPGs.
	Each of the horizontal oscillators are also coupled with their respective vertical oscillator in order to encapsulate the dynamics of each leg.
	We chose to implement four different gaits with the CPG -- tripod, ripple, wave, and four-two (see \fig{fig:gaits}). 
	For a more detailed description of these gaits we refer the reader to~\cite{Campos2010}.
	We use the same frequency and phase difference for the whole network in order to reduce the number of parameters and speed up the rate of convergence.
	We use two separate parameters for amplitude, each controlling the left and right set of legs respectively.
	This choice of parameters allows us to control the turning of the robot which is necessary for path planning and corrections for not walking straight.

    
\subsection{Learning to Walk Straight}
\label{sec:results:soo}

	We optimized the four gaits considered (i.e., dual tripod, ripple, wave, and four-two) using as our objective function the walking speed of the robot (measured as the distance traveled after $\SI{1}{\second}$).
	Since some gaits result in curved motions, we also penalized the speed objective with a term proportional to the drift from the axis of locomotion.
	The optimization used the 4 parameters outlined in \sec{sec:bg:cpg} and was repeated 50 times for each of the gaits. 
	In \fig{fig:soo}, we show the median and 65th percentiles of the best solution obtained so far in the trials.
	The results show that the optimizer was able to learn to walk from scratch within 50 iterations.
	Moreover, it can be noted that the optimized tripod and ripple are the fastest gaits at $\sim \SI[per-mode=symbol]{1.1}{\centi\meter\per\second}$ and $\sim \SI[per-mode=symbol]{1.2}{\centi\meter\per\second}$ respectively.
	
\subsection{Multi-objective Gait Optimization}
\label{sec:results:moo}
	%
	\begin{figure}[t]
	  \centering
	  \begin{subfigure}{0.49\linewidth}
		  \includegraphics[width=0.99\linewidth]{fig/Dual_Tripod.pdf}
		  \caption{Dual Tripod}
		  \label{fig:moo:1}
	  \end{subfigure}
	  \hfill  
	  \begin{subfigure}{0.49\linewidth}
		  \includegraphics[width=0.99\linewidth]{fig/Ripple.pdf}
		  \caption{Ripple}
		  \label{fig:moo:2}
	  \end{subfigure}
	  \\
	  \begin{subfigure}{0.49\linewidth}
		  \includegraphics[width=0.99\linewidth]{fig/Wave.pdf}
		  \caption{Wave}
		  \label{fig:moo:3}
	  \end{subfigure}
	  \hfill
	  \begin{subfigure}{0.49\linewidth}
		  \includegraphics[width=0.99\linewidth]{fig/Four-Two.pdf}
		  \caption{Four-Two}
		  \label{fig:moo:4}
	  \end{subfigure}
	  \caption{Performance measured for the four gaits, and the corresponding PFs. ParEGO is able to quickly explore the PF for each of our four gaits.}
	  \label{fig:moo}
	\end{figure}
	%

	In the previous simulation we only considered walking speed as our objective. 
	However, for practical gait design, energy efficiency is another objective of great interest, particularly when it comes to designing gaits for a microrobot with real energy restrictions. 
	For this reason, we now consider a multi-objective optimization setting and compare the different gaits w.r.t. both walking speed, and energy consumption.
	The energy consumption of the robot was computed by measuring the forces exerted by each of the 12 motors along the axis of actuation and calculating the power used to actuate the motors. 
	Since the retraction of the legs is spring powered, the energy input in the cycle is only during motor extension.
	Hence, we only consider the cost of extending the legs.
	With the mass of the robot and the time of each trial being held constant, we quantify the energy efficiency of a gait and estimate the cost of transport.
   
            %
	\begin{wrapfigure}{r}{0.52\linewidth} 
	\vspace{-12pt}
	  \centering
	  \includegraphics[width=\linewidth]{fig/all_pareto.pdf}
	  \caption{Comparison of the PFs obtained for the different gaits.}
	  \label{fig:moo:all}
	  \vspace{-10pt}
	\end{wrapfigure}
	% 
	We optimized the four gaits again with the same 4 parameters as the previous optimization, but this time using multi-objective Bayesian optimization with a budget of 50 iterations.
	    %
	\begin{figure}[t]
	  \centering
	  \includegraphics[width=0.95\linewidth]{fig/discovery2.pdf}
	  \caption{PF of the unrestrained gait optimization versus the best performance of the four nature-inspired gaits. The faster solutions outperform the fastest nature-inspired gaits, albeit with more energy expenditure. However, the inability of the optimizer to match the performance of the gaits at lower speeds within 1250 trials shows that the gait parametrization can help limit the search space to find better solutions easier. \textit{(top)} Pattern for two of the discovered gaits.}
	  \label{fig:moo:new}
	\end{figure}
	%
	In \fig{fig:moo} we can see the performance measured and Pareto fronts obtained for the different gaits.
	To better compare the PF from the different gaits, we also visualized just  the PFs together in \fig{fig:moo:all}. 
	From these results, we can see how the tripod gait dominates the other gaits for speed $<\SI[per-mode=symbol]{0.6}{\centi\meter\per\second}$, while Ripple dominates when the speed is $>\SI[per-mode=symbol]{0.6}{\centi\meter\per\second}$, hence giving a clear indication of which gait is preferable under different circumstances. 
    

\subsection{Discovering New Gaits with Multi-objective Optimization}

	In addition to optimizing the four nature-inspired gaits, we also tested multi-objective optimization on the walker without constraining to using predefined gaits.
	To parametrize the oscillator couplings, we thus discretized each gait into intervals of constant length.
	Within each of these intervals, we assume that each leg steps exactly once, keeping each of the oscillators in the CPG in phase with each other.
	This allows us to parametrize gaits by assigning each leg a point during each interval where it begins stepping.
	While this parametrization excludes certain gaits that cannot be expressed in this form, we leave the study of more sophisticated gait parameterizations for gait discovery to future works.
	
	The resulting multi-objective optimization task had 8 parameters (frequency, phase difference between horizontal and vertical motors, and the six gait coupling parameters).
	Due to the higher parameter dimensionality, and because this training was not intended for on-line training, we ran the optimization for 250 iterations in order to allow a more comprehensive exploration of the optimization space.
	We also repeated the optimization five times for a total of 1250 trials.
	In \fig{fig:moo:new} we can see the Pareto front for the resulting gaits.
	We found that the fastest discovered gaits were actually able to outperform the four nature-inspired gaits implemented by a substantial margin.
	Even while penalizing curved paths, the fastest discovered gait outperformed Ripple (the fastest nature-inspired gait we found) by almost $50\%$.
	However, for low-speed gaits, the nature inspired gaits out-perform the gaits produced by the unconstrained optimization, indicating the optimization did not yet fully converged to the optimal PF.
	
\subsection{Learning to Walk on Inclined Surfaces}
\label{sec:results:context1}
	%
	\begin{figure}[t]
	  \centering
	  \includegraphics[width=0.96\linewidth]{fig/contextual_generalized_mod.pdf}
	  \caption{Performance of the contextual policy (median and 65th percentile) for a wide range of inclines. The policy was trained only at 5, 10 and 15 degrees, but it was capable of generalizing smoothly to unseen inclinations. 
	  }
	  \label{fig:incline}
	\end{figure}
    
	\begin{figure}[t]
	  \centering
	  	\begin{subfigure}{0.49\linewidth}
      \centering
	  \includegraphics[width=\columnwidth]{fig/contextual_vs_normal.pdf}
	  \caption{Inclined surface.}
	  \label{fig:contextual:1}
	\end{subfigure}
\hfill
	\begin{subfigure}{0.49\linewidth}
	  \centering
	  \includegraphics[width=\linewidth]{fig/contextual_vs_normal_turning.pdf}
	  \caption{Curved trajectory.}
	  \label{fig:contextual:2}
	  	\end{subfigure}
\caption{Comparison between the optimization performance of a contextual optimizer and a normal optimizer for two different tasks: (a) walking on inclines (b) walking curved trajectories. In both cases, the contextual optimizer can leverage prior simulations to obtain high-performing gaits in fewer simulations.}
	   \vspace{-10pt}
       \end{figure}
       
	We now consider the case of contextual optimization and specifically the task of gait optimization for slopes with different inclinations.
	We framed learning to walk on inclined terrain as a contextual policy search, where the angle of the inclination is the context. 
	In this simulation, we decided to use Dual Tripod for our gait with mostly the same open parameters as the previous simulations.
    We used a single parameter to represent the amplitude for the entire network in order to keep the number of parameters low with the addition of a contextual variable, leaving us with 3 parameters and 1 contextual parameter.
	To respect real world constraints, where testing randomly sampled incline angles over a continuous interval can be excessively time-consuming, we chose at training time to perform simulations only from a small number of inclines: 5, 10, and 15 degrees.
	
	After optimizing the gaits for these three inclines over 50 iterations, we studied how the contextual optimizer is able to generalize across the context space by testing the performance of the contextual policy for a wide range of inclines.
	In \fig{fig:incline} we can see that the policy performs well on intermediary inclines and seems to smoothly interpolate between the training inclines as is desirable.
	The gradual decrease in performance as the inclines get steeper can be attributed to the increasing physical difficulty for climbing up steeper inclines.
	We also compared cBO against using standard BO to train the robot for an untested incline. 
	As shown in \fig{fig:contextual:1}, the contextual optimization was able to converge on optimal performance significantly faster than standard BO.
	This result demonstrate the ability of cBO to efficiently use data accumulated in previous contexts to quickly reach optimize gaits in new unseen contexts.

	
\subsection{Learning to Curve}
\label{sec:results:context2}
	
	Another useful task that can be framed as contextual optimization is learning motor primitives to walk curved trajectories for use in path planning.
	We used the same parameters as in \sec{sec:results:soo} and the contextual parameters in this case were the target displacements along both the x and y axes from the point of origin.
	In order to train particular trajectories, we selected five evenly spaced target points along the front quadrant of the field of vision.
	Since the primary objective was to reach the desired destination, we chose to use the distance of the final position to the target position as our sole objective function.
	We found that over 10 repetitions, the walker was able to accurately move and turn towards all of the target points within 250 iterations.
	In \fig{fig:contextual:2}, we compared the performance of cBO against standard BO on a previously unseen target position $(4\cos{\pi / 16}, 4\sin{\pi / 16})$.
	We found that, as in the case of inclinations, the contextual policy was able to learn the optimal parameters for a novel trajectory within very few iterations.


\subsection{Learning Motor Primitives for Path Planning}
\label{sec:results:planning}
    %
	\begin{figure}[t]
	  \centering
	  \includegraphics[width=\linewidth]{fig/turning_map_both_hor.pdf}
	  \caption{Comparison of the performances of cBO and our approach for learning motor primitives (using the same data). 
	  With the robot having an initial position of $(0,0)$, we evaluated the error between the desired position (indicated by the element of the grid) and the reached position.
	  Darker color indicates better target accuracy.
	  While cBO accurately learned trajectories near the training targets, it did not generalize well to unseen targets. 
	  In contrast, our approach had a more comprehensive coverage as it could leverage better information about the environment to improve generalization.}
	  \label{fig:pathing1}
	\end{figure}
	% 

	    %
	\begin{wrapfigure}{r}{0.50\linewidth} 
	\vspace{-10pt}
	  \centering
	  \includegraphics[width=\linewidth]{fig/contextual_path.pdf}
	  \caption{Path constructed using the locomotion primitives learned with our approach.}
	  \label{fig:pathing2}
	   \vspace{-8pt}
	\end{wrapfigure}
	% 
	In the previous simulation we learned motor primitives capable of walking curved trajectories.
    While the model handled trajectories near and between the targets quite well, the performance on trajectories well within the physical capabilities of the robot but not in proximity to the targets left much to be desired, as shown in \fig{fig:pathing1}.
	We now demonstrate how our approach presented in \sec{sec:approach} can be used to significantly improve the movement accuracy (compared to cBO using the same data), as well as how such motor primitives can be used to perform path planning.
    First, we reused the data from the previous simulation in order to reformulate the task as a multi-objective optimization as described in \sec{sec:approach}.
    Then, we used our trained model to sample 10,000 trajectories by randomly sampling from the parameter space.
    Out of all these trajectories, we selected the one with the smallest expected error subject to not walking through the wall.
    Evaluating the resulting sequence of motor primitives on the real system (\ie, the simulator) demonstrated that the expected trajectory was capable of navigating the maze, as shown in \fig{fig:pathing2}.



    
    
    

