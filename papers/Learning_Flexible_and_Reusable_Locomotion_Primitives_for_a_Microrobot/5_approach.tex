%
\begin{figure}[t]
	\centering
	\includegraphics[height=2.4cm]{fig/cpg2.pdf}
	\caption{Output of one vertical-horizontal oscillator pair in the CPG network, which corresponds to one leg on the robot. 
	The retraction phase of both motors occurs concurrently and rapidly in order to simulate the physical constraints on the actual physical microrobot.}
	\label{fig:cpg}
\end{figure}
% 
%
\begin{figure}[t]
	\centering
	\includegraphics[width=0.98\linewidth]{fig/gaits.pdf}
	\caption{Contact/swing patterns for different gaits.}
	\label{fig:gaits}
	\vspace{-8pt}
\end{figure}
%

We now present our novel approach to learn motor primitives for path planning.
This approach relies on the possibility of re-using the evaluations collected using cBO to convert the task into a multi-objective optimization problem.
We specifically consider a cBO task where we want to optimize the parameters $\parameters$ to reach different target positions $\context=\left[ \Delta x_\text{des}, \Delta y_\text{des} \right]$ (this setting is evaluated in \sec{sec:results:context2}).
The objective function in this case can be defined as the Euclidean distance 
%
\begin{align}
	\objfuncNo = \sqrt{\left(\Delta x_\text{des} -\Delta x_\text{obs}\right)^{2} + \left(\Delta y_\text{des} -\Delta y_\text{obs}\right)^{2}}\,,
\end{align}
%
where $\Delta x_\text{obs}, \Delta y_\text{obs}$ are the actual positions measured after evaluating a set of parameters.
The cBO model would map $\tilde{\objfuncNo}: \left[\parameters, \Delta x_\text{des}, \Delta y_\text{des}\right] \rightarrow \objfunc{\parameters}$. 
However, in order to compute $f$ it would need to measure $\Delta x_\text{obs}, \Delta y_\text{obs}$, effectively generating data of the form
%
\begin{align}
	\left[\parameters, \Delta x_\text{des}, \Delta y_\text{des}\right] \rightarrow \left[\Delta x_\text{obs}, \Delta y_\text{obs}, \objfunc{\parameters}\right]
\end{align}
%
We can now re-use the data generated from this contextual optimization to learn a motor primitive model in the form $g: \parameters \rightarrow \left[\Delta x_\text{obs}, \Delta y_\text{obs}\right]$.
The purpose of this learned model~$g$ is now to provide an estimate of the final displacement obtained for a set of parameters independently from the optimization process that generated it.
Once such a model is learned, we can use it to compute parameters that lead to the desired displacement $\Delta x^*_\text{obs}, \Delta y^*_\text{obs}$ by optimizing the parameters w.r.t. the output of the model
	%
\begin{align}
	\parameters^* = \maximize_{\parameters}\, z(g(\parameters))\,,
% 
\end{align}
%
where $z$ is a scalarization function of our choice (e.g., the Euclidean distance).
This is equivalent to learning a continuous function that generates motor primitives from the desired displacement.
It should be noted that this optimization is performed on the model $g$ and therefore does not require any physical interaction with the robot.
Moreover, we can optimize the parameters over a series of multiple displacements to obtain a path planning optimization. 
In \sec{sec:results:planning}, when performing path planning using the learned motor primitives we will employ a simple shooting method optimization which randomly samples multiple candidate parameters and selects the best outcome.

