\section{Implementation}
\label{sec:impl}
%This section describes our implementation details. %for calculating aDVF.
%The core of the implementations includes a tool and a series of
%techniques to improve the tool usability and configurability.

%\subsection{ARAT: A Tool for aDVF Analysis}
To calculate the aDVF value for a data object, %to model the application resilience,
we develop a tool, named~\textit{ARAT} (standing for \textit{A}pplication-level \textit{R}esilience \textit{A}nalysis \textit{T}ool). 
Figure~\ref{fig:tool_framework} shows the tool framework.
ARAT has three components: an application trace generator, a trace analysis tool, and a deterministic fault injector.


\begin{figure*}
  \begin{center}
  \includegraphics[height=0.13\textheight,keepaspectratio]{flow_chart.pdf}
  \vspace{-5pt}
  \caption{ARAT, a tool for application-level resilience modeling based on the aDVF analysis}
  \label{fig:tool_framework}
  \end{center}
  \vspace{-15pt}
\end{figure*}

The \textbf{application trace generator} is an LLVM instrumentation pass to generate a dynamic LLVM IR trace.
LLVM IR is architecture independent, and each instruction in the IR trace corresponds to one operation.
The trace includes dynamic register values and memory addresses referenced in each operation.
The current trace generator is based on a third-party tool~\cite{ispass13:shao}, but with some extensions 
for the deterministic fault injection %intermediate state recording, 
and Phi instruction processing to identify ambiguous branches.

The \textbf{trace analysis tool} is the core of ARAT. Using an application trace as input, the tool calculates the aDVF value of a given data object.
In particular, the trace analysis tool conducts the operation-level and fault propagation analysis. %counts tier-1 and tier-2 fault masking events.
Also, for those unresolved fault propagation analyses that reach the boundary of the fault propagation analysis,   
%but cannot be determined if the fault masking exists or not,  
the trace analysis tool will output 
%the unresolved instruction information 
a set of fault injection information for the deterministic fault injection. Such information includes dynamic instruction IDs, IDs of the operands that reference the target data object, and the bit locations of the operands that have undetermined fault masking.
%(i.e., the dynamic instruction ID, the ID of the operand that references the target data object, 
%and the bit location of the operand that has undetermined fault masking) for the guided fault injection.  
After the fault injection results (i.e., the existence of algorithm-level fault masking or not) are available from the deterministic fault injector,
we re-run the trace analysis tool, and use the fault injection results to address the unresolved analyses and update the aDVF calculation. 

%In a LLVM IR-based trace, the value of the target data object can be loaded into a regist
For the fault propagation analysis, we associate data semantics (the data object name) with the data values in registers,
such that we can identify the data of the target data object in registers. %in the trace 
%and correlate the LLVM IR-based analysis  with the application-level fault masking analysis.  
%Identifying the data of the target data object in registers 
This is necessary to analyze fault propagation.
To associate data semantics with the data in registers, 
ARAT tracks the register allocation when analyzing the trace, such that we can know at any moment which registers have the data of the target data object. 

For the value shadowing analysis to determine which bits can have their bit flips masked, we ask users to provide a set of value shadowing thresholds, each of which defines
a boundary (either upper bound or lower bound) of valid data values for a data element of the target data object. 
Only those bit positions whose bit flips result in a valid data value
are determined to have the fault masking of value shadowing.
If users cannot provide such thresholds, then we will perform deterministic fault injection test for each bit of the data element of the target data object to determine the effect of bit flip on the application outcome.
%However, this method can be time-consuming because of intensive fault injection.
%We introduce a technique in Section~\ref{sec:acc_analysis} to prune fault injection tests.
To accelerate the value shadowing analysis, we further introduce
a series of optimization techniques, such as (1) using the 
deterministic fault injection results for higher-order bits to deduce
the fault injection results for lower-order bits; (2) leveraging
iterative structure of the application;
and (3) analysis parallelization. 
Those implementation details can be found in our technical report~\cite{resilience_modeling:tr}. 

The trace analysis tool is configurable and extensible. 
It gives the user flexibility to control the trace analysis. %and explore the trade-off between accuracy and analysis speed.
%Table~\ref{tab:arat-config} summarizes the major configuration parameters.
For example, the user can define a maximum fault propagation length for the fault propagation analysis; %to accelerate the analysis;
the user can also configure fault patterns for analysis. 
%and \textbf{set up a value shadowing threshold based on the application information}.
%The trace analysis tool also allows the user to configure fault patterns for analysis.
Based on the user configuration, the tool can enumerate all fault patterns during the analysis or just examine one specific pattern.
%Furthermore, the trace analysis tool supports the identification of the three operation-level fault masking (see Section~\ref{sec:statement_analysis}) 
%and the optimization technique for the fault propagation analysis (see Section~\ref{sec:fault_propagation_analysis}).
To make the trace analysis tool extensible for future improvement,
the tool also exposes APIs that allow users to hook up new
techniques to identify fault masking and optimize analysis.
%Hence, the trace analysis tool is extensible for future development.

The \textbf{deterministic fault injector} is a tool to capture the algorithm level fault masking
%and facilitate the calculation of aDVF 
for the trace analysis tool.
The input to the deterministic fault injector is a list of fault injection points
generated by the trace analysis tool for those unresolved fault masking analyses.
Each fault injection point includes a dynamic instruction ID, %in LLVM IR, 
the ID of the operand that references the target data object, and a specific bit-position of the operand for bit flipping (i.e., the fault injection).
%and the bit location of the operand that has undetermined fault masking
%Hence, the list of fault injection points works as an interface 
%between the guided fault injector and the trace analysis tool. 
The bit-positions of the operand for bit flipping are determined after the value shadowing analysis. %(see Table~\ref{tab:arat-config}).
%Given a m-bit data, if there are n bits ($ 0 \leq n \leq m$) whose bit flips can be masked, then the rest $m-n$ bits will need deterministic fault injection tests.

Similar to the application trace generation, the deterministic fault injector is also based on the LLVM instrumentation. %and dynamic LLVM IR.
We use the LLVM instrumentation to count dynamic instructions and trigger bit flips. 
After the LLVM instrumentation, the application execution will trigger bit flip when a fault injection point is encountered.
%and during the application execution, when a LLVM IR instruction specified in the list of fault injection points is to be executed,
%we trigger a bit flip. 

\begin{comment}
(\textbf{Dong: the following part in this paragraph needs to be refined.})
The bit-locations of the operand for bit flipping are determined by the value shadowing threshold. %(see Table~\ref{tab:arat-config}).
Given a data value of the operand, the product of the data value and the value shadowing threshold
defines a boundary of the valid data value.
%Given a data value in the operand, 
The bit-locations for bit flipping are those that have data values beyond 
the boundary after bit-flipping.
Those bit-locations for fault injection can cause large value deviation from the original data value, 
and we cannot determine fault masking using the statement-level and fault propagation analysis,
and have to rely on the analysis at the algorithm level.

Similar to the application trace generation, the deterministic fault injector is also based on LLVM instrumentation and dynamic LLVM IR.
We use the LLVM instrumentation to count dynamic instruction ID.
During the application execution, when a LLVM IR instruction specified in the list of fault injection points is to be executed,
we trigger a bit flip. 
\end{comment}

%\textbf{How to handle the phi instruction; how to optimize the analysis efficiency}
%\textbf{How to handle value shadowing} how to determine the threshold to determine if a giant value plus a small value is fault masking
%\textbf{A threshold for the fault propagation analysis}

