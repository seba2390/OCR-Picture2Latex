\section{Related Work}
%The statistical based random fault injection is one of the major methods to understand
%application vulnerability.
\begin{spacing}{0.9}
\textbf{Application-level random fault injection.}
Casa et al.~\cite{mg_ics12} 
study the resilience of an algebraic multi-grid solver 
by injecting faults into instructions' output based on LLVM. 
%the LLVM typed byte code. 
Similar work can be found in~\cite{europar14:calhoun, prdc13:sharma}.
Cher et al.~\cite{sc14:cher} employ a GDB-like debugging tool to corrupt register states.
Li et al.~\cite{bifit:sc12} build a binary instrumentation-based fault injection tool 
for random fault injection.
%and perform random fault injection into the data objects of realistic applications. %based on the PIN infrastructure.
Shantharam et al.~\cite{2-shantharam2011characterizing} manually change the values of data objects %at the application level 
to study the resilience of iterative methods.
%Sharma et al.~\cite{prdc13:sharma} and Calhoun et al.~\cite{europar14:calhoun} use
%LLVM-based tools to inject faults into random instructions for application vulnerability study. 
Ashraf et al.~\cite{sc15:ashraf} and Wei et al.~\cite{dsn14:wei} also use LLVM-based tools to inject faults, but
they further introduce the functionality of tracking fault propagation. 
Xu et al.~\cite{dsn12:xu} and Hari et al.~\cite{asplos12:hari} aggressively employ static and dynamic program analyses to reduce the number of fault injection tests.
%analyze application fault sites and pick a small representative subset for selectively fault injections.
Their work %reduces the number of fault injection tests, but
still has randomness for fault injection.
%randomness of traditional fault injection, but the effectiveness of the selective fault injection  depends on application characteristics. 

\begin{comment}
Fault injection can also happen at the circuit level with radiation exposed to processor chips~\cite{aspdac14:cher, sc14:cher},
or be simulated with the architecture-level simulators~\cite{hpcs11:Bohm, asplos10:feng}.  
In general, the random fault injection can be inaccurate if the fault injections are not sufficient. Our methodology avoids the randomness.
%the random fault injection can also be costly because of massive repetition of application execution.
\end{comment}

%\textbf{Static analysis for fault injection}
\textbf{Resilience metrics.}
Architectural vulnerability factor (AVF) is a hardware-oriented metric
to quantify the probability of a fault in a hardware component resulting in
the incorrect final application outcome. It was first introduced  in~\cite{isca05:mukherjee, micro03:mukherjee},
and then attracted a series of follow-up work. This includes
statistical-based modeling techniques to accelerate AVF estimate~\cite{micro07:cho, hpca09:duan, mascots06:fu}, %, isca07:walcott},
online AVF estimation~\cite{isca08:Li, isca07:soundararajan},  %isca07:walcott, 
%semi-statistical models to accelerate AVF estimate~\cite{isca12:arvind}, 
and AVF analysis for spatial multi-bit faults~\cite{micro14:wilkening}.
%and identification of the inaccuracy of AVF estimate~\cite{isca07:wang}.
Another metric, the program vulnerability factor (PVF) is based on AVF~\cite{hpca09:sridharan}, %selse10:sridharan}, 
but eliminates microarchitecture effects. %from AVF.

AVF calculation and its variants are highly hardware-oriented. 
%(architecture or microarchitecture). 
In fact, AVF presents an aggregation effect of hardware and application, but is typically employed to evaluate the hardware vulnerability. AVF calculation usually requires detailed hardware simulations, and requires a
large number of simulations to derive insight into the impact of (micro)architectural events on AVF, which can be time-consuming.
Although the recent work based on statistical approaches improves evaluation speed~\cite{micro07:cho, hpca09:duan, mascots06:fu}, %isca07:walcott}, 
it limits modeling accuracy. 
AVF calculation does not consider application semantics, and hence can overestimate vulnerability.
%remove s, by anzheng
Yu et al.~\cite{dvf_sc14} introduce a metric, DVF. DVF 
%provides a fast solution 
%(fast enough to be employed at runtime) 
%to evaluate the effects of both application and hardware on the resilience of data
captures the effects of both application and hardware on the resilience of data
structures. 
%However it loses the modeling accuracy because it is based on high-level hardware information and coarse-grained memory access analysis.
In contrast to AVF and DVF, our metric, aDVF, is a highly 
application-oriented metric.
\end{spacing}

\vspace{-5pt}