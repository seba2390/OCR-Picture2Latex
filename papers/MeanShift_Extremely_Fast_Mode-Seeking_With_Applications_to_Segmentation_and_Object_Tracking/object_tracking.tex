\section{Object Tracking}

The mode-seeking behavior of MeanShift makes it a good candidate for visual tracking. A basic implementation would take in a mask and/or search window of an object and build a histogram of the colors found in that object in RGB or HSV space. Afterwards, the histogram is normalized by the colors found in surrounding, non-target points into a probability distribution. At each step, the tracking algorithm would backproject each point in the window into a probability that it is part of the original object. The center of the window moves in $(x, y)$ space to the mode of the distribution within the window until convergence in the same way that MeanShift iteratively moves each point to the mean of its neighbors. Every frame thereafter would be initialized with the final window of the previous frame.

\begin{algorithm}
\caption{MeanShift++ for Tracking}
\label{alg:meanshiftpp_tracking}
\begin{algorithmic}[H]
  \State {\bf Inputs}: bandwidth $h$, tolerance $\eta$, initial window $W_0$, sequence of frames $X_0,X_1,...,X_T$.
  \State Define: $W \cap X$ as pixels in window $W$ for frame $X$.
  \State Run MeanShift++ on the pixels (in color space) in $W_0 \cap X_0$ and manually select the cluster(s) desired to track. Let the union of selected cluster(s) be $C$.
  \State $B \leftarrow \{\lfloor c / h \rfloor  : c \in C\}$.
  \For{$i=1,2,...,T$}
    \State Initialize $W_i \leftarrow W_{i-1}$.
    \Do
    \State $R_i := \{ x \in W_i \cap X_i : \lfloor x / h \rfloor \in B \}$.
    \State Move $W_i$ so that it's centered at the average $(x,y)$-position of points in $R_i$.
    \doWhile{$W_i$'s center converges with tolerance $\eta$.}
    \State Optionally update $B \leftarrow \{\lfloor x / h \rfloor  : x \in W_i \cap X_i\} \cap N(B)$, where $N(B)$ are all cells that are in $B$ or adjacent to one in $B$.
    \State {\bf emit} $W_i$ for frame $X_i$.
  \EndFor
\end{algorithmic}
\end{algorithm}

MeanShift++ can be used for object tracking in a similar, albeit more principled way (Algorithm~\ref{alg:meanshiftpp_tracking}). Instead of color histograms, which need to be computed and require extra hyperparameters to determine the size of bins, the grid cells generated by MeanShift++ during clustering are already precomputed and suitable for tracking: we can quickly compute which points fall into any bin belonging to the target cluster(s).

MeanShift is also too slow to generate masks needed for real-time tracking. It often requires the user to provide a precomputed mask or color range. Relying on user input is imperfect and subject to biases. MeanShift++ is fast enough to generate masks through real-time clustering. 

Off-the-shelf versions of MeanShift tracking rely on a histogram calculated from the original frame throughout the whole scene. This does not work well if the illumination in the scene changes, since the algorithm cannot make fast updates to the histogram \cite{freedman2005illumination,whoang2012object,phadke2013illumination,phadke2017mean}. MeanShift++ can adapt to changing color distributions by finding and adding neighboring grids of points to the histogram in linear time, making it more robust to gradual changes in lighting, color, and other artifacts of the data.

CamShift \cite{bradski1998computer,allen2004object} improves MeanShift tracking by adjusting window sizes as objects move closer or farther away and updating color histograms based on lighting changes, among other things. Future work may involve adapting these ideas to a MeanShift++-based tracking algorithm.

In Figure~\ref{fig:object_tracking}, we show the performance of MeanShift++ and MeanShift (from the Python OpenCV library \cite{bradski2008learning}) on object tracking in various scenes. In practice, we found that MeanShift tends to be easily misled by the surroundings, particularly when there are areas of similar color. Finally, MeanShift++ usually finds better windows than MeanShift.
