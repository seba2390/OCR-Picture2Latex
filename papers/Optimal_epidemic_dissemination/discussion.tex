\section{The regular push-then-pull algorithm is asymptotically optimal}
\label{sec:pushthenpull}

As we demonstrated in this work, pushing is asymptotically unnecessary. Of course, practitioners have known for thirty years that it is preferable to push when the rumor is young, and to pull when the rumor is old~\cite{Demers:1987:EAR:41840.41841}.  It appears, however, that most researchers are unaware that pushing and pulling at the same time is not optimal. It also seems that both practitioners and researchers are unaware of the benefits of switching from the push to the pull phase \emph{early enough}.

The regular push-then-pull algorithm leverages the push and pull strategies when they are at their best, and decreases the prohibitive communication overhead caused by pushing messages to processes already informed. When $\fanin\in\mathcal{O}(1)$, as long as the communication overhead of the push phase is in $\mathcal{O}(n)$, the algorithm is asymptotically optimal. Note that even if pulling when the rumor is young incurs little overhead, one should substitute pull requests with push messages; for instance, a young rumor is more likely to propagate early using a regular push algorithm with $\fanout=2$ than if pushing and pulling at the same time with ${\fanout}=\fanin=1$.

Another advantage of the regular push-then-pull algorithm is that we can estimate with great precision the number of push rounds to reach a predefined communication overhead threshold. This is further discussed in the extended version of~\cite{DBLP:conf/podc/MercierHM17}, where it is proved, for instance, that running the push phase for $\log_{\fanout+1} n - \log_{\fanout+1} \ln n$ rounds guarantees that the communication overhead is in  $\mathcal{O}\left(\frac{n}{(\ln n)^2}\right)$. This makes no difference asymptotically compared to the regular pull algorithm, but in practice it bypasses the slow pull dissemination of young rumors while ensuring a bounded communication overhead. The number of messages quickly grows to $\omega(n)$ if the push phase is too long: with $\fanout=\fanin=1$, if we run the push phase during $\log_2 n +\Theta(\ln \ln n)$ rounds followed by a pull phase of $\mathcal{O}(\ln \ln n)$ rounds, the resulting push-then-pull algorithm exhibits the behavior of the seminal push-pull algorithms of Karp et al.~\cite{DBLP:conf/focs/KarpSSV00} and requires $\Theta(n \ln \ln n)$ messages. 

\section{Handling multiple rumors}
\label{sec:multiplerumors}

We can easily modify the regular pull and push-then-pull algorithms to handle multiple rumors of size $b$ over a long period of time as follows. First, processes append the age of the rumors to the messages containing them so that they know when to switch from the push to the pull phase, and when to stop their dissemination. If needed, these messages can also include the identifier of the process that first created the rumor to distinguish identical rumors initiated by multiple processes concurrently. Second, processes transmit the identity of the active rumors they already know with the pull requests to avoid receiving them multiple times during their pull phase. If $\fanin=1$, and if the overhead at the end of the push phase is in $o(n)$, then the resulting algorithms require the transmission of $n+o(n)$ messages containing each rumor and $\mathcal{O}(n \ln n \ln b) + (n+o(n)) (b + \ln \ln n)$ bits of communication per rumor. If $b$ is between $\omega(\ln \ln n)$ and $o(\ln n \ln \ln n)$, the push-pull algorithm with concise feedback of Fraigniaud and Giakkoupis~\cite{DBLP:conf/spaa/FraigniaudG10} using $\mathcal{O}(n (b + \ln \ln n \ln b ) ))$ bits is asymptotically better. However, if $b \in \omega(\ln n \ln \ln n)$, which is the case for most applications of interest, our algorithm requires $nb + o(nb)$ bits. This is optimal and better than the algorithm of~\cite{DBLP:conf/spaa/FraigniaudG10} which requires $c \cdot nb$ bits for a constant $c \geq 1$ based on the probability of imperfect dissemination. Again, asymptotically both solutions are equivalent, but we expect the simplicity of our approach and its multiplicative constant of 1 to make a significant difference for practical applications.

% %%% Local Variables:
% %%% mode: latex
% %%% TeX-master: "main"
% %%% End:
