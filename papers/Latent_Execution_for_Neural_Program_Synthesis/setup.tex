\vspace{-0.1in}
\section{Neural Program Synthesis from Input-Output Examples}
\vspace{-0.1in}
In programming by example tasks, the program specification is a set of input-output examples~\cite{devlin2017robustfill,bunel2018leveraging}. Specifically, we provide the synthesizer with a set of $K$ input-output pairs $\{(I^{(k)}, O^{(k)})\}_{k=1}^K$ ($\{IO\}^K$ in short). These input-output pairs are annotated with a ground truth program $P^\star$, so that $P^\star(I^{(k)})=O^{(k)}$ for any $k \in \{1, 2, ..., K\}$. To measure the program correctness, we include another set of held-out test cases $\{IO\}_{test}^{K_{test}}$ that differs from $\{IO\}^K$. The goal of the program synthesizer is to predict a program $P$ from $\{IO\}^K$, so that $P(I)=P^\star(I)=O$ for any $(I, O) \in \{IO\}^K + \{IO\}_{test}^{K_{test}}$.

%\label{sec:c-data}
\textbf{C Program Synthesis}. In this work, we make the first attempt of synthesizing C code in a restricted domain from input-output examples only, and we focus on programs for list processing. List processing tasks have been studied in some prior works on input-output program synthesis, but they synthesize programs in restricted domain-specific languages instead of full-fledged popular programming languages~\cite{balog2016deepcoder,odena2020learning,odena2020bustle}. 

Our C code synthesis problem brings new challenges for programming by example. Compared to domain-specific languages, the syntax and semantics of C are much more complicated, which significantly enlarges the program search space. Meanwhile, learning good representations for partially decoded programs also becomes more difficult. In particular, prior neural program synthesizers that utilize per-line interpreters for the programming language to guide the synthesis and representation learning~\cite{chen2018execution,shin2018improving,nye2020representing,Ellis2019WriteEAExtendExecution,odena2020bustle} are not directly applicable to C. Although it is possible to dump some intermediate variable states during C code execution~\cite{campbell2012executable}, since partial C programs are not executable, we are able to obtain all the execution states only until a full C code is generated, which is too late to include them in the program decoding process. In particular, the intermediate execution state is not available when the partial program is syntactically invalid, and this happens more frequently for C due to its syntax design.
\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{fig/c-program-synthesis-crop.pdf}
\caption{\small Illustration of the C program synthesis pipeline. For dataset construction, we develop a random program generator to sample random C programs, then execute the program over randomly generated inputs and obtain the outputs. The input-output pairs are fed into the neural program synthesizer to predict the programs. Note that the synthesized program can be more concise than the original random program.}
\label{fig:ex-c}
\end{figure}

