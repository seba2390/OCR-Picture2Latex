\documentclass{article}
% Recommended, but optional, packages for figures and better typesetting:
\usepackage[final,nonatbib]{neurips_2021}
\usepackage{microtype}
\usepackage{graphicx}
\usepackage{bmpsize}
% \usepackage{subfigure}
\usepackage{booktabs} % for professional tables
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[colorinlistoftodos,textsize=scriptsize]{todonotes}
\usepackage{marginnote}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{float}
\usepackage{subcaption}
\usepackage{wrapfig}
% \usepackage{xcolor}
\graphicspath{{./Figures/}}
\usepackage{hyperref}
\usepackage[utf8]{inputenc}
\usepackage{bbm}
\usepackage{enumitem}
\usepackage{pifont}
\usepackage{xcolor}
\usepackage[frozencache=true,cachedir=.]{minted}
\newif\ifarxivsubmit
\arxivsubmittrue

\title{Latent Execution for Neural Program Synthesis}
\author{
    Xinyun Chen \\
    UC Berkeley \\ 
    \texttt{xinyun.chen@berkeley.edu} 
    \And 
    Dawn Song \\
    UC Berkeley \\ 
    \texttt{dawnsong@cs.berkeley.edu}
    \And
    Yuandong Tian \\
    Facebook AI Research \\
    \texttt{yuandong@fb.com}
}

\begin{document}
\input{def}

\maketitle

\iffalse
\begin{abstract}
Program synthesis from input-output examples has been a long-standing challenge, and recent works have demonstrated some success in designing deep neural networks for program synthesis. However, existing efforts in input-output neural program synthesis have been focusing on domain-specific languages, thus the applicability of previous approaches to synthesize code in full-fledged popular programming languages, such as C, remains a question. The main challenges lie in two folds. On the one hand, the program search space grows exponentially when the syntax and semantics of the programming language become more complex, which poses higher requirements on the synthesis algorithm. On the other hand, increasing the complexity of the programming language also imposes more difficulties on data collection, since building a large-scale training set for input-output program synthesis require random program generators to sample programs and input-output examples. In this work, we take the first step to synthesize C programs from input-output examples. In particular, we propose {\ours}, which learns the latent representation to approximate the execution of partially generated programs, even if their semantics are not well-defined. We demonstrate the possibility of synthesizing elementary C code from input-output examples, and leveraging learned execution significantly improves the prediction performance over existing approaches. Meanwhile, compared to the randomly generated ground-truth programs, {\ours} synthesizes more concise programs that resemble human-written code. We show that training on these synthesized programs further improves the prediction performance for both Karel and C program synthesis, indicating the promise of leveraging the learned program synthesizer to improve the dataset quality for input-output program synthesis.
\end{abstract}
\fi

\iffalse 
in designing deep neural networks for program synthesis.
existing efforts in input-output neural program synthesis 
The main challenges lie in two folds. 

search space grows exponentially when become more complex, which poses higher requirements on the synthesis algorithm. On the other hand, increasing the complexity of the programming language also imposes more difficulties on data collection, since building a large-scale training set for input-output program synthesis require random program generators to sample programs and input-output examples. 

we take the first step to synthesize C programs from input-output examples. In particular, We demonstrate the possibility of synthesizing elementary C code from input-output examples, 
\fi

\begin{abstract}
Program synthesis from input-output (IO) examples has been a long-standing challenge. While recent works demonstrated limited success on domain-specific languages (DSL), it remains highly challenging to apply them to real-world programming languages, such as C. Due to complicated syntax and token variation, there are three major challenges: \textbf{(1)} unlike many DSLs, programs in languages like C need to compile first and are not executed via interpreters; \textbf{(2)} the program search space grows exponentially when the syntax and semantics of the programming language become more complex; and \textbf{(3)} collecting a large-scale dataset of real-world programs is non-trivial. As a first step to address these challenges, we propose {\ours} and show its efficacy in a \emph{restricted-C} domain (i.e., C code with tens of tokens, with sequential, branching, loop and simple arithmetic operations but no library call). More specifically, \ours{} learns the latent representation to approximate the execution of partially generated programs, even if they are incomplete in syntax (addressing \textbf{(1)}). The learned execution significantly improves the performance of next token prediction over existing approaches, facilitating search (addressing \textbf{(2)}). Finally, once trained with randomly generated ground-truth programs and their IO pairs, \ours{} can synthesize more concise programs that resemble human-written code. Furthermore, retraining our model with these synthesized programs yields better performance with fewer samples for both Karel and C program synthesis, indicating the promise of leveraging the learned program synthesizer to improve the dataset quality for input-output program synthesis (addressing \textbf{(3)}). When evaluating on whether the program execution outputs match the IO pairs, \ours{} achieves 55.2\% accuracy on generating simple C code with tens of tokens including loops and branches, outperforming existing approaches without executors by around 20\%.~\footnote{The code is available at \url{https://github.com/Jungyhuk/latent-execution}.}
\end{abstract}

\input{intro}
\input{setup}
\input{approach}
\input{exp}
\input{work}
\input{conc}

{%\small
\bibliographystyle{abbrv}
\bibliography{ref}
}

%\clearpage
%\input{checklist}
\clearpage
\appendix
\input{app}
\end{document}
