\section{Threats to Validity}
\label{validity}
The threats mainly exist in applying \tool{} for code optimization. The same optimization for one Python application may show different speedups on different computer architectures. Some optimizations are input-sensitive, and a different profile may demand a different optimization. We use either typical inputs or production inputs of Python applications to ensure that our optimization improves the real execution.  As \tool{} pinpoints inefficiencies and provides optimization guidance, programmers will need to devise a safe optimization for any execution.


\section{Conclusions}
\label{conclusions}
% This paper {\em for the first time} studies the interaction inefficiencies in complex Python applications. We find that interaction inefficiencies occur due to the use of native libraries in Python code, which disjoints the high-level code semantics with low-level execution behaviors. We study a large number of applications to categorize interaction inefficiencies due to their root causes. We further extract the common pattern---redundant loads and stores in the execution behaviors---across different categories of interaction inefficiencies, which helps us design \tool{} to pinpoint such inefficiencies. \tool{} leverages performance monitoring units and debug registers to pinpoint redundant loads and stores, and cooperates with the Python runtime to associate interaction inefficiencies with Python contexts. With the help of \tool{}, we are able to optimize 17 Python applications by fixing 19 interaction inefficiencies, obtaining nontrivial speedups.

This paper is the {\it first} to study the interaction inefficiencies in complex Python applications. Initial investigation finds that the interaction inefficiencies occur due to the use of native libraries in Python code, which disjoins the high-level code semantics with low-level execution behaviors. By studying a large amount of applications, we are able to assign the interaction inefficiencies to five categories based on their root causes. We extract two common patterns, redundant loads and redundant stores in the execution behaviors across the categories, and design \tool to pinpoint interaction efficiencies by leveraging PMUs and debug registers. \tool cooperates with Python runtime to associate the inefficiencies with Python contexts. With the guidance of \tool, we optimize 17 Python applications, fix 19 interaction inefficiencies, and gain numerous nontrivial speedups.




% By studying more than 100 applications, we are able to assign the interaction inefficiencies to five categories based on their root causes. We investigate two common patterns, redundant loads and 


% ...behaviors across the categories, and design PyP to pinpoint interaction efficiencies by leveraging PMUs and debugging registers. Besides pinpointing redundant loads and stores,  PyP cooperates with Python runtime to associate the inefficiencies with Python contexts. With the guidance of PyP, we optimized 17 (20???) out of more than 100 Python applications, fixed 19 interaction inefficiencies, and obtained numerous??? nontrivial speedups. 



%\newpage