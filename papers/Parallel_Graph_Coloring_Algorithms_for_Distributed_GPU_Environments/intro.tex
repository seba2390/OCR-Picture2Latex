\section{Introduction}
%motivate graph coloring by providing applications, and showing significance of the problem.
%Graph coloring is a graph problem where colors are assigned to vertices in such a way that no neighboring vertices have the same color.


We present new multi-GPU, distributed memory implementations of distance-1,
distance-2, and partial distance-2 graph coloring.
\emph{Distance-1 graph coloring} assigns \emph{colors} (i.e., labels) to all vertices in a graph such that no two neighboring vertices have the same color. 
Similarly, \emph{distance-2 coloring} assigns colors such that no vertices within \emph{two hops}, also called a ``two-hop neighborhood,'' have the same color. 
\emph{Partial distance-2 coloring} is a special case of distance-2 coloring, in which only one set of a bipartite graph's vertices are colored.
Usually, these problems are formulated as NP-hard optimization problems, where the number of colors used to fully color a graph is minimized.
Serial heuristic algorithms have traditionally been used to solve these problems, one of the most notable being the DSatur algorithm of Br{\'e}laz~\cite{brelaz1979new}.
%\todo{missing ref; is this the best serial coloring algorithm ref?  Why is it most notable?  Is this citation sufficient?}
% GMS -- most cited and arguably the 'original' purely heuristical general algorithm.
More recently, parallel algorithms~\cite{IAB:deveci2016parallel,IAB:bozdaug2008framework} have been proposed; such algorithms usually require multiple \emph{rounds} to correct for improper \emph{speculative} colorings produced in multi-threaded or distributed environments.

There are many useful applications of graph coloring.
Most commonly, it is employed to find concurrency in parallel scientific computations~\cite{IAB:deveci2016parallel, IAB:allwright1995comparison}; all data sharing a color can be updated in parallel without incurring race conditions.
Other applications use coloring as a preprocessing step to speed up the computation of Jacobian and Hessian matrices~\cite{IAB:gebremedhin2013colpack} and to identify short circuits in printed circuit designs~\cite{IAB:garey1976application}.
Despite the intractability of minimizing the number of colors for non-trivial graphs, such applications benefit from good heuristic algorithms that produce small numbers of colors.
For instance, Deveci et al.~\cite{IAB:deveci2016parallel} show that a smaller number of colors used by a coloring-based preconditioner reduces the runtime of a conjugate gradient solver by 33\%.
%If an application uses the colors to represent work units, it will also benefit from the number of vertices belonging to each color being balanced; such a coloring is called a balanced coloring.

%\note{rewrote/added specific stuff about motivation for GPUs}

In particular, this work is motivated by the use of graph coloring as a preprocessing step for distributed scientific computations such as automatic differentiation~\cite{IAB:gebremedhin2020introduction}. 
For such applications, assembling the associated graphs on a single node to run a sequential coloring algorithm may not be feasible~\cite{IAB:bozdaug2008framework}.
As such, we focus on running our algorithms on the parallel architectures used by the underlying applications.
These architectures typically are highly distributed, with multiple CPUs and/or GPUs per node.
Therefore, we specifically consider coloring algorithms that can use the ``MPI+X'' paradigm, where the Message Passing Interface (MPI) library is used in distributed memory and ``X'' is multicore CPU or GPU acceleration.

%\note{moved some stuff around}

\subsection{Contributions}

We present and examine two MPI+X implementations of distance-1 coloring as well as one MPI+X implementation of distance-2 coloring.
In order to run on a wide variety of architectures, we use the Kokkos performance portability framework~\cite{IAB:edwards2014kokkos,kokkoskernels} for on-node parallelism and Trilinos~\cite{IAB:heroux2005overview} for distributed MPI-based parallelism.
The combination of Kokkos and MPI allows our algorithms to run on multiple multicore CPUs or multiple GPUs in a system.
For this paper, we focus on the performance of our algorithms in MPI+GPU environments.
For distance-1 coloring of real-world networks, our algorithms achieve up to 2.38x speedup on 128 GPUs compared to a single GPU, and only a 2.23\% increase in the number of colors on average.
%\todo{should probably change this to ``average case'', as this unnecessarily makes us look bad}.
For distance-2 coloring, our algorithm achieves up to 33x speedup and, on average, a 7.5\% increase in the number of colors.
%For partial distance-2 coloring, our algorithm achieves up to a 39x speedup and a 8\% increase in colors on average.
We also demonstrate good weak scaling behavior up to 128 GPUs for graphs with up to 12.8 billion vertices and 76.7 billion edges.
%\note{added this last sentence. I think it'd be good to err on over-emphasizing our ability to process graphs much much larger than can fit in a single node. What's the largest graph colored before in distributed memory?}

% Distance-1 colorings require that each vertex has a different color from its neighboring vertices. 
% Distance-2 colorings require that each vertex has a different color from its neighboring vertices, and the vertices which neighbor those neighbors.
%\note{also some edits here}

%We also present a hybrid MPI+X implementation of a Distance-2 coloring algorithm.
%Distance-2 colorings are an instance of graph coloring where each vertex has a different color from each of its neighbors, and its neighbors' neighbors.

% We contribute three MPI+X algorithms for graph coloring problems that are able to run in both CPU and GPU-equipped systems.

%Our contribution is two MPI+X algorithms that are able to run in both CPU and GPU-equipped systems. 
%For Multi-GPU runs, we achieve a 3.6x speedup, while the number of colors used increases by about 24\% in the worst case.

%\fix{these go in background.}
%There are a few existing hybrid implementations for Distance-1 coloring. 
%Grosset et. al.~\cite{IAB:grosset2011evaluating} present a CPU+GPU implementation, but it is only able to utilize a single GPU.
%Sariy{\"u}ce et. al.~\cite{IAB:sariyuce2012scalable} propose an MPI+OpenMP implementation that builds off of the distributed-memory-only implementation presented by Bozda{\u{g}} et. al.~\cite{IAB:bozdaug2008framework}
%Our general approach is similar to the approach taken by Sariy{\"u}ce et. al.
%\fix{Important general introduction information that needs much more explicit detail: 1. What specific problem is this research trying to address? 2. Why is it important? How have people addressed it (most detail in background)? How am I going to address it that is different?}


%explain the problem we are trying to solve (Distance-1, Distance-2, partial Distance-2)
%\fix{this should all probably be moved to the background}
%There are many variations of graph coloring. Distance-1 graph coloring is the typical instance, where each vertex has a different color from each neighbor.
%Distance-2 is where each vertex has a different color from each of its neighbors, and from each of its neighbors' neighbors.
%Partial Distance-2 coloring is similar to Distance-2 but on a bipartite graph, and only one set of the vertices are colored.

%explain that a Distance-1 coloring can be used as a first step towards solving the other problems.


%show the significance of the problem (Distance-2 automatic differentiation, surely other applications)

