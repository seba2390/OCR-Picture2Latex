With the transformation in \cite{HongIJER15}, each party's share of problem cannot be learnt by other untrusted parties, even if the transformed shares are disclosed to them. However, the information leakage in the communication protocol cannot be quantified. We now extend it to a more secured transformation based on Homomorphic cryptosystem (e.g., Paillier \cite{Paillier99}).\footnotemark[1]

\footnotetext[1]{Homomorphic cryptosystem is a semantically-secure public key encryption with an additional property to generate the ciphertext of an arithemetic operation between two plaintexts by other operations between their individual ciphertexts. For instance, two encryptions $E(A)$ and $E(B)$, there exists operations *, such that $E(A*B)=E(A)*E(B)$ where * is either addition or mutiplication (in some abelian group).}


\subsection{Overview}

The basic idea of the extended transformation is described as follows. For any party $M_i$'s shares in the LP problem $A_i$, $B_i$ and $\vec{c_i}^T$, we let all the parties jointly transform such shares (via Homomorphic Encryption) in sequence -- while transforming $M_i$'s shares, party $M_j$ locally generates a new random nonnegative monomial matrix $\forall j\in[1,n], Q_{ij}$, and post-multiplies it to each of the three transformed shares (by the previous party). In case that $j=i$ holds, $M_i$ post-multiplies its own shares by its own matrix $Q_{ii}$. Similarly, all the parties jointly reconstruct every share of the optimal solution $\vec{y}$ by pre-multiplying their matrices in a reverse order (also via Homomorphic Encryption). 

\subsection{Extended Secure Transformation}

Without loss of generality, we let an external party $P$ (e.g., the cloud) solve the transformed problem. In the extended secure transformation protocol, $P$ generates the public/private key pair $(pk, sk)$, and distributes the public key $pk$ to $M_1,\dots, M_n$. Since the transformation for $A_i, B_i$ and $\vec{c_i}^T$ are identical \cite{HongIJER15}, we can take $A_i$ as an example to illustrate our secure transformation protocol in Algorithm \ref{algm:tran}.


\begin{algorithm}[!h]
	\small
	\begin{algorithmic}[1]
		\renewcommand{\algorithmicrequire}{\textbf{Input:}}
		\renewcommand{\algorithmicensure}{\textbf{Output:}}

		\FOR{$i \in [1,n]$} 
		\STATE $M_i$ randomly generates $Q_{ii}$ 
		
		\STATE $M_i$ encrypts $A_iQ_{ii}$ with $pk$ to generate $E=Enc_{pk}(A_iQ_{ii})$, and sends $E$ to the next party $M_j$ in Line 4
		
		\FOR{$\forall j\in [1,n], j\ne i, M_j$}
		
		\STATE $M_j$ randomly generates $Q_{ij}$ 
		
		
		\STATE $M_j$ updates $E$ with $Q_{ij}$ (Line 7-9: $E_{ab}$ denotes the entry at row $a$ and column $b$ in $E$, and $(Q_{ij})_{kb}$ denotes the entry at row $k$ and column $b$ in $Q_{ij}$)
			
		\FOR {each row $a$ of $E$ and each column $b$ of $Q_{ij}$}
		\STATE $M_j$ computes $E_{ab} \leftarrow \prod^{n}_{k=1} E_{ak}^{(Q_{ij})_{kb}}$
		\ENDFOR
		
		\STATE $M_j$ sends the updated $E$ to the next party
		
		\ENDFOR
		
		\STATE the last party sends $E$ to the solver $P$
		
		\STATE $P$ decrypts $E$ to obtain: $A_iQ_{ii}\prod_{j=1,j\ne i}^nQ_{ij}$
		
		\ENDFOR
	
\end{algorithmic}
	\caption{Extended Secure Transformation}\label{algm:tran}
\end{algorithm}

After decrypting all the ciphertexts, solver $P$ can forumate a new LP problem with the transformed shares:

\begin{align}
\forall i\in[1,n], A_i&\longrightarrow A_iQ_{ii}\prod_{j=1,j\ne i}^nQ_{ij}\nonumber\\
\forall i\in[1,n], B_i&\longrightarrow B_iQ_{ii}\prod_{j=1,j\ne i}^nQ_{ij}\nonumber\\
\forall i\in[1,n], \vec{c_i}^T&\longrightarrow \vec{c_i}^TQ_{ii}\prod_{j=1,j\ne i}^nQ_{ij}\nonumber\\
\forall i\in[1,n], \vec{x_i}&\longrightarrow \vec{y_i}
\label{eq:newtrans}  
\end{align}

Then, $P$ can solve the new LP problem and distribute the solution share $\vec{y_i}^*$ to $M_i$, which securely reconstructs its solution share in the original problem with all the other parties.

\subsection{Secure Reconstruction}

Following the proof in \cite{HongIJER15,HongJCS12}, the optimal solution in the original problem $\forall i\in[1,n], \vec{x_i}^*$ can be reconstructed as below:

\begin{equation}
\forall i\in[1,n], \vec{x_i}^*=Q_{ii}\prod_{j=1,j\ne i}^nQ_{ij}\vec{y_i}^*
\end{equation}

As a result, all the parties $M_1,\dots, M_n$ should jointly reconstruct each solution share. Then, we present the secure communication protocol for the optimal solution reconstruction in Algorithm \ref{algm:re}.

\begin{algorithm}[!h]
	\small
	\begin{algorithmic}[1]
		\renewcommand{\algorithmicrequire}{\textbf{Input:}}
		\renewcommand{\algorithmicensure}{\textbf{Output:}}
		
		\FOR{$i \in [1,n]$} 
		\STATE $M_i$ generates a public/private key pair $(pk_i, sk_i)$ and sends the public key $pk_i$ to all the other parties $M_1,\dots, M_n$ 
		
		\STATE $M_i$ encrypts $\vec{y_i}^*$ with $pk_i$ to generate $Y=Enc_{pk}(\vec{y_i}^*)$, and sends $Y$ to the next party $M_j$ in Line 4
		
		\FOR{$\forall j\in [n,1], j\ne i, M_j$} 
		
		
	\STATE $M_j$ updates $Y$ with $Q_{ij}$ (Line 6-8: $Y_a$ denotes the $a$th entry in $Y$)
	
	\FOR{each row $a$ of $Q_{ij}$}
	\STATE $M_j$ computes $Y_a \leftarrow \prod^{n}_{k=1} Y_k^{(Q_{ij})_{ak}}$
	\ENDFOR
		
		\STATE $M_j$ sends the updated $Y$ to the next party
		
		\ENDFOR
		
		\STATE the last party sends $Y$ to $M_i$
		
		\STATE $M_i$ decrypts $Y$ to obtain: $\prod_{j=1,j\ne i}^nQ_{ij}\vec{y_i}^*$
		
		\STATE $M_i$ reconstructs its share in the original optimal solution $\vec{x_i}^*=Q_{ii}\prod_{j=1,j\ne i}^nQ_{ij}\vec{y_i}^*$ (pre-multiplying by $Q_{ii}$)
		
		\ENDFOR
		
	\end{algorithmic}
	\caption{Secure Reconstruction}\label{algm:re}
\end{algorithm}

Finally, in the optimal energy sharing, each party $M_i$ can locally route the energy amount $x_{ij}^*\in \vec{x_i}^*$ to the recipient $M_j$ (note that $x_{ij}=0$ if $i=j$ holds).


\subsection{Privacy Preservation and Collusion Resistance}

\noindent\textbf{Privacy.} We now analyze the privacy leakage of the two protocols. For both extended secure transformation and secure reconstruction, there is no privacy leakage while executing the protocol under the definition of secure multiparty computation \cite{Yao86,Goldreich87} (all the messages received by all the parties can be simulated in polynomial time by repeating the protocols). Therefore, private inputs (e.g., demand, supply, and power quality of each party) can be protected. 

On the other hand, the information leakage in the outputs can be quantified:

\begin{itemize}
	\item The solver only learns the transformed optimization problem (the obfuscated shares of each party and the corresponding optimal solution).
	\item Each party only knows its share in the optimal solution, e.g., how much energy transmitted from itself to the energy recipient in the global optimal sharing.
\end{itemize}


\noindent\textbf{Handling Collusions.} The two protocols can also effectively handle potential collusions while solving the problem. None of those parties knows the actual overall transformation (aka. a combination of transformations), since each of $\{\forall i, \forall j, Q_{ij}\}$ is privately generated as a random nonnegative monomial matrix by $M_j$ (for transforming $M_i$'s shares). As a consequence, the solution reconstruction cannot be completed if any party $M_j$ is absent (missing $\forall i, M_{ij}$). Therefore, any number of microgrids (less than $n$) cannot collude with each other to infer private information from other honest microgrids while executing the protocol. The collusion resistant feature provided by the two protocols is equivalent to a trusted-third party. 