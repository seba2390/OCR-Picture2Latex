\section{Security proofs for QKD}
\label{sec:securityproofs}

In this section, we discuss security proofs for QKD. For this we consider a generic protocol as shown in \figref{fig:GenericQKD}. The techniques presented here are however not restricted to QKD. Concepts such as information reconciliation or privacy amplification, which we will describe in this section, also play a role in other protocols, for instance those discussed in \secref{sec:other}.

While the first QKD security proofs such as~\textcite{May01,SP00} treat  the entire QKD protocol as a whole, modern security proofs are modular~\cite{Ren05}. This means that a separate security statement is established for each part of the cryptographic protocol. The overall security statement for QKD then follows by combining these individual statements.  In the case of the protocol shown in \figref{fig:GenericQKD}, one statement concerns the raw key distribution and parameter estimation step (see \secref{sec:RawKeyDistribution}), another one the information reconciliation step (see \secref{sec_infrec}), and yet another one the privacy amplification step (see \secref{sec_pa}). According to the AC framework, each part can be regarded as a constructive statement, asserting that the corresponding subprotocol constructs a particular resource from certain given resources. This modular analysis does not only come with the obvious advantage that the proofs are more versatile and can be adapted to different protocols, but also that the arguments are more transparent and easier to understand and verify.

In the following, we focus on the modular approach to proving security proposed in~\textcite{Ren05}. We note however that there exist various other methods (we discuss these in \secref{sec_othersecurityproofs}). The common feature of all security proofs is that they derive a relation between the information accessible to the legitimate parties and the maximum information that may have been gained by Eve. In the description below, this relation is given by \eqnref{eq_HminBB84}; it lower bounds Eve's uncertainty about the raw key~$\mathbf{X}$ generated by Alice. Crucially, although the statement concerns Eve's knowledge, the bound depends only on data that is accessible to Alice and Bob, in this case the error rate $\eta_0$  between their raw keys $\mathbf{X}$ and~$\mathbf{Y}$.  

There are various different ways to derive and interpret such bounds on Eve's information. In the case of prepare-and-measure schemes, they can be understood as consequences of the \emph{no-cloning principle}~\cite{Wootters82}. According to this principle, if Eve attempts to copy parts of the information transmitted from Alice to Bob into her register $E$,  the transmitted information is disturbed, resulting in a decrease of the correlations between Alice and Bob. This disturbance is larger the more information Eve has gained --- a fact that is known as the \emph{information-disturbance tradeoff}~\cite{Fuchs98}. In the case of entanglement-based protocols, the bounds on Eve's information can be regarded as an instance of the \emph{monogamy of entanglement}. It asserts that the stronger Alice's entanglement with Bob the weaker is her correlation with Eve~\cite{Coffman00,Terhal04,KoashiWinter04}. 


\begin{figure}
\noindent\fbox{%
    \parbox{\columnwidth}{%
\begin{enumerate}
  \item \textbf{protocol} $\mathrm{QKD}$
  \item $(\mathbf{X}, \mathbf{Y}) := \mathrm{RawKeyDistribution()}$
  \item \textbf{if} $\mathrm{ParameterEstimation}(\mathbf{X}, \mathbf{Y}) = \mathrm{fail}$ \\ \textbf{then} \textbf{return} $(\perp, \perp)$ and \textbf{abort}
  \item $(\mathbf{X}, \mathbf{X'}) := \mathrm{InformationReconciliation}(\mathbf{X}, \mathbf{Y})$
  \item $(\mathbf{S}, \mathbf{S'}) := \mathrm{PrivacyAmplification}(\mathbf{X}, \mathbf{X'})$
  \item \textbf{return} $(\mathbf{S}, \mathbf{S'})$ 
\end{enumerate}
    }%
}
\caption{Generic QKD protocol \label{fig:GenericQKD}}
\end{figure}


\subsection{Protocol replacement} 

Cryptographic protocols that are optimised for practical use are often not easy to analyse directly. Conversely, protocols that are designed in a way that simplifies their security proofs are usually not easily implementable in practice. For example, building an entanglement-based QKD protocol in practice is technologically more challenging than building a  prepare-and-measure scheme. Conversely, the structure of entanglement-based schemes fits more naturally with the known techniques for proving security.

A first step in a security proof for a practical protocol $\pi_{\mathrm{practical}}$ is thus usually to conceive of another protocol $\pi_{\mathrm{theoretical}}$ that is adapted to the proof techniques at hand. One then argues that, for the purpose of the security proof, $\pi_{\mathrm{practical}}$ can be replaced by $\pi_{\mathrm{theoretical}}$, i.e., that the security of $\pi_{\mathrm{practical}}$ is implied by the security of $\pi_{\mathrm{theoretical}}$. A generic way to achieve this is to show that for any possible attack against $\pi_{\mathrm{practical}}$ there exists a corresponding attack against $\pi_{\mathrm{theoretical}}$.

For a concrete example, suppose that $\pi_{\mathrm{practical}}$ is the BB84 protocol~\cite{BB84}. The protocol follows the generic structure shown in \figref{fig:GenericQKD}, with a particular raw key distribution procedure as shown in \figref{fig:BB84RawKeyDistribution}. The protocol prescribes that Alice and Bob proceed in rounds. In each round~$i$, Alice inputs one qubit $Q_i$ to the quantum channel.  The qubit encodes a random signal bit $X_i$ with respect to a randomly chosen basis $B_i$. Bob measures the output $Q'_i$ of the quantum channel with respect to a randomly chosen basis $B'_i$ to obtain a bit~$Y_i$. This is a prepare-and-measure scheme and in this sense ``practical''.

\begin{figure}[h]
\noindent\fbox{%
    \parbox{\columnwidth}{%
\begin{enumerate}
  \item \textbf{protocol} $\mathrm{RawKeyDistribution}()$ [BB84]
  \item \textbf{parameters} 
     $n$ [number of signals];
     $\phi_{x, 0} := \ket{x}$, $\phi_{x,1} := \frac{1}{\sqrt{2}} (\ket{0} + (-1)^x \ket{1})$, for $x \in \{0,1\}$  [bases for encoding] 
  \item $i:=1$
  \item \textbf{while} $i \leq n$ \textbf{do}
  \item Alice chooses $B_i, X_i \in_R \{0, 1\}$ 
  \item Bob chooses $B'_i \in_R \{0,1\}$
  \item Alice prepares a qubit $Q_i$ in  state $\phi_{X_i,B_i}$ and gives it as input to the quantum channel
  \item Bob measures the output $Q'_i$ of the quantum channel w.r.t.\ basis $\{\phi_{0, B'_i}, \phi_{1, B'_i}\}$ to get $Y_i$
  \item Alice and Bob communicate $B_i$ and $B'_i$ over the classical channel
  \item \textbf{if} $B_i = B'_i$ \textbf{then} $i:=i+1$
  \item \textbf{endwhile}
  \item \textbf{return} $(\mathbf{X} = (X_1, \ldots, X_n), \mathbf{Y} = (Y_1, \ldots, Y_n))$
\end{enumerate}
    }%
}
\caption{Prepare-and-measure raw key distribution \label{fig:BB84RawKeyDistribution}}
\end{figure}

The corresponding ``theoretical'' protocol $\pi_{\mathrm{theoretical}}$ could be an entanglement-based protocol similar to the E91 protocol \cite{Eke91}. This protocol is identical to the BB84 protocol described above, except that the raw key distribution step is replaced by the procedure shown in \figref{fig:EntanglementBasedRawKeyDistribution}. In each round~$i$, Alice creates an entangled state between two qubits $\bar{Q}_i$ and $Q_i$ and sends the latter to Bob, who receives it as $Q'_i$.\footnote{Security is also guaranteed if this entangled state is generated by an untrusted third party and distributed to Alice and Bob.}  Alice and Bob then both select random bases $B_i$ and $B'_i$ and measure their qubits accordingly to obtain bits $X_i$ and $Y_i$, respectively. 

\begin{figure}[h]
\noindent\fbox{%
    \parbox{\columnwidth}{%
\begin{enumerate}
  \item \textbf{protocol} $\mathrm{RawKeyDistribution}()$ [entanglement-based]
  \item \textbf{parameters} 
     $n$ [number of signals];
     $\phi_{x, 0} := \ket{x}$, $\phi_{x,1} := \frac{1}{\sqrt{2}} (\ket{0} + (-1)^x \ket{1})$, for $x \in \{0,1\}$  [bases for encoding]
  \item $i:=1$
  \item \textbf{while} $i \leq n$ \textbf{do}
  \item Alice chooses $B_i \in_R \{0, 1\}$ 
  \item Bob chooses $B'_i \in_R \{0,1\}$
  \item Alice prepares qubits $(\bar{Q}_i, Q_i)$ in state $\smash{\frac{1}{\sqrt{2}} (\ket{0} \ket{0} + \ket{1} \ket{1})}$ and gives $Q_i$ as input to the quantum channel
    \item Alice measures $\bar{Q}_i$ w.r.t.\ basis $\{\phi_{0, B_i}, \phi_{1, B_i}\}$ to get $X_i$ 
  \item Bob measures the quantum channel output $Q'_i$ w.r.t.\ basis $\{\phi_{0, B'_i}, \phi_{1, B'_i}\}$ to get $Y_i$
    \item Alice and Bob communicate $B_i$ and $B'_i$ over the classical channel
  \item \textbf{if} $B_i = B'_i$ \textbf{then} $i:=i+1$
  \item \textbf{endwhile}
  \item \textbf{return} $(\mathbf{X} = (X_1, \ldots, X_n), \mathbf{Y} = (Y_1, \ldots, Y_n))$
\end{enumerate}
    }%
}
\caption{Entanglement-based raw key distribution \label{fig:EntanglementBasedRawKeyDistribution}}
\end{figure}

As first shown in \textcite{BBM92}, these two protocols, $\pi_{\mathrm{practical}}$ and $\pi_{\mathrm{theoretical}}$, are equivalent in terms of their security.\footnote{This statement is only valid in the device-dependent setting, but does not extend to device-independent security proofs [see \textcite{ER14}]. For full device-independent security, it is necessary to distribute entanglement.} Note first that Bob's part of the protocol is obviously the same for $\pi_{\mathrm{practical}}$ and $\pi_{\mathrm{theoretical}}$. To see the correspondence of Alice's part, consider the two bits $B_i$ and $X_i$ together with the qubit $Q_i$ generated by Alice in any round~$i$. It is straightforward to verify that, for both $\pi_{\mathrm{practical}}$ and $\pi_{\mathrm{theoretical}}$, these are described by the same ccq-state of the form
\begin{align}
  \rho_{B_i X_i Q_i}
  = \frac{1}{4} \sum_{b=0}^1 \sum_{x=0}^1 \proj{b} \otimes \proj{x} \otimes \proj{\phi_{x,b}} \ .
\end{align}
This shows in particular that, from the viewpoint of an adversary, who may have access to the quantum channel and hence to~$Q_i$, the two protocols are equivalent. 

The entanglement-based protocol $\pi_{\mathrm{theoretical}}$ described above may be further modified to make it even more suitable for security proofs. One such modification concerns the timing of the steps. Instead of running through $n$ rounds,  in each of which an entangled qubit pair is created and the qubits measured, one may instead consider a first step in which $n$ entangled qubit pairs $(\bar{Q}_i, Q_i)$ are distributed between Alice and Bob and, rather than being measured directly, first stored in quantum memories. Only in a second step Alice and Bob choose bases $B_i = B'_i$ for each of their qubit pairs and measure them accordingly. This is shown in \figref{fig:MemoryEntanglementBasedRawKeyDistribution}. An argument similar to the one above shows that this change has no impact on the security of the protocol. 

\begin{figure}[h]
\noindent\fbox{%
    \parbox{\columnwidth}{%
\begin{enumerate}
  \item \textbf{protocol} $\mathrm{RawKeyDistribution}()$ [with postponed measurement]
  \item \textbf{parameters} 
     $n$ [number of signals];
     $\phi_{x, 0} := \ket{x}$, $\phi_{x,1} := \frac{1}{\sqrt{2}} (\ket{0} + (-1)^x \ket{1})$, for $x \in \{0,1\}$  [bases for encoding]
  \item \textbf{for} $i \in \{1, \ldots, n\}$ \textbf{do}
  \item Alice prepares qubits $(\bar{Q}_i, Q_i)$ in state $\smash{\frac{1}{\sqrt{2}} (\ket{0} \ket{0} + \ket{1} \ket{1})}$ and gives $Q_i$ as input to the quantum channel
  \item Bob stores the quantum channel output $Q'_i$
  \item \textbf{endfor}
    \item \textbf{for} $i \in \{1, \ldots, n\}$ \textbf{do}
      \item Alice chooses $B_i \in_R \{0,1\}$ and communicates $B_i$ to Bob over the classical channel
 \item Alice measures $\bar{Q}_i$ w.r.t.\ basis $\{\phi_{0, B'_i}, \phi_{1, B_i}\}$ to get $X_i$     
  \item Bob measures $Q'_i$ w.r.t.\ basis $\{\phi_{0, B'_i}, \phi_{1, B_i}\}$ to get $Y_i$
  \item \textbf{endfor}
  \item \textbf{return} $(\mathbf{X} = (X_1, \ldots, X_n), \mathbf{Y} = (Y_1, \ldots, Y_n))$
\end{enumerate}
    }%
}
\caption{Entanglement-based raw key distribution with postponed measurement \label{fig:MemoryEntanglementBasedRawKeyDistribution}}
\end{figure}





\subsection{Raw key distribution and parameter estimation} \label{sec:RawKeyDistribution}

The first part of the security proof concerns the raw key distribution and the parameter estimation step. For raw key distribution we consider the particular subprotocol described in \figref{fig:MemoryEntanglementBasedRawKeyDistribution}. Parameter estimation is shown in \figref{fig:ParameterEstimation}. It essentially calculates an estimate for the fraction~$\eta$ of positions~$i$ in which the bit strings $\mathbf{X}$ and $\mathbf{Y}$ differ, i.e., $|X_i - Y_i| = 1$, and returns the value ``$\mathrm{fail}$'' if this fraction exceeds a given threshold~$\eta_0$. 

\begin{figure}[h]
\noindent\fbox{%
    \parbox{\columnwidth}{%
\begin{enumerate}
  \item \textbf{protocol} $\mathrm{ParameterEstimation}(\mathbf{X}, \mathbf{Y})$
  \item \textbf{parameters} $s$ [sample size]; $\eta_0$ [threshold]
  \item Alice chooses a subset $S \subset_R \{1, \ldots, n\}$, \\ with $n=|\mathbf{X}|$ [length of $\mathbf{X}$] and $s=|S|$ [size of $S$]
  \item Alice communicates $\{(i, X_i): \, i \in S\}$ over the classical channel
  \item Bob computes $\eta = \frac{1}{s} \sum_{i \in S} |X_i - Y_i|$
  \item \textbf{if} $\eta \leq \eta_0$ \textbf{then} \textbf{return} $\mathrm{ok}$ \textbf{else} \textbf{return} $\mathrm{fail}$
\end{enumerate}
    }%
}
\caption{Parameter estimation \label{fig:ParameterEstimation}}
\end{figure}

To run the raw key distribution and parameter estimation protocol, one needs as initial resources   an insecure quantum channel $\aQ$ together with an authentic classical channel $\aA$, as shown for example in \figref{fig:qkd.real}. The target is a \emph{raw key} resource $\aR$, which can be understood as a weak version of a shared secret key resource as shown in \figref{fig:qkd.resource.switch}. The resource~$\aR$ is equipped with a switch controlled by Eve~\cite{Portmann2017}. If the switch is in position~$1$, the resource merely outputs $\perp$ to Alice and Bob. If the switch is in position~$0$, the resource outputs bit strings $\mathbf{X}$ and $\mathbf{Y}$ of length~$n$ to Alice and Bob, but at the same time enables Eve to interact with the resource, allowing her to gain information~$E$. The latter is bounded by a secrecy condition, which may be expressed in terms of a lower bound~$t$ on the \emph{smooth min-entropy}~\cite{Ren05} of  Alice's output $\mathbf{X}$ conditioned on~$E$,
\begin{align} \label{eq:Hminboundgeneral}
  H_{\min}^\varepsilon(\mathbf{X} | E) \geq t \ .
\end{align}
Here $\varepsilon > 0$ is a small parameter that will contribute additively to the failure probability of the protocol. The choice of this particular measure for entropy will be relevant for the further proof steps below, especially privacy amplification. Intuitively, one may think of $H_{\min}^\varepsilon(\mathbf{X} | E)$ as the minimum number of bits that can be extracted from $\mathbf{X}$ that are uniform and uncorrelated to~$E$, except with probability~$\varepsilon$. 

The desired statement is that running the raw key distribution protocol followed by the parameter estimation protocol on $\aQ$ and $\aA$ constructs the raw key resource $\aR$  for appropriately chosen parameters. One may view this as the core of security proofs in QKD. It shows that a criterion on the statistics of the  data $\mathbf{X}$ and $\mathbf{Y}$ measured by Alice and Bob, as tested by the parameter estimation protocol, is sufficient to imply a certain level of secrecy of $\mathbf{X}$ towards Eve. 

To illustrate the idea behind the argument, let us for the moment focus on collective attacks (see \secref{sec:qkd.other.models}). Under this assumption, each of the qubit pairs $(\bar{Q}_i, Q'_i)$ held by Alice and Bob when they execute the raw key distribution protocol of \figref{fig:MemoryEntanglementBasedRawKeyDistribution}, prior to the measurement, is in the same state $\rho_{\bar{Q}_i, Q'_i}$. Recall, however, that the second qubit, $Q'_i$, is what Bob received. Since Eve may corrupt the quantum communication channel, it is not guaranteed that this qubit coincides with the qubit $Q_i$ that Alice sent. The state $\rho_{\bar{Q}_i, Q'_i}$ may thus be different from the entangled state $\smash{\frac{1}{\sqrt{2}} (\ket{0} \ket{0} + \ket{1} \ket{1})}$ that Alice prepared. 

To gain some intuition, it may be useful to consider the special case where the threshold in the subprotocol for parameter estimation is small, say even $\eta_0 = 0$. If the subprotocol returns the value ``$\mathrm{ok}$'' then this means that the bit strings $\mathbf{X}$ and $\mathbf{Y}$ largely coincice. This yields a constraint on the state  $\rho_{\bar{Q}_i, Q'_i}$, namely that if both Alice and Bob measure it  with respect to the basis $\{\ket{0}, \ket{1}\}$ or with respect to the basis $\{\frac{1}{\sqrt{2}} (\ket{0} \pm \ket{1} )\}$ they obtain identical outcomes, except with some small probability that is due to the finite sample size used for parameter estimation. 

It is now straightforward to verify that the only states $\rho_{\bar{Q}_i Q'_i}$ that can pass the test with $\eta_0 = 0$ are those that are close to the pure state $\smash{\frac{1}{\sqrt{2}} (\ket{0} \ket{0} + \ket{1} \ket{1})}$ that Alice prepared. Next, one may consider the joint state $\rho_{\bar{Q}_i Q'_i E}$ that includes Eve. But because the state of the first two qubits is almost pure, one can conclude that this state must be of the form
\begin{align}
  \rho_{\bar{Q}_i Q'_i E} \approx \rho_{\bar{Q}_i Q'_i} \otimes \rho_E \ .
\end{align}
That is, Eve's information $E$ is almost uncorrelated to $\bar{Q}_i$ and $Q'_i$. But because each of the $n$ bits $X_i$ of $\mathbf{X}$ is obtained from a measurement of $\bar{Q}_i$, it is as well almost uncorrelated to $E$. This proves that each bit $X_i$ is almost uniformly random and independent of $E$. The smooth min-entropy of the entire sequence $\mathbf{X}$ of bits is thus almost maximal, i.e., $H_{\min}^\varepsilon(\mathbf{X} | E) \approx n$. 

If, instead of $\eta_0 = 0$, one inserts an arbitrary value for the tolerated noise tolerance $\eta_0$, which is also known as the \emph{Quantum Bit Error Rate (QBER)}, a refinement of the argument we just sketched gives~\cite{RGK05,Ren05}
\begin{align} \label{eq_HminBB84}
  H_{\min}^{\varepsilon}(\mathbf{X}|E) \geq n (1-h(\eta_0)) + O(\sqrt{n})
\end{align}
where $h(x) = -x\log_2(x) -(1-x)\log_2(1-x)$ denotes the binary entropy function. 

We also note that the argument can be adapted to the case of device-independent security. In this case  the parameter estimation tests whether the outcome statistics of Alice and Bob violates a Bell inequality. The lower bound on the entropy then depends on the degree of this violation; see \textcite{ABGMPS07} for the example of the CHSH Bell inequality~\cite{CHSH69}.

The assumption of collective attacks is necessary    to sensibly talk about the state $\rho_{\bar{Q}_i Q'_i}$ of the individual systems. However, there are no good reasons why an adversary should be restricted to such attacks (see~\secref{sec:attacks:assumptionlist}). Modern security proofs therefore usually consist of an additional step, in which it is shown that general attacks cannot be more powerful than collective attacks. 

There exist various techniques to achieve this. The most widely one used so far is based on the \emph{exponential de Finetti theorem}~\cite{Ren05,Ren07,RC09}. The theorem states that, if a state over many subsystems, such as $\rho_{\bar{Q}_1 Q'_1 \cdots \bar{Q}_n Q'_n}$, is symmetric under reorderings, i.e., the state remains the same if one permutes the subsystems $\bar{Q}_i Q'_i$, then it is well approximated by a mixture of i.i.d.\ states, i.e., states of the form $\rho_{\bar{Q}_1 Q'_1} \otimes \cdots \otimes \rho_{\bar{Q}_n Q'_n}$. The latter corresponds to the structure one has if one assumes collective attacks. 

To apply the exponential de Finetti theorem, it is sufficient to argue that the rounds of the protocol, in which the individual signals are sent, could be reordered arbitrarily. Like in the example of the BB84 protocol described above, this is the case for most protocols that have been proposed in the literature. A notable exception are the \emph{Coherent One-Way (COW)} protocol~\cite{SBGSZ05} and the \emph{Differential Phase Shift (DPS)} protocol~\cite{IWY02}, where information is encoded in the correlations between signals. 

Another method, which is related to the de Finetti theorem, is the  \emph{post-selection technique}~\cite{CKR09}. Like the former, it can be used to lift security proofs against collective attacks to security proofs against general attacks, provided that the protocol satisfies the symmetry assumptions described above. 

Under certain conditions, it is also possible to establish bounds of the form of \eqnref{eq_HminBB84} directly for general attacks, i.e., without first restricting to collective attacks. This is the case for the approaches presented in~\textcite{CRE04} and in~\textcite{RGK05}, which are both applicable to the device\-/dependent setting, as well as the techniques proposed in~\textcite{TR11,TLGR12}, which include semi\-/device\-/independent scenarios, and in~\textcite{RUV13,VV14,MS14}, which applies to particular device\-/independent protocols. 

The most recent approach to directly prove security against general attacks relies on the  \emph{Entropy Accumulation Theorem (EAT)}~\cite{DFR20}. This approach, in contrast to methods based on the de Finetti theorem, gives rather tight min-entropy bounds even when the number~$n$ of protocol rounds is relatively small. It is furthermore applicable to the semi\-/device\-/independent and the device-independent setting~\cite{AFRV19}, which will be discussed in~\secref{sec:alternative}.

\subsection{Information reconciliation} \label{sec_infrec}

The goal of information reconciliation is to ensure that Alice and Bob have the same (raw) key. The most common way to achieve this is to regard Alice's bit string $\mathbf{X}$ as the key, and to let Bob infer this key from the information $\mathbf{Y}$ he has. To this end, Alice sends partial information about $\mathbf{X}$ to Bob over the classical channel. 

\begin{figure}[h]
\noindent\fbox{%
    \parbox{\columnwidth}{%
\begin{enumerate}
  \item \textbf{protocol} $\mathrm{InformationReconciliation}(\mathbf{X}, \mathbf{Y})$
  \item \textbf{parameters} $\mathrm{enc}, \mathrm{dec}$ [coding scheme]
  \item Alice sends $C = \mathrm{enc}(\mathbf{X})$ over the classical channel
  \item Bob computes $\mathbf{X'} = \mathrm{dec}(C, \mathbf{Y})$
\item \textbf{return} $(\mathbf{X}, \mathbf{X'})$
\end{enumerate}
    }%
}
\caption{Information reconciliation \label{fig:InformationReconciliation}}
\end{figure}

The protocol shown in \figref{fig:InformationReconciliation} uses as resources a raw key $\aR$, as described in the previous section, as well as, again, an authentic classical communication channel~$\aA$. Its purpose is to generate a weak key resource $\aR'$,  which provides a guarantee of the form of \eqnref{eq:Hminboundgeneral} on the secrecy of the key, and, in addition, ensures that  Alice and Bob's values, $\mathbf{X}$ and $\mathbf{X'}$, are identical. 

We note that information reconciliation is a purely classical subprotocol. It is also largely independent of the other parts of the QKD protocol, and hence  works in both the device-dependent and the device-independent setting. The choice of the \emph{coding scheme}, i.e., the functions $\mathrm{enc}$ and $\mathrm{dec}$ that the protocol invokes,  merely depends on the \emph{noise model}. The latter describes how  Alice and Bob's inputs to the protocol, $\mathbf{X}$ and $\mathbf{Y}$, are correlated with each other. 

The noise model is most generally specified in terms of a joint probability distribution of $\mathbf{X}$ and $\mathbf{Y}$. The coding scheme must then be chosen such that
\begin{align} \label{eq:decodingsuccess}
  \Pr\bigl[ \mathrm{dec}(\mathrm{enc}(\mathbf{X},\mathbf{Y}) = \mathbf{X}  \bigr] \geq 1-\varepsilon
\end{align}
The parameter $\varepsilon>0$  bounds the failure probability of the subprotocol and will hence, similarly to the parameter  $\varepsilon$ used in the step above,  contribute additively to the total failure probability of the QKD protocol. Furthermore, to maintain as much secrecy as possible for $\mathbf{X}$, the function $\mathrm{enc}$ should be chosen such that $C=\mathrm{enc}(\mathbf{X})$ does not reveal too much information about $\mathbf{X}$.  (Recall that the classical channel is accessible to Eve, so she may get hold of~$C$.) This may be achieved by making $C$ as small as possible. It can be shown using classical techniques from information theory that any coding scheme that satisfies \eqnref{eq:decodingsuccess} requires a communication~$C$ of
\begin{align} \label{eq:communicationbound}
  k \geq H^{\varepsilon}_{\max}(\mathbf{X} | \mathbf{Y}) \ ,
\end{align}
bits, where $H^{\varepsilon}_{\max}$ denotes the smooth max-entropy~\cite{RW05}. Furthermore, there exist coding schemes that saturate this bound (up to a small additive constant).  

In the case of an i.i.d.\ noise model, $H^{\varepsilon}_{\max}(\mathbf{X} | \mathbf{Y})$ is approximated by the Shannon entropy, up to terms of order $\sqrt{n}$, where $n$ is the length of $\mathbf{X}$. For a protocol such as BB84, which uses single qubits, and assuming that the QBER is $\eta_0$, one thus has
\begin{align}
  k \approx n h(\eta_0) + O(\sqrt{n}) \ .
\end{align}

Letting $E$ be the initial information that Eve has about the raw key $\mathbf{X}$ before information reconciliation, the secrecy after information reconciliation with communication~$C$ consisting of $k$ bits is given by
\begin{align} \label{eq:secreduction}
  H_{\min}^{\varepsilon}(\mathbf{X} | E C) \gtrapprox H_{\min}^{\varepsilon}(\mathbf{X} | E) - k - O(1) \ .
\end{align}
Hence, for an optimal information reconciliation protocol, we have 
\begin{align}
  H_{\min}^{\varepsilon}(\mathbf{X} | E C) \gtrapprox H_{\min}^{\varepsilon}(\mathbf{X} | E) - H_{\max}(\mathbf{X} | \mathbf{X'}) - O(\sqrt{n}) \ .
\end{align}
In particular, for the case of the BB84 protocol, we get 
\begin{align}
  H_{\min}^\varepsilon(\mathbf{X} | E C)  \geq n (1- 2 h(\eta_0)) - O(\sqrt{n}) \ .
\end{align}

As is clear from \eqnref{eq:secreduction}, the amount of secrecy that is left after information reconciliation  depends on the amount~$k$ of  communication required. The design of coding schemes  $(\mathrm{enc}$, $\mathrm{dec})$ that optimise this parameter is a main subject of classical information theory~\cite{CT12}. While the bound in \eqnref{eq:communicationbound} can already be saturated with randomly constructed encoding functions, a main challenge is to develop schemes for which the encoding and decoding functions are efficiently computable~\cite{LABZG08,ELAB09,EMM11,JK14}.

While the information reconciliation protocol of \figref{fig:InformationReconciliation} invokes only one-way communication from Alice to Bob, one may also consider two-way schemes. In fact, the first proposals for QKD implementations used a procedure to correct errors that required multiple rounds of communication between Alice and Bob~\cite{BBBSS92}.\footnote{Despite its two-way nature, the particular method proposed in~\textcite{BBBSS92} did not achieve the information-theoretic bounds described above. It was only realised later in~\textcite{BBCS92}, in the context of oblivious transfer, that one-way error correction is sufficient and can be made (asymptotically) optimal.} Furthermore, one may also include \emph{advantage distillation}~\cite{Mau93}. Here the idea is that Alice and Bob group their data into small blocks. They then try to distinguish blocks that are likely to contain few errors from those that are likely to contain many errors. The ones with many errors are then discarded. It has been shown that this technique can be advantageous compared to standard error correction~\cite{GL03,Ren05,TLR20}. 



\subsection{Privacy amplification} \label{sec_pa}

The aim of privacy amplification is to turn the weakly secret key~$\mathbf{X}$, which after information reconciliation is known to Alice and Bob, into  a strong secret key $K$, i.e., a bit string that is essentially uniform and independent of the information held by an adversary~\cite{BBR88,BBCM95}. This is typically achieved with a protocol as in  \figref{fig:PrivacyAmplification}. Apart from the weak key resource $\aR$, which satisfies a secrecy bound of the form of \eqnref{eq:Hminboundgeneral} and which is assumed to output the same string~$\mathbf{X}$ to Alice and Bob,  the protocol requires an authentic communication channel~$\aA$. From these resources, the protocol constructs a secret key resource as shown in \figref{fig:qkd.resource.switch}.

\begin{figure}[h]
\noindent\fbox{%
    \parbox{\columnwidth}{%
\begin{enumerate}
  \item \textbf{protocol} $\mathrm{PrivacyAmplification}(\mathbf{X}, \mathbf{X'})$
  \item \textbf{parameters} $\{\mathrm{ext}_s\}_{s \in \cS}$ [randomness extractor]
  \item Alice chooses $S \in_R \cS$ and sends it over the classical channel
  \item Alice computes $K = \mathrm{ext}_S(\mathbf{X})$ 
  \item Bob computes $K' = \mathrm{ext}_S(\mathbf{X'})$ 
  \item \textbf{return} $(K, K')$
\end{enumerate}
    }%
}
\caption{Privacy amplification \label{fig:PrivacyAmplification}}
\end{figure}

The protocol makes use of a \emph{randomness extractor}~\cite{Zuc90,Shaltiel04}. This is a family of functions $\mathrm{ext}_s$ parameterised by a \emph{seed} $s \in \cS$, which take as input a bit string, such as $\mathbf{X}$, and output a bit string of a fixed length~$\ell$. In the classical literature, a \emph{strong $(k, \varepsilon)$-extractor} is defined by the property that, for any input $\mathbf{X}$ whose min-entropy satisfies the lower bound $H_{\min}(\mathbf{X}) \geq k$, the output $\mathrm{ext}_s(\mathbf{X})$ is $\varepsilon$-close to uniform. More precisely, the expectation over a randomly chosen seed $s \in \cS$ of the variational distance between the distribution of the output $\mathrm{ext}(\mathbf{X})$ and a uniform string $U$ of $\ell$ bits must be upper bounded by $\varepsilon$,
\begin{align}
  \mathrm{Exp}_s\bigl[D(P_{\mathrm{ext}_s(\mathbf{X})}, P_{U})\bigr] \leq \varepsilon \ .
\end{align}
This definition does however not take into account the quantum nature of information that an adversary may have about $\mathbf{X}$~\cite{KMR05,GKKRD07}. It is hence not sufficient for use in the context of quantum key distribution, unless one restricts to security against individual attacks, which corresponds to forcing the adversary to store classical information only (see \secref{sec:attacks:assumptionlist}). 

To be able to prove general security, it is necessary to demand that the randomness extractor $\{\mathrm{ext}_s\}_{s \in \cS}$ be \emph{quantum-proof}, for parameters $k$ and $\varepsilon$ as above. This means that, for any $\mathbf{X}$ and any quantum system $E$ such that $H_{\min}(\mathbf{X} | E) \geq k$ one has
\begin{align}
 \mathrm{Exp}_s\bigl[D(\rho_{\mathrm{ext}_s(\mathbf{X}) E}, \rho_{U} \otimes \rho_E)\bigr] \leq \varepsilon \ .
\end{align}
Note that this criterion refers to min-entropy $H_{\min}(\mathbf{X} | E) = H_{\min}^{\varepsilon'}(\mathbf{X} | E)$ with smoothness parameter $\varepsilon' = 0$. However, a straightforward application of the triangle inequality for the distance between states implies that a corresponding criterion  also holds if $\varepsilon'>0$~\cite{Ren05}. 

A number of constructions for quantum-proof extractors have been proposed in the literature~\cite{RK05,Ren05,FS08,KT08,DPVR12,BT12,MPS12,BFS17}. In the context of QKD, the most widely used extractors are based on two-universal hashing~\cite{CW79,WC81}. As shown in~\textcite{RK05,Ren05,TSSR10}, these  can achieve an output length of  $\ell = k -  2 \log_2(1/\varepsilon)$ while still being quantum-proof $(k, \varepsilon)$ extractors. Using them within the protocol of \figref{fig:PrivacyAmplification}, it generates a key of length 
\begin{align}
   \ell = H_{\min}^\varepsilon(\mathbf{X} | E C) - O(1) \ ,
 \end{align}
 with a failure probability of the order~$\varepsilon$.
Combining this with the results of the previous sections, with optimal information reconciliation and privacy amplification, it is possible to generate a key of length
\begin{align}
  \ell = H_{\min}^\varepsilon(\mathbf{X} | E) - H_{\max}(\mathbf{X} | \mathbf{Y}) - O(1) \ .
\end{align}
In particular, in the case of the BB84 protocol, we obtain
\begin{align}
  \ell = n (1-2 h(\eta_0)) - O(\sqrt{n})
\end{align}
where $\eta_0$ is the QBER. The asymptotic key rate is thus $1-2 h(\eta_0)$. 

\subsection{Other approaches to prove security} \label{sec_othersecurityproofs}

The generic security proof described above follows the approach proposed in \textcite{Ren05}. It is sometimes termed ``information-theoretic'', as its core part consists of bounds on entropic quantities, such as \eqnref{eq_HminBB84}. Such bounds have first been proposed in \textcite{DW05}. They were further developed in \textcite{RenRen12} and used in \textcite{PhysRevLett.95.080501,RGK05}; see also \textcite{christandl2007unifying} for related work. However, as already mentioned, there exist a variety of other proof strategies. 

Early proofs~\cite{LoChau99,SP00} used a reduction to the problem of entanglement distillation. For this, one rearranges the key distribution protocol such that all measurements are postponed to the very last step. If one now omits these final measurements, Alice and Bob end up with correlated quantum registers rather than classical keys. One may thus regard the protocol as an entanglement distillation protocol~\cite{Bennett96,Benett96b} and prove that the registers held by Alice and Bob are almost maximally entangled. If this is the case then, by the monogamy of entanglement, the information in these registers is uncorrelated to Eve, and hence secret.\footnote{The following is a quantitative version of this statement. If the entanglement distilled by Alice and Bob has fidelity~$F$ to a maximally entangled state then it follows from Theorem~1 of \textcite{FuchsvanGraaf} that the corresponding security parameter~$\varepsilon$ according to~\eqnref{eq:qkd.security} is bounded by $\epsilon \leq \sqrt{1-F^2}$.}

This approach may be more generally understood as follows. Assuming that Alice and Bob's start with quantum correlation stored in individual qubits equipped with a computational basis, the entanglement distillation protocol can be regarded as a quantum error correction scheme~\cite{CS96,Steane96} that corrects both for bit and phase flip errors. The correction of bit flip errors ensures that Alice and Bob end up with the same key. The correction of phase flip errors ensures that the two registers are not only classically correlated but maximally entangled. Since, as indicated above, the latter implies secrecy, one can understand the correction of phase flip errors as a kind of privacy amplification~\cite{Renes2013}.

The technique has  been used originally to prove the security of the BB84 protocol, including variants with imperfect devices~\cite{GLLP04}, but can also be applied to other quantum key distribution protocols~\cite{Tamaki03,Koashi04,Boileau}. While the correspondence to entanglement distillation requires that error correction and privacy amplification be treated as a single quantum error correction step, it is under certain conditions possible to achieve a separation in a way similar to the modular description above~\cite{Lo03}. Furthermore, as shown in \textcite{HHHLO08}, the method also works if the registers of Alice and Bob merely contain \emph{bound entanglement}, i.e., entanglement from which no maximally entangled states can be distilled~\cite{HHH98}. 

A somewhat related strategy, proposed originally in \textcite{May01}, is the use of complementarity~\cite{Koa09}. Specifically, one uses the fact that if Alice is able to accurately predict the outcomes of a measurement in one basis, say the computational basis, then by the uncertainty principle any predictions for the outcomes of measurements in a complementary basis, e.g., the diagonal basis in the case of single qubits, will be inaccurate.  This technique has been refined in a series of works and made applicable to the study of finite-size effects~\cite{HT12,TLGR12} and to measurement-device independent cryptography~\cite{TamakiLo12}. The complementarity approach is also related to the use of  \emph{entropic uncertainty relations}~\cite{Berta10,Coles,TR11}.


%%% Local Variables:
%%% TeX-master: "main.tex"
%%% End:
