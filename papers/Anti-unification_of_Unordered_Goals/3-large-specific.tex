\section{Large and Specific Generalizations}\label{section-relation-1}

In this section we prove that msg's and lcg's as defined above can be computed with polynomial-time algorithms. First, we need the concept of a \textit{variabilization} which is basically a function mapping couples of terms to new variables. 

\begin{definition}%[Variabilization function]
	Given a context $\langle X, \mathcal{V}, \mathcal{F}, \mathcal{Q}\rangle$, let
	$V\subset \mathcal{V}$ denote a set of variables. A function $\Phi_V : \mathcal{T}^2\mapsto\mathcal{V}\cup X$ is called a \emph{variabilization function} if, for any $(t_1, t_2)\in\mathcal{T}^2$ it holds that if $\Phi_V(t_1,t_2) = v$, then
	$(1)\; v \notin V,\;(2)\;\nexists (t_1', t_2') \in \mathcal{T}^2 : (t_1', t_2') \neq (t_1, t_2) \wedge \Phi_V(t_1', t_2') = v, \; (3) \; v \in X \Leftrightarrow t_1 = t_2\in X$ and in that case, $v = t_1 = t_2$.
\end{definition}

Note that a variabilization function $\Phi_V$ introduces a new variable (not present in $V$) for any couple of terms, except when the terms are the same constant. It can thus be seen as a way to introduce new variable names when going through the process of anti-unifying two goals. In what follows, when manipulating goals $G_1$ and $G_2$, we will use $\Phi_{\vars(G_1\cup G_2)}$ to represent an arbitrary variabilization function. If the goals at hand are clearly identified from the context, we will abbreviate the notation to $\Phi$. In most upcoming examples we will use applications of $\Phi$ (e.g. $\Phi(X,Y), \Phi(t(X), 5),\dots$) rather than coined variable names (e.g. $V_1, V_2,\dots$) when an anti-unification operator is -- ostensibly or not -- at work.

Algorithm~\ref{algo-rel-1-lcg} shows the intuitive solution for computing a lcg with two goals $G_1$ and $G_2$ (where we suppose $|G_1|\le|G_2|$) as input. In the algorithm, $\au_\leqslant(A_1,A_2)$ denotes the use of a function that outputs a $\leqslant$-common generalization on the atomic level for atoms $A_1$ and $A_2$ with respect to relation $\leqslant$. In our development we will call such functions \textit{anti-unification operators}. %, defined as follows. 
As stated in the following observation, such operators exist for our relations.

\begin{algorithm}[hbtp]
	\caption{Computing a lcg $G$ for goals $G_1$ and $G_2$ with generalization relation $\leqslant$} 
	\label{algo-rel-1-lcg}
	\begin{algorithmic}
		\State $G = \{\}, R = \{\}$ 
		\For {each ($A_1 \in G_1$)}
		\For {each ($A_2 \in G_2\setminus R$)}
		\State $A_1'$ = $\au_\leqslant(A_1, A_2)$
		\If{$A_1' \neq \bot$}				
		\State $G \gets G\cup A_1'$
		\State $R \gets R\cup A_2$
		\State \textbf{break} out of the inner loop
		\EndIf
		\EndFor
		\EndFor
		\State \textbf{return} $G$
	\end{algorithmic}
\end{algorithm}

\begin{lemma}\label{lemma-au-op}
	There exist polynomial anti-unification operators to compute the $\leqslant$-lcg and/or the $\leqslant$-msg of two atoms. In particular for two atoms $A_1$ and $A_2$, there exist (1) an operator $\au_\sqsubseteq(A_1,A_2)$ computing a $\sqsubseteq$-lcg for ${A_1}$ and ${A_2}$ in $\mathcal{O}(n)$ with $n$ the arity of $A_1$; (2) an operator $\au_\preceq(A_1,A_2)$ computing a $\preceq$-lcg in $\mathcal{O}(m)$ with $m$ the maximum number of function applications in the argument terms of the atom $A_1$; (3) an operator $\dau_\sqsubseteq(A_1,A_2)$ computing a $\sqsubseteq$-msg with a complexity that is linear in the number of terms appearing in $A_1$.
\end{lemma}
%The lemma will be shown correct by the definition of three anti-unification operators. A first anti-unification operator, based on $\sqsubseteq$ is the following. 
%
%\begin{definition}%[Simple anti-unification operator]
%	\label{def-atoms-au}
%	Given a variabilization function $\Phi$, let $\au^\Phi_\sqsubseteq$ (or simply $\au_\sqsubseteq$ if $\Phi$ is clear from the context) denote the anti-unification operator such that for any two atoms $A = a(t^A_1, \dots, t^A_n)$ and $B = b(t^B_1, \dots, t^B_m)$, it holds that \[\au^{\Phi}_\sqsubseteq(A,B)=\left\{\begin{array}{l}
%	a\big(\Phi(t^A_1, t^B_1), \dots, \Phi(t^A_n, t^B_n)\big) \\ \qquad  \mbox{if } a = b \mbox{ and } n = m\\
%	\bot \\
%	\qquad \mbox{otherwise}\\
%	\end{array}\right. \]
%\end{definition} 
%
%\begin{example}\label{ex-au-sq}
%	In Table~\ref{table:sqsubseteq}, we show three atomic anti-unification results obtained by the application of $\au_\sqsubseteq^\Phi$ with $\Phi$ a given variabilization function. Note how in the first example, the predicates used in $A_1$ and $A_2$ differ (resp. $p/2$ and $p/3$), leading to an impossible anti-unification.
%\end{example}
%
%\begin{table*}
%	\caption{Example results for $au_\sqsubseteq^\Phi$}
%	\label{table:sqsubseteq}
%	\centering
%		\begin{tabular}{l|l|l}
%		%\hline 
%		$\bm{A_1}$ & $\bm{A_2}$ & $\bm{\au_\sqsubseteq^\Phi(A_1, A_2)}$\\\hline 
%		$p(X, 5, q(Y,4))$ & $p(W,t(Z))$ & $\bot$\\\hline 
%		$p(r(X,3), t(5))$ & $p(W, t(Z))$ & $p(\Phi(r(X,3),W), \Phi(t(5), t(Z)))$\\\hline 
%		$p(r(X,3), t(Y))$ & $p(r(W,3),t(Z))$ & $p(\Phi(r(X,3),r(W,3)), \Phi(t(Y),t(Z)))$ %\\\hline 
%	\end{tabular} 
%\end{table*}
%
%Note that the anti-unification operator defined in Definition~\ref{def-atoms-au} differs from the traditional subsumption operator in the ordered case (i.e. when goals are ordered sequences of atoms). The difference comes from the fact that our goals being sets, all the possible couples of atoms have to be considered, whereas traditional subsumption must handle one atom at the time, making the anti-unification operator more straigtforward.     
%
%Let us now introduce a second anti-unification operator that will allow to compute a $\preceq$-lcg. 
%%and to prove Theorem~\ref{thm-preceq-lcg}. 
%Since the result of this operator should be a $\preceq$-common generalization, the operator need only to anti-unify the \textit{variables} occurring at the corresponding positions in the atoms under investigation. 
%The operator must thus go deeper into the term structure of the atoms than $\au_\sqsubseteq$ does, as it needs to only anti-unify those atoms that harbor the exact same structure at the level of their non-variable terms.
%\begin{definition}%[Variable anti-unification operator]
%	\label{def-term-au-through-variables}
%	Given some variabilization function $\Phi$, let $\au^\Phi_\preceq$ (or simply $\au_\preceq$ if $\Phi$ is clear from the context) denote the function such that for any two terms $T = t(t_1, \dots, t_n)$ and $U = u(u_1, \dots, u_m)$ it holds that
%	\[\au^\Phi_\preceq(T,U)=\left\{\begin{array}{l}
%	\Phi(T,U) 
%		\\ \qquad \mbox{if } T\in\mathcal{V}\mbox{ and } U\in\mathcal{V}
%	\\t\big(\au^\Phi_\preceq(t_1,u_1), \dots, \au^\Phi_\preceq(t_n, u_n)\big) 
%		\\ \qquad \mbox{if } t = u \mbox{ and } n = m 
%		\\ \qquad \mbox{and } \forall i \in 1..n: \au^\Phi_\preceq(t_i,u_i)\neq\bot
%	\\ \bot
%		\\ \qquad  \mbox{otherwise}
%	\end{array}\right.\]
%	and for any two atoms $A = a(t^A_1, \dots, t^A_n)$ and $B = b(u^B_1, \dots, u^B_m)$, it holds that
%	\[\au^\Phi_\preceq(A,B)=\left\{\begin{array}{l}
%	a\big(\au^\Phi_\preceq(t^A_1, u^B_1),\dots, \au^\Phi_\preceq(t^A_n, u^B_n)\big) 
%		\\ \qquad \mbox{if } a = b \mbox{ and } n = m 
%		\\ \qquad \mbox{and } \forall i \in 1..n: \au^\Phi_\preceq(t^A_i, u^B_i) \neq\bot
%	\\ \bot  
%		\\ \qquad \mbox{otherwise}
%	\end{array}\right.\]
%\end{definition}
%
%\begin{example}
%	In Table~\ref{table:preceq}, we treat the anti-unification of the same atoms as above, this time with the use of $\au_\preceq^\Phi$ with $\Phi$ a given variabilization function. Note how $\au_\preceq$ behaves differently than $\au_\sqsubseteq$ on the second and third couple of atoms as it requires its arguments to exhibit a similar structure in order to be anti-unifiable.
%\end{example}
%
%\begin{table*}
%	\caption{Example results for $au_\preceq^\Phi$}
%	\label{table:preceq}
%	\centering
%		\begin{tabular}{l|l|l}
%		%\hline
%		$\bm{A_1}$ & $\bm{A_2}$ & $\bm{\au_\preceq^\Phi(A_1, A_2)}$\\\hline 
%		$p(X, 5, q(Y,4))$ & $p(W,t(Z))$ & $\bot$\\\hline 
%		$p(r(X,3), t(5))$ & $p(W, t(Z))$ & $\bot$\\\hline 
%		$p(r(X,3), t(Y))$ & $p(r(W,3),t(Z))$ & $p(r(\Phi(X,W),3), t(\Phi(Y,Z)))$ %\\\hline
%	\end{tabular}
%\end{table*}
%
%Now, in order to compute $\sqsubseteq$-msgs, we need a more precise anti-unification operator: one that goes deeper into detail when comparing atoms so as not to miss their maximal common structure. 
%\begin{definition} %[Deep anti-unification operator]\label{def-deep-operator}
%	Given some variabilization function $\Phi$, let $\dau^\Phi_\sqsubseteq$ (or simply $\dau_\sqsubseteq$ if $\Phi$ is clear from the context) denote the function such that for any two terms $T = t(t_1, \dots, t_n)$ and $U = u(u_1, \dots, u_m)$ it holds that 
%	\[\dau^\Phi_\sqsubseteq(T,U)=\left\{\begin{array}{l}
%	
%	t\big(\dau^\Phi_\sqsubseteq(t_1,u_1), \dots, \dau^\Phi_\sqsubseteq(t_n, u_n)\big) 
%		\\ \qquad \mbox{if } t = u \mbox{ and } n = m 
%		\\ \qquad \mbox{and } T \notin \mathcal{V} \mbox{ and } U \notin \mathcal{V}
%	\\ \Phi(T,U) 
%		\\ \qquad \mbox{otherwise}
%	\end{array}\right.\]
%	and for any two atoms $A = a(t^A_1, \dots, t^A_n)$ and $B = b(u^B_1, \dots, u^B_m)$, it holds that
%	\[\dau^\Phi_\sqsubseteq(A,B)=\left\{\begin{array}{l}
%	a\big(\dau^\Phi_\sqsubseteq(t^A_1, u^B_1),\dots, \dau^\Phi_\sqsubseteq(t^A_n, u^B_n)\big) 
%		\\ \qquad \mbox{if } a = b \mbox{ and } n = m 
%	\\ \bot
%		\\ \qquad \mbox{otherwise}
%	\end{array}\right.\]
%\end{definition}
%
%When applied on atoms, it is easy to see that $\dau_\sqsubseteq$ is an anti-unification operator based on relation $\sqsubseteq$.
%
%\begin{example}
%	Let us once more consider the anti-unification of the atoms introduced in Example~\ref{ex-au-sq}. This time we make use of $\dau_\sqsubseteq^\Phi$ with $\Phi$ a given variabilization function, to anti-unify the three pairs of atoms. The result is shown in Table~\ref{table:dau} Notice how the operator preserves as much non-variable atomic structure as possible in the process.
%\end{example}
%\begin{table*}
%	\caption{Example results for $dau_\sqsubseteq^\Phi$}
%	\label{table:dau}
%	\centering
%	\begin{tabular}{l|l|l}
%		%\hline 
%		$\bm{A_1}$ & $\bm{A_2}$ & $\bm{\dau_\sqsubseteq^\Phi(A_1, A_2)}$\\\hline 
%		$p(X, 5, q(Y,4))$ & $p(W,t(Z))$ & $\bot$\\\hline 
%		$p(r(X,3), t(5))$ & $p(W, t(Z))$ & $p(\Phi(r(X,3),W),t(\Phi(5,Z)))$\\\hline 
%		$p(r(X,3), t(Y))$ & $p(r(W,3),t(Z))$ & $p(r(\Phi(X,W),3), t(\Phi(Y,Z)))$ %\\\hline 
%	\end{tabular} 
%\end{table*}
%The existence of these operators proves Lemma~\ref{lemma-au-op}.

%\begin{definition}%[Anti-unification operator]
%	An \emph{anti-unification operator based on $\leqslant$} is a function $f:\mathcal{A}\times\mathcal{A}\mapsto \mathcal{A}\cup\{\bot\}$ such that for any couple of atoms $(A, B)$, it holds that $f(A,B)$ returns either a $\leqslant$-common generalization of $A$ and $B$ or $\bot$.
%\end{definition}

%In other words, if the atoms $A$ and $B$ involve the same predicate symbol, $\au_\sqsubseteq(A,B)$ will be an atom involving that same predicate but where its arguments are either a constant (if the corresponding arguments in $A$ and $B$ are the same constant) or a new variable. If the atoms involve different predicate symbols, they cannot be anti-unified and the operator returns $\bot$.
%
%\begin{example}\label{ex-au-sq}
%	In the following table, we show three atomic anti-unification results obtained by the application of $\au_\sqsubseteq^\Phi$ with $\Phi$ a given variabilization function. Note how in the first example, the predicates used in $A_1$ and $A_2$ differ (resp. $p/2$ and $p/3$), leading to an impossible anti-unification.
%	
%	\begin{center}
%		\begin{tabular}{l|l|l}
%			%\hline 
%			$\bm{A_1}$ & $\bm{A_2}$ & $\bm{\au_\sqsubseteq^\Phi(A_1, A_2)}$\\\hline 
%			$p(X, 5, q(Y,4))$ & $p(W,t(Z))$ & $\bot$\\\hline 
%			$p(r(X,3), t(5))$ & $p(W, t(Z))$ & $p(\Phi(r(X,3),W), \Phi(t(5), t(Z)))$\\\hline 
%			$p(r(X,3), t(Y))$ & $p(r(W,3),t(Z))$ & $p(\Phi(r(X,3),r(W,3)), \Phi(t(Y),t(Z)))$ %\\\hline 
%		\end{tabular} 
%	\end{center}
%\end{example}

% First, consider relation $\sqsubseteq$ along with the following reasoning: by definition, an atom's arguments are terms, so that two atoms that both represent a call to a same predicate $p/n$ have a trivial $\sqsubseteq$-common generalization $p(V_1,\dots, V_n)$ with $\forall i\in1..n: V_i\in\mathcal{V}$. If instead the atoms represent calls to different predicates (say $p/n$ and $q/m$), they can't be anti-unified: their anti-unification should return $\bot$. This is achieved by the following operator.

Algorithm~\ref{algo-rel-1-lcg} merely applies a given anti-unification operator to pairs of atoms and keeps the results (if not $\bot$) in the generalization under construction, leading to the conclusion:
\begin{theorem}\label{thm-ausqsubseteq}
	Given two goals $G_1$ and $G_2$, Algorithm~\ref{algo-rel-1-lcg} can compute (1) a $\sqsubseteq$-lcg in $\mathcal{O}(|G_1|\cdot |G_2|\cdot N)$ with $N$ the maximum arity of the predicate symbols occurring in $G_1$ and $G_2$; (2) a $\preceq$-lcg in $\mathcal{O}(|G_1|\cdot |G_2|\cdot N)$ with $M = \underset{A\in G_1}{\max}\{|\allterms(A)|\}$. 
	%$N = \underset{a(t_1,\dots, t_n)\in G_1}{\max}\{n\}$. 
\end{theorem}
%\begin{proof}
%	Obviously the $\au_\sqsubseteq(A_1,A_2)$ operation can be achieved in a time linear with respect to the arity $n$ of $A_1$. In the worst case, the operation needs to be performed for each atom in $G_1$ with respect to each atom in $G_2$. Hence the result.
%\end{proof}

Note that although Algorithm~\ref{algo-rel-1-lcg} is able to find a $\sqsubseteq$-lcg for two goals $G_1$ and $G_2$, it can produce different lcg's depending on the order in which the atoms of $G_1$ and $G_2$ are considered. %The following result states that the same algorithm can be used to compute $\preceq$-lcgs in polynomially bounded time.
%Obviously $\au_\preceq$ is an anti-unification operator based on relation $\preceq$ when applied on atoms. As it is defined recursively on terms, we have the following result.
%\begin{theorem}\label{thm-preceq-lcg}
%	
%\end{theorem}
%\begin{proof}
%	It is easy to see that the $\au_\preceq(A_1,A_2)$ operation can be achieved in linear time with respect to the maximum number of function applications in the argument terms of the atom $A_1$ under scrutiny. In the worst case, the operation needs to be performed for each atom in $G_1$ with respect to each atom in $G_2$. Hence the result.
%\end{proof}
Although the $\preceq$-lcg computed by Algorithm~\ref{algo-rel-1-lcg} is necessarily a $\preceq$-msg (according to Proposition~\ref{prop-msg-lcg-preceq}), the same observation does not hold when the underlying relation is $\sqsubseteq$ and the anti-unification operator is adapted accordingly. The fact that Algorithm~\ref{algo-rel-1-lcg} can miss out on a $\sqsubseteq$-msg is due to the algorithm itself not trying to match those pairs of atoms $(A_1, A_2)$ that share as much structure as possible. Therefore, finding a $\sqsubseteq$-lcg with maximal $\terms$-value (i.e. a $\sqsubseteq$-msg) can be seen as an optimization problem.

%\begin{example}
%	Let us once more consider the anti-unification of the atoms introduced in Example~\ref{ex-au-sq}. This time we make use of $\dau_\sqsubseteq^\Phi$ with $\Phi$ a given variabilization function, to anti-unify the three pairs of atoms. Notice how the operator preserves as much non-variable atomic structure as possible in the process.
%	
%	\begin{center}
%		\begin{tabular}{l|l|l}
%			%\hline 
%			$\bm{A_1}$ & $\bm{A_2}$ & $\bm{\dau_\sqsubseteq^\Phi(A_1, A_2)}$\\\hline 
%			$p(X, 5, q(Y,4))$ & $p(W,t(Z))$ & $\bot$\\\hline 
%			$p(r(X,3), t(5))$ & $p(W, t(Z))$ & $p(\Phi(r(X,3),W),t(\Phi(5,Z)))$\\\hline 
%			$p(r(X,3), t(Y))$ & $p(r(W,3),t(Z))$ & $p(r(\Phi(X,W),3), t(\Phi(Y,Z)))$ %\\\hline 
%		\end{tabular} 
%	\end{center}
%\end{example}
%

Indeed, applying Algorithm~\ref{algo-rel-1-lcg} as-is does not guarantee that the matched atoms from $G_1$ and $G_2$ are chosen in a way that optimizes the output's $\terms$-value. The algorithm should be adapted in such a way that first, the anti-unification of $A_1$ and $A_2$ is computed for \textit{all} $A_1\in G_1$ and $A_2\in G_2$; then, there must be a selection of pairs of atoms so that the resulting generalization has a maximized $\terms$-value. This is similar to the well-known assignment problem, and can consequently be solved by existing maximization matching algorithms~\cite{CATTRYSSE1992260}. Indeed, with $G_1$ and $G_2$ the goals at hand, our problem can be characterized by drawing a weighted bipartite graph with as left vertexes the atoms of $G_1$ and as right vertexes the atoms of $G_2$. When considering as granted an operator $\dau\footnote{For \textit{deep anti-unification}}_\sqsubseteq$ computing a $\sqsubseteq$-msg for two atoms, an edge between two vertexes $A_1$ and $A_2$ has an associated weight $w$ indicating the potential benefit (in number of terms and predicate symbols) of anti-unifying $A_1$ and $A_2$, formally defined as 
\[w(A_1,A_2)=\left\{\begin{array}{ll}
-1 & \mbox{if } \dau_\sqsubseteq(A_1, A_2) = \bot
\\ |\terms(\dau_\sqsubseteq(A_1,A_2))| & \mbox{otherwise}
\end{array}\right.\]

Since all edges are labeled by a measurement of their $\terms$-value, the maximum weight matching (MWM) in the bipartite graph will give the selection of pairs of atoms that, once properly anti-unified, keep the maximal structure in the generalization. Observe that by giving negative scores to atom couples that do not anti-unify, we prevent these couples from playing any part in the computed generalization. %The entire process is described in Algorithm~\ref{algo-rel-1-mwm}.

\begin{example}\label{example-mwm}
	Let us consider the goals $G_1 = \{p(X, t(4)), r(u(5,s(Y)),8), r(u(8,Z),5)\}$ and $G_2 = \{p(A), r(u(8,s(3)),5)\}$. The corresponding assignment problem is shown in Figure~\ref{fig:mwm}. The MWM consists of the sole edge $(r(u(8, Z), 5), r(u(8, s(3)), 5)$, so that the resulting generalization for this simple example is $G = \{r(u(8, \Phi(Z, s(3))), 5)\}$.
\end{example}

\begin{figure}
%	\hspace{-0.3cm}
	\begin{tikzpicture}[thick,
	fsnode/.style={draw, circle},
	ssnode/.style={draw, circle},
	every fit/.style={ellipse,text width=3cm},
	-,shorten >= 3pt,shorten <= 3pt,
	]
	
	% the vertices of U
	\begin{scope}[start chain=going below,node distance=6mm]
	\node[fsnode,on chain] (g1) [label=left: {$p(X, t(4))$}] {};
	\node[fsnode,on chain] (g2) [label=left: {$r(u(5,s(Y)),8)$}] {};
	\node[fsnode,on chain] (g3) [label=left: {$r(u(8,Z),5)$}] {};
	\end{scope}
	
	% the vertices of V
	\begin{scope}[xshift=3.6cm,start chain=going below,node distance=10mm]
	\node[ssnode,on chain] (h1) [label=right: {$p(A)$}] {};
	\node[ssnode,on chain] (h2) [label=right: {$r(u(8,s(3)),5)$}] {};
	\end{scope}
	
	% the set U
	\node [black, fit=(g1) (g3),label=above:{$G_1$}] {};
	% the set V
	\node [black, fit=(h1) (h2),label=above:{$G_2$}] {};
	
	\path (g1) edge[bend left] node [fill=white] {$-1$} (h1);
	\path (g1) edge node [fill=white] {$-1$} (h2);
	
	\path (g2) edge[bend left] node [fill=white] {$-1$} (h1);
	\path (g2) edge node [fill=white] {$3$} (h2);
	
	\path (g3) edge[bend right] node [fill=white] {$-1$} (h1);
	\path (g3) edge[bend right] node [fill=white] {$4$} (h2);
	]	
	\end{tikzpicture}
	\caption{The bipartite graph for the assignment problem from Example~\ref{example-mwm}}
	\label{fig:mwm}
	
\end{figure}

%\begin{algorithm}[hbtp]
%	\caption{Computing an msg $G$ for goals $G_1$ and $G_2$ with relation $\leqslant$} 
%	\label{algo-rel-1-mwm}
%	\begin{algorithmic}
%		\State $G = \{\}$ 
%		\State $E = \{\}$
%		\For {each ($A_1 \in G_1$)}
%			\For {each ($A_2 \in G_2$)}
%				\State $s\gets$ $\score(A_1, A_2)$
%				\State $E \gets E \cup \{(A_1, A_2, \mbox{s})\}$
%			\EndFor
%		\EndFor
%		\State $H \gets \MWM(E)$
%		\For {each $(A_1,A_2,s) \in H$} 
%			\State $G\gets G\cup\au_\leqslant(A_1,A_2)$ 
%		\EndFor
%	\end{algorithmic}
%\end{algorithm}

\begin{theorem}\label{thm-sqsubseteq-msg}
	Let $G_1$ and $G_2$ be goals and $N = \underset{A\in G_1}{\max}\{|\allterms(A)|\}$. Then a $\sqsubseteq$-msg of $G_1$ and $G_2$ can be computed in $\mathcal{O}\big(|G_1|\cdot |G_2|\cdot N +max(|G_1|,|G_2|)^3\big)$.
\end{theorem}
%\begin{proof}
%	First note how the atomic anti-unifications and the weights of the associated bipartite graph's edges can be computed simultaneously, by working out $\dau_\sqsubseteq(A_1,A_2)$ for each possible couple $(A_1,A_2)$ in $G_1\times G_2$ and keeping account of the number of non-variable terms encountered during the operation (or $-1$). Given that $\dau_\sqsubseteq(A_1,A_2)$ can obviously operate linearly in the number of terms appearing in $A_1$ (denoted $N$), the computation of all weights is carried out in a time not exceeding $\mathcal{O}(|G_1|.|G_2|.N)$.
%	
%	Now the obtained assignment problem can be solved by existing algorithms (such as the Hungarian method~\cite{assignment}) that compute a MWM in $\mathcal{O}(n^3)$, where $n$ is the number of vertexes appearing on the side of the bipartite graph that has the most vertexes. In our case, there are $|G_1|$ left vertexes and $|G_2|$ right vertexes so that a MWM algorithm can be ran in $\mathcal{O}(max(|G_1|,|G_2|)^3)$.
%\end{proof}

Note that the process described above finds \textit{a} $\sqsubseteq$-msg but there is no guarantee regarding \textit{which} $\sqsubseteq$-msg is found: as previously observed, the maximal $\terms$-value can sometimes be reached through different atomic structures. Another inconstant parameter from one msg to the other is the number of \textit{different} variables that are introduced in the generalization process. In fact, both aspects can sometimes be related, for example when minimizing the number of variables leads to the choice of a certain msg structure over another. A $\sqsubseteq$-most specific generalization that has \textit{as few} different variables as possible is often seen as an even more specific generalization; the computation of such a msg is the main topic of the following section.
%However, notice that invariably, all $\sqsubseteq$-msg's of two goals $G_1$ and $G_2$ only differ in their variable names, i.e. two $\sqsubseteq$-msg's necessarily harbor the same atomic structure, due to the matching process by essence trying to match in priority the atoms that have the heaviest structure.