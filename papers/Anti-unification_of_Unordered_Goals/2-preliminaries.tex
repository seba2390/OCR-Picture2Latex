\section{Preliminaries}\label{section-preliminaries}
In the following, we introduce concepts and notations that will be used throughout the paper. We suppose a language of Horn clauses defined over a context, which is a 4-tuple $\langle X, \mathcal{V}, \mathcal{F}, \mathcal{Q}\rangle$, where $X$ is a non-empty set of constant values, $\mathcal{V}$ is a set of variable names, $\mathcal{F}$ a set of function names and $\mathcal{Q}$ a set of predicate symbols. The sets $X, \mathcal{V}, \mathcal{F}$ and $\mathcal{Q}$ are all supposed to be disjoint sets. Symbols from $\mathcal{F}$ and $\mathcal{Q}$ have an associated arity (i.e. its number of arguments) and we write $f/n$ to represent a symbol $f$ having arity $n$. Given a context $\mathcal{C} = \langle X, \mathcal{V}, \mathcal{F}, \mathcal{Q}\rangle$, we define the set of \textit{terms} over it as $\mathcal{T}_\mathcal{C}= X \cup \mathcal{V} \cup \{f(t_1, t_2, \dots, t_n) | f/n \in \mathcal{F}\wedge\forall i \in 1..n : t_i \in \mathcal{T}_\mathcal{C}\}$. Terms are thus ground domain constants, variables and functor-based expressions over other terms. In what follows we will use uppercase symbols to represent variables whereas lowercase symbols will be used for function and predicate symbols. 
The set of \textit{atoms} over $\mathcal{C}$ is defined as $\mathcal{A}_\mathcal{C}=\{p(t_1,\ldots,t_n)\:|\:p/n\in \mathcal{Q} \wedge \forall i\in 1..n:t_i\in\mathcal{T}_\mathcal{C}\}$. An atom $p(t_1,\ldots,t_n)$ is understood as representing an atomic formula involving the predicate $p$ over $n$ arguments, the arguments being represented by terms.
%An atom is understood as a \textit{call} to a predicate $p/n$, each of the $n$ arguments of the call being terms. %For an atom $A = a(t_1, \dots, t_n)$, we will use $\lVert A \rVert$ to denote the arity $n$ of the predicate $a/n$ it is built upon.
%
A \textit{goal} $G$ is a set of atoms, representing an (unordered) conjunction, thus $G\subseteq\mathcal{A}_\mathcal{C}$. 
%A program $P$ is then defined over a context $\mathcal{C}$ as a set of constraint Horn clause definitions where each clause definition is of the form $p(V_1,\ldots,V_n)\leftarrow G$ with $p(V_1,\ldots,V_n)$ an atom where $\forall i \in 1..n:V_i\in\mathcal{V}$ called the head of the clause, and $G$ a goal called the body of the clause. 

\begin{example}\label{ex:syntax}
    Let us consider a numerical context (e.g. $X = \mathbb{Z}$ and $\mathcal{F}$ is the set of usual functions over integers composed of addition ($+$), substraction ($-$), integer division ($/$), multiplication ($*$) and modulo ($\%$)). Supposing $X$ and $Y$ to represent variables, then the following are terms: $3$, $X$, $+(3,X)$,  $+(4, *(X,\%(Y, 2)))$.
    Given predicates $p/1$, $q/1$, $r/2$ and $c/2$, the following are atoms: $p(3)$, $q(X)$, $r(+(2,4), +(3,X))$
    %Goals being sets of atoms, $\{p(3), r(+(2,4), +(3,X))\}$ is a goal.
\end{example}


%When the context is unambiguous, we will omit the $\mathcal{C}$ subscript of the above notations. In the paper, we consider working with an arbitrary context $\mathcal{C} = \langle X, \mathcal{V}, \mathcal{F}, \mathcal{Q}\rangle$. For the sake of clarity, in textual representations of program artefacts we will suppose that $\mathcal{V}$ is constituted of capitalized symbols while functors and predicate symbols will be typed in lowercase, as is the case in Example~\ref{ex:syntax}. 

%A fact is a clause with only constraints in its body. For a predicate symbol $p$, we use $\pred(p)$ to denote the definition of $p$ in the program at hand, i.e. the set of clauses having a head atom using $p$ as predicate symbol. Without loss of generality, we suppose that all clauses defining a predicate have the same head (i.e. use the same variables to represent the arguments).

In what follows we will often leave the underlying context implicit and simply talk about variables, function and predicate symbols. A \textit{substitution} is a mapping from variables to terms and will be denoted by a Greek letter. For any substitution $\sigma : \mathcal{V} \mapsto \mathcal{T}_\mathcal{C}$, $\dom(\sigma)$ represents its domain, $\img(\sigma)$ its image, and for a program expression $e$ (be it a term, an atom or a goal) and a substitution $\sigma$, we write $e\sigma$ to represent the result of substitution application, i.e. simultaneously replacing in $e$ those variables $V$ that are in $\dom(\sigma)$ by $\sigma(V)$. A \textit{renaming} is a special kind of substitution, mapping variables to variables only. Thus for any renaming $\rho$ we have that $\img(\rho) \subseteq \mathcal{V}$. %Two expressions $e_1$ and $e_2$ are \textit{variants}, denoted $e_1\sim e_2$ if and only if $e_1\rho=e_2$ and $e_1=e_2\rho^{-1}$ for some injective renaming $\rho$. 
%\begin{example}
%    Let us consider the goal $G = \{a(9,X), b(X,Y,W)\} $.
%    Applying the substitution $\sigma = [X\mapsto Z, Y\mapsto +(1,Z)]$ on $G$ yields $G\sigma = \{a(9,Z), b(Z,+(1,Z),W)\}$. %Similarly, applying the renaming $\rho = [X\mapsto C, Y\mapsto D, Z\mapsto E, W\mapsto F]$ on $G$ yields $G\rho = \{a(9,C), b(C,D,F)\}$.
%\end{example}
We can now define what constitutes a generalization relation $\sqsubseteq$, which essentially defines a goal as more general than another if the latter is a potentially larger and potentially more instantiated goal than the former. 

\begin{definition}%[Generalization]
	\label{def-generalization}
	Let $G$ and $G'$ be goals. $G$ is a \emph{generalization} of $G'$ if and only if there exists $\theta$, a substitution such that $G\theta \subseteq G'$. We denote this fact by $G\sqsubseteq G'$ (or sometimes $G\sqsubseteq_\theta G'$ if we want to emphasize the substitution $\theta$ in question).
\end{definition}

\begin{example}
	$\{p(X,Y,Z)\}, \{q(a(X))\}$ and $\{p(t(1), Y, u(Z)), q(W)\}$ are generalizations of $\{p(t(1), t(2), u(+(4,X))), q(a(t(u(1))))\}$.
\end{example} 

In some applications (e.g. for some usual computation domains in Constraint Logic Programming), it makes sense to use a more restricted generalization relation, in which variables are substituted by other variables rather than terms. As such, when the substitution $\theta$ in Definition~\ref{def-generalization} is a renaming, we say that $G$ is a \textit{variable generalization} of $G'$, which we denote by $G\preceq G'$ (or sometimes $G\preceq_\theta G'$ to emphasize the renaming $\theta$ in question). When considering the relation $\preceq$, only variables are generalized and the function symbols are considered as being a part of the language structure itself (i.e. they are not subject to generalization). This can be advantageous, for instance in applications working with a small finite domain such as Booleans, where considering $G = \{=\!\!(A,B)\}$ to be a generalization of both $\{=\!\!(X, true)\}$ and $\{=\!\!(Y, false)\}$ can feel like ignoring too much of the goal's semantics.
%
%\begin{example}
%	$\{r(A, t(3), u(+(B,2))), q(C)\}$ and $\{q(Z)\}$ are variable generalizations of $\{r(X,t(3), u(+(Y,2)), q(X)\}$. 
%\end{example}

Our generalization relations are variations of the classical $\theta$-subsumption~\cite{plotkin}, adapted to goals being sets rather than ordered sequences of atoms. They share the following property with $\theta$-subsumption.
\begin{proposition}\label{prop-quasi-order}
	Relations $\sqsubseteq$ and $\preceq$ are quasi-orders. 
\end{proposition}
%\begin{proof}
%	We will prove the result for relation $\sqsubseteq$, the proof for $\preceq$ being similar. We need to prove that $\sqsubseteq$ is reflexive and transitive. For reflexivity, it is obvious that since $G\subseteq G$ for any goal $G$, we have $G\sqsubseteq_\theta G$ for the empty substitution $\theta$. For transitivity, suppose that for goals $G_1$, $G_2$ and $G_3$, it holds that $G_1 \sqsubseteq_{\theta_1} G_2$ and $G_2 \sqsubseteq_{\theta_2} G_3$. Then by Definition~\ref{def-generalization}, there exist sets of atoms $\Delta_1$ and $\Delta_2$ such that $G_1\theta_1 \cup \Delta_1 = G_2$ and $G_2\theta_2\cup\Delta_2 = G_3$. In other words it holds that $(G_1\theta_1\cup\Delta_1)\theta_2\cup\Delta_2 = G_3$ or equivalently, $(G_1\theta_1)\theta_2 \cup (\Delta_1\theta_2 \cup\Delta_2) = G_3$. As the composition of two substitutions is a substitution, by defining $\theta_3 = \theta_2\circ\theta_1$ and $\Delta_3 = \Delta_1\theta_2 \cup\Delta_2$, we have $G_1\theta_3 \cup \Delta_3 = G_3$, so $G_1\sqsubseteq_{\theta_3} G_3$, which concludes the proof. 
%\end{proof}

We will now turn our attention towards the basic concept in anti-unification, namely that of a goal being a \textit{common generalization} of some given goals~\cite{plotkin}. In the following, we restrict ourselves to common generalizations of \textit{two} goals, but the concept can straightforwardly be extended to any number of goals. As for notation, when a result or definition holds for both our relations $\preceq$ and $\sqsubseteq$, for the sake of simplicity we will sometimes use $\leqslant$ to denote both relations at once. 

\begin{definition}%[Common generalization]
	\label{def-common-generalization} 
	Let $G_1,\dots,G_n$ be goals and $\leqslant$ a generalization relation. Then $G$ is a \emph{$\leqslant$-common generalization} of $\{G_1,\dots,G_n\}$ if and only if $\forall i \in 1..n : G\leqslant G_i$.
\end{definition}

The definition essentially states that each $G_i (1\le i\le n)$ can be generalized by $G$ through its own substitution. Formally there exist $\theta_1, \dots, \theta_n$ such that $\forall i \in 1..n : G \sqsubseteq_{\theta_i} G_i$. A common generalization of goals is thus, in essence, a part of their shared atomic structure, with a possible introduction of variables in certain places -- the liberality of which depends on the underlying relation. Note that renamings being (restricted) substitutions, for any two goals $G$ and $G'$ it holds that $G\preceq_\theta G' \Rightarrow G\sqsubseteq_\theta G'$ so that if a goal is a $\preceq$-common generalization of a set of goals it is also a $\sqsubseteq$-common generalization of said goals. 

\begin{example}\label{ex:common-gen}
	Let $G_1 = \{p(t(X), Y), q(3, f(X))\}$ and $G_2 = \{p(5, Z), q(3, f(Z))\}$. The following is a (non-exhaustive) list of $\sqsubseteq$-common generalizations of $G_1$ and $G_2$: $\emptyset, \{p(V_1, V_2)\}$, $\{q(3, f(V_1))\}, \{p(V_1, V_2), q(V_3, V_4)\}, \{p(V_1, V_2), q(3, V_3)\}$. The following are $\preceq$-common generalizations of $G_1$ and $G_2$ as well: $\emptyset, \{q(3, f(V_1))\}$. 
\end{example} 

As a slight lexical abuse, given atoms $\{A_1,\dot,A_n\}$ we will say that an atom $A$ is a $\leqslant$-common generalization of $\{A_1,\dot,A_n\}$ iff $\{A\}$ is a $\leqslant$-common generalization of $\{A_1,\dot,A_n\}$.
%
Note that no matter the relation and no matter the goals $G_1$ and $G_2$, at least one common generalization will always exist: the empty goal $\emptyset$. Obviously, wherever possible we are interested in more detailed representations of the common structure found in goals. 

For an expression $e$, we use $\vars(e)$ to represent the set of variables that appear in $e$ and $\terms(e)$ to denote the multiset of all atoms and non-variable terms occurring in $e$. We will sometimes refer to the cardinality of $\tau(e)$ as the $\tau$-value of $e$. The multiset of all atoms and terms, variables included, is denoted by $\allterms(e)$.
\begin{example}
	Let $G$ be the goal $\{p(f(x, Y)), q(Y,X)\}$. The multiset $\tau(G)$ is equal to $\{p(f(x,Y)), f(x,Y), x, q(Y,X)\}$. $G$'s $\tau$-value is $4$, $\vars(G) = \{X,Y\}$ and $\allterms(G)$ is the multiset $\{p(f(x,Y)), f(x,Y), x, Y, q(Y,X), Y, X\}$. 
\end{example} %For an expression $e$, a fresh renaming of $e$ is a variant of $e$ where all variables have been renamed to new, previously unused variables.

 One is typically interested in those common generalizations that are the \textit{most specific}, i.e. that capture as much common structure as possible amongst $G_1$ and $G_2$~\cite{plotkin}.  

\begin{definition}%[Most specific generalization]
	\label{def-msg}
	Given goals $G_1,\dots,G_n$ and $G$ such that $G$ is a $\leqslant$-common generalization of $\{G_1,\dots,G_n\}$, we say that $G$ is a \emph{$\leqslant$-most specific generalization ($\leqslant$-msg)} of $\{G_1,\dots,G_n\}$ if $\nexists G'$, another $\leqslant$-common generalization of $\{G_1,\dots,G_n\}$, such that $|\terms(G')|>|\terms(G)|$.
\end{definition}

\begin{example}\label{ex:msg}
	Consider again the goals $G_1$ and $G_2$ from Example~\ref{ex:common-gen}. It is easy to see that $G = \{p(V_1, V_2), q(3, f(V_3))\}$ has a higher $\terms$-value than all the other common generalizations listed in the example; $G$ is in fact a $\sqsubseteq$-msg of $G_1$ and $G_2$, and in this case, all other msg's of $G_1$ and $G_2$ differ from $G$ only in a renaming of the variables $V_1$, $V_2$ and $V_3$. As for relation $\preceq$, the goal $\{q(3, f(V_1))\}$ as well as its variants with $V_1$ renamed are $\preceq$-msg's of $G_1$ and $G_2$. 
\end{example} 

A weaker yet useful measure for comparing common generalizations is the number of atoms (i.e. the cardinality) of the common generalization $G$. 

\begin{definition}%[Largest common generalization]
	\label{def-mcg}
		Given goals $G_1,\dots,G_n$ and $G$ such that $G$ is a $\leqslant$-common generalization of $\{G_1,\dots,G_n\}$, we say that $G$ is a \emph{$\leqslant$-largest common generalization ($\leqslant$-lcg)} of $\{G_1,\dots,G_n\}$ if $\nexists G'$, another $\leqslant$-common generalization of $\{G_1,\dots,G_n\}$, such that $|G'|>|G|$.
\end{definition}

%The following example stresses the differences between msg and lcg.
\begin{example}\label{ex:lcg} 
	Let us again take a look at the goals from Example~\ref{ex:common-gen}. Each goal of size 2 (such as $\{p(V_1, V_2), q(V_3, V_4)\}$) is a $\sqsubseteq$-lcg, seeing that no larger $\sqsubseteq$-common generalization can exist as $|G_1| = |G_2| = 2$. Regarding the $\preceq$ relation, common generalizations of size 1 (e.g. $\{q(3, f(V_1))\}$) are the largest that exist in the example since the atoms involving $p/2$ have no $\preceq$-common generalization because of the structural difference in their first argument. 
\end{example} 

Before we can dive into the process of computing common generalizations, a few more preliminary observations need to be assessed regarding relations $\sqsubseteq$ and $\preceq$. First, 
%observe the following property that holds for both relations, essentially stating that a common generalization that is not a lcg has a direct extension obtained by the addition of one atom. 
%
%\begin{proposition}\label{prop-lcg-extensible}
%	Let $G_1, \dots, G_n$ and $G$ be goals such that $G$ is a $\leqslant$-common generalization, but not a $\leqslant$-lcg, of $\{G_1, \dots, G_n\}$. Then there exists an atom $A\notin G$ such that $G\cup\{A\}$ is a $\leqslant$-common generalization of $\{G_1, \dots, G_n\}$.
%\end{proposition} 
% Next,
we state that there is no other way for a common generalization to be most-specific than to harbor as many atoms as possible.
\begin{proposition}\label{prop-msg-lcg}\label{prop-msg-lcg-preceq}
	Any $\leqslant$-msg is a $\leqslant$-lcg and any $\preceq$-lcg is a $\preceq$-msg. 
\end{proposition}	

\begin{example} 
	Let us consider $G_1 = \{a(Y,Z), a(t(1), X)\}$ and $G_2 = \{a(t(1), E)\}$ as well as $G = \{a(t(1), V_1)\}$. It is easy to see that $G$ (and all its variations with $V_1$ renamed) is the only $\preceq$-lcg (thus $\preceq$-msg), as $G_2$'s atom can only be anti-unified with the atom in $G_1$ that has the same structure -- and so the same $\terms$-value. Here, $G$ is also a $\sqsubseteq$-msg (thus a  $\sqsubseteq$-lcg).
\end{example} 

Regarding $\sqsubseteq$, the converse of the above proposition ("any $\sqsubseteq$-lcg is a $\sqsubseteq$-msg") is not true, as shown by the following example.
Let us consider $G_1 = \{a(Y,Z), a(t(1), X)\}$ and $G_2 = \{a(t(1), E)\}$ as well as the following $\sqsubseteq$-lcg's: $G = \{a(V_1,V_2))\}$ and $G' = \{a(t(1), V_1)\}$. Obviously $|\tau(G')| = 3 >|\tau(G)| = 1$. In fact, $G'$ is a $\sqsubseteq$-msg for this example. 

For a set of goals $\{G_1,\dots,G_n\}$, we have defined most specific and largest generalizations using the plural. In fact, by the definitions above and as appears clearly in our examples, $G_1, \dots, G_n$ can have more than one $\preceq$-lcg (and equivalently $\preceq$-msg), but all are equivalent modulo a variable renaming. The same does not necessarily hold with the relation $\sqsubseteq$: %As outlined in Example~\ref{example-msg-lcg} for instance,
there might exist more than one sensibly different $\sqsubseteq$-lcg's, depending on the degree at which the different terms are abstracted away through the generalizations process. The following example shows that a similar observation holds for $\sqsubseteq$-msg's. 

\begin{example} 
	Consider the goals $G_1 = \{p(t,u)\}$ and $G_2 = \{p(t,X),p(X,u)\}$. There are two possible structures of $\sqsubseteq$-msg's, namely $\{p(t,V_1)\}$ and $\{p(V_1, u)\}$. There is one more possible structure of $\sqsubseteq$-lcg, namely $\{p(V_1, V_2)\}$
\end{example} 

For the sake of clarity, in the results and discussions that follow we will simplify and consider common generalizations of \textit{two} goals, but the ideas are straightforwardly applicable to groups of more than two goals. Furthermore, when discussing the generalization process of two goals we will suppose that the goals in question share no common variable name. This hypothesis is by no means a loss of generality as renaming all variables from one goal into fresh, unused variable names can ensure this property while not altering the goal's semantics.



%For brevity, in the following we will denote by \lcg (resp. \msg) the problem of finding a lcg (resp. msg) for two goals.


%A variant of the generalization relation of Definition~\ref{def-generalization} is the \textit{variable generalization} relation.

%\begin{definition}[Variable generalization]\label{def-variable-generalization}
%	Let $G$ and $G'$ be goals. $G$ is a \emph{variable generalization} of $G'$, denoted $G \preceq_\sigma G$, if and only if $\exists \rho$, a renaming such that $G\rho \subseteq G'$. 
%\end{definition}

%Consider some goal $G'$ and one of its generalizations $G$ with respect to either $\sqsubseteq$ or $\preceq$. Both relations allow that if some program structure $e$ occurs more than once in $G'$, it can be generalized by different variables in $G$. This is no hard limitation for our relations: the fact that $G$ has more variables than $G'$ comes as a natural consequence of $G$ being a more generalized, and thus more variabilized, form of $G'$. However, it can be useful to limit the number of introduced variables through the generalization process, for instance when looking for the most specific $G$ generalizing a group of goals. Both our relations thus harbor a more strict form when the substitution (or renaming) from Definition~\ref{def-generalization} is injective. We will denote by $\sqsubseteq^\iota$ and $\preceq^\iota$ these variants of relations $\sqsubseteq$ and $\preceq$, respectively, and will as a slight abuse of language sometimes characterize the relations themselves as injective, rather that the substitution.

%\begin{definition}[Injective generalization]\label{def-injective-generalization}
%	Let $G$ and $G'$ be goals. If $\exists \mu$, an injective substitution such that for some (variable) generalization relation $\leqslant$, it holds that $G\leqslant_\mu G'$, then we say that $G$ is an \emph{injective generalization of} $G'$, denoted $G\leqslant^\iota_\mu G'$. 
%\end{definition}

%In fact, injective generalization considers a goal to be a generalization of another if dataflows from the latter are preserved in the former. To grasp the interest of injective generalization, consider the following example.

%%\begin{example}
%Let $G = \{g(X,0), f(X,5), h(X, Y)\}$ be a goal over some numerical computation domain. With variable generalization, $G_1 = \{g(A, 0), f(B,5)\}$ is a generalization of $G$, i.e. $G_1\preceq_{[A -> X, B -> X]}G$. However, $G_1$ isn't an injective generalization, as variable $X$ is generalized by two different variables. In contrast, $\mu = [A -> X]$ and goal $G_2 = \{g(A,0), f(A,5)\}$ verify $G_2\preceq^\iota_\mu G$.
%\end{example}

%In the following lines, we will refer to relations $\sqsubseteq, \sqsubseteq^\iota, \preceq$ and $\preceq^\iota$ as the \textit{generalization relations}. Each of these relations is in fact a partial order.