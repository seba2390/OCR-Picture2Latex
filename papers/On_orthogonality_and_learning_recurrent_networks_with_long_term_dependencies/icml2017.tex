\documentclass{article} % For LaTeX2e

% From ICML example template
\usepackage{times}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{natbib}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{hyperref}

% Packages hyperref and algorithmic misbehave sometimes.  We can fix
% this with the following command.
\newcommand{\theHalgorithm}{\arabic{algorithm}}

% ICML
\usepackage[accepted]{icml2017} 

% Other
\usepackage{url}
\usepackage{amsmath}
\usepackage{placeins}
\usepackage{mathrsfs}
\usepackage[utf8]{inputenc}
\usepackage{amsfonts}
\usepackage{todonotes} 
\usepackage{bm}
\usepackage{upgreek}
\usepackage{mathtools,xparse}

\icmltitlerunning{On orthogonality and learning RNNs with long term dependencies}

\begin{document}

\twocolumn[
\icmltitle{On orthogonality and learning recurrent networks with long term dependencies}

\begin{icmlauthorlist}
\icmlauthor{Eugene Vorontsov}{poly,mila}
\icmlauthor{Chiheb Trabelsi}{poly,mila}
\icmlauthor{Samuel Kadoury}{poly,chum}
\icmlauthor{Chris Pal}{poly,mila}
\end{icmlauthorlist}

\icmlaffiliation{poly}{École Polytechnique de Montréal, Montréal, Canada}
\icmlaffiliation{mila}{Montreal Institute for Learning Algorithms, Montréal, Canada}
\icmlaffiliation{chum}{CHUM Research Center, Montréal, Canada}

\icmlcorrespondingauthor{Eugene Vorontsov}{eugene.vorontsov@gmail.com}
\vskip 0.3in
]

\printAffiliationsAndNotice{}

\begin{abstract}
It is well known that it is challenging to train deep neural networks and recurrent neural networks for tasks that exhibit long term dependencies. The vanishing or exploding gradient problem is a well known issue associated with these challenges. One approach to addressing vanishing and exploding gradients is to use either soft or hard constraints on weight matrices so as to encourage or enforce orthogonality. Orthogonal matrices preserve gradient norm during backpropagation and may therefore be a desirable property. This paper explores issues with optimization convergence, speed and gradient stability when encouraging or enforcing orthogonality. To perform this analysis, we propose a weight matrix factorization and parameterization strategy through which we can bound matrix norms and therein control the degree of expansivity induced during backpropagation. We find that hard constraints on orthogonality can negatively affect the speed of convergence and model performance.
\end{abstract}


\section{Introduction}

The depth of deep neural networks confers representational power, but also makes model optimization more challenging. Training deep networks with gradient descent based methods is known to be difficult as a consequence of the vanishing and exploding gradient problem ~\citep{hochreiter1997long}. Typically, exploding gradients are avoided by clipping large gradients ~\citep{pascanu2013difficulty} or introducing an $L_2$ or $L_1$ weight norm penalty. The latter has the effect of bounding the spectral radius of the linear transformations, thus limiting the maximal gain across the transformation. ~\citet{krueger2015regularizing} attempt to stabilize the norm of propagating signals directly by penalizing differences in successive norm pairs in the forward pass and ~\citet{pascanu2013difficulty} propose to penalize successive gradient norm pairs in the backward pass. These regularizers affect the network parameterization with respect to the data instead of penalizing weights directly.

Both expansivity and contractivity of linear transformations can also be limited by more tightly bounding their spectra. By limiting the transformations to be orthogonal, their singular spectra are limited to unitary gain causing the transformations to be norm-preserving. ~\citet{le2015simple} and ~\citet{henaff2016orthogonal} have respectively shown that identity initialization and orthogonal initialization can be beneficial. ~\citet{arjovsky2015unitary} have gone beyond initialization, building unitary recurrent neural network (RNN) models with transformations that are unitary by construction which they achieved by composing multiple basic unitary transformations. The resulting transformations, for some n-dimensional input, cover only some subset of possible $\mathit{n \times n}$ unitary matrices but appear to perform well on simple tasks and have the benefit of having low complexity in memory and computation. Similarly, \citep{jing2016tunable} introduce an efficient algorithm to cover a large subset.

The entire set of possible unitary or orthogonal parameterizations forms the Stiefel manifold. At a much higher computational cost, gradient descent optimization directly along this manifold can be done via geodesic steps \citep{nishimori2005note,tagare2011notes}. Recent work \citep{wisdom2016fullcap} has proposed the optimization of unitary matrices along the Stiefel manifold using geodesic gradient descent. To produce a full-capacity parameterization for unitary matrices they use some insights from \citet{tagare2011notes}, combining the use of canonical inner products and Cayley transformations. Their experimental work indicates that full capacity unitary RNN models can solve the copy memory problem whereas both LSTM networks and restricted capacity unitary RNN models having similar complexity appear unable to solve the task for a longer sequence length (${\mathit{T }}$ = 2000). \citet{hyland2017learning} and \citet{mhammedi2016efficient} introduced more computationally efficient full capacity parameterizations. \citet{harandi2016generalized} also find that the use of fully connected ``Stiefel layers'' improves the performance of some convolutional neural networks.

We seek to gain a new perspective on this line of research by exploring the optimization of real valued matrices within a configurable margin about the Stiefel manifold. We suspect that a strong constraint of orthogonality limits the model's representational power, hindering its performance, and may make optimization more difficult. We explore this hypothesis empirically by employing a factorization technique that allows us to limit the degree of deviation from the Stiefel manifold\footnote{Source code for the model and experiments located at \url{https://github.com/veugene/spectre_release}}. While we use geodesic gradient descent, we simultaneously update the singular spectra of our matrices along Euclidean steps, allowing optimization to step away from the manifold while still curving about it.

\subsection{Vanishing and Exploding Gradients}

The issue of vanishing and exploding gradients as it pertains to the parameterization of neural networks can be illuminated by looking at the gradient back-propagation chain through a network.

A neural network with ${\mathit{N}}$ hidden layers has pre-activations
\begin{equation}
 \mathbf{a}_i(\mathbf{h}_{i-1}) = \mathbf{W}_i \; \mathbf{h}_{i-1} + \; \mathbf{b}_i, \ \ i \in \{2, \cdots, N-1\}
\end{equation}
For notational convenience, we combine parameters ${\mathbf{W}_i}$ and ${\mathbf{b}_i}$ to form an affine matrix $\boldsymbol{\uptheta}$. We can see that for some loss function ${\mathit{L}}$ at layer ${\mathit{n}}$, the derivative with respect to parameters ${\boldsymbol{\uptheta}_{i}}$ is:

\begin{equation}\label{eq:dL_dtheta}
\frac{\partial L}{\partial \boldsymbol{\uptheta}_{i}} =
\frac{\partial \mathbf{a}_{n+1}}{\partial \boldsymbol{\uptheta} _{i}}
\frac{\partial L}{\partial \mathbf{a}_{n+1}}
\end{equation}

The partial derivatives for the pre-activations can be decomposed as follows:
\begin{equation}\label{eq:chain_rule}
\begin{aligned} 
\frac{\partial \mathbf{a}_{i+1}}{\partial \boldsymbol{\uptheta}_i}
&=
\frac{\partial \mathbf{a}_i}{\partial \boldsymbol{\uptheta}_i}
\frac{\partial \mathbf{h}_i}{\partial \mathbf{a}_i}
\frac{\partial \mathbf{a}_{i+1}}{\partial \mathbf{h}_i}
\\&=
\frac{\partial \mathbf{a}_i}{\partial \boldsymbol{\uptheta}_i} \; \mathbf{D}_i \mathbf{W}_{i+1}
\ \rightarrow \
\frac{\partial \mathbf{a}_{i+1}}{\partial \mathbf{a}_i} = \mathbf{D}_i \mathbf{W}_{i+1},
\end{aligned}
\end{equation}
where ${\mathbf{D_i}}$ is the Jacobian corresponding to the activation function, containing partial derivatives of the hidden units at layer ${\mathit{i \;+}}$ 1 with respect to the pre-activation inputs. Typically, ${\mathbf{D}}$ is diagonal. Following the above, the gradient in equation \ref{eq:dL_dtheta} can be fully decomposed into a recursive chain of matrix products:
\begin{equation}
\frac{\partial L}{\partial \boldsymbol{\uptheta}_{i}} =
\frac{\partial \mathbf{a}_i}{\partial \boldsymbol{\uptheta}_i}
\prod_{j=i}^{n} (\mathbf{D}_j \mathbf{W}_{j+1})
\frac{\partial L}{\partial \mathbf{a}_{n+1}}
\end{equation}

In \citet{pascanu2013difficulty}, it is shown that the 2-norm of ${\mathit{\dfrac{\partial \mathbf{a}_{i+1}}{\partial \mathbf{a}_i}}}$ is bounded by the product of the norms of the non-linearity's Jacobian and transition matrix at time ${\mathit{t\;}}$ (layer ${\mathit{i}}$), as follows:
\begin{equation}\label{eq:bounded_norm}
\begin{aligned}
\begin{gathered}
\left| \left | \frac{\partial \mathbf{a}_{t+1}}{\partial \mathbf{a}_{t}} \right| \right| \leq || \mathbf{D}_t || \; || \mathbf{W}_t || \leq \lambda_{\mathbf{D}_t} \; \lambda_{\mathbf{W}_t} = \eta_t , \\  \ \lambda_{\mathbf{D}_t} , \lambda_{\mathbf{W}_t} \in \mathbb{R}.
\end{gathered}
\end{aligned}
\end{equation}
where $\lambda_{\mathbf{D}_t}$ and $\lambda_{\mathbf{W}_t}$ are the largest singular values of the non-linearity's Jacobian ${\mathit{\mathbf{D}_t}}$ and the transition matrix ${\mathit{\mathbf{W}_t}}$. In RNNs, ${\mathit{\mathbf{W}_t}}$ is shared across time and can be simply denoted as ${\mathit{\mathbf{W}}}$.

Equation \ref{eq:bounded_norm} shows that the gradient can grow or shrink at each layer depending on the gain of each layer's linear transformation ${\mathbf{W}}$ and the gain of the Jacobian ${\mathbf{D}}$. The gain caused by each layer is magnified across all time steps or layers. It is easy to have extreme amplification in a recurrent neural network where ${\mathbf{W}}$ is shared across time steps and a non-unitary gain in ${\mathbf{W}}$ is amplified exponentially. The phenomena of extreme growth or contraction of the gradient across time steps or layers are known as the exploding and the vanishing gradient problems, respectively. It is sufficient for RNNs to have $\eta_t$ $\leq$ 1 at each time $t$ to enable the possibility of vanishing gradients, typically for some large number of time steps ${T}$. The rate at which a gradient (or forward signal) vanishes depends on both the parameterization of the model and on the input data. The parameterization may be conditioned by placing appropriate constraints on ${\mathbf{W}}$. It is worth keeping in mind that the Jacobian ${\mathbf{D}}$ is typically contractive, thus tending to be norm-reducing) and is also data-dependent, whereas ${\mathbf{W}}$ can vary from being contractive to norm-preserving, to expansive and applies the same gain on the forward signal as on the back-propagated gradient signal.

\section{Our Approach}
\label{sec:method}

%\subsection{Encouraging orthogonality vs. bounding expansivity and contractivity}

Vanishing and exploding gradients can be controlled to a large extent by controlling the maximum and minimum \emph{gain} of ${\mathit{\mathbf{W}}}$.
% Define gain here
The maximum gain of a matrix $\mathbf{W}$ is given by the spectral norm which is given by
\begin{equation}
||\mathbf{W}||_2= \max\Bigg[ \frac{||\mathbf{W}\mathbf{x}||}{||\mathbf{x}||} \Bigg].
\end{equation}

By keeping our weight matrix $\mathbf{W}$ close to orthogonal, one can ensure that it is close to a norm-preserving transformation (where the spectral norm is equal to one, but the minimum gain is also one). One way to achieve this is via a simple soft constraint or regularization term of the form:
\begin{equation}\label{eq:soft_orthogonality}
\lambda \sum_i ||\mathbf{W}_i^T \mathbf{W}_i - \mathbf{I}||^2.
\end{equation}
However, it is possible to formulate a more direct parameterization or factorization for $\bf{W}$ which permits \emph{hard bounds} on the amount of expansion and contraction induced by $\bf{W}$.   %transformation's singular values which determine the gain that it applies on an input along its basis vectors. 
This can be achieved by simply parameterizing ${\mathbf{W}}$ according to its singular value decomposition, which consists of the composition of orthogonal basis matrices ${\mathbf{U}}$ and ${\mathbf{V}}$ with a diagonal spectral matrix ${\mathbf{S}}$ containing the singular values which are real and positive by definition. We have
\begin{equation}
\mathbf{W}=\mathbf{U}\mathbf{S}\mathbf{V}^T.
\label{eq:factorization}
\end{equation}
Since the spectral norm or maximum gain of a matrix is equal to its largest singular value, this decomposition allows us to control the maximum gain or expansivity of the weight matrix by controlling the magnitude of the largest singular value. Similarly, the minimum gain or contractivity of a matrix can be obtained from the minimum singular value.
%as we have:
%\begin{equation}
%||\mathbf{W}||_2^2= \textrm{trace}(\mathbf{W}^T\mathbf{W}) = \sum_{i=1}^{min(m,n)} s_i^2, 
%\end{equation}
% where $\mathit{W^*}$ denotes the conjugate transpose of $\mathit{W}$, and $\mathit{s_i}$ are the singular values of W that constitute the diagonal of ${\mathit{S}}$. 
%when $\mathit{W}$ is complex one can use $\mathit{W^*}$, the conjugate transpose in place of ${W^T}$. 
%where ${\mathit{m}}$ and ${\mathit{n}}$ are respectively the rows of the squared matrices ${\mathbf{U}}$ and ${\mathbf{V}}$ and constitute also the dimension of $\mathbf{W}$.
%When $\mathbf{W}$ is real, 

We can keep the bases $\mathbf{U}$ and $\mathbf{V}$ orthogonal via \emph{geodesic gradient descent} along the set of weights that satisfy $\mathbf{U}^T\mathbf{U}=\mathbf{I}$ and $\mathbf{V}^T\mathbf{V}=\mathbf{I}$ respectively.  The submanifolds that satisfy these constraints are called Stiefel manifolds. We discuss how this is achieved in more detail below, then discuss our construction for bounding the singular values.

%We then bound the deviation of the ${\mathit{i^{th}}}$ singular value ${\mathit{s_i}}$ from unity by parameterizing each singular value with a sigmoid. The singular values are thus allowed to fall within some margin ${\mathit{m}}$ around one, i.e.
%\begin{equation}
%s_i = m(\sigma(s_{i,param}) - 0.5) + 1
%\end{equation}

%\subsection{Hard orthogonality constraints}

During optimization, in order to maintain the orthogonality of an orthogonally-initialized matrix $\bf{M}$, i.e. where $\bf{M}= \bf{U}$, $\bf{M}= \bf{V}$ or $\bf{M}= \bf{W}$ if so desired, we employ a Cayley transformation of the update step onto the Stiefel manifold of (semi-)orthogonal matrices, as in \citet{nishimori2005note} and \citet{tagare2011notes}. Given an orthogonally-initialized parameter matrix $\bf{M}$ and its Jacobian, $\bf{G}$ with respect to the objective function, an update is performed as follows:
\begin{equation}\label{eq:geoSGD}
\begin{aligned}
&\mathbf{A} = \mathbf{G}\mathbf{M}^T - \mathbf{M}\mathbf{G}^T\\
&\mathbf{M}_{new} = (\mathbf{I}+\frac{\eta}{2} \mathbf{A})^{-1}(\mathbf{I}-\frac{\eta}{2} \mathbf{A}) \mathbf{M},
\end{aligned}
\end{equation}
where $\bf{A}$ is a skew-symmetric matrix (that depends on the Jacobian and on the parameter matrix) which is mapped to an orthogonal matrix via a Cayley transform and ${\mathit{\eta}}$ is the learning rate.

While the update rule in (\ref{eq:geoSGD}) allows us to maintain an orthogonal hidden to hidden transition matrix $\bf{W}$ if desired, we are interested in exploring the effect of stepping away from the Stiefel manifold. As such, we parameterize the transition matrix $\bf{W}$ in factorized form, as a singular value decomposition with orthogonal bases $\bf{U}$ and $\bf{V}$ updated by geodesic gradient descent using the Cayley transform approach above.
%
%\begin{equation}\label{eq:factorization}
%\mathbf{W} = \mathbf{U}\mathbf{S}\mathbf{V}^T
%\end{equation}
%

If $\bf{W}$ is an orthogonal matrix, the singular values in the diagonal matrix ${\mathbf{S}}$ are all equal to one. However, in our formulation we allow these singular values to deviate from one and employ a sigmoidal parameterization to apply a hard constraint on the maximum and minimum amount of deviation. Specifically, we define a margin ${\mathit{m}}$ around 1 within which the singular values must lie. This is achieved with the parameterization
%
\begin{equation}
\begin{gathered}
s_i = 2m(\sigma(p_i) - 0.5) + 1, \hspace{.2in} 
~~s_i \in \{\textrm{diag}(\mathbf{S})\} , \;
m \in \mathbb[0, \; 1].
\label{eq:margin}
\end{gathered}
\end{equation}
%
The singular values are thus restricted to the range ${\mathit{[\textrm{1}-m, \; \textrm{1}+m]}}$ and the underlying parameters ${\mathit{p_i}}$ are updated freely via stochastic gradient descent. 
% Note that the parameterization of the singular values with a sigmoid is contractive toward unitary values.
Note that this parameterization strategy also has implications on the step sizes that gradient descent based optimization will take when updating the singular values -- they tend to be smaller compared to models with no margin constraining their values. Specifically, a singular value's progression toward a margin is slowed the closer it is to the margin. The sigmoidal parameterization can also impart another effect on the step size along the spectrum which needs to be accounted for. Considering \ref{eq:margin}, the gradient backpropagation of some loss ${\mathit{L}}$ toward parameters ${\mathit{p_i}}$ is found as
%
\begin{equation}
\begin{aligned}
\frac{dL}{dp_i} = \frac{ds_i}{dp_i} \frac{dL}{ds_i} = 2m \frac{d\sigma(p_i)}{dp_i} \frac{dL}{ds_i}.
\end{aligned}
\label{eq:backprop}
\end{equation}
%
From (\ref{eq:backprop}), it can be seen that the magnitude of the update step for ${\mathit{p_i}}$ is scaled by the margin hyperparameter ${\mathit{m}}$. This means for example that for margins less than one, the effective learning rate for the spectrum is reduced in proportion to the margin. Consequently, we adjust the learning rate along the spectrum to be independent of the margin by renormalizing it by ${\mathit{2m}}$. 

This margin formulation both guarantees singular values lie within a well defined range and slows deviation from orthogonality. Alternatively, one could enforce the orthogonality of $\bf{U}$ and $\bf{V}$ and impose a regularization term corresponding to a mean one Gaussian prior on these singular values. This encourages the weight matrix $\bf{W}$ to be norm preserving with a controllable strength equivalent to the variance of the Gaussian.  We also explore this approach further below.

\section{Experiments}

In this section, we explore hard and soft orthogonality constraints on factorized weight matrices for recurrent neural network hidden to hidden transitions. With hard orthogonality constraints on $\bf{U}$ and $\bf{V}$, we investigate the effect of widening the spectral margin or bounds on convergence and performance. Loosening these bounds allows increasingly larger margins within which the transition matrix $\bf{W}$ can deviate from orthogonality. We confirm that orthogonal initialization is useful as noted in \citet{henaff2016orthogonal}, and we show that although strict orthogonality guarantees stable gradient norm, loosening orthogonality constraints can increase the rate of gradient descent convergence. We begin our analyses on tasks that are designed to stress memory: a sequence copying task and a basic addition task \citep{hochreiter1997long}. We then move on to tasks on real data that require models to capture long-range dependencies: digit classification based on sequential and permuted MNIST vectors \citep{le2015simple,lecun1998gradient}. Finally, we look at a basic language modeling task using the Penn Treebank dataset \citep{marcus1993building}.

The copy and adding tasks, introduced by \citet{hochreiter1997long}, are synthetic benchmarks with pathologically hard long distance dependencies that require long-term memory in models. The copy task consists of an input sequence that must be remembered by the network, followed by a series of blank inputs terminated by a delimiter that denotes the point at which the network must begin to output a copy of the initial sequence. We use an input sequence of ${\mathit{T}+20}$ elements that begins with a sub-sequence of 10 elements to copy, each containing a symbol ${\mathit{a_i \in \{a_1, ..., a_p\}}}$ out of ${\mathit{p=8}}$ possible symbols. This sub-sequence is followed by ${\mathit{T}-1}$ elements of the blank category ${\mathit{a_0}}$ which is terminated at step ${\mathit{T}}$ by a delimiter symbol ${\mathit{a_{p+1}}}$ and 10 more elements of the blank category. The network must learn to remember the initial 10 element sequence for ${\mathit{T}}$ time steps and output it after receiving the delimiter symbol.

The goal of the adding task is to add two numbers together after a long delay. Each number is randomly picked at a unique position in a sequence of length ${\mathit{T}}$. The sequence is composed of ${\mathit{T}}$ values sampled from a uniform distribution in the range ${[0,1)}$, with each value paired with an indicator value that identifies the value as one of the two numbers to remember (marked 1) or as a value to ignore (marked 0). The two numbers are positioned randomly in the sequence, the first in the range ${[0, \frac{T}{2}-1]}$ and the second in the range ${[\frac{T}{2}, T-1]}$, where 0 marks the first element. The network must learn to identify and remember the two numbers and output their sum.

In the sequential MNIST task from \citet{le2015simple}, MNIST digits are flattened into vectors that can be traversed sequentially by a recurrent neural network. The goal is to classify the digit based on the sequential input of pixels. The simple variant of this task is with a simple flattening of the image matrices; the harder variant of this task includes a random permutation of the pixels in the input vector that is determined once for an experiment. The latter formulation introduces longer distance dependencies between pixels that must be interpreted by the classification model.

The English Penn Treebank (PTB) dataset from \citet{marcus1993building} is an annotated corpus of English sentences, commonly used for benchmarking language models. We employ a sequential character prediction task: given a sentence, a recurrent neural network must predict the next character at each step, from left to right. We use input sequences of variable length, with each sequence containing one sentence. We model 49 characters including lowercase letters (all strings are in lowercase), numbers, common punctuation, and an unknown character placeholder. We use two subsets of the data in our experiments: in the first, we first use 23\% of the data with strings with up to 75 characters and in the second we include over 99\% of the dataset, picking strings with up to 300 characters.


\subsection{Loosening Hard Orthogonality Constraints}

In this section, we experimentally explore the effect of loosening hard orthogonality constraints through loosening the spectral margin defined above for the hidden to hidden transition matrix.

In all experiments, we employed RMSprop \citep{Tieleman2012} when not using geodesic gradient descent. We used minibatches of size 50 and for generated data (the copy and adding tasks), we assumed an epoch length of 100 minibatches. We cautiously introduced gradient clipping at magnitude 100 (unless stated otherwise) in all of our RNN experiments although it may not be required and we consistently applied a small weight decay of 0.0001. Unless otherwise specified, we trained all simple recurrent neural networks with the hidden to hidden matrix factorization as in (\ref{eq:factorization}) using geodesic gradient descent on the bases (learning rate $10^{-6}$) and RMSprop on the other parameters (learning rate 0.0001), using a tanh transition nonlinearity, and clipping gradients of 100 magnitude. The neural network code was built on the Theano framework \citep{2016arXiv160502688short}. When parameterizing a matrix in factorized form, we apply the weight decay on the composite matrix rather than on the factors in order to be consistent across experiments. For MNIST and PTB, hyperparameter selection and early stopping were performed targeting the best validation set accuracy, with results reported on the test set.

\subsubsection{Convergence on Synthetic Memory Tasks}

For different sequence lengths ${\mathit{T}}$ of the copy and adding tasks, we trained a factorized RNN with 128 hidden units and various spectral margins ${\mathit{m}}$. For the copy task, we used Elman networks without a transition non-linearity as in \citet{henaff2016orthogonal}. We also investigated the use of nonlinearities, as discussed below.

\begin{figure*}[htb!]
\centering
\subfigure{
\includegraphics[width=0.204\textwidth]{figures/copy_200.pdf}
}
\subfigure{
\includegraphics[width=0.204\textwidth]{figures/copy_500.pdf}
}
\subfigure{
\includegraphics[width=0.204\textwidth]{figures/copy_1000.pdf}
}
\subfigure{
\includegraphics[width=0.287\textwidth]{figures/copy_10k.pdf}
}
\caption{
Accuracy curves on the copy task for different sequence lengths given various spectral margins. Convergence speed increases with margin size; however, large margin sizes are ineffective at longer sequence lengths (T=10000, right).
}
\label{fig:copy_acc}
\end{figure*}

As shown in Figure \ref{fig:copy_acc} we see an increase in the rate of convergence as we increase the spectral margin. This observation generally holds across the tested sequence lengths (${\mathit{T}=200}$, ${\mathit{T}=500}$, ${\mathit{T}=1000}$, ${\mathit{T}=10000}$); however, large spectral margins hinder convergence on extremely long sequence lengths. At sequence length ${\mathit{T}=10000}$, parameterizations with spectral margins larger than 0.001 converge slower than when using a margin of 0.001. In addition, the experiment without a margin failed to converge on the longest sequence length. This follows the expected pattern where stepping away from the Stiefel manifold may help with gradient descent optimization but loosening orthogonality constraints can reduce the stability of signal propagation through the network.

\begin{figure}[htb!]
\centering
\subfigure{
\includegraphics[width=0.35\textwidth]{figures/adding.pdf}
}
\caption{Mean squared error (MSE) curves on the adding task for different spectral margins ${\mathit{m}}$. A trivial solution of always outputting the same number has an expected baseline MSE of 0.167.}
\label{fig:adding}
\end{figure}

For the adding task, we trained a factorized RNN on ${\mathit{T}=1000}$ length sequences, using a ReLU activation function on the hidden to hidden transition matrix. The mean squared error (MSE) is shown for different spectral margins in Figure \ref{fig:adding}. Testing spectral margins ${\mathit{m}=0}$, ${\mathit{m}=1}$, ${\mathit{m}=10}$, ${\mathit{m}=100}$, and no margin, we find that the models with the purely orthogonal (${\mathit{m}=0}$) and the unconstrained (no margin) transition matrices failed to begin converging beyond baseline MSE within 2000 epochs.

We found that nonlinearities such as a rectified linear unit (ReLU) \citep{nair2010rectified} or hyperbolic tangent (tanh) made the copy task far more difficult to solve. Using tanh, a short sequence length (${\mathit{T}=100}$) copy task required both a soft constraint that encourages orthogonality and thousands of epochs for training. It is worth noting that in the unitary evolution recurrent neural network of \citet{arjovsky2015unitary}, the non-linearity (referred to as the "modReLU") is actually initialized as an identity operation that is free to deviate from identity during training. Furthermore, \citet{henaff2016orthogonal} derive a solution mechanism for the copy task that drops the non-linearity from an RNN. To explore this further, we experimented with a parametric leaky ReLU activation function (PReLU) which introduces a trainable slope ${\mathit{\alpha}}$ for negative valued inputs ${\mathit{x}}$, producing ${\mathit{f}(\mathit{x})=max(\mathit{x}, 0) + \mathit{\alpha} min(\mathit{x}, 0)}$ \citep{he2015delving}. Setting the slope ${\mathit{\alpha}}$ to one would make the PReLU equivalent to an identity function. We experimented with clamping ${\mathit{\alpha}}$ to 0.5, 0.7 or 1 in a factorized RNN with a spectral margin of 0.3 and found that only the model with ${\mathit{\alpha}=1}$ solved the ${\mathit{T}=1000}$ length copy task. We also experimented with a trainable slope ${\mathit{\alpha}}$, initialized to 0.7 and found that it converges to 0.96, further suggesting the optimal solution for the copy task is without a transition nonlinearity. Since the copy task is purely a memory task, one may imagine that a transition nonlinearity such as a tanh or ReLU may be detrimental to the task as it can lose information. Thus, we also tried a recent activation function that preserves information, called an orthogonal permutation linear unit (OPLU) \citep{chernodub2016norm}. The OPLU preserves norm, making a fully norm-preserving RNN possible. Interestingly, this activation function allowed us to recover identical results on the copy task to those without a nonlinearity for different spectral margins.

\subsubsection{Performance on Real Data}
\label{sec:real_data}

\begin{table*}
\centering
\setlength\tabcolsep{4pt}
\begin{tabular}{ cccccccc }
  & & MNIST & pMNIST & \multicolumn{2}{c}{PTBc-75} & \multicolumn{2}{c}{PTBc-300} \\
  margin & initialization & accuracy & accuracy & bpc & accuracy & bpc & accuracy \\
  \hline
  0   & orthogonal & 77.18 & 83.56 & 2.16 & 55.31 & 2.20 & 54.88 \\
  0.001 & orthogonal & 79.26 & 84.59 & - & - & - & - \\
  0.01 & orthogonal & 85.47 & 89.63 & 2.16 & 55.33 & 2.20 & 54.83 \\
  0.1 & orthogonal & 94.10 & 91.44 & 2.12 & 55.37 & 2.24 & 54.10 \\
  1 & orthogonal & 93.84 & 90.83 & 2.06 & 57.07 & 2.36 & 51.12 \\
  100 & orthogonal & - & - & 2.04 & 57.51 & 2.36 & 51.20 \\
  none& orthogonal & 93.24 & 90.51 & 2.06 & 57.38 & 2.34 & 51.30 \\
  none& Glorot normal & 66.71 & 79.33 & 2.08 & 57.37 & 2.34 & 51.04 \\
  none& identity & 53.53 & 42.72 & 2.25 & 53.83 & 2.68 & 45.35 \\
  \hline
  \multicolumn{2}{c}{LSTM} & 97.30 & 92.62 & 1.92 & 60.84 & 1.64 & 65.53 \\
\end{tabular}
\caption{Performance on MNIST and PTB for different spectral margins and initializations. Evaluated on classification of sequential MNIST (MNIST) and permuted sequential MNIST (pMNIST); character prediction on PTB sentences of up to 75 characters (PTBc-75) and up to 300 characters (PTBc-300).}
\label{tab:results_table}
\end{table*}

Having confirmed that an orthogonality constraint can negatively impact convergence rate, we seek to investigate the effect on model performance for tasks on real data. In Table \ref{tab:results_table}, we show the results of experiments on ordered and permuted sequential MNIST classification tasks and on the PTB character prediction task.

\begin{figure}[htb!]
\centering
\subfigure{
%0.416
\includegraphics[width=0.1885\textwidth]{figures/MNIST.pdf}
}
\subfigure{
%0.482
\includegraphics[width=0.2652\textwidth]{figures/pMNIST.pdf}
}
\caption{
Loss curves for different factorized RNN parameterizations on the sequential MNIST task (left) and the permuted sequential MNIST task (right). The spectral margin is denoted by m; models with no margin have singular values that are directly optimized with no constraints; Glorot refers to a factorized RNN with no margin that is initialized with Glorot normal initialization. Identity refers to the same, with identity initialization.
}
\label{fig:mnist}
\end{figure}

For the sequential MNIST experiments, loss curves  are shown in Figure \ref{fig:mnist} and reveal an increased convergence rate for larger spectral margins. We trained the factorized RNN models with 128 hidden units for 120 epochs. We also trained an LSTM with 128 hidden units (tanh activation) on both tasks for 150 epochs, configured with peephole connections, orthogonally initialized (and forget gate bias initialized to one), and trained with RMSprop (learning rate 0.0001, clipping gradients of magnitude 1).

For PTB character prediction, we evaluate results in terms of bits per character (bpc) and prediction accuracy. Prediction results are shown in \ref{tab:results_table} both for a subset of short sequences (up to 75 characters; 23\% of data) and for a subset of long sequences (up to 300 characters; 99\% of data). We trained factorized RNN models with 512 hidden units for 200 epochs with geodesic gradient descent on the bases (learning rate $10^{-6}$) and RMSprop on the other parameters (learning rate 0.001), using a tanh transition nonlinearity, and clipping gradients of 30 magnitude. As a rough point of reference, we also trained an LSTM with 512 hidden units for each of the data subsets (configured as for MNIST). On sequences up to 75 characters, LSTM performance was limited by early stopping of training due to overfitting.

\begin{figure*}[htb!]
\centering
\subfigure{
\includegraphics[width=0.3\textwidth]{figures/spectrum_pMNIST_hsb_0_001.pdf}
}
\subfigure{
\includegraphics[width=0.3\textwidth]{figures/spectrum_pMNIST_hsb_0_01.pdf}
}
\subfigure{
\includegraphics[width=0.3\textwidth]{figures/spectrum_pMNIST_hsb_0_1.pdf}
}
\subfigure{
\includegraphics[width=0.3\textwidth]{figures/spectrum_pMNIST_hsb_1.pdf}
}
\subfigure{
\includegraphics[width=0.3\textwidth]{figures/spectrum_pMNIST_hsb_none.pdf}
}
\subfigure{
\includegraphics[width=0.3\textwidth]{figures/spectrum_pMNIST_glorot.pdf}
}
\caption{
Singular value evolution on the permuted sequential MNIST task for factorized RNNs with different spectral margin sizes (m). The singular value distributions are summarized with the mean (green line, center) and standard deviation (green shading about mean), minimum (red, bottom) and maximum (blue, top) values. All models are initialized with orthogonal hidden to hidden transition matrices except for the model that yielded the plot on the bottom right, where Glorot normal initialization is used.
}
\label{fig:MNIST_spectra}
\end{figure*}

Interestingly, for both the ordered and permuted sequential MNIST tasks, models with a non-zero margin significantly outperform those that are constrained to have purely orthogonal transition matrices (margin of zero). The best results on both the ordered and sequential MNIST tasks were yielded by models with a spectral margin of 0.1, at 94.10\% accuracy and 91.44\% accuracy, respectively. An LSTM outperformed the RNNs in both tasks; nevertheless, RNNs with hidden to hidden transitions initialized as orthogonal matrices performed admirably without a memory component and without all of the additional parameters associated with gates. Indeed, orthogonally initialized RNNs performed almost on par with the LSTM in the permuted sequential MNIST task which presents longer distance dependencies than the ordered task. Although the optimal margin appears to be 0.1, RNNs with large margins perform almost identically to an RNN without a margin, as long as the transition matrix is initialized as orthogonal. On these tasks, orthogonal initialization appears to significantly outperform Glorot normal initialization \citep{glorot2010understanding} or initializing the matrix as identity. It is interesting to note that for the MNIST tasks, orthogonal initialization appears useful while orthogonality constraints appear mainly detrimental. This suggests that while orthogonality helps early training by stabilizing gradient flow across many time steps, orthogonality constraints may need to be loosened on some tasks so as not to over-constrain the model's representational ability.

Curiously, larger margins and even models without sigmoidal constraints on the spectrum (no margin) performed well as long as they were initialized to be orthogonal, suggesting that evolution away from orthogonality is not a serious problem on MNIST. It is not surprising that orthogonality is useful for the MNIST tasks since they depend on long distance signal propagation with a single output at the end of the input sequence. On the other hand, character prediction with PTB produces an output at every time step. Constraining deviation from orthogonality proved detrimental for short sentences and beneficial when long sentences were included. Furthermore, Glorot normal initialization did not perform worse than orthogonal initialization for PTB. Since an output is generated for every character in a sentence, short distance signal propagation is possible. Thus it is possible that the RNN is first learning very local dependencies between neighbouring characters and that given enough context, constraining deviation from orthogonality can help force the network to learn longer distance dependencies.

\subsubsection{Spectral and Gradient Evolution}

It is interesting to note that even long sequence lengths (T=1000) in the copy task can be solved efficiently with rather large margins on the spectrum. In Figure \ref{fig:gradients} we look at the gradient propagation of the loss from the last time step in the network with respect to the hidden activations. We can see that for a purely orthogonal parameterization of the transition matrix (when the margin is zero), the gradient norm is preserved across time steps, as expected. We further observe that with increasing margin size, the number of update steps over which this norm preservation survives decreases, though surprisingly not as quickly as expected.

\begin{figure}[htb!]
\centering
\includegraphics[width=0.5\textwidth]{figures/grad_copy_200.png}
\caption{The norm of the gradient of the loss from the last time step with respect to the hidden units at a given time step for a length 220 RNN over 1000 update iterations for different margins. Iterations are along the abscissa and time steps are denoted along the ordinate. The first column margins are: 0, 0.001, 0.01. The second column margins are: 0.1, 1, no margin. Gradient norms are normalized across the time dimension.}
\label{fig:gradients}
\end{figure}

Although the deviation of singular values from one should be slowed by the sigmoidal parameterizations, even parameterizations without a sigmoid (no margin) can be effectively trained for all but the longest sequence lengths. This suggests that the spectrum is not deviating far from orthogonality and that inputs to the hidden to hidden transitions are mostly not aligned along the dimensions of greatest expansion or contraction. We evaluated the spread of the spectrum in all of our experiments and found that indeed, singular values tend to stay well within their prescribed bounds and only reach the margin when using a very large learning rate that does not permit convergence. Furthermore, when transition matrices are initialized as orthogonal, singular values remain near one throughout training even without a sigmoidal margin for tasks that require long term memory (copy, adding, sequential MNIST). On the other hand, singular value distributions tend to drift away from one for PTB character prediction which may help explain why enforcing an orthogonality constraint can be helpful for this task, when modeling long sequences. Interestingly, singular values spread out less for longer sequence lengths (nevertheless, the T=10000 copy task could not be solved with no sigmoid on the spectrum).

\subsection{Exploring Soft Orthogonality Constraints}

\begin{figure*}[tb!]
\centering
\subfigure{
\includegraphics[width=0.192\textwidth]{figures/Worth_copy_200.pdf}
}
\subfigure{
\includegraphics[width=0.257\textwidth]{figures/Worth_factorized_copy_500.pdf}
}
\subfigure{
\includegraphics[width=0.189\textwidth]
{figures/sorth_factorized_copy200_hsb_none.pdf}
}
\subfigure{
\includegraphics[width=0.262\textwidth]
{figures/sorth_factorized_copy200_hsb_1.pdf}
}
\caption{Accuracy curves on the copy task for different strengths of soft orthogonality constraints. All sequence lengths are $\mathit{T}=200$, except in (B) which is run on $\mathit{T}=500$. A soft orthogonality constraint is applied to the transition matrix $\mathbf{W}$ of a regular RNN in (A) and that of a factorized RNN in (B). A mean one Gaussian prior is applied to the singular values of a factorized RNN in (C) and (D); the spectrum in (D) has a sigmoidal parameterization with a large margin of 1. Loosening orthogonality speeds convergence.}
\label{fig:soft_copy}
\end{figure*}

We visualize the spread of singular values for different model parameterizations on the permuted sequential MNIST task in Figure \ref{fig:MNIST_spectra}. Curiously, we find that the distribution of singular values tends to shift upward to a mean of approximately 1.05 on both the ordered and permuted sequential MNIST tasks. We note that in those experiments, a tanh transition nonlinearity was used which is contractive in both the forward signal pass and the gradient backward pass. An upward shift in the distribution of singular values of the transition matrix would help compensate for that contraction. Indeed, \citet{saxe2013exact} describe this as a possibly good regime for learning in deep neural networks. That the model appears to evolve toward this regime suggests that deviating from it may incur a cost. This is interesting because the cost function cannot take into account numerical issues such as vanishing or exploding gradients (or forward signals); we do not know what could make this deviation costly.

Unlike orthgonally initialized models, the RNN on the bottom right of Figure \ref{fig:MNIST_spectra} with Glorot normal initialized transition matrices begins and ends with a wide singular spectrum. While there is no clear positive shift in the distribution of singular values, the mean value appears to very gradually increase for both the ordered and permuted sequential MNIST tasks. If the model is to be expected to positively shift singular values to compensate for the contractivity of the tanh nonlinearity, it is not doing so well for the Glorot-initialized case; however, this may be due to the inefficiency of training as a result of vanishing gradients, given that initialization.

That the transition matrix may be compensating for the contraction of the tanh is supported by further experiments: applying a 1.05 pre-activation gain appears to allow a model with a margin of 0 to nearly match the top performance reached on both of the MNIST tasks. Furthermore, when using the OPLU norm-preserving activation function \citep{chernodub2016norm}, we found that orthogonally initialized models performed equally well with all margins, achieving over 90\% accuracy on the permuted sequential MNIST task.

It is reasonable to assume that the sequential MNIST task benefits from a lack of a transition nonlinearity because it is a pure memory task. However, using no transition nonlinearity results in reduced accuracy. Furthermore, while a nonlinear transition may lose information, thus countering the task of memory preservation, it is critical on more advanced tasks like PTB character prediction. Indeed, tasks that require more than just memory preservation in the hidden state can benefit from forgetting. \citet{jing2017gated} demonstrated that adding a forgetting mechanism to RNNs constrained to have an orthogonal transition matrix improved performance on such tasks. Some forgetting could be achieved by allowing deviation from orthogonality.

Having established that it may indeed be useful to step away from orthogonality, here we explore two forms of soft constraints (rather than hard bounds as above) on hidden to hidden transition matrix orthogonality. The first is a simple penalty that directly encourages a transition matrix $\bf{W}$ to be orthogonal, of the form
%\begin{equation}
$\lambda||\mathbf{W}^T \mathbf{W} - \mathbf{I}||_2^2$.
%\end{equation}
This is similar to the orthogonality penalty introduced by \citet{henaff2016orthogonal}. In subfigures (A) and (B) of Figure \ref{fig:soft_copy}, we explore the effect of weakening this form of regularization. We trained both a regular non-factorized RNN on the $\mathit{T}=200$ copy task (A) and a factorized RNN with orthogonal bases on the $\mathit{T}=500$ copy task (B). For the regular RNN, we had to reduce the learning rate to $10^{-5}$. Here again we see that weakening the strength of the orthogonality-encouraging penalty can increase convergence speed.

The second approach we explore replaces the sigmoidal margin parameterization with a mean one Gaussian prior on the singular values. In subfigures (C) and (D) of Figure \ref{fig:soft_copy}, we visualize the accuracy on the length 200 copy task, using geoSGD (learning rate $10^{-6})$ to keep $\mathbf{U}$ and $\mathbf{V}$ orthogonal and different strengths $\gamma$ of a Gaussian prior with mean one on the singular values $s_i$: $\gamma \sum_i ||s_i-1||^2$. We trained these experiments with regular SGD on the spectrum and other non-orthogonal parameter matrices, using a $10^{-5}$ learning rate. We see that strong priors lead to slow convergence. Loosening the strength of the prior makes the optimization more efficient. Furthermore, we compare a direct parameterization of the spectrum (no sigmoid) in (C) with a sigmoidal parameterization, using a large margin of 1 in (D). Without the sigmoidal parameterization, optimization quickly becomes unstable; on the other hand, the optimization also becomes unstable if the prior is removed completely in the sigmoidal formulation (margin 1). These results further motivate the idea that parameterizations that deviate from orthogonality may perform better than purely orthogonal ones, as long as they are sufficiently constrained to avoid instability during training.

\section{Conclusions}
We have explored a number of methods for controlling the expansivity of gradients during backpropagation based learning in RNNs through manipulating orthogonality constraints and regularization on weight matrices. Our experiments indicate that while orthogonal initialization may be beneficial, maintaining hard constraints on orthogonality can be detrimental. Indeed, moving away from hard constraints on matrix orthogonality can help improve optimization convergence rate and model performance. However, we also observe with synthetic tasks that relaxing regularization which encourages the spectral norms of weight matrices to be close to one too much, or allowing bounds on the spectral norms of weight matrices to be too wide, can reverse these gains and may lead to unstable optimization.

\subsubsection*{Acknowledgments}
We thank the Natural Sciences and Engineeering Research Council (NSERC) of Canada and Samsung for supporting this research.


\bibliography{icml2017}
\bibliographystyle{icml2017}

\end{document}
