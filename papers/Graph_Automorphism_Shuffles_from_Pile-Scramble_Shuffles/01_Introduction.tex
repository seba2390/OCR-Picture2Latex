\section{Introduction}

\subsection{Background}

Let $X, Y$ be finite sets, $n \in \N$ a natural number, and $f: X^n \ra Y$ a function. 
Suppose that $n$ players each having $x_i \in X$ as input wish to know an output value $f(x_1, x_2, \ldots, x_n) \in Y$ without \md{revealing anything about their own inputs beyond the output value to other players}. 
Secure computation protocols can solve this kind of situation. 
Secure computation, which was formalized by Yao\cite{Yao82, Yao86}, plays an important role in cryptography (cf. see the survey on secure computation by Lindell \cite{Lindell20}). 
%$X, Y$を有限集合、$n\in \N$を自然数、$f: X^n \ra Y$を関数とする。
%今、$n$人のプレイヤー$\PT_1, \PT_2, \ldots, \PT_n$がそれぞれ$x_1, x_2, \ldots, x_n \in X$を入力情報として保持しており、全員の入力の関数値$f(x_1, x_2, \ldots, x_n) \in Y$を知りたいが、自分の入力$x_i$は明かしたくないという状況であったとする。
%このような一見すると達成不可能に思える状況を解決する暗号技術が秘密計算である。
%秘密計算プロトコルは、上記の状況において、$f(x_1, x_2, \ldots, x_n)$を正しく計算するという性質（正当性）と、各プレイヤーの入力$x_i$を他のプレイヤーに対して秘匿する性質（安全性）の両方を達成する。
%秘密計算の概念はYao\cite{Yao82, Yao86}によって定式化され、暗号理論のメインテーマとして精力的に研究されている（cf. Lindellによる秘密計算のサーベイ論文\cite{Lindell20}）。

Card-based cryptography \cite{Boer89, Kilian93} is a kind of secure computation, which uses a deck of physical cards. 
Given a sequence of face-down cards (which is typically an encoding of input $(x_1, x_2, \ldots, x_n) \in X^n$), a card-based protocol transforms it to an output sequence (which is typically an encoding of output $f(x_1, x_2, \ldots, x_n) \in Y$) by a bunch of physical operations on cards. 
One of the features of card-based cryptography is that it allows us to understand intuitively the correctness and security of a protocol, since we can actually perform the protocol by hands. 
For this reason, it is expected to be used as an educational material. 
Indeed, some universities \cite{CHL13, Marcedone15, MizukiTeaching16} have actually \md{used} card-based cryptography as an educational material. 
%カードベース暗号\cite{Boer89, Kilian93}は、物理的なカード組を用いて秘密計算を実現することを目的とする秘密計算の一分野である。
%カードベース暗号プロトコルは、以下のような流れで計算を行う。
%まず、各プレイヤー$\PT_i$は入力情報$x_i \in X$をカード列に符号化し、伏せたカード列$\back\,\back\,\cdots\,\back$を提出する。
%次に、全員の提出した入力カード列をつなげて一つのカード列とし、それに対して所定の操作（並べ替え・ターン・シャッフル）を施す。
%最後に、所定の位置のカードをめくり、その結果によって出力値$f(x_1, x_2, \ldots, x_n) \in Y$を決定する。
%カードベース暗号プロトコルも秘密計算プロトコルと同様に正当性と安全性の両方を満たす必要がある。
%%特に安全性に関しては、入力情報が一切推測できないという情報理論的安全性を要求する。
%カードベース暗号の特徴は、カードを並べて実際にプロトコルを手操作で実現できるため、プロトコルの正当性や安全性を直感的に理解できることである。
%そのため、教育的効果が期待されており、実際にいくつかの大学においてカードベース暗号を教材として用いた事例がある\cite{CHL13, Marcedone15, MizukiTeaching16}。

In card-based protocols, a \emph{shuffle}, which is a probabilistic rearrangement, is allowed to \md{apply to a sequence of cards}. 
It is considered as the most crucial operation in card-based protocols since randomness from shuffles is the primary tool to obtain the security of protocols. 
Among shuffles, a \emph{(pile) random cut (RC)}, a \emph{random bisection cut (RBC)}, and a \emph{pile-scramble shuffle (PSS)} are the most effective shuffles\footnote{\md{Our classification focuses on the group structure of permutations: the cyclic groups (RCs) and the symmetric groups (PSSs). Since RBCs are historically important shuffles and the intersection of RCs and PSSs, we classify them as RC, RBC, and PSS.}} \md{in card-based cryptography}. 
% Some reader might feel this classification (RC, RBC, and PSS) is not natural because a RC and a pile version of RC (also known as a pile-shifting shuffle) are completely different, and RBCs are a special case of both RCs and PSSs. }
%We regard a \emph{pile-shifting shuffle} which is a pile version of a random cut as a random cut. 
% \md{a \emph{pile random cut (PRC)}}\footnote{\md{It is known as a \emph{pile-shifting shuffle}. We use this terminology to avoid a collision of abbreviation with a pile-scramble shuffle.}},
Indeed, most card-based protocols are constructed with these shuffles only (cf. protocols with RCs only \cite{Boer89, Kilian93, Niemi98, Niemi99, Stiglic01, Uchiike06, Heather14, MiyaharaCOCOA18, ShinagawaICISC18, ToyodaAPKC20, SaitoTPNC20, MiyaharaTCS20, KoyamaAPKC21, RobertCiE21, AbeNGC21, KochFUN21}, protocols with RBCs only \cite{MizukiFAW09, MizukiAC12, MizukiUCNC13, NishidaTPNC13, NishidaTAMC15, NishidaIEICE15, MizukiCANS16, ShinagawaFAW19,RuangwisesTCS21}, protocols with PSSs only \cite{GradwohlFUN07, PascalFUN16, SasakiFUN18, Koch18b, RobertSSS20, SasakiTCS20, ShinagawaDAM21, MurataWALCOM21,RuangwisesNGC21}, protocols with RCs and RBCs only \cite{AbeAPKC18, TakashimaTPNC19, KoyamaCSR21, MiyaharaFUN21}, protocols with RCs and PSSs only \cite{ShinagawaSSS18, TakashimaCOCOA19, DumasCOCOON19, MiyaharaISPEC19, TakashimaTCS20, RuangwisesTCS21a}, and protocols with RBCs and PSSs only \cite{IshikawaUCNC15, MizukiTCS16, HashimotoICITS17, ShinodaSecITC20}). 
With this background, it is essential to study further what can be done by these shuffles. 
%In this \md{paper, we study what ``shuffle" can be done by PSSs.}
%\md{we propose a new shuffle protocol using only PSSs. }

%In particular, we study what other shuffles can be done by PSSs. 
%a protocol using these shuffles only is considered to be practical. 
%Following this line of research, we study the feasibility of PSSs. 
%This shows that a lot of natural protocols can be constructed from RCs, RBCs, and PSSs. 
%it is an important research direction to study what task can be done by these shuffles. 
%In card-based cryptography, the most important operation in protocols is considered to be shuffle
%カードベース暗号プロトコルの効率性指標の中で最も重要なものがカード枚数と操作回数である。
%カード枚数と操作回数を削減することはカードベース暗号の最重要課題である。
%操作回数に関しては、プロトコルの三種類の操作（並べ替え・ターン・シャッフル）の中でシャッフルは最も複雑で最も実行に時間を要すると考えられており、シャッフル回数が特に重要である。
%そのためプロトコルの効率性は、カード枚数$a$枚、シャッフル回数$b$回の形で述べられることが多い。
%多種多様なシャッフルの中でも特に基本的かつ重要なものに、ランダムカット\cite{Boer89}、ランダム二等分割カット\cite{MizukiFAW09}、パイルスクランブルシャッフル\cite{IshikawaUCNC15}がある\footnote{この三つのシャッフル以外が物理的に実現容易でないというわけではないことに注意する。この三つのシャッフルは数多くのプロトコルで用いられており、物理的実現容易かつ有用なシャッフルとして知られている。なお、ランダム二等分割カットはパイルスクランブルシャッフルの特殊ケースとみなせるが、歴史的にもランダム二等分割カットは重要であるため特別扱いしている。}。
%この三種類のシャッフルのみを用いて構成されたプロトコルは、特に物理的実現容易であるとみなされる。
%それでは、他にどのようなシャッフルであったら物理的実現容易であろうか。
%すぐに分かることは、物理的実現容易なシャッフルのみを用いて、あるシャッフルを実現できたとしたら、そのシャッフルは物理的実現容易であるということである。
%これは、あるシャッフルをより基本的なシャッフルに帰着するということを意味する。
%すなわち、シャッフルを用いて別のシャッフルを実現するというプロトコルを構成すればよい。
%本稿ではこのようなプロトコルをシャッフルプロトコルと呼ぶことにする。
%当然、シャッフルプロトコルのカード枚数やシャッフル回数は帰着効率を測る際に重要である。
%例えば、ランダムカット、ランダム二等分割カット、パイルスクランブルシャッフルのみを用いてあるシャッフルが実現できたとしたら、そのシャッフルは物理的実現容易である。
%例えば、Cr\'{e}peau and Kilian \cite{Kilian93}のANDプロトコルはカード枚数$10$枚、シャッフル回数平均$8$回であるが、Mizuki and Sone \cite{MizukiFAW09}のANDプロトコルはカード枚数$6$枚、シャッフル回数$1$回であり、後者の方が効率的である。
%シャッフルには多種多様なものが存在し、種類によって物理的実現容易性には大きな違いがあるため、より精緻な効率性比較を行うためにはシャッフル回数だけでなくシャッフルの種類についても言及する必要がある。
%しかし、シャッフルの種類を考慮した場合、プロトコルの効率性比較が困難になる場合がある。
%例えば、二つのプロトコルについて、カード枚数とシャッフル回数が同じであるがシャッフルの種類が異なっていた場合、どちらがより効率的であるかを比較することが難しい。

%これに対する一つの方策が、あるシャッフルをより基本的なシャッフルから実現した際の効率性を調べることである。
%基本的なシャッフルとして、例えばランダムカット\cite{Boer89}、ランダム二等分割カット\cite{MizukiFAW09}、パイルスクランブルシャッフル\cite{IshikawaUCNC15}を選んだ\footnote{この三つのシャッフル以外が物理的に実現容易でないというわけではないことに注意する。この三つのシャッフルは数多くのプロトコルで用いられており、物理的実現容易かつ有用なシャッフルとして知られている。}とすれば、。
%%ある二つのプロトコル$A, B$が共にカード枚数$a$枚、シャッフル回数$b$回だったとしても、$A$と$B$の効率性が
%%例えば、AND関数に対するプロトコルのカード枚数を削減する研究は、初期の頃から継続的に取り組まれており、カードベース暗号のカード枚数の削減は重要な

%カードベース暗号プロトコルの操作の中で最も重要なものがシャッフルである。
%シャッフルとは、確率分布に従って置換を選び、その置換に従ってカード列を並び替える操作である。
%ただし、実際にどの置換が選ばれたかは全てのプレイヤーに対して秘匿されている\footnote{伝統的なカードベース暗号では、この性質は保証されているものと仮定した上で、ブラックボックス的に用いることが多い。実際にどのようにシャッフルを実現するかという具体的方法を提案することも重要な研究であり、いくつかの研究が報告されている\cite{NishimuraTPNC15, Ueda20, ShinagawaISITA16, SaitoTPNC20}。}。
%プロトコルの安全性は、シャッフルによって暗に生成されたランダムネスによって保証されており、シャッフルは安全性の要である。
%また、ある関数を計算する際に、シャッフルの種類によって達成できる効率性にも違いがあるため、シャッフルは効率性の要でもある。
%ただし、プロトコルの効率性は、一般的にカード枚数と操作回数で測られる。
%
%歴史的には、カードベース暗号の最初の10年間はランダムカットと呼ばれるシャッフルのみを用いてプロトコル構成が行われた\cite{Boer89, Kilian93, Niemi98, Niemi99, Stiglic01, Uchiike06}。
%その後、Mizuki and Sone \cite{MizukiFAW09}によってランダム二等分割カットと呼ばれるシャッフルが提案され、（AND関数やXOR関数等の基本的論理演算に対する）プロトコルの効率性が格段に向上した。
%また、Ishikawa, Chida, and Mizuki \cite{IshikawaUCNC15}によってパイルスクランブルシャッフルと呼ばれるシャッフルが提案され、不動点のない置換のランダム生成やパズルに対するゼロ知識証明プロトコル等の複雑な関数に対するプロトコルの効率性も向上した。

%カードベース暗号プロトコルは、入力情報を保持するカード列に対して、並べ替え・ターン・シャッフルの三種類\footnote{これ以外にも秘匿置換等の秘匿操作を用いるモデルも存在するが、本稿では秘匿操作は扱わない。}の操作を順次適用し、出力情報を保持するカード列に変換する。
%特にシャッフルは入力情報の秘匿性を保証するために必要不可欠な操作であり、カードベース暗号プロトコルの要と言える。
%カードベース暗号の特徴は実際にプロトコルを実行できることである。
%特に、手操作で容易に実行できるシャッフルのみを用いてプロトコルを構成することは、実行容易性の観点から望ましい。
%手操作で容易に実行できるシャッフルとして知られている代表的なものとして、ランダムカット・ランダム二等分割カット・パイルスクランブルシャッフルがある\footnote{ランダム二等分割カットはパイルスクランブルシャッフルの束の個数が$2$個の場合なので、本稿ではパイルスクランブルシャッフルに含まれるものとする。}。
%ランダムカットは
%シャッフルは、置換の集合$\Pi$と$\Pi$上の確率分布$\F$で定義される。
%確率分布$\F$の取り方は無限に存在するため、シャッフルの種類も無限に存在する。
%$\Pi$が置換の合成について閉じていて$\F$が一様分布である一様閉シャッフルというクラスに属するシャッフルが望ましい。

\subsection{Contribution}

In this \md{paper}, we show that \emph{graph shuffles} can be \md{implemented} with PSSs. 
Let $G$ be a directed graph\footnote{\md{We regard undirected graphs as directed graphs by identifying each undirected edge with two directed edges with opposite directions.}}. 
A graph shuffle for $G$ is a shuffle that arranges a sequence of cards according to an automorphism of $G$ chosen uniformly at random. 
Our main contribution is to construct a card-based protocol that achieves a graph shuffle for any graph $G$. 
We call this a \emph{graph shuffle protocol for $G$}. 
The number of cards in our protocol is $2(n+m)$, where $n$ and $m$ are the numbers of vertices and \md{edges} of $G$, respectively. 
\md{The number of shuffles (i.e., PSSs) in our protocol is $|\f{Deg}_G|+1$, where $\f{Deg}_G$ is the set of vertex degree of $G$ (see Section \ref{ss:graph}).}
%All shuffles in our protocol are PSSs.  
\md{We remark that our protocol has one drawback: it requires to compute a graph isomorphism between $G$ and its isomorphic graph $G'$. In general, computing a graph isomorphism is a complex computational task (see also Remark \ref{rem:iso}). We conjecture that computing a graph isomorphism is inherent in implementing a graph shuffle. We left it as an open problem whether computing a graph isomorphism can be removed or not.}

A class of graph shuffles includes many interesting shuffles (see Section \ref{ss:implication}). 
Indeed, RCs, RBCs, and PSSs are special cases of graph shuffles. 
\md{In particular, a RC is a graph shuffle for a directed cycle graph.} 
A straightforward corollary of our main result is that a RC can be implemented with PSSs. 
Since a PSS can be implemented with RCs (cf. see Cr\'{e}peau and Kilian \cite{Kilian93}'s idea for generating a random fixed-free permutation), PSSs and RCs are essentially equivalent from the viewpoint of feasibility. 
\md{It is worthwhile to mention the importance of the fact that RCs are implementable by PSSs. From the theoretical viewpoint, this shows that every protocol with RCs is transformed into a protocol with PSSs and vice versa. 
From the practical viewpoint, you can choose whether to use RCs or PSSs as shuffles in a protocol execution. 
In order to execute a RC by hand, we need to ensure that everyone must be able to verify that the rearrangement is indeed a cyclic shift while hiding the rearrangement itself. 
On the other hand, a PSS can be done by a rearrangement of piles in a completely randomly fashion although it requires physical envelopes as an additional tool. 
Which shuffle can be easily executable depends on a situation and thus there should be some cases that PSSs are more desirable than RCs. 
%For example, Koch and Walzer \cite{KochFUN21} showed that \emph{uniform closed shuffles} (see Definition \ref{def:ucshuffle}) can be implemented with RCs only. 
%Thus, uniform closed shuffles can be also implemented with PSSs from the above observation.
%in order to execute a PSS by hand, 
%We remark that RCs are not always easy to execute since it is not requires . 
%Although RCs are believed to be the most practical shuffles, which shuffle can be easily executable is not unclear and depends on a situation. 
}
%Which shuffle can be easily executable is not unclear and depends on a situation. 
%For example, if you have physical envelopes, PSSs may be easier than RCs 

\md{Due to the importance of the result of RC, we improve a graph shuffle protocol for a directed cycle graph. 
In particular,} for the directed cycle graph with $n$ vertices, we design a graph shuffle protocol with \md{$3n$} cards while the general protocol requires \md{$4n$} cards. 
%For some \md{specific} cases of graph shuffles, we improve the number of cards in our protocol. 
%In particular, we improve graph shuffle protocols for a directed cycle graph and a cycle graph. 
%Note that a graph shuffle for a directed cycle graph is a RC. 

\md{We also improve a graph shuffle protocol for an undirected cycle graph. 
A graph shuffle for the undirected cycle graph is equivalent to the \emph{dihedral shuffle}, which is introduced by Niemi and Renvall \cite{Niemi98}.} For the undirected cycle graph with $n$ vertices, we design a graph shuffle protocol with \md{$3n$} cards while the general protocol requires \md{$6n$} cards. 

\subsection{Related works}\label{relatedworks}

\md{
Koch and Walzer \cite{KochFUN21} showed that \emph{uniform closed shuffles} (see Definition \ref{def:ucshuffle}) can be implemented with RCs only. 
It is an essential milestone for implementing uniform closed shuffles. 
Since graph shuffles are uniformly closed, Koch and Walzer's method allows that every graph shuffle can be done by RCs.
However, we point out that their protocol requires each party somehow to generate a uniformly random element of a given group in the party's head. This action is not allowed in the Mizuki-Shizuya model \cite{MizukiIJISEC14} which is known as the standard computational model of card-based cryptography. 
From this viewpoint, our protocol for graph shuffles and their protocol are based on different models of card-based cryptography. 
Our motivation is to implement a subclass of uniform closed shuffles in the Mizuki-Shizuya model. 
Besides the theoretical aspect, it is worthwhile to note that removing a randomness generation in the head brings a practical benefit for security because it is not clear how close the distribution of random elements generated in the head will be to the distribution of truly random elements. 
}


%a RC. 
%The number of shuffles is $k+1$, where $k$ is the number of degrees of vertices of $G$, and all of them are PSSs. 
%本研究では、グラフシャッフルというクラスのシャッフルはパイルスクランブルシャッフルのみから実現可能であることを示す。
%$G$を有向グラフとする。
%$G$に対するグラフシャッフルとは、$G$の各頂点にカードを配置し、$G$の自己同型写像$\sigma \in \aut(G)$をランダムに選び、$\sigma$に従ってカード列を並び替えるシャッフルである。
%本研究の主結果は、グラフシャッフルプロトコルの構成である。
%$G$の頂点数を$n$、辺数を$m$としたとき、補助カードのカード枚数は$n + 2m$枚である。
%また、シャッフル回数は$k+1$回のパイルスクランブルシャッフルであり、ただし$k$は頂点集合を同じ辺次数を持つ頂点たちでグループ分けしたときのグループ数である。

%Since this implication is important, we 
%As an application of our protocol, we obtain that a RC is done by two PSSs. 
%さまざまなシャッフルを自然にグラフシャッフルとして捉えることができる。
%特に重要な具体例に、ランダムカットがある。
%ランダムカット（あるいはパイルシフティングシャッフル）は、有向サイクルグラフに対するグラフシャッフルと一致する。
%したがって、ランダムカット（パイルシフティングシャッフル）をパイルスクランブルシャッフルのみから実現可能であることが示される。
%$n$枚のランダムカット（$n$束のパイルシフティングシャッフル）は$2n$枚の追加カードと$2$回のパイルスクランブルシャッフルによって実現できる。
%なお、パイルスクランブルシャッフルをランダムカットから実現することは簡単である（cf. Cr\'{e}peau and Kilian \cite{Kilian93}のランダム置換生成のアイディア）。
%さらに、二面体群シャッフル\cite{Niemi98}も無向サイクルグラフに対するグラフシャッフルと一致するため、パイルスクランブルシャッフルのみから実現可能である。
%$n$枚の二面体群シャッフルは$2n$枚の追加カードと$3$回のパイルスクランブルシャッフルによって実現できる。
