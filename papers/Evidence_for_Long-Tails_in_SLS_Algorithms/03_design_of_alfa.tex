
Our SLS solver \Alfa{} (Adjusted logical formula algorithm) receives a satisfiable formula~$F$ as input.
The algorithm then proceeds by adding to~$F$ a set~$\Clauses$ of logically generated clauses.
It finally calls an SLS solver to solve the clause set~$F \cup \Clauses$.


\begin{algorithm}[htb]
	\textbf{Input:} Boolean formula $F$, \textbf{Promise:} $F \in \SAT$\\
	\BlankLine
	Generate \textbf{randomly} a set $\Clauses$ of clauses such that $F \vDash \Clauses$\\
	Call \algoformat{SLS}$(F \cup \Clauses)$ for some SLS solver~\algoformat{SLS}
	\caption{\Alfa{} acts as a base algorithm that can use different SLS algorithms.}
	\label{algo:main}
\end{algorithm}



Definition~\ref{def:width-w-res} is used
in Algorithm~\ref{algo:res} as a natural way to sample a set~$\Clauses$ of logically equivalent clauses with respect to a base instance~$F$.

\begin{algorithm}[htb]
	
	\SetKw{KwWithProb}{with probability}
	\SetKw{KwDo}{do}	
	\SetKwFunction{Shuffle}{Shuffle}
	
	\textbf{Input:} Boolean formula $F$, integer $w$, probability $p \in (0,1]$, Boolean \textit{shuffle}\\
	\BlankLine
	
	\ForEach{$R \in \operatorname{Res}_w^{\ast}(F) \setminus F$}{
		\KwWithProb $p$ %
		\KwDo
		$L := L \cup \set{R}$
	}
	
	\lIf{shuffle}{\textbf{return} \Shuffle{$L$} \textbf{else} \textbf{return} $L$}
	
	\caption{Generation of the random set $\Clauses$ with resolution}
	\label{algo:res}
\end{algorithm}


\begin{definition}
	\label{def:width-w-res}
	Let $F$ be a clause set, and $w$ be a positive integer. We define the operator
	\[
	\operatorname{Res}_w(F) := F \cup \Setdescr{R}{R \text{ is a resolvent of two clauses in } F \text{ and } |R| \leq w}.
	\]
	Also, we inductively define $\operatorname{Res}_w^{0}(F) := F$ and
	\[
	\operatorname{Res}_w^{n+1}(F) := \operatorname{Res}_w \! \big( \operatorname{Res}_w^{n}(F) \big), \text{ for } n \geq 0.
	\]
	Finally, we set	
	\[
	\operatorname{Res}_w^{\ast}(F) := \bigcup_{n \geq 0} \operatorname{Res}_w^{n}(F).
	\]
\end{definition}



