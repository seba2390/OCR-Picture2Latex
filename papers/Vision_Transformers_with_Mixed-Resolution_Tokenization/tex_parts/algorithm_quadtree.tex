\begin{algorithm}[t!]
% \vspace{6pt}
\footnotesize
\textbf{Input:}

Image~~$im\in\mathbb{R}^{h \times w \times 3}$~,

\vspace*{1pt}
% desired $\#$patches~~$L \in \mathbb{N}$~,
desired number of patches $L \in \mathbb{N}$~,

\vspace*{1pt}
patch edge sizes~~$s_{min},s_{max} \in \mathbb{N}$~,

\vspace*{1pt}
saliency scorer~~$score: patch \to \mathbb{R}^+$

\vspace*{1pt}
\textbf{Output:}

The set of chosen patches $P_{chosen}$

\vspace*{6pt}
\textbf{Algorithm:}

\vspace*{1pt}
$P_{chosen} \gets$ slice $im$ into a uniform grid with patch size $s_{max}$

\vspace*{3pt}
\While{$~\lvert P_{chosen} \lvert~<~L~$}{

\vspace*{1pt}
$P_{splittable} \gets \{p~~|~~p \in P_{chosen}~~\&~~size(p) \ge 2s_{min}\}$

\vspace*{1pt}
$p_{split} \gets \arg\max_{p \in P_{splittable}} score(p) $

\vspace*{2pt}
$children(p_{split}) \gets$ divide $p_{split}$ into 4 quadrants

\vspace*{1pt}
$P_{chosen} \gets children(p_{split}) \cup P_{chosen} \setminus \{ p_{split} \} $
}

\vspace*{3pt}

\textbf{Return} $P_{chosen}$

\vspace*{10pt}

\caption{\small The saliency-based Quadtree. We iteratively choose the ``most important'' image region as ranked by a saliency scorer and split it into 4 quadrants. In practice, we run the algorithm on a batch of images for improved speed, taking only $19 \mu\text{-}secs$ per image for the splitting logic. Patch scoring is also batched, taking $19\text{--}157 \mu\text{-}secs$ per image depending on the scorer. See subsection \ref{paragraph:impl_quadtree} and Table \ref{table:cost_breakdown} for more details.}
\label{algorithm:quadtree}
\end{algorithm}