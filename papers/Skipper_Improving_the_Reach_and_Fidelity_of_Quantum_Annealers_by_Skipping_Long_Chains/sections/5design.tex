% Skipper-G
\newpage
\section{Skipper-G: A Marcovian Approach}

We propose \emph{Skipper-G}, a greedy scheme that reduces the quantum cost of Skipper by skipping the examination of sub-problems unlikely to contain the global optimum. 
However, this strategy entails a trade-off: Skipper-G achieves marginally lower fidelity gains compared to Skipper and is ineffective for enhancing QA capacity.

% ++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Insight: Not ALL Sub-Spaces Include Global Optimum}

Skipper employs a Breadth-First Search (BFS) strategy to examine sub-problems, as depicted in Fig.~\ref{fig:BFS_DFS}(a). 
Trimming each chain bifurcates the search space, with skipping $c$ chains resulting in a binary tree of depth $c$. 
To ensure successful recovery, Skipper evaluates all leaf nodes, running a separate QMI for each sub-space at the tree's last level. 
Notably, Skipper does not examine intermediate nodes (or sub-spaces) since all chains are trimmed simultaneously. 

Users define the number of chain cuts in Skipper, with the option to skip up to eleven chains based on their budgetary constraints. 
For instance, if a user opts for the maximum allowable eleven cuts, Skipper must run 1024 QMIs when all linear coefficients are zero~\cite{ayanzadeh2023frozenqubits}, and up to 2048 QMIs otherwise.
Nonetheless, these sub-problems are independent, allowing for parallel execution by Skipper. 
Notably, Skipper's overall runtime remains comparable to the baseline, attributed to the significantly reduced embedding time, as detailed in Section~\ref{subsec:m1_reliability}.
However, the quantum costs incurred on QCs are substantially higher than those on classical platforms, which may present affordability issues for some users.

Not every sub-space contains the global optimum. 
Leveraging this insight, we introduce \emph{Skipper-G} (\emph{greedy Skipper}), which reduces the quantum cost of Skipper by adopting a Depth-First Search (DFS) strategy (Fig.~\ref{fig:BFS_DFS}(b)), to bypass sub-spaces unlikely to include the global optimum.
When pruning the maximum of eleven chains, Skipper-G executes 23 QMIs, in contrast to Skipper's potential 2048 QMIs.

\begin{figure}[b]
    \centering
    \includegraphics[width=0.9\columnwidth]{./figures/bfs_dfs_cropped.pdf}
    \caption{
        (a) Skipper utilizes a Breadth-First Search (BFS) strategy, examining all leaf nodes (intermediate nodes are not examined).
        (b) Skipper-G adopts a Depth-First Search (DFS) strategy, examining only two nodes at each level of the binary tree (including intermediate nodes).
        Example: With $c=11$ chain cuts, Skipper and Skipper-G execute at most 2048 and 23 QMIs, respectively.
}       
    \label{fig:BFS_DFS} 
\end{figure}  

% ++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{How Skipper-G Work?}

Figure \ref{fig:m2_overview} illustrates the overview of the Skipper-G scheme. 
In Skipper-G, similar to Skipper, users can determine the number of chain cuts, with the possibility of skipping up to eleven chains, depending on their budget constraints.
However, unlike Skipper where all chains are cut simultaneously, Skipper-G employs an iterative approach, cutting one chain in each iteration.
As illustrated in Fig.~\ref{fig:BFS_DFS}(b), Skipper-G initiates by setting the root node (i.e., the baseline with no chains cut) as the current node and executing the corresponding quantum program.
For each chain cut, Skipper-G performs the following steps:
\begin{enumerate}
    \item 
    In the current node (problem), the dominant chain is trimmed by setting its corresponding program qubit to either +1 or -1, resulting in two child nodes. 
    If the current node at level $c$ has the index $x$, then its left and right children at level $c+1$ will have indices $2x$ and $2x+1$, respectively (e.g., node $x=1$ at the third level leads to nodes 2 and 3 in Fig.~\ref{fig:BFS_DFS}(b)).
    
    \item 
    The quantum programs corresponding to the children are executed on the QA.
    
    \item 
    The best offspring is set as the current node.
\end{enumerate}

% All chains in Skipper are trimmed simultaneously, locating all sub-problems at the same level in the binary tree. 
% Consequently, all sub-problems possess identical structures, allowing Skipper-G to utilize the same embedding. 

% ++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Branch and Bound Criteria}

% In classical computing, both DFS and BFS guarantee optimum solution discovery, but in quantum hardware, noise introduces stochastic behavior, posing a challenge. 
% While Skipper remains unaffected by this, Skipper-G can be sensitive to node evaluation criteria, leading to different paths and outcomes across multiple runs.

When evaluating a node in Skipper-G, a quantum program is executed on a QA device for multiple trials. 
Each trial produces an outcome with an associated objective value. 
The assessment of node quality in Skipper-G is based on the following feature (lower is better):
\begin{equation}
    \downarrow f(Z) = \left| \frac{1}{\text{E}_{\text{min}} \times \text{EV}} \right|,
    \label{eq:m2_f}
\end{equation}
where $Z$ denotes the set of obtained samples, and $\text{E}_{\text{min}}$ and $\text{EV}$ represent the minimum and the expected value of the energy values in $Z$, respectively. 
The lower the value of $f$, the greater the likelihood that a child includes the global optimum in its corresponding subspace during the traversal of the associated binary tree. 
This feature balances the best sample with the overall quality of all samples, reducing the likelihood of getting trapped in local optima.


%\newpage
% ++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Overhead of Skipper-G}

Skipper-G is capable of trimming up to eleven chains, which necessitates a maximum of 23 distinct QMI executions.
Although Skipper-G examines two nodes at each level of the binary tree, these nodes, due to their identical structures, can utilize a single embedding. 
Consequently, Skipper-G requires $c$ embeddings for $c$ chain cuts. 
Nonetheless, since these embeddings can be executed in parallel, the embedding time for Skipper-G remains similar to that of the baseline, as the root node's embedding is expected to be more time-consuming than the embeddings of the smaller intermediate nodes.
% The classical time and memory complexity of Skipper-G are comparable to Skipper.


\begin{figure}[t]
    \centering
    \includegraphics[width=1\columnwidth]{./figures/m2_overview_cropped.pdf}
    \caption{
Overview  of Skipper-G. 
}       
    \label{fig:m2_overview}
\end{figure}  

% \newpage
% ++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Evaluation Results}

Figure~\ref{fig:DFS_fidelity}(a) illustrates the ER for various chain cut counts in Skipper-G, showing that progressively trimming more dominant chains leads to a decrease in the ER, approaching the global minimum. 
Additionally, Fig~\ref{fig:DFS_fidelity}(b) reveals that pruning up to five chains in Skipper-G can reduce the gap between the global optimum and the best QA sample by as much as 40.75\% (Avg. 29.19\%) compared to the baseline. 

Skipper marginally outperforms Skipper-G, achieving a 3.89\% greater reduction in ER, albeit at the expense of significantly higher quantum resource utilization. 
Skipper-G includes the baseline at the root of the binary tree, ensuring it performs no worse than the baseline.
% However, although Skipper can enhance QA capacity as well, the effect of Skipper-G on capacity enhancement is negligible.


\begin{figure}[h]
    % \vspace{-0.05 in}
    \captionsetup[subfigure]{position=top} %, singlelinecheck=off,justification=raggedright 
    \centering
    % (a)
    \subfloat[]{
        \includegraphics[width=0.48\columnwidth]{./figures/DFS_ER_k136_advantage.pdf}
    }%\hspace*{-0.8em}        
    % (b)
    \subfloat[]{
        \includegraphics[width=0.48\columnwidth]{./figures/DFS_BFS_relative_ER_advantage.pdf}
    }%\hspace*{-0.8em}              
    \caption{  
        Relative ER for five chain cuts compared to the baseline (lower is better). 
        (a) Skipper-G: Relative ER with increasing $C$. 
        (b) Overall Relative ER (lower is better) for Skipper vs. Skipper-G.
    }
    \label{fig:DFS_fidelity} 
\end{figure}  



% ++++++++++++++++++++++++++++++++++++++++++++++++++
% ++++++++++++++++++++++++++++++++++++++++++++++++++
% ++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Skipper and Skipper-G in Classical Realm}

Unfortunately, neither Skipper nor Skipper-G can be utilized to enhance the fidelity of optimization techniques used in classical realm. 
In the classical domain, the hardness of optimization problems depends on the number of variables and the graph topology. 
For instance, while planar graphs are tractable~\cite{dei2006exact,hadlock1975finding} in classical realm, neither regular nor power-law graphs become planar simply by eliminating a few nodes.
Additionally, eliminating ten nodes from a 1000-node graph results in sub-graphs with 990 nodes, which typically remain intractable in the classical realm.

Similarly, Skipper is not suitable for tackling larger problems in the classical realm. 
Its primary goal is to address the sparse connectivity of qubits, a key factor limiting the capacity of QAs. 
However, the full connectivity of classical bits does not present a similar limitation.



