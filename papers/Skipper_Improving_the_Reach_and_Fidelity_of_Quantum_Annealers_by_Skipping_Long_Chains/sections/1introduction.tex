% Intro 



\section{Introduction}

%intro 
Quantum computers (QCs) have the potential to solve certain problems beyond the capabilities of classical computers~\cite{arute2019quantum,villalonga2020establishing,preskillNISQ,king2021scaling,wu2021strong}. %spanning domains such as quantum simulations~\cite{feynman1982simulating}, cryptography~\cite{shor1999polynomial}, optimization~\cite{farhi2014quantum}, and machine learning~\cite{nielsen2010quantum,huang2021power}. 
Two main types of QCs exist: %~\cite{nielsen2010quantum,albash2018adiabatic}: 
digital machines, exemplified by industry leaders like IBM~\cite{IBMQ}, Google~\cite{GoogleAI}, IonQ~\cite{IonQ}, and Quantinuum~\cite{quantinuum},  
and analog devices such as superconducting \emph{Quantum Annealers} (\emph{QAs}) developed by D-Wave~\cite{D-Wave}, as well as neutral atom platforms by QuEra~\cite{QuEra} and PASQAL~\cite{PASQAL}. 
Both digital and analog QCs have polynomial equivalent computing power~\cite{aharonov2008adiabatic,albash2018adiabatic}.
For instance, QAs have demonstrated their potential in tackling real-world applications such as finance~\cite{elsokkary2017financial}, drug discovery~\cite{mulligan2020designing}, cryptography~\cite{peng2019factoring,hu2020quantum}, Boolean Satisfiability (SAT)~\cite{su2016quantum,ayanzadeh2020reinforcement,ayanzadeh2018solving,ayanzadeh2019sat}, planning and scheduling~\cite{inoue2021traffic,rieffel2015case,venturelli2015quantum,tran2016hybrid}, linear algebra~\cite{o2018nonnegative}, and signal processing~\cite{ayanzadeh2019quantum,ayanzadeh2020ensemble}, 
extending beyond application-specific acceleration.


%operation model 
While both QC types are accessed via the cloud~\cite{AmazonBraKet,MicrosoftAzure,D-Wave}, their operation models and design trade-offs differ significantly~\cite{ayanzadeh2022equal}.
In digital QCs (namely the gate-based or circuit model quantum computing), as shown in Fig.~\ref{fig:QC_operation_models}(a), qubits undergo a scheduled sequence of quantum operations defined by the quantum algorithm to directly manipulate their states~\cite{nielsen2010quantum}.
Conversely, as shown in Fig.~\ref{fig:QC_operation_models}(b), analog QCs operate as single-instruction systems, where the qubit environment is incrementally modified based on the evolution of a physical system, called \emph{Hamiltonian}, thereby allowing natural qubit evolution and indirect state alteration~\cite{ayanzadeh2022equal,albash2018adiabatic,mcgeoch2020theory}.



\begin{figure}[htb]
    \centering
    %   \vspace{0.05 in}
      \includegraphics[width=\columnwidth]{./figures/qc_models.pdf}
    % \vspace{0.05 in}
    \caption{
        Operation Model of QCs: 
        (a) Digital QCs execute compiled quantum circuits.  
        (b) Analog QAs execute the embedded problem Hamiltonian. 
        \emph{Operating as single-instruction machines, analog QAs do not incorporate quantum circuits.} 
}       
    \label{fig:QC_operation_models}
\end{figure}  


%capacity  
%Analog QCs boast faster scaling, with recent generations of QAs featuring 5700-plus qubits~\cite{D-Wave, mcgeochd}, 
%while the largest digital QC to date (Osprey by IBM) includes only 433 qubits~\cite{newsroom2022ibm, IBMQ}. 
%However, the operation model of QAs as single-instruction machines restricts their ability to effectively handle program qubits~\cite{ayanzadeh2022equal}.


% physical and logical capacity 
Full connectivity of qubits at scale is infeasible. 
In digital QCs, compilers introduce SWAP operations to make physical qubits adjacent~\cite{zulehner2018efficient,murali2019noise,tannu2019not}. 
%allowing every program qubit to be represented by one physical qubit. 
Conversely, analog QCs cannot apply operations to qubits, thus preventing the use of SWAPs for qubit routing.
Instead, QAs employ \emph{embedding}~\cite{zbinden2020embedding,pelofske20234,pelofske2019solving,pelofske2022solving,barbosa2021optimizing} 
where multiple physical qubits are \emph{chained} (or entangled) to represent a program qubit with higher connectivity, as shown in Fig.~\ref{fig:intro_embedding}(a).  
Compiling quantum circuits in digital QCs preserves qubit utilization (1-to-1 mapping between program and physical qubits), however, embedding in QAs can substantially increase physical qubit utilization ~\cite{ayanzadeh2022equal}. 
For instance, the 5761-qubit QA can accommodate up to 177 program qubits with all-to-all connectivity, highlighting nearly 33x reduced \emph{logical capacity}.


\begin{figure}[htb]
 %   \vspace{-0.06 in}
    \captionsetup[subfigure]{position=top} %, singlelinecheck=off,justification=raggedright 
    \centering
    % (a)     
    \subfloat[]{
        \includegraphics[width=0.49\columnwidth]{./figures/intro_embeding_cropped.pdf}
    }%\hspace*{-0.8em}        
    % (b) 
    \subfloat[]{
        \includegraphics[width=0.24\textwidth]{./figures/current_max_embeddable_advantage.pdf}
    }%\hspace*{-0.8em}            
    \caption{
(a) Embedding seven program qubits $(Q_i)$ onto a $5\times7$ grid of physical qubits.
% utilizes twenty qubits, leaving fifteen qubits unutilized.
(b) Max embeddable Barabasi--Albert (BA) graphs on a 5761-qubit QA device for different preferential attachment factors (${m}$), ranging from sparse BA-1 ($m=1$) to highly dense BA-6 ($m=6$) structures.
            }    
    \label{fig:intro_embedding}    
\end{figure}  




Given that the hardware graph remains fixed after fabrication, QAs’ logical capacity is primarily determined by the topology of the problem graph.
Real-world applications typically involve irregular ``Power-Law’’ graphs~\cite{agler2016microbial,clauset2016colorado,gamermann2019comprehensive,goh2002classification,house2015testing,mislove2007measurement,pastor2015epidemic}, 
and Barabasi--Albert (BA) graphs are widely considered representative of such real-world graphs~\cite{albert2005scale,barabasi1999emergence,barabasi2000scale,gray2018super,kim2022sparsity,lusseau2003emergent,wang2019complex,zadorozhnyi2012structural,zbinden2020embedding}.
Figure~\ref{fig:intro_embedding}(b) illustrates the largest embeddable BA graphs on a 5761-qubit QA, ranging from sparse (with attachment factor $m=1$, BA-1) to nearly fully connected (with $m=6$, BA-6) structures.
As $m$ increases linearly, the logical capacity experiences a superpolynomial reduction, converging to the 177-node fully connected graph.

%Our Observations
%Not all chains are created equal. 
We observe that chain lengths in QAs follow a ``Power-Law’’ distribution, where a few \emph{dominant chains} are significantly longer than most other chains (see section~\ref{subsec:method_insights} for more information). 
Moreover, we observe that a significant portion of physical qubits, nearly 25\%, remain unused as they become trapped in long chains. 
Furthermore, we observe that long chains can reduce the fidelity of QAs too. 
The qubits within a chain might take different values post-measurement, called \emph{broken chains}. 
Broken chains can negatively impact QAs' reliability, and longer chains are more likely to break. 


%Our Goal:
In this study, we aim to improve the capacity and fidelity of QAs through  eliminating dominant chains, as they account for a substantial portion of qubit utilization and are the main reason for isolating physical qubits.
We propose \emph{Skipper}, which \emph{prunes} these chains by removing their corresponding program qubits and replacing them with two possible measurement outcomes: -1 and +1.
By eliminating a dominant chain, Skipper accomplishes two objectives: 
(a) releasing physical qubits previously used within pruned chains, 
and (b) releasing all qubits previously trapped with the pruned chain. 
This can enable us to use all released physical qubits to accommodate more program qubits. 

However, identifying and pruning dominant chains is nontrivial. 
Chains are formed post-embedding. 
First, when a (long) chain is eliminated, the remaining embedding is likely not to be optimum, necessitating re-embedding the new problem to maximize the reliability of QAs. 
Embedding itself is nontrivial, as it can take several hours for problems at scale. 
Moreover, embedding techniques are heuristic, and they may fail to find an embedding successfully for a problem, requiring multiple attempts. 
Second, pruning the longest chain can change the position of the second-longest chain when re-embedding the problem, necessitating an embedding for every pruned chain. 
To this end, Skipper adopts a greedy approach to prune $c$ chains by sorting program qubits based on their degree and removing the top $c$ qubits simultaneously. 
We observe that this greedy approach exhibits desirable, near-optimal behavior for $c \ge 5$ chain cuts.


Importantly, the number of chain cuts in Skipper is user-defined; the system allows for a maximum of eleven chains to be cut, and this does not scale with the problem size, offering flexibility within the user's budget constraints. 
Each chain cut bifurcates the search space of the initial problem; therefore, trimming eleven chains can lead to up to 2048 sub-problems, and Skipper examines all of them to ensure guaranteed recovery.
Our experiments with a 5761-qubit QA by D-Wave demonstrate that Skipper can address up to 59\% (Avg. 28.3\%) larger problems when up to eleven chains are trimmed. 
Additionally, Skipper can significantly enhance QA fidelity by up to 44.4\% (Avg. 33.1\%), when trimming up to five chains and running 32 quantum executables.


Skipper is inspired by FrozenQubits~\cite{ayanzadeh2023frozenqubits}.
Skipper enhances both the capacity and fidelity of analog QAs. 
However, FrozenQubits has a negligible impact on the capacity of digital QCs, where one program qubit is represented with one physical qubit. 
Furthermore, FrozenQubits' performance diminishes as graph density increases, whereas Skipper effectively handles graphs ranging from sparse to dense structures.

% Previous techniques for solving larger problems on smaller QAs have utilized iterative approaches involving approximations, leading to reduced reliability as the problem size increases~\cite{pelofske2022solving, okada2019improving}.
%  also another group of previous techniques are application-specific (for Max-Clique)
% Conversely, Skipper can enhance the QA fidelity while solving larger problems.
% All sub-problems in Skipper share a single embedding, whereas previous techniques require separate embeddings for each sub-problem, which can be a bottleneck for problems at scale. 


The quantum cost of Skipper can present affordability challenges for certain users. 
We introduce \emph{Skipper-G}, a greedy approach that bypasses sub-spaces less likely to include the global optimum. 
Consequently, it runs at most 23 quantum executables, compared to the 2048 required by Skipper for trimming up to eleven chains.
It is worth noting that Skipper-G is proposed to improve QA fidelity, with its effect on increasing capacity being negligible.
Our experiments demonstrate that Skipper-G can boost QA fidelity by up to 40.8\% (Avg. 29.2\%), with five chain cuts and 11 runs.
% Skipper has the dual capability of enhancing both the capacity and fidelity of QAs, while Skipper-G is specifically designed for boosting the reliability of these devices.

    
\vspace{0.1 in}
Overall, this paper makes the following contributions:
\vspace{0.05 in}

\begin{enumerate}[ leftmargin=0.5cm,itemindent=0.cm,labelwidth=.5cm,labelsep=0cm,align=left, itemsep=0.2 cm, listparindent=0.5cm]

\item 
We show that in QAs, the chain length exhibits a ``Power-Law’’ distribution, with a few dominant chains having significantly more qubits. 
Moreover, we demonstrate that approximately 25\% of physical qubits remain unused as they become trapped within long chains.

\item 
We introduce \emph{Skipper} that enhances the capacity and reliability of QAs by cutting dominant chains, 
thereby addressing up to 59\% (Avg. 28.3\%) larger problems and improving QA fidelity by up to 44.4\% (Avg. 33.1\%), when up to eleven and five chains are cut, respectively.
To our knowledge, Skipper is the first proposal to simultaneously enhance both the capacity and fidelity of QAs.
 
\item 
We demonstrate that the quantum cost of Skipper in enhancing QA fidelity can be substantially reduced (to only 23 runs, compared to over 2000 runs in Skipper) by bypassing sub-spaces unlikely to contain optimal solutions.

\item 
We propose \emph{Skipper-G}, a greedy scheme that enhances QA fidelity by up to 40.8\% (Avg. 29.2\%), with five chain cuts and only 11 runs (compared to 32 runs in Skipper). 

\end{enumerate}
     


\ignore{

In addition to logical capacity, chaining can significantly impact the reliability of QAs. 
For instance, the qubits within a chain might take different values post-measurement, a phenomenon known as a \emph{broken chain}, which can negatively impact QAs' performance. 
Additionally, the distribution of chain lengths can influence QA outcomes, and uniformity in the value of chains is desirable~\cite{boothby2016fast,venturelli2015quantum}.


}
