\section{WiFi Responds When It Should Not}\label{sec:polite-wifi}

Most networks use security protocols to prevent unauthorized devices from communicating with their devices. Therefore, one may assume that a WiFi device only acknowledges frames received from the associated access point or other devices in the same network. However, we have found that all today's WiFi devices acknowledge even the frames they receive from an unauthorized device from outside of their network. In particular, as long as the destination address matches their MAC address, their physical layer acknowledges it, even if the frame has no valid payload. In this section, we examine this behavior in more detail, and explain why this problem happens and why it is not preventable.

\begin{figure}[!t]
    \centering
    \includegraphics[width = 0.8\columnwidth]{figures/polite-wifi.png}
    \caption{WiFi devices send an ACK for any frame they receive without checking if the frame is valid.}
    \label{fig:polite-wifi}
\end{figure}

To better understand this behavior, we run an experiment where we use two WiFi devices to act as a victim and an attacker. The attacker sends fake WiFi packets to the victim. We monitor the real traffic between the attacker and the victim's device.

\vspace{0.05in}
\noindent \textbf{Setup:} For the victim, we use a tablet, and for the attacker, we use a USB WiFi dongle that has a Realtek RTL8812AU 802.11ac chipset. This is a \$12 commodity WiFi device. The attacker uses this device to send fake frames to the victim's device. To do so, we develop a python program that uses the Scapy library~\cite{scapy} to create fake frames. Scapy is a python-based framework that can generate arbitrary frames with custom data in the header fields. Note, that the only valid information in the frame is the destination MAC address (i.e., the victim's MAC address). The transmitter MAC address is set to a fake MAC address (i.e., aa:bb:bb:bb:bb:bb), and the frame has no payload (i.e., null frame) and is not encrypted.

\vspace{0.05in}
\noindent
\textbf{Result:} Figure~\ref{fig:wireshark} shows the real traffic between the attacker and the victim device captured using Wireshark packet sniffer~\cite{wireshark}. As can be seen, when the attacker sends a fake frame to the victim, the victim sends back an ACK to the fake MAC address (aa:bb:bb:bb:bb:bb). This experiment confirms that WiFi devices acknowledge  frames without checking their validity. 
\begin{figure}[t!]
        \centering
        \includegraphics[width=0.8\linewidth, page=2]{figures/wireshark.png}
        \caption{Frames exchanged between attacker and victim} 
        \label{fig:wireshark}
\end{figure}  
Finally, to see if this behavior exists on other WiFi devices, we have repeated this test with a variety of devices (such as laptops, smart thermostats, tablets, smartphones, and access points) with different WiFi chipsets from different vendors, as shown in Table~\ref{tbl:controled-devices}. Note, target devices are connected to a private network and the attacker does not have their secret key. After performing the same experiment as before, we found that all of these devices also respond to fake packets received from a device outside of their network.

\begin{table}[t]
\centering
\begin{tabular}{|l|l|l|}
     \hline
     Device & WiFi module & Standard  \\
     \hline
     MSI GE62 laptop&Intel AC 3160 & 11ac\\
     Ecobee3 thermostat& Atheros & 11n\\
     Surface Pro 2017& Marvel 88W8897 & 11ac\\
     Samsung Galaxy S8 & Murata KM5D18098 & 11ac\\
     Google Wifi AP &  Qualcomm IPQ 4019 & 11ac\\
     \hline
\end{tabular}
\caption{List of tested chipsets/devices}
\label{tbl:controled-devices}
\end{table}

\subsection{How widespread is this loophole?}\label{sec:testing}
In the previous section, we examined a few different WiFi devices and showed that they are all responding to fake frames from unauthorized devices. Here, we examine thousands of devices to see how widespread this behavior is. In the following, we explain the setup and results of this experiment. 

\vspace{0.05in}
\noindent
\textbf{Setup:} To examine thousands of devices, we mounted a WiFi dongle on the roof of a vehicle and drove around the city to test all nearby devices. For the WiFi dongle, we use the same  Realtek  RTL8812AU  USB  WiFi dongle, and connect it to a Microsoft Surface, running Ubuntu 18.04. We develop a multi-threaded program using the Scapy library~\cite{scapy} to discover nearby devices, send fake 802.11 frames to the discovered devices, and verify that target devices respond to our fake frames. Specifically, our implementation contains three threads. The first thread discovers nearby devices by sniffing WiFi traffic and adding the MAC address of unseen devices to a target list. The second thread sends fake 802.11 frames to the list of target devices. Finally, the third thread checks to verify that target devices respond with an ACK. 


% Note that 802.11 ACK does not have a transmitter field in the MAC header and it only has a destination address.
% Therefore, when we receive an ACK, we do not know which target device transmitted this ACK.
% To solve this problem, we use a unique transmitter MAC address in the fake frame transmitted to each target device.
% The target device then sends an ACK to this MAC address and we can find out which device responded.
% One might think that the transmitter of an ACK is known because it must be the destination of the last fake frame.
% However, since independent threads perform sending fake frames and receiving ACKs, there is no way to synchronize them.

\begin{table}[t]
    \centering
    \begin{tabular}{|l|c||l|c|}
        \hline
        \multicolumn{2}{|c||}{WiFi Client Device} & \multicolumn{2}{|c|}{WiFi Access Point}\\
        \hline
        Vendor & \# devices &   Vendor & \# devices  \\
        \hline
        Apple&  143	&	Hitron &  723 \\
        Google&  102	&	Sagemcom &  601 \\
        Intel&  66	&	Technicolor&  410 \\
        Hitron &  65	&	eero &  195 \\
        HP &  63	&	Extreme N. &  188 \\
        Samsung&  56	&	Cisco &  156 \\
        Espressif&  47	&	HP &  104 \\
        Hon Hai&  46	&	TP-LINK &  101 \\
        Amazon &  41	&	Google &  80 \\
        Sagemcom &  38	&	D-Link  &  75 \\
        Liteon &  33	&	NETGEAR &  69 \\
        AzureWave &  30	&	ASUSTek  &  51 \\
        Sonos &  30	&	Aruba &  46 \\
        Nest Labs &  27	&	SmartRG, &  44 \\
        Murata  &  24	&	Ubiquiti N.&  35 \\
        Belkin &  20	&	Zebra &  35 \\
        TP-LINK  &  20	&	Pegatron &  28 \\
        Cisco&  16	&	Belkin  &  25 \\
        ecobee &  13	&	Mitsumi &  25 \\
        Microsoft &  13	&	Apple &  19 \\
        Others & 630	&	Others & 789 \\
        \hline\hline	
        Total & 1523	&	Total & 3805  \\
        \hline
    \end{tabular}
    \caption{List of WiFi devices and APs that respond to our fake 802.11 frames.}
    \label{tbl:uncontroled-devices}
\end{table}

\vspace{0.05in}
\noindent
\textbf{Results}: We perform this experiment for one hour while driving around the city. In total, we discovered 5,328 WiFi nodes from 186 vendors. The list includes 1,523 different WiFi client devices from 147 vendors and 3,805 access points from 94 vendors. Table~\ref{tbl:uncontroled-devices} shows the top 20 vendors for WiFi devices and WiFi access points in terms of the number of devices discovered in our experiment. The list includes devices from major smartphone manufacturers (such as Apple, Google, and Samsung) and major IoT vendors (such as Nest, Google, Amazon, and Ecobee). We found that all 5,328 WiFi Access Points and devices responded to our fake 802.11 frames with an acknowledgment, and hence we infer that most probably all of today's WiFi devices and access points respond to fake frames when they should not.

\subsection{Can this loophole be fixed?}\label{sec:cannot-be-fixed}
So far, we have demonstrated that all existing WiFi devices respond to fake packets received from unauthorized WiFi devices outside of their network. Now, the next question is why this behavior exists, and if it can be prevented in future WiFi chipsets.

In a WiFi device, when the physical layer receives a frame, it checks the correctness of the frame using error-checking mechanisms (such as CRC) and transmits an ACK if the frame has no error. However, checking the validity of the content of a frame is performed by the MAC and higher layers. Unfortunately, this separation of responsibilities and the fact that the physical layer does not coordinate with higher layers about sending ACKs seem to be the root cause of the behavior. In particular, we have observed that when some access points receive fake frames, they start sending \emph{deauthentication frames} to the attacker, requesting it to leave the network. %Note this makes no sense since the attacking device has never been part of the network and is not authenticated. 
These access points detect the attacker as a ``malfunctioning'' device and that is why they send deauthentication frames. Surprisingly, although the access points have detected that they are receiving fake frames from a ``malfunctioning'' device, we found that they still acknowledge the fake frames.

An example traffic that demonstrates this behavior is shown in Figure~\ref{fig:deauth-rts-cts}. As can be seen, although the access point has already sent three deauthentication frames to the attacker, it still acknowledges the attacker's fake frame. We then manually blocked the attacker's fake MAC address on the access point. Surprisingly, we observed that the AP still acknowledges the fake frames. These observations verify that sending ACK frames happens automatically in the physical layer without any communication with higher layers. Therefore, the software running on the access points does not prevent the physical layer from sending ACKs to fake frames.

\begin{figure}[t!]
    \centering
    \includegraphics[width=\columnwidth]{figures/polite-wifi-deaut-frame.png}
    \caption{The attacked access point detects that something strange is happening, however it still ACKs fake frames}
    \label{fig:deauth-rts-cts}
\end{figure}


The next question is why the software running on WiFi devices does not prevent this behavior by verifying if the frame is legitimate before sending an ACK. Unfortunately, this is not possible due to the WiFi standard timing requirements. Specifically, in the IEEE 802.11 standard, upon receiving a frame, an ACK must be transmitted by the end of the Short Interframe Space (SIFS)\footnote{The SIFS is used in the 802.11 standard to give the receiver time to go through different procedures before it is ready to send the ACK.
These procedures include Physical-layer and MAC-layer header processing, creating the waveform for the ACK, and switching the RF circuit from receiving to transmitting mode.
} interval which is 10~$\mu$s and 16 $\mu$s for the 2.4 GHz and 5 GHz bands, respectively.
If the transmitter does not receive an ACK by the end of SIFS, it assumes that the frame has
been lost and retransmits the frame. Therefore, the WiFi device nefeds to verify the validity of the received frame in less than 10 $\mu s$. This verification must be done by decoding the frame using the secret shared key. Unfortunately, decoding a frame in such a short period is not possible. In particular, past work has shown that the time required to decode a frame is between 200 to 700 $\mu s$ when the WPA2 security protocol is used~\cite{decoding-time-1, decoding-time-2, decoding-time-3}. This processing time is orders of magnitude longer than SIFS. Hence, existing devices cannot verify the validity of the frame before sending the ACK, and they acknowledge a frame as long as it passes the error detection check. One potential approach to solve this loophole is to implement the security decoder in WiFi hardware instead of software to significantly speed up its delay. Although this may solve the problem in future WiFi chipsets, it will not fix the problem in billions of WiFi chipsets which are already deployed. 




% \textcolor{blue}{I think the following part needs to be removed}
% One potential solution to fix this behaviour is to design a faster security decoder in the WiFi hardware rather than software. Unfortunately, even with a faster security decoder, \name is still unpreventable since the  attacker  can send fake  Request  to Send (RTS) frames instead of fake  data  frames. Wang et. al~\cite{rts-cts} show that if a Request to Send (RTS) frame
% is sent to an unassociated device, it responds with a Clear To Send (CTS) frame. Therefore, if an attacker sends fake RTS frames, the victim responds with CTS frames. The RTS and CTS frames are typically used between WiFi devices in a network to reserve the wireless channel for a certain amount of time. What makes RTS/CTS interesting is that these frames cannot be encrypted in WiFi networks. This is because all nearby devices must receive them to respect channel reservation.
% The lack of encryption for RTS and CTS frames
% makes the \name behavior unpreventable.\footnote{The IEEE 802.11w standard~\cite{ieee802.11w} 
% supports protected management frames to prevent an unauthenticated station from carrying out an attack by injecting fake management frames. However, control frames are still unprotected. Fundamentally, WiFi cannot encrypt control packets because all devices in the vicinity must understand them.}
% For the rest of this paper, we continue using fake frame and ACK for simplicity, although CTS/RTS can be used interchangeably.










% \begin{table}[t]
%     \centering
%     \begin{tabular}{|l|c|}
%     \hline
%     Vendor & \# devices  \\
%     \hline
%     Hitron Technologies. Inc &  723 \\
%     Sagemcom Broadband SAS &  601 \\
%     Technicolor CH USA Inc. &  410 \\
%     eero inc. &  195 \\
%     Extreme Networks, Inc. &  188 \\
%     Cisco Systems, Inc &  132 \\
%     TP-LINK Technologies Co., Ltd. &  101 \\
%     Google, Inc. &  80 \\
%     Hewlett Packard &  79 \\
%     D-Link International &  75 \\
%     NETGEAR &  69 \\
%     ASUSTek COMPUTER INC. &  51 \\
%     Aruba, a Hewlett Packard Company &  46 \\
%     SmartRG, Inc. &  44 \\
%     Ubiquiti Networks Inc. &  35 \\
%     Zebra Technologies Inc &  35 \\
%     PEGATRON CORPORATION &  28 \\
%     Belkin International Inc. &  25 \\
%     MITSUMI Electric Co., Ltd. &  25 \\
%     Hewlett Packard Enterprise &  25 \\
%     Others & 838 \\
%     \hline\hline
%     Total & 3805  \\
%     \hline
%     \end{tabular}
%     \vspace{5pt}
%     \caption{3805 WiFi access points from 94 vendors are verified to have the \name vulnerability.}
%     \label{tab:polite_wifi_ap}
% \end{table}




%\begin{table}[t]
%     \centering
%     \begin{tabular}{|l|c|}
%     \hline
%     Vendor & \# devices  \\
%     \hline
%     Apple, Inc. &  143 \\
%     Google, Inc. &  102 \\
%     Intel Corporate &  66 \\
%     Hitron Technologies. Inc &  65 \\
%     Hewlett Packard &  63 \\
%     Samsung Electronics Co.,Ltd &  56 \\
%     Espressif Inc. &  47 \\
%     Hon Hai Precision Ind. Co.,Ltd. &  46 \\
%     Amazon Technologies Inc. &  41 \\
%     Sagemcom Broadband SAS &  38 \\
%     Liteon Technology Corporation &  33 \\
%     AzureWave Technology Inc. &  30 \\
%     Sonos, Inc. &  30 \\
%     Nest Labs Inc. &  27 \\
%     Murata Manufacturing Co., Ltd. &  24 \\
%     Belkin International Inc. &  20 \\
%     TP-LINK Technologies Co., Ltd. &  20 \\
%     Cisco Systems, Inc &  16 \\
%     ecobee inc &  13 \\
%     Microsoft Corporation &  13 \\
%     Others & 630 \\
%     \hline\hline
%     Total & 1523 \\
%     \hline
%     \end{tabular}
%     \vspace{5pt}
%     \caption{1523 WiFi devices from 147 vendors are verified to have the \name vulnerability.}
%     \label{tab:polite_wifi_client}
% \end{table}




%The existing 802.11 chipsets already use most of SIFS time.
%For example, the Broadcom BCM4339 802.11ac chip~\cite{BCM4339} requires 5 $\mu s$ just for the Tx to Rx switching.




% To answer this question, we need to understand the underlying mechanism for sending an acknowledgment.
% In 802.11 networks, two types of frames require an immediate response from the receiver.
% A data frame must be followed by an ACK if the frame is received correctly, and a Request To Send (RTS) frame
% must be followed by a Clear to Send (CTS) frame if the channel is clear for transmission.
% Ideally there should be no gap between these frame to utilize the channel as much as possible.
% However, it is not possible to immediately send an ACK or CTS after receiving a data frame or RTS.
% This is because the receive needs some time to go through different procedures before it is ready to send transmit the response.




% SIFS = RTT (based on PHY Transmission rate) + FRAME PROCESSING DELAY AT RECEIVER (PHY PROCESSING DELAY + MAC PROCESSING DELAY) + FRAME PROCESSING DELAY (FOR COMPOSING RESPONSE CTS/ACK)+ RF TUNER DELAY (CHANGE FROM RX to TX)

% SIFS=D+M+Rx/Tx

% Where,

% D=(Receiver delay (RF delay) and decoding of physical layer convergence procedure (PLCP) preamble/header)

% M=(MAC processing delay)

% Rx/Tx=(transceiver turnaround time)

% Modern 802.11 ac chip requires 4 micro seconds to swtich from TX to RX
% https://www.cypress.com/file/298796/download

% 5 micro
% %https://www.mouser.com/datasheet/2/100/002-14784_CYW4339_Single_Chip_5G_WiFi_IEEE_802.11a-961626.pdf

% BCM43569 5 micro
% https://media.digikey.com/pdf/Data%20Sheets/Cypress%20PDFs/BCM43569_RevI_Jul1,2016.pdf

% ====
% 0.2 ms delay for wpa2?
% %https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5763598&casa_token=xZlWJCfXARgAAAAA:q9oTITvt7JVJrBEixWnhj0furAXDFFTxD9DtF4vzxt7-4i0e2Q7FLPbBn2zsPLwozqF33OgH&tag=1
% same?
% %https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=5763598


% also around 0.2 RTT
% %https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=7993928

% 0.7
% %https://dl.acm.org/doi/pdf/10.1145/3102304.3102335

