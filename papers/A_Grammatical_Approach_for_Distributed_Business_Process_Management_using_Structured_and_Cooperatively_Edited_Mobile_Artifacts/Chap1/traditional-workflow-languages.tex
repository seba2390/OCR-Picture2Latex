\mySection{Peer to Peer Business Process Management}{}
\label{chap1:sec:p2p-bpm}
Knowing that workflows are naturally distributed, they can sometimes involve resources from different organisations. Within each organisation, WfMS must therefore be built with a strong emphasis on (sometimes inter-organisational) cooperation; this differs from the idea in which classical information systems have often been built. However, even if WfMS must be \textit{interoperable} to facilitate cooperation, they must also ensure the \textit{autonomy} and the \textit{confidentiality} of actors and organisations involved in workflow execution; because, though organisations are aware of the need and necessity to participate in cooperation, they wish to protect their expertise in order to ensure sufficient confidentiality on their local data and local processes \cite{boukhedouma2015adaptation}. 
The main challenge for WfMS designers over the last two decades, has therefore been to build WfMS capable of both ensuring the agility of organisations and fostering the interconnection of business processes, while preserving their autonomy and the confidentiality of their local processes and data.

The production of fully distributed WfMS proved to be an effective solution to this challenge \cite{meilin1998workflow}. This has been made more feasible with the advent of new concepts such as the \textit{Multiagent} paradigm and the \textit{Service-Oriented Architecture} (SOA). In this section, we take a look at how the distributed workflow management approach works, and some of the decentralised WfMS that have been developed for this purpose


\mySubSection{The Advent of the Multiagent and Service-Oriented Concepts}{}
\label{chap1:sec:agent-soa-soc-concepts}

\mySubSubSection{The Multiagent Concept}{}
\label{chap1:sec:agent-concept}
The \textit{agent} and \textit{multiagents systems} concepts emerged in the 1980s. These concepts have generated lots of excitement in different research communities mainly because, they form the basis of a new paradigm for designing and implementing software systems that operates in distributed and open environments\footnote{\textit{"An open system is one in which the structure of the system itself is capable of dynamically changing. The characteristics of such a system are that its components are not known in advance; can change over time; and can consist of highly heterogeneous agents implemented by different people, at different times, with different software tools and techniques. Perhaps the best-known example of a highly open software environment is the internet. The internet can be viewed as a large, distributed information resource, with nodes on the network designed and implemented by different organisations and individuals."} (Katia P. Sycara, \citeyearpar{sycara1998multiagent})}, such as the internet \cite{sycara1998multiagent}. One of the best-known and most famous definitions of the agent concept was formulated by Jacques Ferber \citeyearpar{ferber1997systemes} and states that : \textit{an agent is a physical or logical entity capable of acting upon itself and its environment, which has a partial representation of that environment, which, in a multiagent system, can communicate with other agents, and whose behaviour is the consequence of its observations, knowledge and interactions with other agents}.

Multiagent systems have brought a new way to look at distributed systems and have provided a path to more robust intelligent applications \cite{deloach2001multiagent}. The challenge of the multiagent concept is to build distributed systems in which the nodes (agents), endowed with great autonomy, high reactivity and communicating using an asynchronous messaging system (they therefore possess cooperation and deliberation/decision capabilities \cite{theseKanzow}), can appear and disappear at any time without paralysing the system. A multiagent system is characterised as follows \cite{sycara1998multiagent}:
\begin{enumerate}
	\item Each agent has incomplete information or capabilities for solving problems and thus, has a limited viewpoint;
	\item There is no system global control;
	\item Data are decentralised;
	\item Computation is asynchronous.
\end{enumerate}
Such properties for a multiagent system provide it with several capabilities that have mainly attracted researchers and professionals to the multiagent paradigm. Among these capabilities we can distinguish the following \cite{sycara1998multiagent}: 
\begin{itemize}
	\item The capability to solve problems that are too large and difficult to handle by a centralised agent/server, because of resource limitations, or the sheer risk of having one centralised entity that could be a performance bottleneck or could fail at critical times;
	\item The capability to allow for the interconnection and interoperation of multiple existing legacy systems;
	\item The capability to provide solutions to problems that can naturally be regarded as a society of autonomous interacting components-agents;
	\item The capability to provide solutions that efficiently use information sources that are spatially distributed;
	\item The capability to provide solutions in situations	where expertise is distributed.
\end{itemize}

The above mentioned capabilities of multiagent systems are in line with the desired capabilities of a distributed WfMS. This has motivated the growing use of concepts developed for multiagent systems, in the production of such WfMS. However, the vocabulary used by the designers of distributed WfMS is not always identical to the multiagent jargon, and it is sometimes necessary to abstract the proposed systems to exhibit the multiagent concepts involved in their design and implementation.



\mySubSubSection{The Service-Oriented Architecture}{}
\label{chap1:sec:soa-concept}
\noindent\textbf{\textit{Basic concepts}} 

\textit{Service-Oriented Architecture} (SOA) has spread rapidly as a result of its growing success, and has been widely accepted as a supporting architecture for information systems because of its pivotal concept of \textit{service} \cite{boukhedouma2015adaptation}. Service is the essential concept of SOA and can be defined as \textit{"self-describing, platform-agnostic computational elements that support rapid, low-cost composition of distributed applications. Services perform functions, which can be anything from simple requests to complicated business  processes. Services allow organisations to expose their core competencies programmatically over a network using standard languages and protocols, and be implemented via a self-describing interface based on open standards"} (Mike P. Papazoglou, \citeyearpar{papazoglou2003service}). For MacKenzie et al. \citeyearpar{mackenzie2006reference}, the term service combines the following related ideas :
\begin{itemize}
	\item The offer to perform work for another;
	\item The capability to perform work for another;
	\item The specification of the offered work.
\end{itemize}

From a purely technological point of view, a service is a software component represented by two separate elements: its interface, which allows defining the access modalities to the service (name of the service and the parameters of the public operations defining the signatures of the operations) and its implementation \cite{boukhedouma2015adaptation}. Services are offered by \textit{service providers} (see fig. \ref{chap1:fig:basic-soa}); these are organisations that procure the service implementations, supply their service interfaces and provide related technical and business support \cite{papazoglou2003service}. Service interfaces are available for their searching, their binding, and their invocation by \textit{service consumers} (see fig. \ref{chap1:fig:basic-soa}) \cite{mackenzie2006reference}. Clients of services (service consumers) can be other solutions or applications within an enterprise or clients outside the enterprise. Service providers must therefore provide a distributed computing infrastructure for both intra and cross-enterprise application integration and collaboration. To satisfy these requirements, provided services should be \cite{papazoglou2003service}:
\begin{itemize}
	\item \textit{Technology neutral}: they must be able to be invoked by clients coded with various technologies having a few standards as a common denominator;
	\item \textit{Loosely coupled}: they must not require neither knowledge nor internal structures or conventions (context) at the service consumer or service provider side;
	\item \textit{Transparent from the point of view of their location}: one should be able to locate and invoke the services irrespective of their real location. To do so, the use of a \textit{service registry} where services interfaces and location information are stored, is required (see fig. \ref{chap1:fig:basic-soa}).
\end{itemize}

SOA is an architectural style, a logical way of designing a software system to provide services to either end-user applications or other services distributed in a network through published and discoverable interfaces. Basically, SOA defines an interaction between software agents as an exchange of messages between service consumers (clients) and service providers (see fig. \ref{chap1:fig:basic-soa}).
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.6]{./Chap1/images/basic-soa.png}}
	\caption{The basic Service-Oriented Architecture (source \cite{papazoglou2003service}).}
	\label{chap1:fig:basic-soa}
\end{figure}
In SOA, the exchange of messages between agents can be \textit{synchronous} or \textit{asynchronous}.

In the synchronous model, the service consumer invokes a service and expects a result. The invoked service is then designed to immediately return a result and is the only service involved. This model operates similarly to remote procedure call technologies such as Remote Method Invocation (RMI) but with a much loosely coupling between the service consumer and its provider.

In the asynchronous model (which is generally a particular form of \textit{publish/subscribe}\footnote{Publish/Subscribe is a communication paradigm well adapted to the loosely coupled nature of distributed interaction in large-scale applications; with systems based on its interaction scheme, subscribers register their interest in an event, or a pattern of events, and are subsequently asynchronously notified of events generated by publishers \cite{eugster2003many}.}), a given service consumer $A$ expresses its desire to be aware of the execution state of a given service $b$, published (provided) by a service provider $B$, by subscribing to it. During this subscription, it provides information about one or more services $(a_i)$ that it also provides and that must be invoked when the execution state of $b$ has changed. Several services are thus involved, and each agent is generally both a service provider and a service consumer.

SOA has been designed to facilitate the implementation of distributed applications based on Peer-to-Peer architectures (nodes/agents communicate directly without going through a central server) and in which, the skills of each agent are exposed, discoverable and invocable by the others but, the technique and technology used by each agent is confidential. This setting completes the concept of agents to answer correctly to the challenges of distributed WfMS: hence the very increasing use of the concept of service in workflow systems. Actually, some currents of thought claim that SOA was designed to facilitate the automation of business processes and thus, the design of distributed WfMS. This is the case of Hurwitz et al. \citeyearpar{hurwitz2009service} who define SOA as : \textit{"a software architecture for building applications that implement business processes or services by using a set of loosely coupled black-box components orchestrated to deliver a well-defined level of service"}.

~

\noindent\textbf{\textit{Shared-data Overlay Network}} 

As the use of SOA in P2P applications escalates, there is a proliferation of tools to facilitate the design and implementation of these new applications \cite{kaur2013design}. \textit{Shared-data Overlay Network} (SON) \cite{SON} is one of those tools. SON is a middleware offering several \textit{Domain Specific Languages} (DSL) to facilitate the implementation of P2P systems whose components communicate in an asynchronous manner by services invocations. SON combines the powerful concepts of \textit{Component-Based Software Engineering}\footnote{Component-Based Software Engineering is an emerging paradigm of software development whose goal is, composing applications with plug \& play software components on the frameworks; so, to realise software reuse by changing both software architecture and software process \cite{aoyama1998new}.}, \textit{Service-Oriented Computing} and \textit{P2P Computing} in its engineering. 

By using SON middleware, the P2P application designer (software developer) is able not only to specify applications in component-based service model, but also to perform an effective code generation. In fact (see fig. \ref{chap1:fig:son-model}), the software developer defines using a dedicated DSL called \textit{Component Description Meta Language} (CDML), for each component, a set of services (input, internal and output). Then, he only implements the code of the components, i.e., the methods that implement the defined services. Afterwards, a code generation tool, called \textit{Component Generator}, generates a set of Java source files that implement the so-called \textit{container of the component}. These Java files are compiled together with the implementation code to generate a standalone and ready-to-use component. 
Thus, software developers are assisted and have greater ease in developing component and service-based P2P applications. These facilities allow them to focus more on the business logic and to defer to SON, the management of the runtime requirements (e.g., communication mechanisms, instantiation and connection of components, service discovery, etc.).
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.7]{./Chap1/images/son-model.png}}
	\caption{Overview of a P2P application development process with SON (source \cite{SON}).}
	\label{chap1:fig:son-model}
\end{figure}
We use SON to implement prototypes of some of the models presented in this manuscript.


\mySubSection{Some Existing Distributed WfMS}{}
\label{chap1:sec:some-p2p-wfms}
In this section, we briefly present some existing approaches to distributed workflow management. As mentioned in \cite{theseKanzow}, these approaches have the following characteristics :
\begin{itemize}
	\item They are based on distributed entities that can communicate;
	\item These entities act autonomously, locally and thus, influence the further execution of the process (through their local actions, they choose the next actions to be executed);
	\item Each entity has a confidential local state;
	\item Each entity has only a partial view of the system's overall state at a given time;
	\item Workflow execution results from the automated interaction between the different entities.
\end{itemize}
The approaches to distributed workflow management presented here, can be divided into two categories :
\begin{enumerate}
	\item The first category contains those in which, data and controls are partially distributed and the WfMS is based on a client-server architecture;
	\item The second one is concerned with those in which WfMS, data and controls are fully distributed.
\end{enumerate}

\mySubSubSection{Some Partially Distributed WfMS}{}
\label{chap1:sec:partially-distributed-wfms}
\noindent\textbf{\textit{ADEPT (Advanced Decision Environment for Process Tasks) \cite{adept}}}

The ADEPT project was designed to automate flexible workflows at British Telecom\footnote{Nowadays British Telecom is renamed BT Group and remains the leader in the fixed telephony sector (source Wikipedia - \url{https://fr.wikipedia.org/wiki/BT_Group} - visited the 07/03/2020).}. Its main goal is to allocate resources to business processes using agents. According to its logic, workflow tasks are executed by agents acting as cooperating actors in a system supervised by one or more statically or dynamically assigned servers.
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.7]{./Chap1/images/adept.png}}
	\caption{An ADEPT environment (source \cite{adept}).}
	\label{chap1:fig:adept}
\end{figure}

Each agent is capable of providing one or more services. Services can be atomic (reduced to the execution of a single task) or composite (resulting from the combination of several other services, using operators that define the execution constraints - parallel, sequential, etc. -). If an agent needs the services of another agent, they must enter into an agreement called \textit{Service Level Agreement}\footnote{A Service Level Agreement is a formal contract used to guarantee that consumers' service quality expectation can be achieved \cite{wu2012service}.}. To facilitate the negotiation of agreements between agents, ADEPT provides a negotiation protocol and a service description language. Technically, the service description language allows agents to expose their services so that, they can be discovered by other agents which can then initiate negotiations for the use of those services, through the negotiation protocol.

Figure \ref{chap1:fig:adept} shows the architecture of ADEPT on an example of a workflow in which, four agents (marketing team, design team, sales team and legal department) collaborate to achieve business goals. Other publications on the ADEPT project may be useful for its understanding \cite{reichert1998adept, dadam2000clinical, reichert2003adept}.

~

\noindent\textbf{\textit{EvE (an Event-driven Distributed Workflow Execution Engine) \cite{eve}}}

According to the EvE approach, the distributed execution of workflows is done by event communication between agents (called \textit{brokers}) in charge of executing tasks. These agents perform tasks and create events in response to the occurrence of other events. EvE is based on a multi-server architecture in which, each server manages an entire cluster (a local network). However, this multi-server architecture is made transparent for the different agents thanks to \textit{adapters}; they can communicate independently of their respective domains. EvE provides amongst others the following services: 
\begin{itemize}
	\item Agents managed by servers and distributed across the network, capable of detecting events and executing tasks assigned to them; thereby, generating new events that are notified to other agents thanks to an inter-server communication mechanism that has been set up;
	\item A data warehouse in which information about agents, runtime data and \textit{Event - Condition - Action}\footnote{ECA is a paradigm that specifies the desired behaviour for reactive systems (i.e. systems that maintain ongoing interactions with their environments \cite{manna2012temporal}). In such a system centered around the ECA paradigm, when an event occurs, a condition is evaluated (by a querying mechanism) and the system takes corresponding action \cite{almeida2005modular}.} (ECA) event handling rules are stored. The information stored in the warehouse can be updated dynamically without the need to restart the system;
	\item Logging services for failure analysis and recovery. EvE supports exception notification, alerts and has the ability to resume execution after temporary disconnections;
\end{itemize}
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.6]{./Chap1/images/eve.png}}
	\caption{The workflow execution process in EvE (source \cite{eve}).}
	\label{chap1:fig:eve}
\end{figure}

The execution of a workflow starts as soon as an event is generated by a broker. The local EVE-server (its manager) then performs event detection and ECA-rule execution. Within the execution of each rule, task assignment determines responsible brokers, which are then notified and subsequently react as defined by their ECA-rules. Particularly, brokers can generate new events, which again are handled by EVE-servers, and so on transitively (see fig. \ref{chap1:fig:eve}).


\mySubSubSection{Some Fully Distributed WfMS}{}
\label{chap1:sec:fully-distributed-wfms}
\noindent\textbf{\textit{METEOR$_2$ (Managing End-To-End OpeRations 2) \cite{das1997orbwork, meteor}}}

The METEOR$_2$ project is a continuation of the METEOR \cite{krishnakumar1995managing} effort. It is intended to reliably support coordination of users and automated tasks in real-world multi-enterprise heterogeneous computing environments. Key capabilities of the METEOR$_2$ WfMS include a comprehensive toolkit for building workflows and supporting high-level process modelling, detailed workflow specification and automatic code generation for its workflow enactment systems. 
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.8]{./Chap1/images/meteor2.png}}
	\caption{The METEOR$_2$ architecture (source \cite{das1997orbwork}).}
	\label{chap1:fig:meteor2}
\end{figure}

METEOR$_2$ introduces concepts to represent each workflow as a set of tasks, task managers, processing entities and interfaces, in order to execute them in a completely distributed manner. Figure \ref{chap1:fig:meteor2} shows the various modules in METEOR$_2$ and their interaction. As can be seen in the picture, METEOR$_2$ includes a workflow designer that is used to create workflow models in a dedicated language. Once created, workflow models are stored in a workflow model repository. METEOR$_2$ also includes a workflow code generator that can read a stored workflow model and generate a convenient specific distributed workflow application. The generated application called the \textit{runtime system}, consists of a set of communicating agents called \textit{task managers} and their associated tasks, web-based user interfaces, a distributed recovery mechanism, a distributed scheduler and various monitoring components. All these workflow component are \textit{Common Object Request Broker Architecture}\footnote{CORBA is a standard middleware for distributed object systems. In its paradigm, a client application wishing to perform an operation on a server object, sends a request. The request is received by an Object Request Broker (ORB), responsible for all of the mechanisms required to find the object implementation for the request, to prepare the object implementation to receive the request, and to communicate the data making up the request to the server object. A server object accessible by CORBA is referred to as a CORBA object \cite{houlding2004system}.} (CORBA) objects and thus, they possess communication capabilities.

~

\noindent\textbf{\textit{The "Web Workflow Peer" Approach \cite{fakas04}}}

The approach proposed by Fakas and Karakostas is based on the concepts of \textit{Web Workflow Peer Directory} (WWPD) and \textit{Web Workflow Peer} (WWP). WWPD is an active directory system that maintains a list of all peers (WWP) that are available to participate in web workflow processes. It allows peers to register with the system and offer their services and resources to other peers. During the execution of workflow processes, the WWPD assists WWP to locate other WWP and use their services and resources. In their setting, key functionalities and data are distributed among WWP. The architecture is completely decentralised as no central workflow engine is employed to coordinate the process execution. The WWP encapsulates the necessary knowledge to perform the activities that are assigned to it and also to delegate some of the process execution to other WWP. The only centralised feature is the WWPD.
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.8]{./Chap1/images/wwp.png}}
	\caption{A P2P workflow architecture (source \cite{fakas04}).}
	\label{chap1:fig:wwp}
\end{figure}

A WWP is a processing unit with an interface that is exposed on the Web and which can be accessed using Internet protocols. Its interface describes different types of processing capabilities, each corresponding to a workflow activity. When combined, such activities form a workflow process. A WWP that initiates and administers the process is called the \textit{Administrator Peer}. Other WWP delegated to carry out workflow activities are called the \textit{Participating Peers} (see fig. \ref{chap1:fig:wwp}). In practice, all peers are capable of becoming administrators in different workflow process instances. WWP use mobile documents called \textit{Workflow Process Description} as communication medium. Segments of those documents move from site to site and conveys structural information about the running workflow instance.

Workflow process administration is achieved by employing a notification mechanism. For instance, at the completion of an activity the WWP notifies the Administrator Peer so that, an updated status of the process instance is maintained. Similarly, upon expiration of an activity deadline, the  Administrator Peer notifies the WWP responsible for the expired activity. As far as we know, there is still no real workflow system based on this promising architecture.


~

\noindent\textbf{\textit{SwinDeW (Swinburne Decentralised Workflow) \cite{junYan06}}}

Combining workflow and P2P concepts, SwinDeW \cite{junYan06} has been designed as a special P2P system, which provides workflow management support in a truly decentralised way. SwinDeW adopts a flat, flexible and loosely coupled structure with an intentional absence of both a centralised device for data storage, and a centralised control engine for coordination. SwinDeW offers several distributed protocols, especially for the definition, instantiation and execution of processes.
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.5]{./Chap1/images/swindew.png}}
	\caption{A high-level view of SwinDeW's architecture (source \cite{junYan06}).}
	\label{chap1:fig:swindew}
\end{figure}

The SwinDeW system is defined as four layers (see fig. \ref{chap1:fig:swindew}). The top layer is the application layer; it defines application-related functions to fulfil workflows. \textit{Workflow Participant Software} (WfPS) is an application that provides interfaces to interact with a workflow participant and other WfPS, requesting services and responding to requests. Core services of the workflow system are provided at the service layer, which include the peer management service, the process definition service, the process enactment service, and the monitoring and administration service. The data layer consists of distributed Data Repositories (DR) that store workflow-related information. Finally, the monitoring and administration service provides supervisory capabilities and status monitoring.

In SwinDeW, a peer is given by a WfPS and a set of DR (see fig. \ref{chap1:fig:swindew-wfps}). Each peer resides on a physical machine, enabling direct communication with other peers in order to carry out the workflow. A peer is a self-managing entity that is associated with and operates on behalf of a workflow participant. From the functional perspective, the WfPS of a peer consists of three software components :
\begin{enumerate}
	\item A user component which serves as  a "bridge" between the associated workflow participant and the workflow environment;
	\item A task component that is in charge of the execution of tasks conducted by the associated participant;
	\item A flow component which helps to fit an individual task into the workflow. It deals with data dependency and control dependency among tasks by handling incoming and outgoing messages.
\end{enumerate}
A peer (agent) consists also in a set of four DR : the peer repository, the resource and tool repository, the task repository, and the process repository.
\begin{enumerate}
	\item A given peer repository stores an organisational model that represents organisational entities and their relationships. This repository represents a user's view of the completely defined organisational model;
	\item A resource and tool repository stores part of the resource model, which represents non human resources such as machines, external hardware, tools, etc.
	\item A task repository stores a set of active task instances, which represent the work allocated to the associated workflow participant in the context of process instances;
	\item A process repository stores a partial process definition distributed to the considered peer.
\end{enumerate}
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.5]{./Chap1/images/swindew-wfps.png}}
	\caption{Structure of a peer in SwinDeW (source \cite{junYan06}).}
	\label{chap1:fig:swindew-wfps}
\end{figure}

Workflow processes in SwinDeW are defined by a definition peer, which is associated with an authorised participant such as a process engineer. The resulting workflow models are stored in a distributed manner, in the process repositories of various peers. To avoid the distribution of too large workflow models, SwinDeW uses a "\textit{know what you should know}" policy to partition these models and thus, to configure each peer only with the partitions of the models that are of interest to it.

In SwinDeW, a workflow instance is executed under the management of the workflow system. Once such an instance is created, a peer network is also constructed for carrying out this process instance. Various task instances are scheduled to enact at different sites, step by step. The execution of a task depends on the satisfaction of two conditions : the \textit{information condition}, which defines the start condition of a task from the data dependency
perspective (a task can be executed only after essential input data are available), and the \textit{control condition}, which indicates the start condition of a task from the control dependency perspective (a task can be executed only after some relevant work has been logically completed). Peers collaborate with one another through direct message exchange, to properly schedule the execution of various task instances. There are two kinds of messages flowing between peers: \textit{information messages} and \textit{control messages}, which are structured in XML format. When a peer receives messages from its predecessor peers directly, it evaluates the information and control conditions of the task instance independently, starts working when both the conditions are satisfied, and notifies its successor peers directly by delivering information messages and control messages after the task instance is completed. The successor peers repeat the same procedure until the completion of the whole process instance. This approach is then fully distributed; moreover, it has an implementation.

