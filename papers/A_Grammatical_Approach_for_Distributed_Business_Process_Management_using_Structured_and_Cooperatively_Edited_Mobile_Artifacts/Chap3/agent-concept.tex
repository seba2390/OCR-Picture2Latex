\mySection{Agent and choreography}{}
\label{chap3:sec:agents-and-choreography}

Now that we have formally defined the structure and the editing model of artifacts, let's focus on the structure of agents that oversee the execution of tasks and update the artifact accordingly, as well as on the artifact-centric choreography implemented between them. 

\mySubSection{Relations between Agent, Actor and Choreography}{}
\label{chap3:sec:agent-definition}
We borrowed the term \textit{agent} from \cite{lohmann2010artifact}. In the case of our study, an \textit{agent} (which we also call a \textit{peer}) is a software component, installed at a given site, piloted by a human agent called \textit{actor} (the tasks of the processes we handle are executed by humans) and capable of interacting with other agents by service invocation (message exchange). An agent is completely \textit{autonomous}: i.e. it encapsulates all the data and functions necessary for the execution of the tasks assigned to it, or precisely, tasks assigned to the actor piloting it. The agent is \textit{reactive}: it reacts in the same way to each message it receives by executing a well-defined protocol that goes from the analysis of the received message (artifact) to the possible transmission of other messages. As announced in the introduction, each message contains a collectively edited \textit{mobile artifact}. For the execution of a given process, the choreography is therefore a result of the messages (artifact replicas) exchanges between the agents involved and of the reaction of the latter to the reception of messages.

\mySubSection{Structure of an Agent}{}
\label{chap3:sec:agent-structure}

An agent is built to be able to fully manage the lifecycle (creation, storage, edition/execution) of a given business process' artifacts. Thus, an agent is made up of three major software components: a local workflow engine (LWfE), a specialised graphical editor and a storage device (see fig. \ref{chap3:fig:simplify-architecture-peer}).
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.45]{./Chap3/images/architectureSimplifieDUnPair.png}}
	\caption{Simplified architecture of an agent.}
	\label{chap3:fig:simplify-architecture-peer}
\end{figure}


\mySubSubSection{The Local Workflow Engine}{}
\label{chap3:sec:the-local-workflow-engine}

The local workflow engine (LWfE) is the main component of an agent. 
It receives messages from other agents and reacts by executing a well defined protocol (see sec. \ref{chap3:sec:the-protocols}). It communicates with the other agent's engines via its communication interface that exposes four services : two input services or \textit{provided services} (\textit{returnTo} and \textit{forwardTo}) connected to two corresponding output services or \textit{required services} (\textit{returnTo} and \textit{forwardTo}) so that: 

\begin{itemize}
	\item The invocation by an agent $j$ of the service \textit{forwardTo} offered by an agent $i$, causes on $i$, the execution of its corresponding input service \textit{forwardTo}. This service makes it possible to send a \textbf{request} from agent $j$ to agent $i$. The request contains the replica of the mobile artifact located on agent $j$. This artifact must contain buds to be completed (executed) by actor $A_i$ (the human agent piloting agent $i$). 
	\item The invocation by an agent $i$ of the service \textit{returnTo} offered by an agent $j$, causes the execution on $j$, of its corresponding input service \textit{returnTo}. This service allows agent $i$ to return the \textbf{response} to a request previously received from agent $j$. As the request, the response contains the replica of the mobile artifact located on agent $i$.
\end{itemize}


\mySubSubSection{The Storage Device}{}
\label{chap3:sec:the-storage-device}

A database (DB) of documents (a JSON\footnote{JavaScript Object Notation, \url{http://www.json.org}, \url{https://www.mongodb.com}, visited the 04/04/2020.} DB for example) is used by the LWfE to store an agent's configuration and data (especially artifacts) that it handles. 	
	
\mySubSubSection{The Specialised Editor}{}
\label{chap3:sec:the-specialised-editor}
	
Each agent provides a specialised editor (preferably WYSIWYG\footnote{What You See Is What You Get.}) that allows its actor (the pilot) to execute tasks. More precisely, the specialised editor allows the actor to view the tasks that are assigned to him, those ready to be executed, and when he has executed a task, it gives him the means to record an execution report. Any (editing) action carried out by the local actor via the specialised editor, causes the consistent update (as presented in section \ref{chap3:sec:artifact-edition}) of the mobile artifact local replica.

The specialised editor is particularly important as it guarantees controlled access to the artifact. Indeed, as announced in the introduction and following the steps of \cite{hull2009facilitating}, for reasons of confidentiality/security, actors do not necessarily have the right to access all information relating to the execution of a process in which they are involved. It is therefore important to provide a mechanism for regulating access to this information (stored in the artifact). In our case, we define this mechanism under the name \textit{accreditation} and we include it in the configuration of an agent in the same way as the GMWf of the studied process.


\mySubSection{Concepts of Accreditation, Partial Replica of an Artifact and Local GMWf}{}
\label{chap3:sec:accreditation-partial-replica}

\mySubSubSection{Concept of Accreditation}{}
\label{chap3:sec:accreditation}

Let's consider a process $\mathcal{P}_{op}$ and its GMWf $\mathbb{G}=\left(\mathcal{S},\mathcal{P},\mathcal{A}\right)$. The accreditation of an agent provides information on the rights (permissions) its actor has on each sort (task) of $\mathbb{G}$. 
To simplify, the nomenclature of rights manipulated here is inspired by the one used in Unix-like operating systems. Three types of accreditation are then defined: accreditation in reading \textit{(r)}, in writing \textit{(w)} and in execution \textit{(x)}. 
\begin{enumerate}
	\item \textit{Accreditation in reading \textit{(r)}}: when an agent is accredited in reading on a sort $X$, its actor has the right to know if the associated task is executed. Moreover, he can access its execution status.
	We call an agent's (actor's) \textbf{\textit{view}} the set of sorts on which it (he) is accredited in reading.
	\item \textit{Accreditation in writing \textit{(w)}}: when an agent is accredited in writing on a sort $X$, its actor can execute the associated task. 
	Note that a task can be executed only by exactly one actor: for a given sort, a single agent is accredited in writing; this is an important point of the model which guarantees the absence of execution conflicts. 
	Since the dedicated editors for "updating artifacts" are of type WYSIWYG (see sec. \ref{chap3:sec:the-specialised-editor}), any agent accredited in writing on a symbol must therefore be accredited in reading on it. 
	\item \textit{Accreditation in execution \textit{(x)}}: an agent accredited in execution on a sort $X$ is authorised to ask the agent which is accredited in writing on it, to execute it. Note that this request can be made without the agent being accredited in reading\footnote{In fact, as we will see later (sec. \ref{chap3:sec:the-protocols} (\textit{the diffusion protocol}, page \pageref{chap3:sec:execution-protocol-diffusion})), it is an automatic task (of the agent) that sends the execution request and not the actor.} on the considered sort.
\end{enumerate}

\noindent More formally, an accreditation is defined as follows:

\begin{definition} \label{defSyllabaire}
	An \textbf{accreditation} $\mathcal{A}_{A_i}$ defined on the set $\mathcal{S}$ of grammatical symbols for an agent $i$ piloted by an actor $A_i$, is a triplet $\mathcal{A}_{A_i}=\left(\mathcal{A}_{A_i(r)},\mathcal{A}_{A_i(w)},\mathcal{A}_{A_i(x)}\right)$ such that, 
	$\mathcal{A}_{A_i(r)} \subseteq \mathcal{S}$ also called \textbf{view} of $i$ (or \textbf{view} of $A_i$), is the set of symbols on which $i$ is accredited in reading, 
	$\mathcal{A}_{A_i(w)} \subseteq \mathcal{A}_{A_i(r)}$ is the set of symbols on which $i$ is accredited in writing and  
	$\mathcal{A}_{A_i(x)} \subseteq \mathcal{S}$ is the set of symbols on which $i$ is accredited in execution.
\end{definition}


The accreditations of various agents must be produced by the workflow designer just after modelling the scenarios in the form of target artifacts. From the task assignment for the peer-review process in the running example (see table \ref{tableau:tachesExecutant}), it follows that the accreditation in writing of the editor in chief is $\mathcal{A}_{EC(w)}=\{A, B, D\}$, that of the associated editor is $\mathcal{A}_{AE(w)}=\{C, E, F\}$ and that of the first (resp. the second) referee is $\mathcal{A}_{R_1(w)}=\{G1, H1, I1\}$ (resp. $\mathcal{A}_{R_2(w)}=\{G2, H2, I2\}$).
Even more, since the editor in chief can only perform the task $D$ if the task $C$ is already executed (see artifacts $art_1$ and $art_2$, fig. \ref{chap3:fig:global-artefacts}), in order for the editor in chief to be able to ask the associated editor to perform this task, it (the agent) must be accredited in execution on it; so we have $\mathcal{A}_{EC(x)}=\{C\}$.
Moreover, in order to be able to access all the information on the peer-review evaluation of a paper (task $C$) and to summarise the right decision to send to the author, the editor in chief must be able to consult the reports (tasks $I1$ and $I2$) and the messages (tasks $H1$ and $H2$) of the different referees, as well as the final decision taken by the associated editor (task $F$). These tasks, added to $\mathcal{A}_{EC(w)}$\footnote{Recall that in our case, we use WYSIWYG tools and therefore, one can only execute what he see.} constitute the set $\mathcal{A}_{EC(r)}=\mathcal{V}_{EC}=\{A, B, C, D, H1, H2, I1, I2, F\}$ of tasks on which, it is accredited in reading. By doing so for each of other agents, we deduce the accreditations represented in table \ref{tableau:vuesActeurs}.
\begin{table}[ht]
	\centering
	\caption{Accreditations of the different agents taking part in the peer-review process.}
	\label{tableau:vuesActeurs}
	\begin{tabular}[t]{|m{3.5cm}|m{10.3cm}|}
		\hline
		\textbf{Agent} & \textbf{Accreditation} \\
		\hline
		Editor in Chief ($EC$) & $\mathcal{A}_{EC}=\left(\{A, B, C, D, H1, H2, I1, I2, F\}, \{A, B, D\}, \{C\}\right)$ \\
		\hline
		Associated Editor ($AE$) & $\mathcal{A}_{AE}=\left(\{A, C, E, F, H1, H2, I1, I2\}, \{C, E, F\}, \{G1, G2\}\right)$ \\
		\hline
		First referee ($R1$) & $\mathcal{A}_{R1}=\left(\{C, G1, H1, I1\}, \{G1, H1, I1\}, \emptyset\right)$ \\
		\hline
		Second referee ($R2$) & $\mathcal{A}_{R2}=\left(\{C, G2, H2, I2\}, \{G2, H2, I2\}, \emptyset\right)$ \\
		\hline
	\end{tabular}
\end{table}

~

\noindent\textbf{\textit{In summary, what is the workflow model ?}}

To summarise, we state that in the artifact-centric model presented in this chapter, an administrative process $\mathcal{P}_{op}$ is completely specified using a triplet $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$ called \textit{a Grammatical Model of Administrative Workflow Process} (GMAWfP) and composed of: a GMWf, a list of actors (agents) and a list of their accreditations. 
The GMWf is used to describe all the tasks of the studied process and their scheduling, while the list of accreditations provides information on the role played by each actor involved in the process execution.  
A GMAWfP can then be formally defined as follows:
\begin{definition}
	\label{defMGSPWfA}
	A \textbf{Grammatical Model of Administrative Workflow Process} (GMAWfP) $\mathbb{W}_f$ for a given business process, is a triplet $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$
	wherein $\mathbb{G}$ is the studied process (global) GMWf, $\mathcal{L}_{P_k}$ is the set of $k$ agents taking part in its execution and $\mathcal{L}_{\mathcal{A}_k}$ represents the set of these agents' accreditations. 
\end{definition}


\mySubSubSection{Concept of Partial Replica of an Artifact}{}
\label{chap3:sec:partial-replica}

To effectively ensure that actors only have access to information of proven interest to them, each agent let them access only to a potentially partial replica $t_{\mathcal{V}_i}$ of the mobile artifact $t$. 
The $t$'s partial replicas are obtained by projections according to the views of each actor. 
A partial replica $t_{\mathcal{V}_i}$ of $t$ according to the \textit{view} $\mathcal{V}_{A_i} =  \mathcal{A}_{A_i(r)} $, is a partial copy of $t$ obtained by means of the so-called \textit{projection operator} denoted $\pi$ as presented below. 

Technically, the projection $t_{\mathcal{V}_i}$ of an artifact $t$ according to the view $\mathcal{V}_{i} = \mathcal{A}_{A_i(r)}$ is obtained by deleting in $t$ all nodes whose types do not belong to $\mathcal{V}_{i}$. In our case, the main challenges in this operation are:
\begin{enumerate}
	\item[\textbf{(1)}] nodes of $t_{\mathcal{V}_i}$ must preserve the previously existing execution order between them in $t$,
	\item[\textbf{(2)}] $t_{\mathcal{V}_i}$ must be build by using exclusively the only two forms of production retained for GMWf and
	\item[\textbf{(3)}] $t_{\mathcal{V}_i}$ must be unique in order to ensure the continuation of process execution (see sec. \ref{chap3:sec:the-protocols}).
\end{enumerate}

The projection operation is noted $\pi$. Inspired by the one proposed in \cite{badouelTchoupeCmcs}, it projects an artifact by preserving the hierarchy (father-son relationship) between nodes of the artifact (it thus meets challenge \textbf{(1)}); but in addition, it inserts into the projected artifact when necessary, new additional \textit{(re)structuring symbols } (accessible in reading and writing by the agent for whom the projection is made). This enables it to meet challenge \textbf{(2)}. The details of how to accomplish the challenge \textbf{(3)} are outlined immediately after the algorithm (algorithm \ref{chap3:algo:artifact-projection}) is presented.
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.35]{./Chap3/images/docEtRepliques.png}}
	\caption{Example of projections made on an artifact and partial replicas obtained.}
	\label{chap3:fig:partial-replicas}
\end{figure}

Figure \ref{chap3:fig:partial-replicas} illustrates the projection of an artifact of the peer-review process relatively to the $R1$ (first referee) and $EC$ (Editor in Chief) agent views. Note the presence in $t_{\mathcal{V}_{EC}}$ of new (re)structuring symbols (in gray). These last ones make it possible to avoid introducing in $t_{\mathcal{V}_{EC}}$, the production $p: C \rightarrow H1 \fatsemi I1 \parallel H2 \fatsemi I2 \fatsemi F$ whose form does not correspond to the two forms of production retained for the GMWf writing\footnote{Note that this production specifies in its right-hand side that we must have parallel and sequential treatments.
Inserting $S1$, $S2$ and $S3$ allows to rewrite $p$ in four productions $p1: C \rightarrow S1 \fatsemi F$, $p2: S1 \rightarrow S2 \parallel S3$, $p3: S2 \rightarrow H1 \fatsemi I1$ and $p4: S3 \rightarrow H2 \fatsemi I2$.}.

~

\noindent\textbf{\textit{The algorithm}}

Let's consider an artifact $t$ and note by $n=X\left[t_1,\ldots,t_m\right]$ a node of $t$ labelled with the symbol $X$ and having $m$ sub-artifacts $t_1,\ldots,t_m$. Note also by $p_n$, the production of the GMWf that was used to extend node $n$; the type of $p_n$ is either \textit{sequential} (i.e. $p_n: X \rightarrow X_1 \fatsemi \ldots \fatsemi X_m$ where $X_1,\ldots,X_m$ are the roots of the sub-artifacts $t_1,\ldots,t_m$) or \textit{parallel} ($p_n: X \rightarrow X_1 \parallel \ldots \parallel X_m$). 
Concretely, to project $t$ according to a given view $\mathcal{V}$ (i.e to find $\mathit{projs_t}=\pi_{\mathcal{V}}\left(t \right)$), the recursive processing presented in algorithm \ref{chap3:algo:artifact-projection}, is applied to the root node $n=X\left[t_1,\ldots,t_m\right]$ of $t$.

\begin{algorithm}
\small
\caption{Algorithm to project a given artifact according to a given view.}
\label{chap3:algo:artifact-projection}
\begin{mdframed}[style=MyFrame]
	%\begin{itemize}[leftmargin=*]
	{\large\textbullet} $~$ \textbf{If symbol $X$ is visible ($X \in \mathcal{V}$)} then :
	%\begin{enumerate}[leftmargin=*]
	
	\textbf{1.}$~$ $n$ is kept in the artifact;
	
	\textbf{2.}$~$ For each sub-artifact $t_i$ of $n$, having node $n_i=X_i\left[t_{i_1},\ldots,t_{i_k}\right]$ as root (of which $p_{n_i}$ is the production that was used to extend it), the following processing is applied :
	%\begin{itemize}[leftmargin=*]
	
	$~~$\textbf{a.}$~$ The projection of $t_i$ according to $\mathcal{V}$ is done. We obtain the list $\mathit{projs_{t_i}} = \pi_{\mathcal{V}}\left(t_i \right) = \left\{t_{i_{\mathcal{V}_1}},\ldots,t_{i_{\mathcal{V}_l}}\right\}$;
	
	$~~~~$\textbf{b.}$~$ If the type of $p_{n_i}$ is the same as the type of $p_{n}$ or the projection of $t_i$ has produced no more than one artifact ($\left|\mathit{projs_{t_i}}\right| \leq 1$), we just replace $t_i$ by artifacts $t_{i_{\mathcal{V}_1}},\ldots,t_{i_{\mathcal{V}_l}}$ of the list $\mathit{projs_{t_i}}$;
	
	$~~~~$ Otherwise, a new (re)structuring symbol $S_i$ is introduced and we replace the sub-artifact $t_i$ with a new artifact $new\_t_i$ whose root node is $n_{t_i}=S_i\left[t_{i_{\mathcal{V}_1}},\ldots,t_{i_{\mathcal{V}_l}}\right]$;
	%\end{itemize}
	
	\textbf{3.}$~$ If the list of new sub-artifacts of $n$ contains only one element $t_1$ having $n_1=S_1\left[t_{1_{\mathcal{V}_1}},\ldots,t_{1_{\mathcal{V}_l}}\right]$ (with $S_1$ a newly created (re)structuring symbol) as root node, we replace in this one, $t_1$ by the sub-artifacts $t_{1_{\mathcal{V}_1}},\ldots,t_{1_{\mathcal{V}_l}}$ of $n_1$. This removes a non-important (re)structuring symbol $S_1$.
	%\end{enumerate}
	
	\noindent{\large\textbullet} $~$ \textbf{Else}, $n$ is deleted and the result of the projection ($\mathit{projs_t}$) is the union of the projections of each of its sub-artifacts: $\mathit{projs_t} = \pi_{\mathcal{V}}\left(t \right) = \bigcup^{m}_{i=1} \pi_{\mathcal{V}}\left(t_i \right)$
	%\end{itemize}
\end{mdframed}
\end{algorithm}

Note that the algorithm described here can return several artifacts (a forest). To avoid that it produces a forest in some cases and thus meet challenge \textbf{(3)}, we make the following assumption: 
\begin{displayquote}
\textit{GMAWfP manipulated in this work are such that all agents are accredited in reading on the GMWf axioms (\textbf{axioms' visibility assumption}).}
\end{displayquote}
The designer must therefore ensure that all agents are accredited in reading on all GMWf axioms. To do this, after modelling a process $\mathcal{P}_{op}$ and obtaining its GMWf $\mathbb{G}=\left(\mathcal{S},\mathcal{P},\mathcal{A}\right)$, it is sufficient (if necessary) to create a new axiom $A_{\mathbb{G}}$ on which, all actors will be accredited in reading, and to associate it with new unit productions\footnote{A production of a context free grammar is a \textit{unit production} if it is on the form $A \rightarrow B$, where $A$ and $B$ are non-terminal symbols.} $pa : A_{\mathbb{G}} \rightarrow X_a$ where, $X_a \in \mathcal{A}$ is a symbol labelling the root of a target artifact.
Moreover, the designer of the GMWf must statically choose the agent responsible for initiating the process. This agent will therefore be the only one to possess an accreditation in writing on the new axiom $A_{\mathbb{G}}$.

\begin{proposition}
	\label{propositionStabiliteProjArt}
	For all GMAWfP $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$ verifying the axioms' visibility assumption, the projection of an artifact $t$ which is conform to its GMWf ($t \therefore \mathbb{G}$) according to a given view $\mathcal{V}$, results in a single artifact $t_{\mathcal{V}}=\pi_{\mathcal{V}} \left(t\right)$ (stability property of $\pi$).
\end{proposition}

\begin{proof}
	Let's show that $\pi_{\mathcal{V}} \left(t\right)$ produces a single tree $t_{\mathcal{V}}$ which is an artifact. 
	Note that the only case in which the projection of an artifact $t$ according to a view $\mathcal{V}$ produces a forest, is when the root node of $t$ is associated with an invisible symbol $X$ ($X \notin \mathcal{V}$). Knowing that $t \therefore \mathbb{G}$ and that $\mathbb{W}_f$ validates the axioms' visibility assumption, it is deduced that the root node of $t$ is labelled by one of the axioms $A_{\mathbb{G}}$ of $\mathbb{G}$ and that $A_{\mathbb{G}} \in \mathcal{V}$ (hence the uniqueness of the produced tree). Since the projection operation preserves the form of productions, it is concluded that $t_{\mathcal{V}}=\pi_{\mathcal{V}} \left(t\right)$ is an artifact.
\end{proof}

A Haskell implementation of this projection algorithm is introduced in appendix \ref{appendice1:algorithms-implementations} of this manuscript. Another implementation in Java has also been proposed and integrated into the prototype that we will present in section \ref{chap3:sec:p2ptinywfms} of this chapter.


\mySubSubSection{The Need of a Local GMWf}{}
\label{chap3:sec:local-gmwf}
Since the artifact copy manipulated at a specific site is a potentially partial replica of the mobile (global) artifact, and since its editing depends on the agent's perception (view) of the process, it becomes crucial to provide each agent with a local GMWf. The latter will serve in addition to preserve the possible confidentiality of certain tasks and data, to guide the local actions of updating the artifact in order to ensure the convergence of the system to a coherent business goal state.
The local GMWf of an agent can be derived by projecting the global GMWf $\mathbb{G}$ according to the view $\mathcal{V}_i$ of its pilot (\textbf{\textit{GMWf projection}}). This projection is carried out using $\Pi$ operator and the GMWf obtained is noted $\mathbb{G}_{\mathcal{V}_i}=\Pi_{\mathcal{V}_i}\left(\mathbb{G}\right)$.

~

\noindent\textbf{\textit{A naive algorithm for non-recursive GMWf projection}}

The goal of this algorithm is to derive by projection of a given GMWf $\mathbb{G}=\left(\mathcal{S},\mathcal{P},\mathcal{A}\right)$ according to a view $\mathcal{V}$, a local GMWf $\mathbb{G}_{\mathcal{V}} = \left(\mathcal{S}_{\mathcal{V}},\mathcal{P}_{\mathcal{V}}, \mathcal{A}_{\mathcal{V}}\right)$ (we note $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$). The proposed algorithm is algorithm \ref{chap3:algo:gmwf-projection}.

\begin{algorithm}
\small
\caption{Algorithm to project a given GMWf according to a given view.}
\label{chap3:algo:gmwf-projection}
\begin{mdframed}[style=MyFrame]
	
	\noindent\textbf{1.}$~$ First of all, it is necessary to generate all the target artifacts denoted by $\mathbb{G}$ (see note (1) below); 
	we thus obtain a set $arts_{\mathbb{G}}=\left\{t_1,\ldots,t_n\right\}$;
	
	\noindent\textbf{2.}$~$ Then, each of the target artifacts must be projected according to $\mathcal{V}$. We thus obtain a set $arts_{\mathbb{G}_{\mathcal{V}}} = \left\{t_{\mathcal{V}_1},\ldots,t_{\mathcal{V}_m}\right\}$ (with $m \leq n$ because there may be duplicates; %\footnote{Deux artefacts cibles différents peuvent avoir la même projection suivant une vue $\mathcal{V}$ donnée.}; 
	in this case, only one copy is kept) of artifacts partial replicas;
	
	\noindent\textbf{3.}$~$ Then, collect the different (re)structuring symbols appearing in artifacts of $arts_{\mathbb{G}_{\mathcal{V}}}$, making sure to remove duplicates (see note (2) below) 
	and to consequently update the artifacts and the set $arts_{\mathbb{G}_{\mathcal{V}}}$. We thus obtain a set $\mathcal{S}_{\mathcal{V}_{Struc}}$ of symbols and a final set $arts_{\mathbb{G}_{\mathcal{V}}} = \left\{t_{\mathcal{V}_1},\ldots,t_{\mathcal{V}_l}\right\}$ (with $l \leq m$) of artifacts. These are exactly the only ones that must be conform to the searched GMWf $\mathbb{G}_{\mathcal{V}}$. So we call them, \textit{local target artifacts for the view $\mathcal{V}$};
	
	\noindent\textbf{4.}$~$ At this stage, it is time to collect all the productions that made it possible to build each of the \textit{local target artifacts for the view $\mathcal{V}$}. We obtain a set $\mathcal{P}_{\mathcal{V}}$ of distinct productions.\\
	\textbf{The searched local GMWf $\mathbb{G}_{\mathcal{V}} = \left(\mathcal{S}_{\mathcal{V}},\mathcal{P}_{\mathcal{V}}, \mathcal{A}_{\mathcal{V}}\right)$ is such as}:
	%\begin{itemize}
	
	$~~$\textbf{a.}$~$ its set of symbols is $\mathcal{S}_{\mathcal{V}} = \mathcal{V} \cup \mathcal{S}_{\mathcal{V}_{Struc}}$;
	
	$~~$\textbf{b.}$~$ its set of productions is $\mathcal{P}_{\mathcal{V}}$;
	
	$~~$\textbf{c.}$~$ its axioms are in $\mathcal{A}_{\mathcal{V}} = \mathcal{A}$
	%\end{itemize}
	%\end{enumerate}
	
	~
	
	\noindent\textit{\textbf{Note (1):}$~$ To generate all the target artifacts denoted by a GMWf $\mathbb{G}=\left(\mathcal{S},\mathcal{P},\mathcal{A}\right)$, one just has to use the set of productions to generate the set of artifacts having one of the axiom $A_{\mathbb{G}}\in \mathcal{A}$ as root. In fact, for each axiom $A_{\mathbb{G}}$, it should be considered that every $A_{\mathbb{G}}$-production $P=\left(A_{\mathbb{G}},X_1\cdots X_n\right)$ induces artifacts $\left\{t_1, \ldots, t_m\right\}$ such as: the root node of each $t_i$ is labelled $A_{\mathbb{G}}$ and has as its sons, a set of artifacts $\left\{t_{i_1},\ldots,t_{i_n}\right\}$, part of the Cartesian product of the sets of artifacts generated when considering each symbol $X_1,\cdots, X_n$ as root node.}
	
	\noindent\textit{\textbf{Note (2):}$~$ In this case, two (re)structuring symbols are identical if for all their appearances in nodes of the different artifacts of $arts_{\mathbb{G}_{\mathcal{V}}}$, they induce the same local scheduling.}
\end{mdframed}
\end{algorithm}

Figure \ref{chap3:fig:gmwf-projection} illustrates the research of a local model $\mathbb{G}_{\mathcal{V}_{EC}}$ such as $\mathbb{G}_{\mathcal{V}_{EC}} = \Pi_{\mathcal{V}_{EC}}\left(\mathbb{G}\right)$ with $\mathcal{V}_{EC}=\mathcal{A}_{EC(r)}=\{A, B, C, D, H1, H2, I1, I2, F\}$. Target artifacts generated from $\mathbb{G}$ (fig. \ref{chap3:fig:gmwf-projection}(b)) are projected to obtain two \textit{local target artifacts for the view $\mathcal{V}_{EC}$} (fig. \ref{chap3:fig:gmwf-projection}(c)). 
From the local target artifacts thus obtained, the searched GMWf is produced (fig. \ref{chap3:fig:gmwf-projection}(d)).
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.3]{./Chap3/images/projectionMGWf.png}}
	\caption{Example of projection of a GMWf according to a given view.}
	\label{chap3:fig:gmwf-projection}
\end{figure}

The GMWf projection algorithm presented here only works for GMWf that do not allow recursive symbols\footnote{It is only in this context that all the target artifacts can be enumerated.}. We therefore assume that:
\begin{displayquote}
\textit{For the execution model presented in this chapter, the manipulated GMAWfP are those whose GMWf do not contain recursive symbols (\textbf{non-recursive GMWf assumption})}.
\end{displayquote} 
Therefore, it is no longer possible to express iterative routing between process tasks (in the general case); except in cases where the maximum number of iterations is known in advance. This algorithm has some interesting properties and the interested reader will find an introduction to its Haskell implementation in appendix \ref{appendice1:algorithms-implementations}.

\begin{proposition}
	\label{propositionStabiliteProjGMWf}
	For all GMAWfP $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$ verifying the axioms' visibility and the non-recursivity of GMWf assumptions, the projection of its GMWf $\mathbb{G}=\left(\mathcal{S},\mathcal{P},\mathcal{A}\right)$ according to a given view $\mathcal{V}$, is a GMWf $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$ for a GMAWfP $\mathbb{W}_{f_{\mathcal{V}}}$ verifying the assumptions of axiom visibility and non-recursivity of GMWf (stability property of $\Pi$).
\end{proposition}

\begin{proof}
	Let's show that $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$ is a GMWf for a new GMAWfP $\mathbb{W}_{f_{\mathcal{V}}}=\left(\mathbb{G}_{\mathcal{V}}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_{\mathcal{V}_k}} \right)$ that verifies the assumptions of axioms' visibility and non-recursivity of GMWf. 
	As $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$ validates the non-recursivity of GMWf assumption, the set of target artifacts ($arts_{\mathbb{G}}=\left\{t_1,\ldots,t_n\right\}$) that it denotes is finite and can therefore be fully enumerated. Knowing further that $\mathbb{W}_f$ validates the axioms' visibility assumption, it is deduced that the set $arts_{\mathbb{G}_{\mathcal{V}}} = \left\{t_{\mathcal{V}_1}=\pi_{\mathcal{V}}\left(t_1\right), \ldots,t_{\mathcal{V}_n}=\pi_{\mathcal{V}}\left(t_n\right)\right\}$ is finite and the root node of each artifact $t_{\mathcal{V}_i}$ is associated with an axiom $A_{\mathbb{G}} \in \mathcal{A}$ (see proposition \ref{propositionStabiliteProjArt}). $\mathbb{G}_{\mathcal{V}}$ being built from the set $arts_{\mathbb{G}_{\mathcal{V}}}$, its axioms $\mathcal{A}_{\mathcal{V}}=\mathcal{A}$ are visible to all actors and its productions are only of the two forms retained for GMWf. In addition, each new (re)structuring symbol ($S \in \mathcal{S}_{\mathcal{V}_{Struc}}$)) is created and used only once to replace a symbol that is not visible and not recursive (by assumption) when projecting artifacts of $arts_{\mathbb{G}}$. The new symbols are therefore not recursive. By replacing in $\mathcal{L}_{\mathcal{A}_k}$ the view $\mathcal{V}$ by $\mathcal{V} \cup \mathcal{S}_{\mathcal{V}_{Struc}}$, one obtains a new set $\mathcal{L}_{\mathcal{A}_{\mathcal{V}_k}}$ of accreditations for a new GMAWfP $\mathbb{W}_{f_{\mathcal{V}}}=\left(\mathbb{G}_{\mathcal{V}}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_{\mathcal{V}_k}} \right)$ verifying the assumptions of axioms' visibility and non-recursivity of GMWf.
\end{proof}


\begin{proposition}
	\label{propositionCoherenceArtefact}
	For all GMAWfP $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$ verifying the axioms' visibility and the non-recursivity of GMWf assumptions, the projection of an artifact $t$ which is conform to the GMWf $\mathbb{G}$ according to a given view $\mathcal{V}$, is an artifact which is conform to the projection of $\mathbb{G}$ according to $\mathcal{V}$ $\left(\forall t, ~t \therefore \mathbb{G} \Rightarrow \pi_{\mathcal{V}}\left(t\right) \therefore \Pi_{\mathcal{V}}\left(\mathbb{G} \right)\right)$.
\end{proposition}

\begin{proof}
	Knowing that the considered GMAWfP $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$ verifies the axioms' visibility and the non-recursivity of GMWf assumptions, it is deduced that the set of its target artifacts $arts_{\mathbb{G}}$ (those who helped to build its GMWf $\mathbb{G}$) is finite and any artifact that is conform to its GMWf $\mathbb{G}$ is a target artifact $\left( \forall t, ~t \therefore \mathbb{G} \Leftrightarrow t \in arts_{\mathbb{G}} \right)$. Therefore, considering a given artifact $t$ such that $t$ is conform to $\mathbb{G}$ ($t \therefore \mathbb{G}$), one knows that it is a target artifact ($t \in arts_{\mathbb{G}}$) and its projection according to a given view $\mathcal{V}$ produces a single artifact $t_{\mathcal{V}}=\pi_{\mathcal{V}}\left(t\right)$ (see "stability property of $\pi$", proposition \ref{propositionStabiliteProjArt}) such as $t$ and $t_{\mathcal{V}}$ have the same root (one of the axioms $A_{\mathbb{G}} \in \mathcal{A}$ of $\mathbb{G}$). Since $t$ is a target artifact, its projection $t_{\mathcal{V}}$ (through the renaming of some potential (re)structuring symbols) is part of the set $arts_{\mathbb{G}_{\mathcal{V}}}$ of artifacts that have generated $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$ by applying the projection principle described in the algorithm \ref{chap3:algo:gmwf-projection}. Therefore, the productions involved in the construction of $t_{\mathcal{V}}$ are all included in the set of productions of the GMWf $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$. As the set of axioms of $\mathbb{G}_{\mathcal{V}}$ is $\mathcal{A}_{\mathcal{V}} = \mathcal{A}$, it is deduced that $A_{\mathbb{G}} \in \mathcal{A}_{\mathcal{V}}$ and concluded that $t_{\mathcal{V}} \therefore \mathbb{G}_{\mathcal{V}}$.
\end{proof}

\begin{proposition}
	\label{propositionReciproqueCoherenceArtefact}
	Consider a GMAWfP $\mathbb{W}_f=\left(\mathbb{G}, \mathcal{L}_{P_k}, \mathcal{L}_{\mathcal{A}_k} \right)$ verifying the axioms' visibility and the non-recursivity assumptions. For all artifact $t_{\mathcal{V}}$ which is conform to $\Pi_{\mathcal{V}}\left(\mathbb{G} \right)$, it exists at least one artifact $t$ which is conform to $\mathbb{G}$ such that $t_{\mathcal{V}}=\pi_{\mathcal{V}}\left(t\right)$ $\left(\forall t_{\mathcal{V}}, ~t_{\mathcal{V}} \therefore \Pi_{\mathcal{V}}\left(\mathbb{G} \right) \Rightarrow \exists t, ~t \therefore \mathbb{G} ~and~ t_{\mathcal{V}}=\pi_{\mathcal{V}}\left(t\right) \right)$.
\end{proposition}

\begin{proof}
	With proposition \ref{propositionStabiliteProjGMWf} ("stability property of $\Pi$") it has been shown that the projection $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$ according to the view $\mathcal{V}$ of a GMWf $\mathbb{G}$ verifying the axioms' visibility and the non-recursivity assumptions, is a GMWf verifying the same assumptions. On this basis and using similar reasoning to that used to prove the proposition \ref{propositionCoherenceArtefact}, it's been determined that an artifact $t_{\mathcal{V}}$ that is conform to $\mathbb{G}_{\mathcal{V}}$, is one of its target artifacts (\textit{local target artifact for the view $\mathcal{V}$}): i.e, $t_{\mathcal{V}} \in arts_{\mathbb{G}_{\mathcal{V}}}$. Referring to the projection process which made it possible to obtain $\mathbb{G}_{\mathcal{V}}$, it is determined that the set $arts_{\mathbb{G}_{\mathcal{V}}}$ is exclusively made up of the projections of the set $arts_{\mathbb{G}}=\left\{t_1,\ldots,t_n\right\}$ of $\mathbb{G}$'s target artifacts. $t_{\mathcal{V}}$ is therefore the projection of at least one target artifact $t_i \in arts_{\mathbb{G}}$ of $\mathbb{G}$ $\left(t_{\mathcal{V}}=\pi_{\mathcal{V}}\left(t_i\right)\right)$. Knowing that $\forall t, ~t \therefore \mathbb{G} \Leftrightarrow t \in arts_{\mathbb{G}}$ (see proof of proposition \ref{propositionCoherenceArtefact}), it is deduced that $t_i \therefore \mathbb{G}$ and the proof of this proposition is made.
\end{proof}


By applying the GMWf projection algorithm presented above to the running example, one obtain the productions listed in table \ref{tableau:gramLocales} for the different agents respectively. Let us note that this algorithm simply project each target artifact according to the view of the considered agent, then gather the productions in the obtained partial replicas while removing the duplicates. In the illustrated case here, we have considered an update of the GMWf of the peer-review process so that it validates the axioms' visibility assumption (see sec. \ref{chap3:sec:partial-replica}).
\begin{table}[h]
	\centering
	\caption{Local GMWf productions of all the agents involved in the peer-review process.}
	\label{tableau:gramLocales}
	\begin{tabular}[t]{|m{3.5cm}|m{10.5cm}|}
		\hline
		\textbf{Agent} & \textbf{Productions of local GMWf} \\
		\hline
		Editor in Chief ($EC$) &
		\[ 
		\begin{array}{l|l|l}
		P_{1}:\; A_{\mathbb{G}}\rightarrow A & \; P_{2}:\; A\rightarrow B\fatsemi D\; & \; P_{3}:\; A\rightarrow C\fatsemi D  \\
		P_{4}:\; C\rightarrow S1\fatsemi F & \; P_{5}:\; S1\rightarrow S2\parallel S3\; & \; P_{6}:\; S2\rightarrow H1 \fatsemi I1  \\
		P_{7}:\; S3\rightarrow H2 \fatsemi I2 & \; P_{8}:\; B\rightarrow \varepsilon\; & \; P_{9}:\; D\rightarrow \varepsilon \\
		P_{10}:\; F\rightarrow \varepsilon & \; P_{11}:\; H1\rightarrow \varepsilon\; & \; P_{12}:\; I1\rightarrow \varepsilon  \\
		P_{13}:\; H2\rightarrow \varepsilon & \; P_{14}:\; I2\rightarrow \varepsilon \; &   \\
		\end{array}
		\]
		\\
		\hline
		Associated Editor ($AE$) & 
		\[ 
		\begin{array}{l|l|l}
		P_{1}:\; A_{\mathbb{G}}\rightarrow A & \; P_{2}:\; A\rightarrow C \; & \; P_{3}:\; C\rightarrow E\fatsemi F  \\
		P_{4}:\; E\rightarrow S1\parallel S2 & \; P_{5}:\; S1\rightarrow H1\fatsemi I1 \; & \; P_{6}:\; S2\rightarrow H2\fatsemi I2  \\
		P_{7}:\; H1\rightarrow \varepsilon & \; P_{8}:\; I1\rightarrow \varepsilon \; & \; P_{9}:\; H2\rightarrow \varepsilon \\
		P_{10}:\; I2\rightarrow \varepsilon & \; P_{11}:\; F\rightarrow \varepsilon \; & \; P_{12}:\; A_{\mathbb{G}}\rightarrow \varepsilon \\
		\end{array}
		\]
		\\
		\hline
		First referee ($R1$) & 
		\[ 
		\begin{array}{l|l|l}
		P_{1}:\; A_{\mathbb{G}}\rightarrow C & P_{2}:\; C\rightarrow G1\; & \; P_{3}:\; G1\rightarrow H1\fatsemi I1 \\
		P_{4}:\; H1\rightarrow \varepsilon & P_{5}:\; I1\rightarrow \varepsilon \; & \; P_{6}:\; A_{\mathbb{G}}\rightarrow \varepsilon \\
		\end{array}
		\]
		\\
		\hline
		Second referee ($R2$) & 
		\[ 
		\begin{array}{l|l|l}
		P_{1}:\; A_{\mathbb{G}}\rightarrow C & P_{2}:\; C\rightarrow G2\; & \; P_{3}:\; G2\rightarrow H2\fatsemi I2 \\
		P_{4}:\; H2\rightarrow \varepsilon & P_{5}:\; I2\rightarrow \varepsilon \; & \; P_{6}:\; A_{\mathbb{G}}\rightarrow \varepsilon \\
		\end{array}
		\]
		\\
		\hline
	\end{tabular}
\end{table}



\mySubSection{The Artifact-Centric Choreography}{}
\label{chap3:sec:execution-model}

In this section, we are interested in the actual execution of a process $\mathcal{P}_{op}$ whose GMWf is $\mathbb{G}=\left(\mathcal{S},\mathcal{P},\mathcal{A}\right)$.

\mySubSubSection{Initial Configuration of an Agent}{}
\label{chap3:sec:initial-configuration-of-a-peer}

Each agent $i$ taking part in the choreography, has a single identifier (its ID). For a proper execution, it manages a local copy of the process' global GMWf $\mathbb{G}$, accreditations of various agents involved and its local GMWf $\mathbb{G}_{i}$. In addition, it handles a list $RET_i$ of agents who have made requests and whose answers are yet to be sent, as well as two queues: $REQ_i$ which stores requests waiting to be executed, and $ANS_i$ which temporally stores answers received from agents to which requests were previously made. A local copy $t_i$ of the mobile artifact and its (potentially partial) replica $t_{\mathcal{V}_{i}}$ are also handled by agent $i$.


\mySubSubSection{The Execution Choreography and Agent's Behaviour}{}
\label{chap3:sec:architecture-of-a-peer}
The execution of an instance of the process is triggered when an artifact $t$ is introduced into the system (on the appropriate agent); this artifact is in fact an unlocked bud of the type of one axiom $A_\mathbb{G} \in \mathcal{A}$ (initial task) of the (global) GMWf $\mathbb{G}$.

An artifact that arrives on a given agent is either a request or a response to a request; depending on the case, it is inserted in the appropriate queue ($REQ_i$ or $ANS_i$).
As soon as possible\footnote{For instance at the end of the local replica completion or after a given time interval.}, the artifact is removed from the queue, merged with the local copy (if it exists) and is then completed as needed.
Completing an artifact consists of executing in a coherent way, the various tasks it imposes, i.e. those on which the current agent is accredited in writing.

At the end of the completion on an artifact, if its configuration shows that it must be completed by other agents (this is the case if the artifact contains buds created by the current agent and whose agent accredited in writing, are remote), replicas of the artifact are sent to the said agents by invoking the service \textit{forwardTo}.
Otherwise, the artifact is complete (it contains no more buds), or semi-complete (it contains buds that had been created by other agents and on which, the current agent is not accredited in writing); in which case, a replica is returned to the agent from which the artifact was previously received by invoking the service \textit{returnTo}.


The execution of the process ends when all the tasks constituting a scenario of the process have been executed. In this case, the artifact that is cooperatively edited is complete (closed) on the agent where the process was triggered.



\mySubSubSection{The Protocols}{}
\label{chap3:sec:the-protocols}

The activity that takes place on an agent in relation to the handling of a given artifact, breaks down into five sub-activities (see fig. \ref{chap3:fig:peer-architecture}); each of them is managed by a dedicated protocol. These activities are the following: 

\begin{itemize}
	\item \textit{creation} (initialisation of a new case) or \textit{receipt-merger} of a replica.
	\item \textit{replication}: it consists in the extraction (from the local replica) of the partial replica that the local agent has to complete (manage its execution).
	\item \textit{execution}: it consists in the extension by the local actor (via the specialised editor) of the buds for which he is accredited in writing.
	\item \textit{expansion-pruning}: it consists in the reconstruction by expansion of the local (global) replica from the updated local partial replica.
	\item \textit{diffusion}: it corresponds to the return of the response to a request, or to the sending of requests.
\end{itemize}
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.28]{./Chap3/images/architecturePair.png}}
	\caption{Activity of an agent in the system.}
	\label{chap3:fig:peer-architecture}
\end{figure}

The management protocols for these different activities are described in the following paragraphs.

~

\noindent\textbf{\textit{The Receipt-Merger Protocol}}

An artifact is received either when a new case is initialised or after a request or a response is delivered. In all cases, a merge using an adaptation of the algorithm in \cite{badouelTchoupeCmcs} is performed. The goal in this step is to update the local copy $t_i$ of the global artifact from those received (the $(t^{maj}_j)_{1 \leq j \neq i \leq k}$ contained in queues $REQ_i$ and $ANS_i$). 
For that purpose (see algorithm \ref{algorithmeFusion}), we merge $t_i$ with each artifact $t^{maj}_j$ from the requests queue (algorithm \ref{algorithmeFusion}, lines 2 to 6) and from the responses queue (algorithm \ref{algorithmeFusion}, lines 7 to 10) until they are empty. 
At each merge, $t_i$ is updated (algorithm \ref{algorithmeFusion}, lines 3 and 8). 
For each received request, the identity of the sender is kept in the list $RET_i$ (algorithm \ref{algorithmeFusion}, line 5) to be able to return a response at the end of the request processing.
Note that during the merge, some previously locked buds can be unlocked: this is the case if all the tasks that precede them have been executed.

\begin{algorithm}
\small
\caption{Merger protocol executed by an agent $i$.\label{algorithmeFusion}}
\begin{algorithmic}[1]
	\Procedure{Merger}{}
		\For{$req : REQ_i$}\Comment{While there is a request}
			\State $t_i \gets merge(t_i,~\textrm{\textit{req.artifact}})$\Comment{We merge the artifact of the request with $t_i$}
			\State delete $req$ from $REQ_i$
			\State $enqueue(req.sender,~RET_i)$\Comment{And we add the request sender in $RET_i$ queue}
		\EndFor
		\For{$ans : ANS_i$}
			\State $t_i \gets merge(t_i,~\textrm{\textit{ans.artifact}})$\Comment{We merge the artifact of the answer with $t_i$}
			\State delete $ans$ from $ANS_i$
		\EndFor
	\EndProcedure
\end{algorithmic}
\end{algorithm}

~

\Needspace{5\baselineskip}
\noindent\textbf{\textit{The Replication Protocol}}

Replication is done just after the merge. The objective here is to update the local partial replica $t_{\mathcal{V}_{i}}$ from the local (global) artifact $t_i$.
To do this (see algorithm \ref{algorithmeReplication}), the local workflow engine proceeds as follows:
\begin{itemize}
	\item It realises the expansion\footnote{It is important to note that the expansion algorithm used here only returns one artifact (see \textit{the expansion-pruning protocol}, page \pageref{chap3:sec:execution-protocol-expansion-pruning}), unlike the one presented in \cite{badouelTchoupeCmcs} which generates a potentially infinite family of artifacts represented by a tree automaton. This uniqueness is guaranteed by the fact that the expansion of $t_{\mathcal{V}_{i}}$ into $t^{maj}_i$ is done using a three-way approach (\textit{three-way merge} \cite{tomMens}). In fact, the expansion is carried out based on the grammatical model $\mathbb{G}$ and on the view $\mathcal{V}_{i}$, but also on the prefix $t_i$ of (the local global artifact replica) $t^{maj}_i$.} of the partial replica $t _{\mathcal{V}_{i}}$ to obtain a global artifact $t^{maj}_i$ which integrates all the updates made during the previous execution (algorithm \ref{algorithmeReplication}, line 2). This operation is necessary, since at the end of the previous expansion, there may have been a pruning (see \textit{the expansion-pruning protocol}, page \pageref{chap3:sec:execution-protocol-expansion-pruning}) which removed from the global artifact local copy $t_i$, some updates contained in $t_{\mathcal{V}_{i}}$;
	\item Then, it merges $t_i$ and $t^{maj}_i$ in one artifact $t_{i_f}$ (algorithm \ref{algorithmeReplication}, line 3);
	\item Finally, it realises the projection of $t_{i_f}$ relatively to the view $\mathcal{V}_{i}$ to obtain the new version of $t_{\mathcal{V}_{i}}=\pi_{\mathcal{V}_i}(t_{i_f})$ (algorithm \ref{algorithmeReplication}, line 4).
\end{itemize}

\begin{algorithm}
\small
\caption{Replication protocol executed by an agent $i$.\label{algorithmeReplication}}
\begin{algorithmic}[1]
	\Procedure{Replication}{}
		\State $t^{maj}_i \gets expand(t_{\mathcal{V}_{i}}, ~t_i, ~\mathcal{V}_{i}, ~\mathbb{G})$
		\State $t_{i_f} \gets merge(t_i,~t^{maj}_i)$
		\State $t_{\mathcal{V}_{i}} \gets \textrm{\textit{projection}}(t_{i_f}, ~\mathcal{V}_{i}, ~\mathbb{G}_{i})$
	\EndProcedure
\end{algorithmic}
\end{algorithm}

~

\noindent\textbf{\textit{The Execution Protocol}}

This protocol (algorithm \ref{algorithmeExecution}) is executed after the production of the local partial replica $t_{\mathcal{V}_{i}}$ by an agent $i$. It is executed by the local actor through the specialised editor, in order to extend the (unlocked) buds of $t_{\mathcal{V}_{i}}$ on which, he is accredited in writing.

The execution of the artifact's local replica by the agent $i$, must be done "as far as possible" by respecting the scheduling (sequential or parallel) of the tasks. Indeed, during the extension of a bud, if there is unlocking or creation of new unlocked buds on which the current agent is accredited in writing, its actor must extend/execute them; this is the purpose of the \textit{while} loop in algorithm \ref{algorithmeExecution}. In addition, the extension of buds whose type $S$ corresponds to a (re)structuring symbol, is automatically done by the local workflow engine when the local GMWf has only one $S$-production.

\begin{algorithm}
\small
\caption{Execution protocol executed by an agent $i$.\label{algorithmeExecution}}
\begin{algorithmic}[1]
	\Procedure{Execution}{}
		\While{$not~isEmpty(buds \gets nextLocalUnlockedBuds(t_{\mathcal{V}_{i}},~\mathcal{A}_{A_i(w)}))$}\Comment{While there are tasks that can be concurrently executed by the actor $A_i$ of agent $i$ in the partial replica $t_{\mathcal{V}_{i}}$}
			\State $bud \gets prompt("Choose~a~task~to~execute",~buds)$\Comment{Actor $A_i$ chooses the task (bud) to execute}
			\State $prods \gets localExecutionPossibilities(bud.type)$\Comment{The specialized editor (agent) generates and activates the set of execution possibilities according to the current (local) configuration}
			\State $choice \gets prompt("Choose~an~execution~possibility",~prods)$\Comment{Actor $A_i$ executes the selected task and provide feedback through the specialized editor}
			\State $t_{\mathcal{V}_{i}} \gets \textrm{\textit{updateArtifact}}(choice,~t_{\mathcal{V}_{i}})$\Comment{Then $t_{\mathcal{V}_{i}}$ is updated accordingly}
		\EndWhile
	\EndProcedure
\end{algorithmic}
\end{algorithm}


~

\noindent\textbf{\textit{The Expansion-Pruning Protocol}}
\label{chap3:sec:execution-protocol-expansion-pruning}

After completion of the partial replica $t_{\mathcal{V}_{i}}$, the updates must be propagated to the local (global) replica $t_i$ of the artifact. This makes it possible to highlight (if they exist) the tasks for which requests must be made, or to determine if answers to requests can be returned.
Algorithm \ref{algorithmeExpansion} allows addressing this concern. For that, the expansion of the local updated partial replica $t_{\mathcal{V}_{i}}$ is made (algorithm \ref{algorithmeExpansion}, line 2) to obtain the global artifact $t^{maj}_i$ which integrates all the contributions made by actor $A_i$ during the previous local execution phase.

Note that the artifact $t^{maj}_i$ may have so called \textit{upstairs buds}\footnote{Intuitively, a node ${n_{X_{\bar{\omega}}}}$ associated with the task $X$ is an \textit{upstair bud} if, $X$ (not already executed) precedes at least one task $Y$ made visible (and naturally not already executed) on the site of an agent $i$, $i$ not having any accreditation in reading on $X$.} (these are the internal nodes of $t^{maj}_i$ that do not belong to $\mathcal{V}_{i}=\mathcal{A}_{A_i (r)}$, and which are not in $t_i$ - see fig. \ref{chap3:fig:execution-figure-2}). 
To prevent and manage this situation, a pruning of $t^{maj}_i$ is performed (algorithm \ref{algorithmeExpansion}, line 3) to ensure compliance with task-related precedence constraints of executions. 
To do this, for every path of $t^{maj}_i$ starting from the root, we prune at the level of the first (upstairs) bud encountered; it must appear unlocked if all the tasks that precede it have already been executed. The artifact obtained after this phase is the new version of $t_i$, and represents the current state of the process execution from the point of view of agent $i$. 

\begin{algorithm}
\small
\caption{Expansion-Pruning protocol executed by an agent $i$.\label{algorithmeExpansion}}
\begin{algorithmic}[1]
	\Procedure{Expansion-Pruning}{}
		\State $t^{maj}_i \gets expand(t_{\mathcal{V}_{i}}, ~t_i, ~\mathcal{V}_{i}, ~\mathbb{G})$
		\State $t_{i} \gets pruning(t^{maj}_i, ~t_i)$%\Comment{We merge the artefact of the request with $t_i$}
	\EndProcedure
\end{algorithmic}
\end{algorithm}

~

\noindent\textbf{\textit{A three-way merging expansion algorithm}}\label{three-way-merge}: consider an (global) artifact under execution $t$, and $t_{\mathcal{V}}=\pi_{\mathcal{V}}\left(t\right)$ its partial replica on the site of an actor $A_i$ whose view is $\mathcal{V}$. Consider the partial replica $t_{\mathcal{V}}^{maj} \geq t_{\mathcal{V}}$ obtained by developing some unlocked buds of $t_{\mathcal{V}}$ as a result of $A_i$'s contribution. The expansion problem consists in finding an (global) artifact under execution $t_f$, which integrates nodes of $t$ and $t_{\mathcal{V}}$. To solve this problem made difficult by the fact that $t$ and $t_{\mathcal{V}}$ are conform to two different models ($\mathbb{G}$ and $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}} \left(\mathbb{G} \right)$), we perform a three-way merge {\cite{tomMens}. We merge the artifacts $t$ and $t_{\mathcal{V}}$ using a (global) target artifact $t_g$ such that: 
\begin{enumerate}
	\item[\textbf{(a)}] $t$ is a prefix of $t_g$ ($t \leq t_g$)
	\item[\textbf{(b)}] $t_{\mathcal{V}}^{maj}$ is a prefix of the partial replica of $t_g$ according to $\mathcal{V}$ $\left(t_{\mathcal{V}}^{maj} \leq \pi_{\mathcal{V}}\left(t_g \right)\right)$
\end{enumerate}	
The proposed algorithm proceeds in two steps.
	
~
	
\noindent\textit{Step 1 - Search for the merging guide $t_g$}:
the search of a merging guide is done by the algorithm \ref{chap3:algo:search-guide}.

\begin{algorithm}
\small
\caption{Algorithm to search a merging guide.}
\label{chap3:algo:search-guide}
\begin{mdframed}[style=MyFrame]
	\noindent\textbf{1.}$~$ First of all, we have to generate the set $arts_{\mathbb{G}}=\left\{t_1,\ldots,t_n\right\}$ of target artifacts denoted by $\mathbb{G}$;
	
	\noindent\textbf{2.}$~$ Then, we must filter this set to retain only the artifacts $t_i$ admitting $t$ as a prefix (criterion \textbf{(a)}) and whose projections according to $\mathcal{V}$ ($t_{i_{\mathcal{V}_j}}$) admit $t_{\mathcal{V}}^{maj}$ as a prefix (criterion \textbf{(b)}). It is said that an artifact $t_a$ (whose root node is $n_a=X_a[t_{a_1},\ldots,t_{a_l}]$) is a prefix of a given artifact $t_b$ (whose root node is $n_b=X_b[t_{b_1},\ldots,t_{b_m}]$) if and only if the root nodes $n_a$ and $n_b$ are of the same types (i.e $X_a=X_b$) and:
	%\begin{itemize}[leftmargin=*]
	
		$~~$\textbf{a.}$~$ The node $n_a$ is a bud or,
		
		$~~$\textbf{b.}$~$ The nodes $n_a$ and $n_b$ have the same number of sub-artifacts (i.e $l=m$), the same type of scheduling for the sub-artifacts and each sub-artifact $t_{a_i}$ of $n_a$ is a prefix of the sub-artifact $t_{b_i}$ of $n_b$.
	%\end{itemize}
	
	\noindent We obtain the set $guides=\left\{t_{g_1},\ldots,t_{g_k}\right\}$ of artifacts that can guide the merging;
	
	\noindent\textbf{3.}$~$ Finally, we randomly select an element $t_g$ from the set $guides$.
	%\end{enumerate}
\end{mdframed}
\end{algorithm}


~

\noindent\textit{Step 2 - Merging $t$, $t_{\mathcal{V}}^{maj}$ and $t_g$}:
we want to find an artifact $t_f$ that includes all the contributions already made during the workflow execution. The structure of the searched artifact $t_f$ is the same as that of $t_g$: hence the interest to use $t_g$ as a guide. The merging is carried out by the algorithm \ref{chap3:algo:three-way-merge}.

\begin{algorithm}
\small
\caption{Three-way merging algorithm.}
\label{chap3:algo:three-way-merge}
\begin{mdframed}[style=MyFrame]
	\noindent A prefixed depth path of the three artifacts ($t$, $t_{\mathcal{V}}^{maj}$ and $t_g$) is made simultaneously until there is no longer a node to visit in $t_g$. Let $n_{t_i}$ (resp. $n_{t_{\mathcal{V}_j}^{maj}}$ and $n_{t_{g_k}}$) be the node located at the address $w_i$ (resp. $w_j$ and $w_k$) of $t$ (resp. $t_{\mathcal{V}}^{maj}$ and $t_g$) and currently being visited. If nodes $n_{t_i}$, $n_{t_{\mathcal{V}_j}^{maj}}$ and $n_{t_{g_k}}$ are such that (\textbf{processing}):
	
	%\begin{itemize}[leftmargin=*]
	\noindent\textbf{1.}$~$ $n_{t_{\mathcal{V}_j}^{maj}}$ is associated with a (re)structuring symbol (fig. \ref{chap3:fig:expansion-pattern}(d)) then: we take a step forward in the depth path of $t_{\mathcal{V}}^{maj}$ and we resume processing;
	
	\noindent\textbf{2.}$~$ $n_{t_i}$, $n_{t_{\mathcal{V}_j}^{maj}}$ and $n_{t_{g_k}}$ exist and are all associated with the same symbol $X$ (fig. \ref{chap3:fig:expansion-pattern}(a) and \ref{chap3:fig:expansion-pattern}(b)) then:
	%\begin{enumerate}[leftmargin=*]
	we insert $n_{t_{\mathcal{V}_j}^{maj}}$ (it is the most up-to-date node) into $t_f$ at the address $w_k$; 
	if $n_{t_{\mathcal{V}_j}^{maj}}$ is a bud then we prune (delete sub-artifacts) $t_g$ at the address $w_k$; 
	we take a step forward in the depth path of the three artifacts and we resume processing.
	%\end{enumerate}
	
	\noindent\textbf{3.}$~$ $n_{t_i}$, $n_{t_{\mathcal{V}_j}^{maj}}$ and $n_{t_{g_k}}$ exist and are respectively associated with symbols $X_i$, $X_j$ and $X_k$ such that $X_k \neq X_i$ and $X_k \neq X_j$ (fig. \ref{chap3:fig:expansion-pattern}(e)) then: 
	%\begin{enumerate}[leftmargin=*]
	we add $n_{t_{g_k}}$ in $t_f$ at address $w_k$. This is an upstair bud; 
	we take a step forward in the depth path of $t_g$ and we resume processing.
	%\end{enumerate}
	
	\noindent\textbf{4.}$~$ $n_{t_i}$ (resp. $n_{t_{\mathcal{V}_j}^{maj}}$) and $n_{t_{g_k}}$ exist and are associated with the same symbol $X$ (fig. \ref{chap3:fig:expansion-pattern}(c) and \ref{chap3:fig:expansion-pattern}(f)) then: 
	%\begin{enumerate}[leftmargin=*]
	we insert $n_{t_i}$ (resp. $n_{t_{\mathcal{V}_j}^{maj}}$) into $t_f$ at the address $w_k$;
	if $n_{t_i}$ (resp. $n_{t_{\mathcal{V}_j}^{maj}}$) is a bud, we prune $t_g$ at the address $w_k$; 
	we take a step forward in the depth path of the artifacts $t$ (resp. $t_{\mathcal{V}}^{maj}$) and $t_g$, then we resume processing.
	%\end{enumerate}
	%\end{itemize}
\end{mdframed}
\end{algorithm}

\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.27]{./Chap3/images/expansionMergePattern.png}}
	\caption{Some scenarios to be managed during the expansion.}
	\label{chap3:fig:expansion-pattern}
\end{figure}

As for the other key algorithms, a Haskell implementation of this expansion-pruning algorithm is introduced in appendix \ref{appendice1:algorithms-implementations}.

\begin{proposition}
	\label{propositionAtLeastOneGuide}
	For any update $t_{\mathcal{V}}^{maj}$ in accordance with a GMWf $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$, of a partial replica $t_{\mathcal{V}}=\pi_{\mathcal{V}}\left(t\right)$ obtained by projecting (according to the view $\mathcal{V}$) an artifact $t$ being executed in accordance with the GMWf $\mathbb{G}$ of a GMAWfP verifying the axioms' visibility and the non-recursivity assumptions, there is at least one target artifact (the three-way merge guide) $t_g \in arts_{\mathbb{G}}$ of $\mathbb{G}$ such as:
	\begin{enumerate}
		\item[\textbf{(a)}] $t$ is a prefix of $t_g$ ($t \leq t_g$)
		\item[\textbf{(b)}] $t_{\mathcal{V}}^{maj}$ is a prefix of the partial replica of $t_g$ according to $\mathcal{V}$ $\left(t_{\mathcal{V}}^{maj} \leq \pi_{\mathcal{V}}\left(t_g \right)\right)$
	\end{enumerate}	
\end{proposition}	

\begin{proof}
	Thanks to the proposals \ref{propositionStabiliteProjGMWf}, \ref{propositionCoherenceArtefact} and the artifact editing model used here (see sec. \ref{chap3:sec:artifact-edition}) it is established that since the artifact $t$ being executed in accordance with $\mathbb{G}$ is a prefix of a non-empty set of $\mathbb{G}$'s target artifacts $arts_{\mathbb{G}}^{'} = \left\{t_{1}^{'},\ldots, t_{n}^{'}\right\}$ ($\forall 1 \leq i \leq n, ~t \leq t_{i}^{'}$), its projection $t_{\mathcal{V}}$ according to the view $\mathcal{V}$ is a prefix of a non-empty set $arts_{\mathbb{G}_{\mathcal{V}}}^{'} = \left\{t_{{\mathcal{V}}_{1}}^{'},\ldots, t_{{\mathcal{V}}_{m}}^{'}\right\}$ of $\mathbb{G}_{\mathcal{V}} = \Pi_{\mathcal{V}}\left(\mathbb{G} \right)$'s local target artifacts for the said view ($\forall 1 \leq j \leq m, ~t_{\mathcal{V}} \leq t_{{\mathcal{V}}_{j}}^{'}$): elements of $arts_{\mathbb{G}}^{'}$ are potential merging guides candidates that all verify the property \textbf{(a)}. In addition, using the propositions \ref{propositionStabiliteProjGMWf} and \ref{propositionReciproqueCoherenceArtefact}, it is established that each element of $arts_{\mathbb{G}_{\mathcal{V}}}^{'}$ is the projection of at least one element of $arts_{\mathbb{G}}^{'}$ according to the view $\mathcal{V}$ \textbf{(1)}. Given that $t_{\mathcal{V}}^{maj}$ is obtained by developing buds of $t_{\mathcal{V}}$ in accordance with $\mathbb{G}_{\mathcal{V}}$, it is inferred that $t_{\mathcal{V}}^{maj}$ is a prefix of a non-empty subset $arts_{\mathbb{G}_{\mathcal{V}}}^{maj} \subseteq arts_{\mathbb{G}_{\mathcal{V}}}^{'}$ of local target artifacts for the view $\mathcal{V}$ \textbf{(2)}. With the proposition \ref{propositionReciproqueCoherenceArtefact} once again, it is determined that for each artifact $t_{{\mathcal{V}}_{j}}^{'} \in arts_{\mathbb{G}_{\mathcal{V}}}^{maj}$, there is at least one artifact $t_{g_j}$ that is conform to $\mathbb{G}$ such as $t_{{\mathcal{V}}_{j}}^{'} = \pi_{\mathcal{V}}\left(t_{g_j} \right)$: this new set $arts_{\mathbb{G}}^{maj} = \left\{t_{g_1},\ldots, t_{g_k}\right\}$ is made up of potential merging guides candidates that all verify the property \textbf{(b)}. Results \textbf{(1)} and \textbf{(2)} show that $arts_{\mathbb{G}}^{maj}$ and $arts_{\mathbb{G}}^{'}$ are not disjoint. As a consequence, the set $guides= arts_{\mathbb{G}}^{maj} \cap arts_{\mathbb{G}}^{'}$ of potential merging guides that all verify both property \textbf{(a)} and \textbf{(b)} is not empty.
\end{proof}

\begin{corollary}
	\label{propositionUniqueExpansion}
	For an artifact $t$ being executed in accordance with a GMWf $\mathbb{G}$ of a GMAWfP verifying the axioms' visibility and the non-recursivity assumptions, and an update $t_{\mathcal{V}}^{maj} \geq t_{\mathcal{V}}$ of its partial replica $t_{\mathcal{V}}=\pi_{\mathcal{V}}\left(t\right)$ according to the view $\mathcal{V}$, the expansion of $t_{\mathcal{V}}^{maj}$ contains at least one artifact and the expansion-pruning algorithm presented here returns one and only one artifact.
\end{corollary}

\begin{comment}
\begin{proof}
	The proof of this corollary derives from the proof of the proposition \ref{propositionAtLeastOneGuide} and from the fact that in the last instruction of the algorithm \ref{chap3:algo:search-guide}, an artifact is randomly selected an returned from a non-empty set of potential guides.
\end{proof}
\end{comment}
This result (corollary \ref{propositionUniqueExpansion}) derives from the proof of the proposition \ref{propositionAtLeastOneGuide} (\textit{there is always at least one artifact in the expansion of $t_{\mathcal{V}}^{maj}$ under the conditions of corollary \ref{propositionUniqueExpansion}}) and from the fact that in the last instruction of the algorithm \ref{algo:search-guide}, an artifact is randomly selected an returned from a non-empty set of potential guides (\textit{only one of the expansion artifacts is used in the three-way merging}).

~

\noindent\textbf{\textit{The Diffusion Protocol}}
\label{chap3:sec:execution-protocol-diffusion}

After expansion-pruning, the local workflow engine must examine whether requests need to be sent to other agents (this is the case if $t_i$ still have unlocked buds created on its site\footnote{An agent only requests the execution of a bud if it was created on its site.}, on which the current agent is not accredited in writing) or, if responses are to be returned (this is the case if $t_i$ is complete or semi-complete).

To build the list of requests to diffuse, the local workflow engine scans the artifact $t_i$ produced by expansion-pruning and builds the list of required agents (those to receive a request) from buds\footnote{Normally (due to assumptions of our model) at this stage, for each unlocked bud of $t_i$, agent $i$ is accredited in execution on the associated task. Any other situation would be a design flaw.} (algorithm \ref{algorithmeDiffusion}, lines 2 to 7). If the required agents list is not empty (the artifact is not complete), it sends a request to each agent in the list (algorithm \ref{algorithmeDiffusion}, lines 8 to 12). Otherwise, if there are agents who have previously made requests, it sends responses instead (algorithm \ref{algorithmeDiffusion}, lines 13 to 18).

\begin{algorithm}
\small
\caption{Diffusion protocol executed by an agent $i$.\label{algorithmeDiffusion}}
\begin{algorithmic}[1]
	\Procedure{Diffusion}{}
		\For{$bud : unlockedBuds(t_i)$ and $bud$ have been created by $i$}%\Comment{For each unlocked bud in the updated artefact}
			\If{$bud.type \in \mathcal{A}_{A_i(x)}$}%\Commnent{If peer $i$ can ask the execution of this task}
				\State $agent \gets \textrm{\textit{executorOf}}(bud.type)$
				\State $enqueue(agent, requiredAgents)$
			\EndIf
			\EndFor
			\If {$not~isEmpty(requiredAgents)$}
				\State $req \gets new~Request(i,~t_i)$
			  \For{$agent : requiredAgents$}
					\State $invoqueService("forwardTo",~req,~agent)$
				\EndFor		
			\ElsIf{$not~isEmpty(RET_i)$}
				\State $ans \gets new~Answer(i,~t_i)$
			 	\For{$agent : RET_i$}
					\State $invoqueService("returnTo",~ans,~agent)$
					\State $delete~agent~from~RET_i$
				\EndFor
			\Else
				\State $alert("The~process~execution~is~terminated.")$
			\EndIf
	\EndProcedure
\end{algorithmic}
\end{algorithm}

