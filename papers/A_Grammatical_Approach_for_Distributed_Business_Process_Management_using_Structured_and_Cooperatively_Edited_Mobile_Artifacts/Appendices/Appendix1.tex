\myChapter{Implementation of Some Important Algorithms Presented in this Thesis}{}
\label{appendice1:algorithms-implementations}
\mySaveMarks

We had thought to present in this appendix, a Haskell implementation of the projection algorithms proposed in chapter \ref{chap3:choreography-workflow-design-execution} of this thesis. However, these are far too voluminous and their presentation here will not be very readable. We have therefore decided to present only the main data types here. We have hosted the rest of the produced Haskell code on the public Git repository accessible via this link: \url{https://github.com/MegaMaxim10/my-thesis-projection-algorithms}.


\mySectionStar{Haskell Type for Tags}{}{false}
Let's start by defining the tags for the node types (sequential or parallel). More clearly, in a given artifact, a node $A$ is tagged with \Verb|Seq| (resp. \Verb|Par|) when its sub-artifacts are executed in sequence (resp. potentially in parallel), i.e. the production used for its extension is a sequential (resp. parallel) one. A node with at most one sub-artifact is always tagged with \Verb|Seq|.
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
data ProductionTag x = Seq x | Par x deriving (Eq, Show)
\end{Verbatim}
The \Verb|untagProduction| function below clears a given symbol of its tag (\Verb|Seq| or \Verb|Par|):
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
untagProduction:: ProductionTag x -> x
untagProduction (Seq x) = x
untagProduction (Par x) = x
\end{Verbatim}

\mySubSectionStar{Definition of tags (\textit{closed}, \textit{locked}, \textit{unlocked} or \textit{upstair}) for symbols}{}{false}
In an artifact: a closed node is tagged \Verb|Closed|, an unlocked bud is tagged \Verb|Unlocked|, a locked bud is tagged \Verb|Locked| and an upstair bud is tagged \Verb|Upstair| (only found after expansion).
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
data NodeTag x = Closed x | Locked x | Unlocked x | Upstair x deriving (Eq, Show)
\end{Verbatim}
The \Verb|untagNode| function below clears a given symbol of its tag (\Verb|Closed|, \Verb|Unlocked|, \Verb|Locked| or \Verb|Upstair|):
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
untagNode:: NodeTag x -> x
untagNode (Closed x) = x
untagNode (Locked x) = x
untagNode (Unlocked x) = x
untagNode (Upstair x) = x
\end{Verbatim}

\mySubSectionStar{Definition of tags for symbol types (structuring or standard)}{}{false}
The symbols of a given artifact $t$ are either those of the grammatical model $\mathbb{G}$ denoting $t$, or (re)structuring symbols introduced to preserve some important properties of our model (mainly, the form of productions used in GMWf): in this case, the symbols of $\mathbb{G}$ are said to be standard and are tagged with \Verb|Standard| while the (re)structuring symbols are tagged with \Verb|Structural|.
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
data SymbolTag x = Structural x | Standard x deriving (Eq, Show)
\end{Verbatim}
As the previous "untag" functions, the \Verb|untagSymbol| function below clears a given symbol of its tag (\Verb|Structural| or \Verb|Standard|):
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
untagSymbol:: SymbolTag x -> x
untagSymbol (Structural x) = x
untagSymbol (Standard x) = x
\end{Verbatim}


\mySectionStar{Haskell Type for Artifacts}{}{false}
Recursively, we consider that an artifact is given by its root node (\Verb|nodeLabel|) and the list of its sub-artifacts (\Verb|sonsList|) tagged either by \Verb|Seq| (to indicate that they are executed in sequence) or by \Verb|Par| (to indicate that they are potentially executed in parallel). We do not consider empty artifacts. The corresponding Haskell type is as follows:
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
data Artifact a = Node {
                       nodeLabel:: a, 
                       sonsList:: ProductionTag [Artifact a]
                  } deriving Eq
\end{Verbatim}
Here is an example of artifact encoded in this type. It corresponds to the target artifact $art_1$ in the figure \ref{chap3:fig:global-artefacts}:
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
art1 = Node (Closed "Ag") (
           Seq [
             Node (Closed "A") (
               Seq [
                 Node (Closed "B") (Seq []), 
                 Node (Closed "D") (Seq [])
               ])
           ])
\end{Verbatim}


\mySectionStar{Haskell Type for GMWf}{}{false}
Let's start by presenting a type for productions: a production is given by its left hand side (\Verb|lhs|) consisting of one symbol and by its right hand side (\Verb|rhs|) consisting of several symbols.
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
data Production symb = Prod {lhs:: symb, rhs:: [symb]} deriving Eq
\end{Verbatim}

Finally, a GMWf is given by the set of symbols and the set of productions constituting it. The productions are tagged either by \Verb|Seq| or by \Verb|Par|:
\begin{Verbatim}[frame=lines, fontsize=\small, numbers=left, numbersep=8pt]
data GMWf a = GMWf {
                   symbols:: [a], 
                   productions:: [ProductionTag (Production a)]
              } deriving (Eq, Show)
\end{Verbatim}


These are the main data types that we have defined and which are manipulated by the different projection functions that are available in our Git repository\footnote{Our Git repository: \url{https://github.com/MegaMaxim10/my-thesis-projection-algorithms}}. They are included with some test cases that one will be able to immediately experiment.


\myRestoreMarks

