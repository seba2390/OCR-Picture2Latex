\mySubSection{Reconciliation by Consensus}{}
\label{chap2:sec:consensus-reconciliation}

\mySubSubSection{Issue and Principle of the Solution of Reconciliation by Consensus}{}
\label{chap2:sec:consensus-reconciliation-issue-principle}
There are generally two distinct phases when synchronising replicas of a document \cite{balasubramaniam98what}: the \textit{updates detection} phase, which consists of recognising the different replica nodes (locations) where updates have been made since the last synchronisation, and the  \textit{propagation} phase, which consists in combining the updates made on the various replicas to produce a new synchronised state (document) for each replica.
In an asynchronous cooperative editing workflow of several partial replicas of a document, when you reach a synchronisation point, you can end up with unmergeable replicas in their entirety as they contain not compatible updates\footnote{This is particularly the case if there is at least one node of the global document accessible by more than one co-author and edited by at least two of them using different productions.}: they must be reconciled. This can be done by questioning (cancelling) some local editing actions in order to resolve conflicts and result in a coherent global version said of consensus.

Studies on reconciling a document versions are based on heuristics \cite{tomMens} as there is no general solution to this problem.
In our case, since all editing actions are reversible\footnote{Reminder: the editing actions made on a partial replica may be cancelled as long as they do not have been incorporated into the global document.} and it is easy to locate conflicts when trying to merge the partial replicas (see section \ref{chap2:sec:consensus-calculation}), we have a canonical method to eliminate conflicts: when merging, we replace any node of the global document whose replicas are in conflict, by a bud. Thus, we prune at the nodes where a conflict appears, replacing the corresponding subtree with a bud of the appropriate type, indicating that this part of the document is not yet edited: the documents obtained are called consensus. These are the maximum prefixes without conflicts of the fusion of the documents resulting from the different expansions of the various updated partial replicas. For example, in figure \ref{chap2:fig:consensus-workflow}, the parts highlighted (blue backgrounds) in trees (f) and (g) are in conflict;  they are replaced in the consensus tree (h) by a bud of type $C$ (node labelled $C_{\omega}$).

The problem of the consensual merging of $k$ updated partial replica whose global model is given by a grammar $\mathbb{G}=\left(\mathcal{S},\mathcal{P},A\right)$ can therefore be stated as follows :\\
\textbf{Problem of the consensual merging}: given $k$ views $(\mathcal{V}_i)_{1 \leq i\leq k}$ and $k$ partial replicas $(t_{\mathcal{V}_i}^{maj})_{1 \leq i\leq k}$, merge consensually the family $(t_{\mathcal{V}_i}^{maj})_{1 \leq i\leq k}$ is to find the largest documents $t^{maj}_{\mathcal{S}}$ conforming to $\mathbb{G}$ such that, for any document $t$ conforming to $\mathbb{G}$ and admitting $t_{\mathcal{V}_i}^{maj}$ as projection along the view ${\mathcal{V}_i}$, $t^{maj}_{\mathcal{S}}$ and $t$ are eventually updates each for other. i.e.:
\begin{center}
$ 
\left( t^{maj}_{\mathcal{S}} \in \otimes_{i=1}^{k} t_i,  ~t_i \in T_{i\mathcal{S}}^{maj} \right) \Leftrightarrow 
\left\{ \begin{array}{l}
	i) ~~	\forall i, \, 1\leq i \leq k, ~ \forall t \therefore \mathbb{G} \mbox{ such that }~ \pi_{\mathcal{V}_i}(t) =   t_{\mathcal{V}_i}^{maj} ,~t^{maj}_{\mathcal{S}} \cong t. \\
	ii) ~~\nexists t' \leq t^{maj}_{\mathcal{S}} \mbox{ such that } t' \in  \otimes_{i=1}^{k} t_i,  ~t_i \in T_{i\mathcal{S}}^{maj} 
\end{array}\right.
$\footnote{The binary relation $\cong$ when it exists between two trees $t_1$ and $t_2$ expresses the fact that they are possibly updates each for other. This relationship is more explicitly explained in definition \ref{chap2:def:relation-cong}.}
\end{center}

The solution that we propose to this problem stems from an instrumentation of that proposed for the expansion (section \ref{chap2:sec:view-projection-expansion-merging}). 
Indeed, we use an associative and commutative operator noted $\otimes$, to synchronise the tree automata $\mathcal{A}^{(i)}$ constructed to carry out the various expansions, in order to generate the tree automaton of consensual merging. Noting $\mathcal{A}_{(sc)}$ this automaton, the documents of the consensus are the trees of the language generated by the automaton $\mathcal{A}_{(sc)}$ from an initial state built from the vector made of the initial states of the automata $(\mathcal{A}^{(i)})$: 
$\mathscr{L}(\mathcal{A}_{(sc)},~(q_{t_{\mathcal{V}_i}^{maj}})) = consensus  \{\mathscr{L}(\mathcal{A}^{(i)},~q_{t_{\mathcal{V}_i}^{maj}})\}$.	
$\mathcal{A}_{(sc)}$ is obtained by proceeding as follows:
\begin{itemize}
	\item[(1)] For each view $\mathcal{V}_i$, build the automaton $\mathcal{A}^{(i)}$ which will carry out the expansion of the partial replica $t_{\mathcal{V}_i}^{maj}$ as previously indicated (sec. \ref{chap2:sec:view-projection-expansion-merging}): $  \mathscr{L}\left(\mathcal{A}^{(i)},~q_{t_{\mathcal{V}_i}^{maj}}\right) = T_{i\mathcal{S}}^{maj}$;
	\item[(2)] Using the operator $\otimes$, compute the automaton generating the consensus language $\mathcal{A}_{(sc)}=\otimes_{i=1}^{k}\mathcal{A}^{(i)}$. 
\end{itemize}




\mySubSubSection{Consensus Calculation}{}
\label{chap2:sec:consensus-calculation}
Before presenting the consensus calculation algorithm, let us specify using the concepts introduced in section \ref{chap2:sec:structured-document-edition-conformity}, the notion of (two) documents in conflict.
Let $t_1,t_2:\mathbb{N}^*\rightarrow \mathbf{A}$ be two trees (documents)  with respectively $\mathit{Dom}(t_1)$ and $\mathit{Dom}(t_2)$ their domains. We say that $t_1$ and $t_2$ admit a consensus, and we note $t_1\curlywedgeuparrow t_2$, if their roots are of the same type\footnote{Trees we handle are AST and therefore, the nodes are labelled by productions names. Any node labelled by an \textit{X-production} is said of \textit{type} $X$. Furthermore, there is a function \textit{typeNode} such that \textit{typeNode(t(w))} returns the type of the node located at the address $w$ in $t$.}, i.e. $\left( t_1\curlywedgeuparrow t_2 \right) \Leftrightarrow \left(typeNode(t_{1}(\epsilon)) = typeNode(t_{2}(\epsilon)) \right)$ \footnote{It may then be noted that two documents (AST) admit no consensus if their roots are of different types. However, for applications that interest us, namely structured editing, since the editions are done from the root (which is always of the type of the axiom) to the leaves using productions, the documents we manipulate always admit at least a consensus.}. It is then say that, $t_1$ and $t_2$ are in conflict, and it is noted $t_1 \curlyveeuparrow t_2$, when they admit a consensus but are not mergeable in their entirety. 
Intuitively, two documents $t_1$ and $t_2$ (not reduced to buds) are not fully mergeable (see fig. \ref{chap2:fig:tree-in-conflict}), if there exists an address $w\in \mathit{Dom}(t_1) \cap \mathit{Dom}(t_2)$ such that, if we note $n_1$ (resp. $n_2$) the node located to address $w$ in $t_1$ (resp. in $t_2$), then, $n_1$ and $n_2$ which are not buds, are of the same type but have different labels. i.e. 
\begin{center}
$
\left( t_1\curlyveeuparrow t_2 ~with~t_1(\epsilon)\neq X_\omega,\, t_2(\epsilon)\neq X_\omega\right) \Leftrightarrow \left\{\begin{array}{l}
													\left(t_1\curlywedgeuparrow t_2\right)\\
													\mbox{and}\\
													\left(\begin{array}{l}\exists w \in \mathit{Dom}(t_1)\cup \mathit{Dom}(t_2), ~t_{1}(w) \neq t_{2}(w) \neq X_\omega ~ and\\
													typeNode(t_{1}(w)) = typeNode(t_{2}(w))
													\end{array}
													\right) 
											 \end{array}
								\right.
$
\end{center}
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.37]{Chap2/images/docConflit.png}}
	\caption{Example of documents in conflict.}
	\label{chap2:fig:tree-in-conflict}
\end{figure}

Figure \ref{chap2:fig:tree-in-conflict} shows two conflicting documents. In fact, at address 2.1 we have two nodes of the same type ("C") but edited with different C-productions:  production $C \rightarrow C ~C $ in the first document, and production $C \rightarrow A~C $ in the second one.

~

\noindent\textbf{\textit{Consensus among multiple (two) documents}}

Let $t_1,t_2:\mathbb{N}^*\rightarrow \mathbf{A}$ be two trees (documents) in conflict with respectively $\mathit{Dom}(t_1)$ and $\mathit{Dom}(t_2)$ their domains.
The consensual tree $t_c:\mathbb{N}^*\rightarrow \mathbf{A}$ derived from $t_1$ and $t_2$ ($t_c = t_1 \otimes t_2$) has as domain the union of domains of the two trees in which, we subtract elements belonging to domains of subtrees derived from the conflicting nodes. In fact, we prune at the nodes in conflict and they appear in the consensus tree as a (unique) bud.
So, 
\begin{center}
$\forall w \in \mathit{Dom}(t_c)$, 
			$ t_c(w) =   
		    \left\{ \begin{array}{lll}
										t_1(w) & \mathit{if} & typeNode(t_1(w)) = typeNode(t_2(w)) ~and ~ t_1(w)=t_2(w)\\
										t_1(w) & \mathit{if} & typeNode(t_1(w)) = typeNode(t_2(w)) ~and ~ t_2 (w) = X_\omega \\
										t_2 (w) & \mathit{if} & typeNode(t_1(w)) = typeNode(t_2(w)) ~and ~ t_1(w) = X_\omega \\
										t_1(w) & \mathit{if} & w \notin Dom(t_2) ~and~ \exists u,\,v \in \mathbb{N}^* ~ tq ~ w=u.v, \\
														&							& ~ t_2 (u) = X_\omega ~and ~typeNode(t_1(u)) = typeNode(t_2(u))  \\
										t_2(w) & \mathit{if} & w \notin Dom(t_1) ~and~ \exists u,\,v \in \mathbb{N}^* ~ tq ~ w=u.v, \\
														&							&~ t_1(u) = X_\omega ~and~typeNode(t_1(u)) = typeNode(t_2(u))  \\
										X_\omega & \mathit{if} & typeNode(t_1(w)) = typeNode(t_2(w)) ~and ~ t_1(w) \neq X_\omega\\
															&							&~and~ t_2 (w) \neq X_\omega ~and~ t_1(w) \neq t_2(w)  										
									\end{array}
								\right.
  $  
\end{center}

Figure \ref{chap2:fig:consensus-documents} presents the document resulting from the consensual merging of the documents in figure \ref{chap2:fig:tree-in-conflict}. We have prune at the level of nodes 2.1  in both documents which are in conflict.
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.4]{Chap2/images/docConsensus.png}}
	\caption{Document resulting from the consensual merging of the documents in figure \ref{chap2:fig:tree-in-conflict}.}
	\label{chap2:fig:consensus-documents}
\end{figure}

When $t_c = t_1 \otimes t_2 $, there may be nodes of $t_1$ and those of $t_2$ which are updates of the nodes of $t_c$: it is said in this case that $t_1$ (resp. $t_2$) and $t_c$ are \textit{updates each for other}. 

\begin{definition}
\label{chap2:def:relation-cong}
Let $t_1, ~t_2$ two documents that are not in conflict. It will be said that \textit{they are updates each for other} and it is noted $t_1 \cong t_2$, if there exists at least two addresses $w, ~w'$ of their respective domains such that $t_1(w)$ (resp. $t_2(w')$) is a bud and $t_2(w)$ (resp. $t_1(w')$) is not.
\end{definition}


~

\noindent\textbf{\textit{Construction of the consensus automaton}}

Consideration of documents with buds requires the readjustment of some models. For example, in the following, we will handle \textit{tree automata with exit states} instead of tree automata introduced in definition \ref{chap2:def:tree-automaton}. Intuitively, a state $q$ of an automaton is called an \textit{exit state} if there is a unique transition $ q \rightarrow (X_\omega, [\, ])$ associated to it for generating a tree reduced to a bud of type $X \in \Sigma$: $q$ is then of the form \textit{(Open X, [])}.

\begin{definition}
A \textbf{tree automata with exit states} $\mathcal{A}$ is a quintuplet $(\Sigma,Q,R,q_0, \mathit{exit})$ where $\Sigma,Q,R,q_0$ designate the same objects as those introduced in definition \ref{chap2:def:tree-automaton}, and $\mathit{exit}$ is a predicate defined on the states ($\mathit{exit}: Q \rightarrow Bool$). Any state $q$ of $Q$ for which $\mathit{exit}~q$ is $\mathit{True}$ is an exit state.
\end{definition}

A type for automata with exit states can be defined in Haskell \cite{Antony} by the listing of algorithm \ref{chap2:algo:automata-type} in which, \textit{state} and \textit{prod} are type variables respectively representing the type of the automaton states and the type of labels of the AST to generate.
\begin{algorithm}
\small
\caption{A Haskell type for automata with exit states.}
\label{chap2:algo:automata-type}
\begin{Verbatim} [numbers=left]
data Automata prod state = Auto{
          exit:: state -> Bool, 
          next :: state -> [(prod,[state])]
          }
\end{Verbatim}
\end{algorithm}  

In section \ref{chap2:sec:consensus-calculation} (\textit{consensus among multiple (two) documents}) above, we said that, \textit{when two nodes are in conflict, "they appear in the consensus tree as a (unique) bud}". From the point of view of automata synchronisation, the concept of "nodes in conflict" is the counterpart of the concept of "states in conflict" (as we specify below), and the above extract is reflected in the automata context by:  "\textit{when two \textit{state} are in conflict, they appear in the \textit{consensus automaton} in the form of a (single) exit state}". 
Thus, if we consider two states of the same type $q_0^1$ and $q^2_0$ (which are not exit states) of two automata $auto_1$ and $auto_2$ with associated transitions families respectively $q_0^1 \rightarrow [(a^1_{1}, qs_1), \dots, (a^1_{n_1}, qs_{n_1})]$ and $q^2_0 \rightarrow [(a^2_{1}, qs'_1), \dots, (a^1_{n_2}, qs'_{n_2})]$, we say that the states $q^1_0$ and $q^2_0$ are in conflict (and we note $q^1_0 \curlyveeuparrow q^2_0$) if there is no transition starting from each of them and with the same label, i.e.  
\[\left(q^1_0 \curlyveeuparrow q^2_0\right) \Leftrightarrow \left(\nexists a^3, ~~~\left(a^3, qs\right) \in \left\{next~ q_o^1\right\}, ~\left(a^3, qs'\right) \in \left\{next~ q_o^2\right\}, ~|qs|=|qs'|\right)\]

This can be coded in Haskell by the function \Verb|isInConflicts| of algorithm \ref{chap2:algo:automata-state-in-conflict}.

\begin{algorithm}
\small
\caption{A Haskell function to check if two states of a given automaton are in conflict.}
\label{chap2:algo:automata-state-in-conflict}
\begin{Verbatim} [numbers=left]
isInConflicts state1@(tagsymb1, ts1) state2@(tagsymb2, ts2) = 
            null [a1 | (a1,states1) <- next auto1 state1,
                       (a2,states2) <- next auto2 state2,
                        a1==a2,
                       (length states1)==(length states2)]
\end{Verbatim}
\end{algorithm}


If $X$ is the type of two states $q$ and $q'$ in conflict, they admit a single consensual state $q_{\omega}=(Open X, [\,])$ such as $next~ q_{\omega} = [(X_{\omega}, [\,])]$. It is therefore obvious that two given automata admit a consensual automaton when their initials states are of the same type. The function defined in algorithm \ref{chap2:algo:automata-admit-consensus} performs this test.
\begin{algorithm}
\small
\caption{A Haskell function used to check if two given automata admit a consensus.}
\label{chap2:algo:automata-admit-consensus}
\begin{Verbatim} [numbers=left]
haveConsensus q0 q0' = (typeState q0) == (typeState q0')
\end{Verbatim}
\end{algorithm}

The operator $\otimes$ used to calculate the synchronised consensual automaton $\mathcal{A}_{(sc)}=\otimes_{i}^{k}\mathcal{A}^{(i)}$ is a relaxation of the operator used for calculating the automata product presented in definition \ref{chap2:def:synchronous-product}. $\mathcal{A}_{(sc)} = (\Sigma, ~Q, ~R, ~q_0, ~exit)$  is an automaton with exit states and is constructed as follows:

\begin{itemize}
	\item Its states are vectors of states : $Q =Q^{(1)}\times\cdots\times Q^{(k)}$; 
	\item its initial state is formed by the vector of initial states of different automata : $q_{0}=\left(q_{0}^{(1)},\cdots, q_{0}^{(k)}\right)$;
	\item For the \textit{exit} function, it is considered that when a given automaton $\mathcal{A}^{(j)}$ reaches an \textit{exit state}\footnote{The corresponding node in the reverse projection of the document is a bud and reflects the fact that, the corresponding author did not edit it. In the case that this node is shared with another co-author who edited it  in its (partial) replica, it is the edition made by the latter that will be retained when merging.}, it no longer contributes to the behaviour, but is not opposed to the synchronisation of the other automata: it is said to be \textit{asleep} (see algorithm \ref{listingConsensus}, lines 17, 19 and 24). So, a state $q = (q^1, \cdots, q^k)$ is an exit state if: 
	\begin{itemize}
		\item[(a)] all composite states $q^i$ are asleep (see algorithm \ref{listingConsensus}, line 6) or 
		\item[(b)] there exist any two states $q^{i}$ and $q^{j}, ~i \neq j$, components of $q$ that are in conflict (see algorithm \ref{listingConsensus}, line 12)  \\
		$\left( exit~\left(q^{(1)},\ldots,q^{(k)}\right)\right)$ $\Leftrightarrow$\\
		$\left( \left( exit~q^{(i)}, \forall i \in \{1\ldots k\} \right) \mbox{or} \left( \exists i, j, ~~i\neq j,  ~ q^{(i)} \curlyveeuparrow  q^{(j)}\right) \right)$;
	\end{itemize}
	
	\item Its transitions are given by:
	\begin{itemize} 
		\item[\textbf{(a)}] If $exit~ q$  then $q \rightarrow (X_\omega, [\,])$ is the unique transition of $q$; $X$ is the type of $q$.
		\item[\textbf{(b)}] Else  $\left(q^{(1)}, \ldots, q^{(k)}\right) \stackrel{a}{\rightarrow}\left(\left(q^{(1)}_1,\ldots,q^{(k)}_1\right),\ldots,\left(q^{(1)}_n,\ldots,q^{(k)}_n\right)\right) \Leftrightarrow$  +				$\forall i,~ 1\leq i\leq k$ 
		\begin{itemize} 
			\item[\textbf{(b1)}] $exit~q^{(i)}$ and $\left( q^{(i)}_j=\left(Open~X,~ [\;]\right), \forall j, ~1\leq j\leq n \right)~ $     \textit{ /*} $q^{(i)}$ \textit{is asleep */}, else\\
			\item[\textbf{(b2)}] ~  $q^{(i)}\stackrel{a}{\rightarrow}\left(q^{(i)}_1,\ldots,q^{(i)}_n \right)$.
		\end{itemize}
	\end{itemize}		
\end{itemize}
\textbf{(a)} reflects the fact that, if a state $q$ is an exit one, we associate a single transition for generating a tree reduced to a bud of the type of $q$ (see algorithm \ref{listingConsensus}, line 12).\\ 
With \textbf{(b1)} we say that, if the component $q^{(i)}$ of $q$ is an exit state, then for all composite state $\left(q^{(1)}_j,\ldots,q^{(k)}_j\right)$, ($1\leq j\leq n$) appearing in the right hand side of the transition \textbf{(b)}, the $i^{th}$ component should be asleep. Since it must not prevent other non-asleep states to synchronise, it must be of the form $(Open~X,~ [\;])$ where $X$ is the type of the other states $q^{(l)}_j$ (yet to be synchronised) belonging to $(q^{(1)}_j,\ldots,q^{(k)}_j)$ (see function \textit{fwdSlpState} defined in algorithm \ref{listingConsensus} line 24, and used in lines 17 and 19). Finally, with \textbf{(b2)} we stipulate that if  $q^{(i)}\stackrel{a}{\rightarrow}\left(q^{(i)}_1,\ldots,q^{(i)}_n \right)$ is a transition of the automaton $\mathcal{A}^{i} $, then for all composite state $\left(q^{(1)}_j,\ldots,q^{(k)}_j\right)$, ($1\leq j\leq n$) appearing in the right part of the transition \textbf{(b)} above, the $i^{th}$ component is $q^{(i)}_j$ (see algorithm \ref{listingConsensus}, lines 13 to 16).
			
	
\begin{algorithm}
\small
\caption{Consensus Listing.}
\label{listingConsensus}
\begin{Verbatim} [numbers=left]
autoconsens::(Eq p, Eq x) =>(x -> p) -> Automata p (Tag x, [st1])
     -> Automata p (Tag x, [st2]) 
     -> Automata p ((Tag x, [st1]), (Tag x, [st2]))
autoconsens symb2prod auto1  auto2 = Auto exit_ next_ where 
   exit_ (state1, state2) = case haveConsensus state1 state2 of
      True  -> (exit auto1 state1) && (exit auto2 state2) 
      False -> True
   next_ (state1, state2) = case haveConsensus state1 state2 of
      False -> []
      True  -> case (exit auto1 state1, exit auto2 state2) of
         (False, False) -> case (isInConflicts state1 state2) of
            True  -> [(symb2prod (typeState state1), [])]   
            False -> [(a1, zip states1 states2) | 
                      (a1, states1) <- next auto1 state1,
                      (a2, states2) <- next auto2 state2,
                      a1 == a2, (length states1) == (length states2)]
         (False, True)  -> [(a, zip states1 (fwdSlpState  states1)) |
                            (a, states1) <- next auto1 state1]
         (True, False)  -> [(a, zip (fwdSlpState  states2) states2) |
                            (a, states2) <- next auto2 state2]
         (True, True)   -> [(a1, []) | (a1,[]) <- next auto1 state1,
                            (a2, []) <- next auto2 state2, a1 == a2]
   where 
      fwdSlpState states = map (\state -> (Open (typeState state), [])) states
\end{Verbatim}
\end{algorithm}

\begin{proposition}
The tree automaton $\mathcal{A}=\otimes_{i=1}^{k}\mathcal{A}^{(i)}$  recognises/generates from the initial state $q_0 = (q_{01}, \ldots , q_{0k})$, all the trees from the consensual merging of trees recognised/generated by each automaton $\mathcal{A}^{(i)}$ from the initial state $q_{0i}$. Moreover, these trees are the biggest prefixes without conflicts of merged trees.
\[
\left( \otimes_{i=1}^{k}\mathcal{A}^{(i)} \models t \triangleright q_0\right) \Leftrightarrow 
  \left\{\begin{array}{l}
	i) ~~ \forall i,\quad\exists t_i\qquad  \mathcal{A}^{(i)}\models t_i \triangleright q_{0i}~\mbox{ and } ~t_i\cong t\\
	ii) ~~\forall t' \mbox{ prefix of } t, \quad \neg \left( \otimes_{i=1}^{k}\mathcal{A}^{(i)} \models t' \triangleright q_0\right)
	\end{array}\right.
\]
\end{proposition}

\begin{proof}
A tree $t$ is recognised by the synchronised automaton $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$ if and only if, one can label each of its nodes by a state of the automaton in accordance with what is specified by the transitions of the automaton. 
Moreover, all the leaf nodes of $t$ must be labelled by using \textit{final transitions}; in our case, they are of the form $q\rightarrow (p, [\;])$.
This means that, if a node whose initial label is $a$, is labelled by the state $q$, and if it admits $n$ successors respectively labelled by $q_1,\ldots,q_n$, then $q\stackrel{a}{\rightarrow}(q_1,\ldots,q_n)$ must be a transition of the automaton. As the automaton is deterministic\footnote{Automata $\mathcal{A}^{(i)}$ being deterministic (see proposition 3.3.3 of \cite{theseTchoupe}), $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$ is deterministic as synchronous product of deterministic automata.}, this labelling is unique (including the initial state attached to the root of the tree). 
By focusing our attention both on the state $q$ labelling a node, and its $i^{th}$ component $q_i$, on each of the branches of $t$, 
\begin{itemize}
	\item[(1)] we cut as soon as we reach an exit state in relation to the automaton $\mathcal{A}^{(i)} $ (i.e. $q_i$ is an exit state), or,
	\item[(2)] if $q$ is an exit state (in this case we are handling a leaf) and $q_i$ is not an exit state relatively to $\mathcal{A}^{(i)}$ (in this case, $q_i$ was in conflict with at least one other component $q_j$ of $q$), we replace that node with any subtree $t'_i$ that can be generated by $\mathcal{A}^{(i)}$ from the state $q_i$.
\end{itemize}
So,
\[
 \left(\otimes_{i=1}^{k}\mathcal{A}^{(i)} \models t \triangleright q_0 \right) \Rightarrow 
\left(\forall i,\;\exists t_i\quad \mathcal{A}^{(i)}\models t_i\triangleright q_{0i}\mbox{ and }t_i\cong t\right)
\]
since a state of $\mathcal{A}$ is an exit one if and only if, each of its components is an exit state (in the $\mathcal{A}^{i}$) or, if at least two of its components are in conflict. \\
Conversely, suppose $ \mathcal{A}^{(i)}\models t_i \triangleright q_{0i}$, by definition of the synchronised consensual automaton, we have $ \otimes_{i=1}^{k}\mathcal{A}^{(i)}\models \otimes_{i=1}^{k}t_i\triangleright (q_{01}, \ldots , q_{0k})$. So overall,
\[
L\left(\otimes_{i=1}^{k}\mathcal{A}^{(i)},~q_0\right) =\left\{ \otimes_{i=1}^{k}t_i | \quad  \mathcal{A}^{(i)}\models t_i\triangleright q_{0i} \right\}
\]

Suppose that $t$ is recognised by $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$; thus, there is a labelling of its nodes with the states of $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$, and as such the transitions used for the labelling of its leaves are final. 
Let $t_p$ be a prefix of $t$. Let us show that $t_p$ is not recognised by $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$ using the fact that, any labelling of $t_p$ has at least one leaf node labelled by a state that is not associated to a final transition.
The labels associated to the nodes of $t_p$ are the same as those associated to the nodes of same addresses in $t$ because, $t_p$ is a prefix of $t$ and $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$ is deterministic. $t_p$ is obtained from $t$ by pruning some subtrees of $t$; so, naturally, it has a (non-zero) number of leaf nodes that can be developed to obtain $t$. Let us choose such a node and call it $n_f$. Suppose that it is labelled $p$ and was associated with a state $q_f= (q_{1}, \ldots q_{k})$ when labelling $t$.
The \textit{p-transition} that allowed to recognise $n_f$ is not a final transition. Indeed, $n_f$ has in $t$, |$p$| sons whose labels can be supposed to be the states $q_{f_1}, \ldots, q_{f_{|p|}}$. This means that, according to the labelling process and considering the fact that $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$ is deterministic, the single transition used for the labelling of $n_f$ and of its |$p$| sons is $q_f\stackrel{p}{\rightarrow}\left(q_{f_1},\ldots,q_{f_{|p|}}\right)$ which, is not a final transition. Therefore, $t_p$ is not recognised by $\otimes_{i=1}^{k}\mathcal{A}^{(i)}$.
\end{proof}





\mySubSubSection{Illustration}{}
\label{chap2:sec:consensus-illustration}
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.3]{Chap2/images/workflowconsensus.png}}
	\caption{An edition with conflicts and corresponding consensus.}
	\label{chap2:fig:consensus-workflow}
\end{figure}

Figure \ref{chap2:fig:consensus-workflow} %et \ref{Workflowast} 
is an illustration of an asynchronous cooperative editing process generating partial replicas (fig. \ref{chap2:fig:consensus-workflow}(c) and fig. \ref{chap2:fig:consensus-workflow}(e)) in conflict\footnote{By realising expansions of each of the replicas, we respectively obtain among others, the documents presented by figure \ref{chap2:fig:consensus-workflow}(f) and figure \ref{chap2:fig:consensus-workflow}(g) on which, one can easily observe a conflict highlighted by areas having a blue background.} from the grammar having as productions: 
\begin{comment}
$P_{1}:\; A\rightarrow C\; B \qquad P_{2}:\; A\rightarrow \varepsilon \qquad  \; P_{3}:\; B\rightarrow C\; A\; \; \\ ~~~~~~~~~~~~~~~~~~~~~~~~~\qquad P_{4}:\; B\rightarrow B\; B\;    \; \qquad P_{5}:\; C\rightarrow A\; C  \qquad 
				 \; P_{6}:\; C\rightarrow C\; C\qquad  	P_{7}:\;C\rightarrow \varepsilon$
\end{comment}
\[ 
\begin{array}{lll}
				P_{1}:\; A\rightarrow C\; B & \; P_{3}:\; B\rightarrow C\; A\; & \; P_{5}:\; C\rightarrow A\; C  \\
				P_{2}:\; A\rightarrow \varepsilon & \; P_{4}:\; B\rightarrow B\; B\; & \; P_{6}:\; C\rightarrow C\; C\\
				& & P_{7}:\;C\rightarrow \varepsilon
\end{array}
 \]


Initially in the process, two partial replicas (fig. \ref{chap2:fig:consensus-workflow}(b) and fig. \ref{chap2:fig:consensus-workflow}(d)) are obtained by projections of the global document (fig. \ref{chap2:fig:consensus-workflow}(a)). After their update (fig. \ref{chap2:fig:consensus-workflow}(c) and fig. \ref{chap2:fig:consensus-workflow}(e)) a synchronisation point is reached and, by applying the approach described in section \ref{chap2:sec:consensus-reconciliation-issue-principle}, a consensus document is found (fig. \ref{chap2:fig:consensus-workflow}(h)). 
More precisely, as detailed below, we associate the automata $\mathcal{A}^{(1)}$ and $\mathcal{A}^{(2)}$ respectively to the updated partial replicas $tv1$ and $tv2$ (fig. \ref{chap2:fig:consensus-workflow}(c) and fig. \ref{chap2:fig:consensus-workflow}(e)), then we build the automaton of consensus $\mathcal{A}_{(sc)}=\mathcal{A}^{(1)}\otimes\mathcal{A}^{(2)}$ by applying the approach described in section \ref{chap2:sec:consensus-calculation} (\textit{construction of the consensus automaton}) and finally, we generate the simplest documents of the consensus (fig. \ref{chap2:fig:consensus-example-trees}) among which is the document in figure \ref{chap2:fig:consensus-workflow}(h).
