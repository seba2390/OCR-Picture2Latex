In this section, we will focus on the implementation of a system that can support cooperative editing as perceived by Badouel and Tchoup\'e. This effort is motivated by the fact that: 
\begin{enumerate}
\item \textit{This type of editing workflow applies to structured documents}: 
this leads to the fact that, one can locally perform validations in accordance with a local model derived from the global one;
\item \textit{This type of editing workflow is particularly compatible with administrative workflows}: concepts of "view" and partial replica introduced by Badouel and Tchoup√©, make that the type of workflow they offer is particularly adapted for the specification of many administrative processes. Consider, for example, the process "tracking a medical record in a health center with the reception and consultation services": the aforesaid record can be modelled as a structured document in which the members of the host service (reception) cannot view and/or modify certain information contained therein; those information, requesting the expertise of the consulting staff for example. Therefore, one can associate views to each of these services. It is left only to specify the medical record's circuit and an editing workflow of the type described in the previous section is obtained;
\item \textit{A generic architectural model describing precisely an approach for the implementation of this type of workflow does not exist}: the only prototype \cite{artTinyCE} which was designed around the concepts handled (view, partial replica, merging, etc.) for this type of workflow, was more of a graphic tool (editor) for the experimentation of concepts and algorithms presented in \cite{badouelTchoupeCmcs}; workflow management is not addressed in it: this tool cannot be used to specify an editing workflow, it does not support routing or storage of artifacts, nothing is done concerning monitoring, etc., yet these concerns are among the most important to be taken care of by a workflow management infrastructure \cite{ima}.
\end{enumerate}


\mySubSection{The Proposed Architecture}{}
\label{chap2:sec:archi-proposed-architecture}

\mySubSubSection{Overall Operations}{}
\label{chap2:sec:archi-overall-operations}
The architecture that we propose is composed of three tiers: some \textit{clients}, a \textit{central server} and several \textit{administration tools}. We consider that, each participant in a given workflow has a client. Initially, the workflow owner (comparable to a deposit owner in Git) connects to the server from his client. He creates his workflow by specifying all necessary informations (the workflow name, the overall grammar, different participants, their rights and their views, the basic document and the workflow's circuit), then triggers the process. Next, participants concerned by the newly created workflow receive an alert message from the system, inviting them to participate. Each participant must therefore connect himself to the server to obtain a partial replica of the workflow model (encoded in a specification file written in a dedicated DSL) and state (his local document model, a partial replica of the initial document, etc.) according to his rights and his view on the given workflow. A given participant performs his duties and submits his local (partial) replica to the central server which performs synchronisations as soon as possible and the process continues (see fig. \ref{chap2:fig:badouel-tchoupe-workflow}) until the end.  For specific needs (authentication, access to corporate data, etc.), clients and server may require the intervention of an administration tool (database, paperwork and many others). These three tiers are interconnected around a middleware as presented in figure \ref{chap2:fig:architecture}.
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.3]{Chap2/images/architectureEn.png}}
	\caption{A software architecture (three-tiers) for centralised management of structured documents' cooperative editing workflows.}
	\label{chap2:fig:architecture}
\end{figure}


\mySubSubSection{Server Architecture}{}
\label{chap2:sec:archi-server-architecture}
The server is responsible for the storage, restoration, execution and monitoring of workflows. Its architecture is based on three basic elements as shown in figure \ref{chap2:fig:architecture}(a) : its \textit{model}, \textit{storage module} and its \textit{runtime engine}.
\begin{enumerate}
\item \textit{The model}: it is the one orchestrating all the tasks supported by the server. It consists of a workflow engine, a set of parsers and three communication interfaces (the interface with the middleware, that with the storage module and the one with the runtime engine).
\item \textit{The storage module}: it is responsible for the storage of workflows. Like CVS, it maintains a main repository for each workflow. The repository space of a given workflow includes its specification file written in a DSL. There are also (global) document versions showing the state of the workflow at given times. These versions of the underlying documents, facilitate the control and monitoring of workflows.
\item \textit{The runtime engine}: it consists of implementations of projection, expansion and consensual merging algorithms. These implementations are used by the workflow engine in the realisation of these tasks. A runtime engine written entirely in Haskell, was proposed in \cite{artTinyCE}. However, it is quite rigid and almost impossible to adapt to the architecture presented here. To this end, we present in section \ref{chap2:sec:archi-tinyce-v2-cross-fertilisation}, a more flexible version of the latter.
\end{enumerate}

\mySubSubSection{Client Architecture}{}
\label{chap2:sec:archi-client-architecture}
The client (figure \ref{chap2:fig:architecture}(b)) is also based on three entities: a \textit{model}, an \textit{editing engine} and a \textit{storage module}. The model is responsible for organising and controlling the execution of tasks and user commands. For each new local workflow, the model generates an editing environment which is used by the editing engine to provide conventional facilities of structured document editors (compliance check, syntax highlighting, graphical editing of documents presentations, etc.). Each workflow is locally represented by a specification file and by one structured document representing the current perception of the overall workflow from the current local site. When reaching synchronisation phases, the local structured document is forwarded to the server site, where it is merged with others, in one structured document representing the current state of the overall workflow : it is therefore, a coordination support between the workflow engines of the client and of the server.


\mySubSubSection{The Middleware}{}
\label{chap2:sec:archi-middleware}
The middleware is responsible for the interaction between different tiers of our architecture. It must be designed so that, the coupling between these tiers is as weak as possible. One can for this purpose, consider a SOA in which:
\begin{itemize}
\item Our clients are service clients;
\item The server is a service provider for clients and a client of services offered by the administration tools;
\item The administration tools are service providers.
\end{itemize}
With such an architecture, we can guarantee the independence of each tier and thus, an easier maintenance.


\mySubSection{TinyCE v2}{}
\label{chap2:sec:archi-tinyce-v2}

\mySubSubSection{Presentation of TinyCE v2}{}
\label{chap2:sec:archi-tinyce-v2-presentation}
Due to its technical nature and to the number of technologies it needs for its instantiation, the architecture presented above has not yet been fully implemented. However, many of its components have already been implemented and tested in a test project called TinyCE v2\footnote{TinyCE v2 is a more advanced version of TinyCE \cite{artTinyCE}.} (a Tiny Cooperative Editor version 2).

TinyCE v2 is an editor prototype providing graphic and cooperative editing of the abstract structure of structured documents. It is used following a networked client-server model. Its user interface offers to the user, facilities for the creation of workflows (documents, grammars, actors and views (see fig. \ref{chap2:fig:workflow-creation})), edition and validation of partial replicas (see fig. \ref{chap2:fig:user-connexion}). 
Moreover, this interface also offers the functionality to experiment the concepts of projection, expansion and consensual merging (see fig. \ref{chap2:fig:workflow-merging}). TinyCE v2 is designed using Java and Haskell languages. It offers several implementations of our architecture concepts namely: parsers, storage modules, server's runtime engine, workflow engines and communication interfaces.
\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.85]{Chap2/images/WorkflowCreationEn.png}}
	\caption{Some screenshots showing the creation process of a cooperative editing workflow in TinyCE v2.}
	\label{chap2:fig:workflow-creation}
\end{figure}

\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.78]{Chap2/images/connexionUtilisateurEn.png}}
	\caption{Some screenshots of TinyCE v2 showing the authentication window of a co-author (Auteur1) as well as those displaying the various local and remote workflows in which he is implicated.}
	\label{chap2:fig:user-connexion}
\end{figure}

\begin{figure}[ht!]
	\noindent
	\makebox[\textwidth]{\includegraphics[scale=0.55]{Chap2/images/exemplefusionEn.png}}
	\caption{An illustration of consensual merging in TinyCE v2.}
	\label{chap2:fig:workflow-merging}
\end{figure}

\mySubSubSection{Java-Haskell Cross-Fertilisation in TinyCE v2}{}
\label{chap2:sec:archi-tinyce-v2-cross-fertilisation}
As in \cite{artTinyCE}, the runtime engine of TinyCE v2 exploits the possibility offered by Java, to run an "external program".  Indeed, we designed an interface of TinyCE v2 (runtime interface) capable of launching a Haskell interpreter (GHCi - Glasgow Haskell Compiler interactive\footnote{Official website of GHC: \url{http://www.haskell.org/ghc/}, visited the 04/04/2020.} - in this case) and make it execute various commands. When creating a workflow, TinyCE v2 generates a Haskell program file (.hs), containing data types and functions necessary to achieve the operations of projection, expansion and consensual merging on the structured document representing the state of that workflow. In this way, we considerably reduce the use frequency of parsers presented in \cite{artTinyCE}. The functions are more open to changes as they are contained in a text file and not in a compiled program as in \cite{artTinyCE}. In fact, the main differences between our Java-Haskell cross-fertilisation approach and the one of \cite{artTinyCE} are almost the same that drive the debates on interpreted and compiled languages; our approach is likened to interpreted languages and that of \cite{artTinyCE}, to compiled languages. So, even though our approach can present security risks (that can be addressed using PKI (Public Key Infrastructure) and standard encryption systems like AES (Advanced Encryption Standard), RSA (Rivest Shamir Adleman), etc.), it has the advantage of being portable and easier to maintain. 
\begin{comment}
We present a brief summary of this approach below.

~

\noindent\textbf{\textit{Implementation of the Runtime Interface}}

Haskell's GHC implementation is not just a compiler. It is therefore possible to create functions (programs) and have them executed (interpreted) in interactive mode thanks to its GHCi module. A Haskell program under GHC is a well-designed file with the extension \textit{.hs} similar to the one below, stored for example in a file named \textit{helloGHC.hs}:
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
module HelloGHC where
sayHello name = "Hello "++name
\end{Verbatim}

To execute this program in interactive mode, one just has to load the module with the command \Verb|:load| or its shortcut \Verb|:l| then to call the function \Verb|sayHello| in the following way (where \Verb|xxx| is an argument):
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
:load "helloGHC.hs"
sayHello xxx
\end{Verbatim}

Java allows to launch any executable program from a java code, and thus, to launch the GHCi interpreter of GHC. To execute a program in Java one can use the class \Verb|ILanguageRunner| defined in algorithm \ref{chap2:algo:java-interpreter}. 
\begin{algorithm}
\small
\caption{A generic Java class to run any executable file.}
\label{chap2:algo:java-interpreter}
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
import java.io.*;
public class ILanguageRunner{
	protected Process process = null;
	protected String language;
	protected String command;
	public ILanguageRunner(String language, String command){
		this.language = language;
		this.command = command;
	}
	public void startExecProcess() throws IOException{
		ProcessBuilder processBuilder = new ProcessBuilder(command);
		process = processBuilder.start();
	}
	public void killExecProcess(){
		if(process != null)
			process.destroy();
	}
	public void setExecCode(String code) throws IOException{...}
	public void getExecErrors() throws IOException{...}
	public String getExecResult() throws IOException{...}
	public String executeCode(String code) throws IOException{
		startExecProcess();
		setExecCode(code);
		getExecErrors();
		String result = getExecResult();
		killExecProcess();
		return result;
	}
}
\end{Verbatim}
\end{algorithm}
In this class,
\begin{itemize}
	\item the attributes \Verb|process|, \Verb|language| and \Verb|command| (algorithm \ref{chap2:algo:java-interpreter}, lines 3, 4 and 5) respectively represent the Java process allowing to launch the executable, the current language\footnote{Let's note that this code is designed for the execution of all types of interactive interpreters and not only for the execution of GHCi.} and the path to the executable;
	\item the method \Verb|startExecProcess| (algorithm \ref{chap2:algo:java-interpreter}, lines 10 to 13) builds the Java process from the current command. The method \Verb|killExecProcess| (algorithm \ref{chap2:algo:java-interpreter}, lines 14 to 17) destroys the process when it exists;
\end{itemize}
\begin{algorithm}
\small
\caption{The method setExecCode of the class ILanguageRunner.}
\label{chap2:algo:java-interpreter-setExecCode}
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
public void setExecCode(String code) throws IOException{
	OutputStream stdin = process.getOutputStream();
	OutputStreamWriter stdinWriter = new OutputStreamWriter(stdin);
	try{
		stdinWriter.write(code);
	}finally{
		try{stdinWriter.close();}catch(IOException e){}
		try{stdin.close();}catch(IOException e){}
	}
}
\end{Verbatim}
\end{algorithm}
\begin{itemize}
	\item the method \Verb|setExecCode| (algorithm \ref{chap2:algo:java-interpreter-setExecCode}) makes it possible to write the code to be executed on the standard input of the interpreter (this is the passing of arguments to the executed program);
\end{itemize}
\begin{algorithm}
\small
\caption{The method getExecErrors of the class ILanguageRunner.}
\label{chap2:algo:java-interpreter-getExecErrors}
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
public void getExecErrors() throws IOException{
	InputStream stdout = process.getErrorStream();
	InputStreamReader stdoutReader = new InputStreamReader(stdout);
	BufferedReader stdoutBuffer = new BufferedReader (stdoutReader);
	StringBuffer errorBuffer = null;
	try{
		String line = null;
		while((line = stdoutBuffer.readLine()) != null){
			if (errorBuffer == null)
				errorBuffer = new StringBuffer();
			errorBuffer.append(line);
		}
	}finally{
		try{stdoutBuffer.close();}catch(IOException e){}
		try{stdoutReader.close();}catch(IOException e){}
		try{stdout.close();}catch(IOException e){}
	}
	if(errorBuffer != null)
		throw new IOException(errorBuffer.toString());
}
\end{Verbatim}
\end{algorithm}
\begin{itemize}
	\item the method \Verb|getExecErrors| (algorithm \ref{chap2:algo:java-interpreter-getExecErrors}) makes it possible to recover the possible errors occurring during the execution of the code defined by \Verb|setExecCode| (the errors are returned in the form of a Java exception);
	\item the method \Verb|getExecResult| (algorithm \ref{chap2:algo:java-interpreter-getExecResult}) makes it possible to recover the possible results of the execution of the code defined by \Verb|setExecCode|;
\end{itemize}
\begin{algorithm}
\small
\caption{The method getExecResult of the class ILanguageRunner.}
\label{chap2:algo:java-interpreter-getExecResult}
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
public String getExecResult() throws IOException{
	InputStream stdout = process.getInputStream();
	InputStreamReader stdoutReader = new InputStreamReader(stdout);
	BufferedReader stdoutBuffer = new BufferedReader(stdoutReader);
	StringBuffer resultBuffer = null;
	try{
		String line = null;
		while((line = stdoutBuffer.readLine()) != null){
			if (resultBuffer == null)
				resultBuffer = new StringBuffer();
			resultBuffer.append(line);
		}
	}finally{
		try{stdoutBuffer.close();}catch(IOException e){}
		try{stdoutReader.close();}catch(IOException e){}
		try{stdout.close();}catch(IOException e){}
	}
	if(resultBuffer != null)
		return resultBuffer.toString();
	return null;
}
\end{Verbatim}
\end{algorithm}
\begin{itemize}
	\item finally, the method \Verb|executeCode| (algorithm \ref{chap2:algo:java-interpreter}, lines 21 to 28) executes any code. It starts a process, defines the code, recovers the errors if there are any, otherwise it recovers the result and then destroys the process.
\end{itemize}

A use of the above class \Verb|ILanguageRunner| for the execution of Haskell codes in interactive mode by GHCi can be done through the class \Verb|HaskellRunner| which inherits from \Verb|ILanguageRunner| and whose code is given in algorithm \ref{chap2:algo:java-haskel-interpreter}.
\begin{algorithm}
\small
\caption{A specialised Java class to run a Haskell program.}
\label{chap2:algo:java-haskel-interpreter}
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
import java.io.IOException;

public final class HaskellRunner extends ILanguageRunner{
	public HaskellRunner(){
		super("Haskell", "ghci");
	}
	@Override
	public String getExecResult() throws IOException{
		String execResult = super.getExecResult(), 
		       tmpString;
		if(execResult == null)
			return null;
		String[] tab = execResult.split("Prelude> ");
		if(tab.length == 2)
			tab = tab[1].split("\\*[a-zA-Z0-9_]{1,}>");
		StringBuilder goodResult = new StringBuilder();
		for(int i = 1; i < tab.length - 1; i++){
			tmpString = tab[i].trim();
			if(!tmpString.isEmpty()){
				goodResult.append(tmpString);
				goodResult.append("\n");
			}
		}
		return goodResult.toString();
	}
}
\end{Verbatim}
\end{algorithm}

In this class, the name of the command has been set to \Verb|ghci| (this implies that the path of the directory containing the GHCi program must be written in the \Verb|path| environment variable) and that of the language to \Verb|Haskell|. We redefined the method \Verb|getExecResult| to better format the result by removing the superfluous strings added by our current version of GHCi\footnote{HaskellPlatform-2014.2.0.0-i386}.

~

\noindent\textbf{\textit{Example of the Runtime Interface Use}}

One can run the Haskell engine with the code of algorithm \ref{chap2:algo:java-haskel-interpreter-example}. 
\begin{algorithm}
\small
\caption{Running a Haskell function with the proposed "Haskell interpreter".}
\label{chap2:algo:java-haskel-interpreter-example}
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
import java.io.IOException;
public class HelloTinyCE {
	public static void main(String[] args){
		HaskellRunner runner = new HaskellRunner();
		String nom = "\"Ange Frank, Chris Maxime and Yann Alex\"";
		String commande = ":load helloGHC.hs\nsayHello " + nom;
		try{
			String resultat = runner.executeCode(commande);
			System.out.println("The execution result is : " + 
								resultat);
		}catch(IOException ex){
			System.err.println("Some errors occured when" +
					" executing commands.");
		}
	}
}
\end{Verbatim}
\end{algorithm}
Executing this code gives the following result:
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
The execution result is : "Hello Ange Frank, Chris Maxime and Yann Alex"
\end{Verbatim}
If we replace the code on line 7 by the code \textit{String commande = ":load helloGHC.hs $\setminus$nsayHello";} then the result is now the following:
\begin{Verbatim}[fontsize=\small, numbers=left, numbersep=8pt]
Some errors occured when executing commands.
\end{Verbatim}

A version of the class \Verb|HaskellRunner| plays the role of "Haskell interpreter" within TinyCE v2. It allows a bidirectional communication between the TinyCE v2 model (coded in Java) and Haskell following a text-based protocol (well-formed strings following an XML-like coding) that we have implemented.
\end{comment}
