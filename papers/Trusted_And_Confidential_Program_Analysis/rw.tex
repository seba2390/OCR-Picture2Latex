
\myparagraph{\tee-based Technology}
The capabilities of \tee{}s have been widely exploited to achieve security, confidentiality and 
simplicity in many application domains. In the design of secure systems, Baumann~\etal 
proposed the notion of shielded execution on cloud platforms~\cite{baumann2015shielding}. 
Their work addresses the dual challenges of executing unmodified legacy binaries 
and protecting them from a malicious host. Similar ideas were adopted in data-processing 
and delegation-based systems to achieve integrity and security without trusting the service 
providers~\cite{hunt2018ryoan,matetic2018delegatee,schneider2019secure}. 
Moreover, Tsai~\etal demonstrated that a 
fully-featured library operating system 
can deploy unmodified applications with the support of a \tee{}~\cite{tsai2017graphene}. 
Shen~\etal further introduced secure and efficient multitasking on top of library 
operating systems with Intel SGX~\cite{shen2020occlum}. 
In the area of blockchain and cryptocurrency, \tee{}s are often considered a tool to enable 
trusted and privacy-preserving transactions. Matetic~\etal leveraged SGX enclaves 
to protect privacy of bitcoin light clients~\cite{matetic2019bite}. Cheng~\etal designed 
a \tee{}-based blockchain that executes transactions with confidential input, 
output and states~\cite{cheng2019ekiden}. Other attempts included building asynchronous 
access~\cite{lind2019teechain}, allowing real-time cryptocurrency exchange~\cite{bentov2019tesseract}, 
resource-efficient mining~\cite{zhang2017rem} and so on. Moreover, \tee{}s have also been 
involved in a diverse collection of optimizations on existing software and hardware, 
\eg, databases~\cite{sun2021building,zhou2021veridb,eskandarian2017oblidb,priebe2018enclavedb}, 
network functionalities~\cite{herwig2020achieving,duan2019lightbox,poddar2018safebricks}, 
storage systems~\cite{bailleu2021avocado,bailleu2019speicher,krahn2018pesos,arasu2017concerto}. 
In addition to applications of \tee{}s, their design has also been the topic on recent papers proposing improvements
interoperability~\cite{feng2016scalable,weiser2019timber}, performance~\cite{li2021confidential}, and
resilience~\cite{bahmani2021cure,dessouky2020hybcache}.

\myparagraph{Program Analysis}
Program analysis has been a mainstream research direction in the programming language 
community for decades. Formal verification techniques were proposed to verify high-level 
programs (usually specified in formal modeling languages) against given specifications 
of target systems, \eg, safety, liveness, \etc 
Clarke~\etal introduced the technology of model checking to systematically 
explore the state space of a system and check whether important properties hold or
not~\cite{clarke2009model}. Hoare and Roscoe proposed Communicating Sequential 
Processes (CSP) as a fundamental formalism to model and verify concurrent 
systems~\cite{hoare1978communicating,roscoe1998theory}. Alur~\etal further 
introduced timed automata to handle timed systems with properties based on 
temporal logic~\cite{alur1994theory}. In addition to automatic techniques, theorem proving 
was designed to deliver rigorous verification with manual or semi-automatic 
proofs~\cite{coquand1986calculus,nipkow2002isabelle}. On the other hand, program 
analysis has also been applied in practical systems with low-level code, \eg, C++, 
Java, x86 binary, JVM bytecode, \etc Based on whether the process requires actually 
executing a program, the analysis is generally categorized into two classes, \ie, static 
and dynamic analysis. In the context of static program analysis, a variety of researches 
have been proposed to address fundamental challenges of programs, \eg, understanding 
semantics~\cite{cousot1977abstract}, memory modeling~\cite{flanagan2002extended}, 
interprocedual analysis~\cite{reps1995precise,horwitz1990interprocedural}, 
multithreading~\cite{engler2003racerx}, \etc In contrast, dynamically approaches check 
programs by instrumenting the code and analyzing it on the fly. Representative types 
of solutions include fuzzing~\cite{rawat2017vuzzer,chen2018angora,godefroid2008grammar}, 
predictive analysis~\cite{flanagan2009fasttrack,bond2010pacer,burckhardt2010randomized} 
and symbolic execution~\cite{cadar2008klee,godefroid2012sage,chipounov2011s2e}. 
In general, the \tcpa framework proposed in this paper is compatible with well-defined 
types of program analysis and the combination of them as well.