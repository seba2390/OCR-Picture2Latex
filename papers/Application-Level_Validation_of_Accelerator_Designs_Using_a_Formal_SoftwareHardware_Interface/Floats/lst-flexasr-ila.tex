% \begin{figure*}[!htb]
% changed BITWIDTH to BITS because of column margins
\begin{figure}[!ht]
  \begin{minipage}[h]{0.31\textwidth}
    \vspace{-3\fboxsep}
    \caption{
    \textbf{ILA model (snippet) for FlexASR accelerator.}
    Lines 3-11 define the inputs and architectural state variables.
    Lines 14-22 show an example ILA instruction 
    ``\texttt{\small pe\_0\_cfg\_mngr}.'' 
    Its decode condition (lines 16-17) specifies that this instruction is triggered when there is a write command to the %address of the 
    processing element's (PE) management configuration register.
    Its state update functions (lines 19-22) specify that this instruction stores arguments from the interface inputs into the corresponding configuration registers. The state update functions of instructions such as for linear layer (elided here) %(not shown here as they are much longer) 
    encode their operational semantics.
    This snippet highlights:
    (1) similarity of ILA with ISA, and
    (2) the formal semantics based on how each instruction reads/writes the architectural state variables.
    }
    \label{fig.ila-example}
  \end{minipage}\hfill
  %\hspace{15pt}
  \begin{minipage}[h]{0.66\textwidth}
    \begin{lstlisting}[language=c]
auto m = ilang::Ila("flexasr-ila");
// declare inputs at the interface
auto wr = m.NewBvInput("top_if_wr", TOP_IF_WR_BITS);
auto rd = m.NewBvInput("top_if_rd", TOP_IF_RD_BITS);
auto addr = m.NewBvInput("top_addr_in", TOP_ADDR_IN_BITS);
auto data = m.NewBvInput("top_data_in", TOP_DATA_IN_BITS);
// declare architectural states
m.NewBvState("pe_0_is_valid", PE_VALID_BITS);
m.NewBvState("pe_0_is_bias", PE_IS_BIAS_BITS);
m.NewMemState("gb_large_buffer", TOP_ADDR_IN_BITS, TOP_DATA_IN_BITS);
// ... (some code)
// ILA instruction for configuring pe_cfg_mngr
auto instr = m.NewInstr("pe_0_cfg_mngr");
// define decode condition for this instruction
auto is_write = (wr == 1) & (rd == 0);
instr.SetDecode(is_write & (addr == PE_0_CFG_MNGR_ADDR));
// define state update functions for this instruction
auto is_valid = ilang::SelectBit(data, PE_IS_VALID_BIT_IDX);
instr.SetUpdate(m.state("pe_0_is_valid"), is_valid);
auto is_bias = ilang::SelectBit(data, PE_IS_BIAS_BIT_IDX);
instr.SetUpdate(m.state("pe_0_is_bias"), is_bias);
// ... (more code)
    \end{lstlisting}
  \end{minipage}%\hfill
\Description{}
\end{figure}