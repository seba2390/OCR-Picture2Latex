%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}
\footnotesize

\begin{tabular}{p{2.5cm}|cccc}
    \toprule
    \textbf{Build}
  & \textbf{Direct call}
  & \textbf{Indirect call}
  & \textbf{Callback}
  & \textbf{Syscall}
  \\
  \toprule
  \trnative (in C) &
  1ns & 56ns & 56ns & 24ns
  \\
%
  \trlucet &
  --- & 1137ns & --- & ---
  \\
%
  \trfullswitch &
  120ns & 209ns & 172ns & 192ns
  \\
%
  \trregsave &
  120ns & 210ns & 172ns & 192ns
  \\
%
  \textbf{\trfast} &
  \bf 7ns & \bf 66ns & \bf 67ns & \bf 60ns
  \\
  \midrule
  \trnative (in C, 32-bit) &
  1ns & 74ns & 74ns & 37ns
  \\
  %
  \trnacl &
  --- & 714ns & 373ns & 356ns
  \\
  %
  \textbf{\trsegmentsfi} &
  \bf 24ns & \bf 108ns & \bf 80ns & \bf 88ns
  \\
  \bottomrule
\end{tabular}

\caption{
%
Costs of transitions in different isolation models.
%
Zero-cost transitions are shown in \textbf{boldface}.
%
\trnative is the performance of an unsandboxed C function call, to serve as a baseline.
}
\label{fig:transition-overheads}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{The cost of transitions}
\label{subsec:eval-transitions}
%
We measure the cost of different cross-domain transitions\dash---direct and
indirect calls into the sandbox, callbacks from the sandbox, and syscall
invocations from the sandbox\dash---for the different system builds
described above.
%
To expose overheads fully, we choose extremely fast payloads---either a
function that just adds two numbers or the \gettimeofday syscall,
which relies on Linux's vDSO to avoid CPU ring changes.
%
The results are shown in \figref{fig:transition-overheads}.
%
All numbers are averages of one million repetitions, and repeated runs have
negligible standard deviation.\footnote{
%
Lucet and NaCl don't support direct sandbox
calls; Lucet further does not support custom callbacks or syscall invocations.
}

We make several observations.
%
First, among Wasm-based SFI schemes, zero-cost transitions (\trfast) are
significantly faster than even optimized heavyweight transitions
(\trfullswitch).
%
Lucet's existing indirect calls written in Rust (\trlucet) are significantly
slower than both.
%
Second, the cost of stack switching (the difference of \trfullswitch and
\trregsave) is surprisingly negligible.
%
Third, the performance of \trnative and \trfast should be identical but is not.
%
This is \emph{not} because our transitions have a hidden cost. Rather, it's
because we are comparing code produced by two different compilers:
\trnative is native code produced by Clang,  while \trfast is code produced by
Lucet, and Lucet's code generation is not yet highly
optimized~\cite{cranelift-speedup}.
%
For example, in the benchmark that adds two numbers, Clang eliminates
the function prologue and epilogue that save and restore the frame
pointer, while Lucet does not.
%
%
We observe similar trends for hardware-based isolation.
%
For example, we find that \trsegmentsfi transitions are much faster than
\tridealheavy and \trnacl transitions and only \tranSegzeroNativeFuncDiff
slower than \trnative for direct calls.
%
Finally, we observe that \trsegmentsfi is slower than \trfast: hardware
isolation schemes like \trsegmentsfi and \trnacl execute instructions to enable
or disable the hardware based memory isolation in their transitions.
