\section{Overlay Semantics}
\label{appendix:overlay}

\figref{fig:appendix:overlay:operational},
\figref{fig:appendix:overlay:operational-aux-judgments}, and
\figref{fig:appendix:overlay:operational-aux-definitions} define the overlay
monitor operational semantics.
%
The semantics are parameterized by a confidentiality policy $\mathbb{C}$.

\begin{center}
  \begin{tabular}{>{$}r<{$} >{$}c<{$} >{$}r<{$} >{$}c<{$} >{$}l<{$}}
    \vals & \ni & \oc{v} & \bnfdef & \val{n}{p} \\

    \frames & \ni & \oc{\SF} & \bnfdef &
      \begin{array}[t]{lllll}
        \{
        & \mathit{base} & \bnftypes & \nats \\
        & \mathit{ret\mbox{-}addr\mbox{-}loc} & \bnftypes & \nats \\
        & \mathit{csr\mbox{-}vals} & \bnftypes & \powerset{\regs \times \nats} & \}
      \end{array} \\

    \functions & \ni & \oc{F} & \bnfdef &
      \begin{array}[t]{lllll}
        \{
        & \mathit{instrs} & \bnftypes & \nats \rightharpoonup \commands \\
        & \mathit{entry} & \bnftypes & \nats \\
        & \mathit{type} & \bnftypes & \nats & \}
      \end{array} \\

    \ostates & \ni & \oc{\Phi} & \bnfdef & \oerror \\
    & & & \bnfalt &
      \begin{array}[t]{lllll}
        \{
        & \Psi & \bnftypes & \states \\
        & \mathit{funcs} & \bnftypes & \nats \rightharpoonup \functions \\
        & \mathit{stack} & \bnftypes & [\frames] & \}
      \end{array}
  \end{tabular}
  \captionof{figure}{Overlay Extended Syntax}
  \label{fig:appendix:syntax:overlay}
\end{center}

\begin{center}
  \judgmentHead{}{\currentop{\Psi}{c} \ostep \Psi'}
  \begin{mathpar}
    \inferrule
    {
      \val{n}{p_e} = \oimmval{\oc{\Phi}}{e}
      \\ n' = k(n)
      \\ sp' = \oc{\Phi}.sp + 1
      \\ M' = \oc{\Phi}.M[sp' \mapsto \oc{\Phi}.pc + 1]
      \\\\ \oname{typechecks}(\oc{\Phi}, n', sp')
      \\ \oc{\SF} = \oname{new-frame}(\oc{\Phi}, n', sp')
      \\ p_e \lesstrusted \untrusted
    }
    {\currentcom{\oc{\Phi}}{\ccall{k}{e}}{\untrusted} \ostep \oc{\Phi}[\mathit{stack} \assign [\oc{\SF}] \concat \oc{\Phi}.\mathit{stack}, pc \assign n', sp \assign sp', M \assign M'] }

    \inferrule
    {
      \oname{is-ret-addr-loc}(\oc{\Phi}, \oc{\Phi}.sp)
      \\ \natval{n} = \oc{\Phi}.M(\oc{\Phi}.sp)
      \\ n' = k(n)
      \\\\ \oname{csr-restored}(\oc{\Phi})
      \\ \oc{\Phi'} = \oname{pop-frame}(\oc{\Phi})
    }
    {\currentcom{\oc{\Phi}}{\cret{k}}{\untrusted} \ostep \oc{\Phi'}[pc \assign n', sp \assign \oc{\Phi}.sp - 1]}

    \inferrule
    {
      \natval{n'} = \oimmval{\oc{\Phi}}{e}
      \\ sp' = \oc{\Phi}.sp + 1
      \\ M' = \oc{\Phi}.M[sp' \mapsto \oc{\Phi}.pc + 1]
      \\\\ n' \in I
      \\ \oname{typechecks}(\oc{\Phi}, n', sp')
      \\ \oname{args-secure}(\oc{\Phi}, sp', n)
      \\ \oc{\SF} = \oname{new-frame}(\oc{\Phi}, n', sp')
    }
    {\currentcom{\oc{\Phi}}{\cgatecall{n}{e}}{\untrusted} \ostep \oc{\Phi}[\mathit{stack} \assign [\oc{\SF}] \concat \oc{\Phi}.\mathit{stack}, pc \assign n', sp \assign sp', M \assign M']}

    \inferrule
    {
      \oc{\Phi'} = \oname{classify}_{\mathbb{C}}(\oc{\Phi})
      \\ \natval{n'} = \oimmval{\oc{\Phi'}}{e}
      \\ sp' = \oc{\Phi'}.sp + 1
      \\\\ M' = \oc{\Phi'}.M[sp' \mapsto \oc{\Phi'}.pc + 1]
      \\ \oc{\SF} = \oname{new-frame}(\oc{\Phi'}, n', sp')
    }
    {\currentcom{\oc{\Phi}}{\cgatecall{n}{e}}{\trusted} \ostep \oc{\Phi'}[\mathit{stack} \assign [\oc{\SF}] \concat \oc{\Phi'}.\mathit{stack}, pc \assign n', sp \assign sp', M \assign M']}

    \inferrule
    {
      \currentop{\oc{\Phi}}{\cret{}} \ostep \oc{\Phi'}
      \\ p' \lesstrusted p
      \\\\ \val{n}{p'} = \oc{\Phi}.R(r_{ret})
    }
    {\currentcom{\oc{\Phi}}{\cgateret}{p} \ostep \oc{\Phi'}}

    \inferrule
    {
      \oc{v} = \oimmval{\oc{\Phi}}{e}
      \\ sp' = \oc{\Phi}.sp + 1
      \\ sp' \in S_p
      \\\\ M' = \oc{\Phi}.M[sp' \mapsto \oc{v}]
      \\ \oname{writeable}(\oc{\Phi}, sp')
    }
    {\currentop{\oc{\Phi}}{\cpush{p}{e}} \ostep \pcinc{\oc{\Phi}}[sp \assign sp', M \assign M']}

    \inferrule
    {
      \val{n}{p_e} = \oimmval{\oc{\Phi}}{e}
      \\ \oc{v} = \val{\_}{p_{e'}} = \oimmval{\oc{\Phi}}{e'}
      \\\\ M' = \oc{\Phi}.M[n' \mapsto \oc{v}]
      \\ \oname{writeable}(\oc{\Phi}, n')
      \\\\ n' = k(n)
      \\ p_e \lesstrusted p
      \\ p_{e'} \nlesstrusted p \Longrightarrow n' \notin H_{\untrusted}
    }
    {\currentcom{\oc{\Phi}}{\cstore{k}{e}{e'}}{p} \ostep \pcinc{\oc{\Phi}}[M \assign M']}

    \inferrule
    {
      \val{n}{p_e} = \oimmval{\oc{\Phi}}{e}
      \\ n' = k(n)
      \\ p_e \lesstrusted p
      \\\\ \oc{v} = \val{\_}{p_{n'}} = \oc{\Phi}.M(n')
      \\ R' = \oc{\Phi}.R[r \mapsto \oc{v}]
    }
    {\currentcom{\oc{\Phi}}{\cload{r}{k}{e}}{p} \ostep \pcinc{\oc{\Phi}}[R \assign R']}

    \inferrule
    {
      \val{v}{p_e} = \oimmval{\oc{\Phi}}{e}
      \\ p_e \lesstrusted p
    }
    {\currentcom{\oc{\Phi}}{\cmov{sp}{e}}{p} \ostep \pcinc{\oc{\Phi}}[sp \assign v]}

    \inferrule
    {
      \val{n}{p_e} = \oimmval{\oc{\Phi}}{e}
      \\ n' = k(n)
      \\\\ p_e \lesstrusted p
      \\ \oname{in-same-func}(\oc{\Phi}, \oc{\Phi}.pc, n')
    }
    {\currentcom{\oc{\Phi}}{\cjmp{k}{e}}{p} \ostep \oc{\Phi}[pc \assign n']}

    \inferrule
    {
      p_r \nlesstrusted p' \Longrightarrow p_r \lesstrusted p
      \\\\ \val{n}{p_r} = \oc{\Phi}.R(r)
      \\ R' = \oc{\Phi}.R[r \assign \val{n}{p'}]
    }
    {\currentcom{\oc{\Phi}}{\cmovlabel{r}{p'}}{p} \ostep \pcinc{\oc{\Phi}}[R \assign R']}

    \inferrule
    {
      \val{n}{p_e} = \oimmval{\oc{\Phi}}{e}
      \\ \val{m}{p_m} = \oc{\Phi}.M(n)
      \\ p_e \lesstrusted p
      \\\\ M' = \oc{\Phi}.M[n \assign \val{m}{p'}]
      \\ p_m \nlesstrusted p' \Longrightarrow p_m \lesstrusted p
    }
    {\currentcom{\oc{\Phi}}{\cstorelabel{p'}{e}}{p} \ostep \pcinc{\oc{\Phi}}[M \assign M']}

    \inferrule
    {
      \currentop{\oc{\Phi}.\Psi}{c} \step \Psi'
      \\\\ \oname{in-same-func}(\oc{\Phi}, \oc{\Phi}.\Psi.pc, \Psi'.pc)
    }
    {\currentop{\oc{\Phi}}{c} \ostep \oc{\Phi}[\Psi \assign \Psi']}
  \end{mathpar}
  \captionof{figure}{Overlay Operational Semantics}
  \label{fig:appendix:overlay:operational}
\end{center}

\begin{center}
  \begin{mathpar}
    \inferrule
    {
      [\oc{\SF}] \concat \_ = \oc{\Phi}.\mathit{stack}
      \\\\ n \in S_p \Longrightarrow
      n \geq \oc{\SF}.\mathit{base} \wedge
      n \neq \oc{\SF}.\mathit{ret\mbox{-}addr\mbox{-}loc}
    }
    {\oname{writeable}(\oc{\Phi}, n)}

    \inferrule
    {
      F = \oc{\Phi}.\mathit{funcs}(\mathit{target})
      \\ F.\mathit{entry} = \mathit{target}
      \\\\ sp \in S_p
      \\ [\oc{\SF}] \concat \_ = \oc{\Phi}.\mathit{stack}
      \\\\ sp \geq \oc{\SF}.\mathit{ret\mbox{-}addr\mbox{-}loc} + \oc{F}.\mathit{type}
    }
    {\oname{typechecks}(\oc{\Phi}, \mathit{target}, sp)}

    \inferrule
    {
      [\oc{\SF}] \concat \_ = \oc{\Phi}.\mathit{stack}
      \\\\ \mathit{ret\mbox{-}addr\mbox{-}loc} = \oc{\SF}.\mathit{ret\mbox{-}addr\mbox{-}loc}
    }
    {\oname{is-ret-addr-loc}(\oc{\Phi}, \mathit{ret\mbox{-}addr\mbox{-}loc})}

    \inferrule
    {
      [\oc{\SF}] \concat \_ = \oc{\Phi}.\mathit{stack}
      \\\\ \forall (r, n) \in \oc{\SF}.\mathit{csr\mbox{-}vals}.~ \oc{\Phi}.R(r) = n
    }
    {\oname{csr-restored}(\oc{\Phi})}

    \inferrule
    {
      \oc{F} \in \cod{\oc{\Phi}.\mathit{funcs}}
      \\ n, n' \in \dom{\oc{F}.\mathit{instrs}}
    }
    {\oname{in-same-func}(\oc{\Phi}, n, n')}

    \inferrule
    {
      \forall \oc{F} \in \cod{\oc{\Phi}.\mathit{funcs}}.~ n \notin \dom{\oc{F}.\mathit{instrs}}
    }
    {\oname{in-same-func}(\oc{\Phi}, n, n')}

    \inferrule
    {\forall i \in [1, n].~ \oc{\Phi}.M(sp - i) = \val{\_}{\untrusted}}
    {\oname{args-secure}(\oc{\Phi}, sp, n)}
  \end{mathpar}
  \captionof{figure}{Overlay Operational Semantics: Auxiliary Judgments}
  \label{fig:appendix:overlay:operational-aux-judgments}
\end{center}

\begin{center}
  \[\begin{array}{rcl}
    \oname{new-frame}(\oc{\Phi}, \mathit{target}, \mathit{ret\mbox{-}addr\mbox{-}loc}) & \triangleq &
      \begin{array}[t]{lllll}
        \{
        & \mathit{base} & = & \mathit{ret\mbox{-}addr\mbox{-}loc} - \oc{\Phi}.\mathit{funcs}(\mathit{target}).\mathit{type} \\
        & \mathit{ret\mbox{-}addr\mbox{-}loc} & = & \mathit{ret\mbox{-}addr\mbox{-}loc} \\
        & \mathit{csr\mbox{-}vals} & = & \{(r, \oc{\Phi}.R(r))\}_{r \in \mathbb{CSR}} & \}
      \end{array} \\
    \\
    \oname{pop-frame}(\oc{\Phi}) & \triangleq & \oc{\Phi}[\mathit{stack} \assign S] \quad \text{where } [\oc{\SF}] \concat S = \oc{\Phi}.\mathit{stack} \\
    \\
    \pcinc{\oc{\Phi}} & \triangleq &
      \begin{cases}
        \oc{\Phi}[\Psi \assign \pcinc{\Psi}] & \oname{in-same-func}(\oc{\Phi}, \oc{\Phi}.pc, \oc{\Phi}.pc + 1) \\
        \oerror & \text{otherwise}
      \end{cases} \\
      \\
      \oname{classify}_{\mathbb{C}}(\oc{\Phi}) & \triangleq &
      \oc{\Phi}[M \assign M', R \assign R'] \\
      & & \text{where } M'(n) = \val{\natval{\oc{\Phi}.M(n)}}{\mathbb{C}(\oc{\Phi}.\Psi)(n)} \\
      & & \phantom{\text{where }} R'(r) = \val{\natval{\oc{\Phi}.R(r)}}{\mathbb{C}(\oc{\Phi}.\Psi)(r)} \\
      \\
      \oimmval{\Psi}{\oc{v}} & \triangleq & \oc{v} \\
      \oimmval{\Psi}{r} & \triangleq & \Psi.R(r) \\
      \oimmval{\Psi}{sp} & \triangleq & \val{\Psi.sp}{\untrusted} \\
      \oimmval{\Psi}{pc} & \triangleq & \val{\Psi.pc}{\untrusted} \\
      \oimmval{\Psi}{e \oplus e'} & \triangleq & \val{v \oplus v'}{p \sqcup p'} \\
      & & \text{where } \val{v}{p} = \oimmval{\Psi}{e} \\
      & & \phantom{\text{where }} \val{v'}{p'} = \oimmval{\Psi}{e'} \\
      \\
      \natval{n} & \triangleq & \val{n}{\_} \\
      \\
      \trusted \sqcup p & \triangleq & \trusted \\
      p \sqcup \trusted & \triangleq & \trusted \\
      \untrusted \sqcup \untrusted & \triangleq & \untrusted \\
  \end{array}\]
  \captionof{figure}{Overlay Operational Semantics: Auxiliary Definitions}
  \label{fig:appendix:overlay:operational-aux-definitions}
\end{center}

\begin{lemma}[Overlay is a refinement] \label{appendix:overlay:refinement}
  For any $\oPhi \ostep \oc{\Phi'}$, if $\oc{\Phi'} \neq \oerror$, then $\oPhi.\Psi \step \oc{\Phi'}.\Psi$
\end{lemma}

\begin{lemma}[Overlay is equivalent on application reduction] \label{appendix:overlay:application-equivalent}
  For any $\oPhi$, if $\oPhi.\Psi \stephigh \Psi'$, then $\oPhi \ostep \{\Psi \assign \Psi', \mathit{funcs} \assign \oPhi.\mathit{funcs}, \mathit{stack} \assign \oPhi.\mathit{stack}\}$.
\end{lemma}

\begin{theorem}[Overlay Integrity Soundness] \label{thm:appendix:overlay-integrity-soundness}
  If $\oc{\Phi_0} \in \programs$, $\oc{\Phi_0} \ostepn{n} \oc{\Phi_1}$,
  $\currentcom{\oc{\Phi_1}}{\_}{\trusted}$, and
  $\oc{\Phi_1} \ostepstar \oc{\Phi_2}$ such that $\oc{\Phi_1}.\Psi \stepwb
  \oc{\Phi_2}.\Psi$ with $\pi = \oc{\Phi_0}.\Psi \stepn{n} \oc{\Phi_1}.\Psi$, then
  \begin{enumerate}
  \item $\mathcal{CSR}(\pi, \oc{\Phi_1}.\Psi, \oc{\Phi_2}.\Psi)$
  \item $\mathcal{RA}(\pi, \oc{\Phi_1}.\Psi, \oc{\Phi_2}.\Psi)$
  \end{enumerate}
\end{theorem}
\begin{proof}
  By induction over the definition of a well-bracketed step and nested induction
  over the logical call stack.
  %
  The last step follows by the fact that $\oc{\Phi_2} \neq \oerror$, and
  therefore the restoration checks in the overlay monitor passed.
\end{proof}

\begin{theorem}[Overlay Confidentiality Soundness] \label{thm:appendix:overlay-confidentiality-soundness}
  If $\oc{\Phi_0} \in \programs$, $\currentcom{\oc{\Phi_1}}{\_}{\untrusted}$,
  $\currentcom{\oc{\Phi_3}}{\_}{\trusted}$, $\oc{\Phi_0}.\Psi \stepstar
  \oc{\Phi_1}.\Psi \steplown{n} \oc{\Phi_2}.\Psi \step \oc{\Phi_3}.\Psi$,
  $\oc{\Phi_1} \ostepn{n + 1} \oc{\Phi_3}$, and $\oc{\Phi_1} =_{\untrusted}
  \oc{\Phi_1'}$,
  %
  then $\oc{\Phi_1'}.\Psi \steplown{n} \oc{\Phi_2'}.\Psi \step \oc{\Phi_3'}.\Psi$,
  $\oc{\Phi_1'} \ostepn{n + 1} \oc{\Phi_3'}$
  $\currentcom{\oc{\Phi_3'}}{\_}{\trusted}$, $\oc{\Phi_3}.pc = \oc{\Phi_3'}.pc$,
  and
  \begin{enumerate}
  \item $\currentop{\oc{\Phi_2}}{\cgatecall{n'}{e}}$, $\currentop{\oc{\Phi_2'}}{\cgatecall{n'}{e}}$, and $\oc{\Phi_3} =_{\mathtt{call}\ n'} \oc{\Phi_3'}$ or
  \item $\currentop{\oc{\Phi_2}}{\cgateret}$, $\currentop{\oc{\Phi_2'}}{\cgateret}$, and $\oc{\Phi_3} =_{\mathtt{ret}} \oc{\Phi_3'}$,
  \end{enumerate}
\end{theorem}
\begin{proof}
  Proof is standard for an IFC enforcement system.
\end{proof}