\section{Language Definitions}
\label{appendix:language-defs}

\figref{fig:appendix:syntax:lang} presents the syntax of our sandbox language model.
%
For all programs we define the regions $M$, $M_p$, $H_p$, $S_p$, $C_p$, and $I$.
%
$M = \nats$ and represents the whole memory space.
%
$M_p$, $H_p$, and $S_p$ are the memory, heap, and stack of the application or library where the heap and stack sit disjointly inside the memory.
%
$C_p$ is set of instruction indices such that $C(n) = (p, \_)$.
%
$I$ is the set of import indices, the beginnings of application functions that the library is allowed to jump to.

A note on calling convention: arguments are passed on the stack and the return
address is placed above the arguments.

\begin{center}
  \begin{tabular}{>{$}r<{$} >{$}c<{$} >{$}r<{$} >{$}c<{$} >{$}l<{$}}
    & & pc, sp, n, \ell & \in & \nats \\
    \privs & \ni & p & \bnfdef & \trusted \bnfalt \untrusted \\
    \vals & \ni & v & \bnfdef & n \\
    \regs & \ni & r & \bnfdef & \mathtt{r}_{n} \bnfalt sp \bnfalt pc \\
    \checks & \ni & k & \in & \nats \rightharpoonup \nats \\

    \expressions & \ni & e & \bnfdef & r \bnfalt v \bnfalt e \oplus e \\

    \commands & \ni & c & \bnfdef & \cpop{r}{p} \\
    & & & \bnfalt & \cpush{p}{e} \\
    & & & \bnfalt & \cload{r}{k}{e} \\
    & & & \bnfalt & \cstore{k}{e}{e} \\
    & & & \bnfalt & \cmov{r}{e} \\
    & & & \bnfalt & \ccall{k}{e} \\
    & & & \bnfalt & \cret{k} \\
    & & & \bnfalt & \cjmp{k}{e} \\
    & & & \bnfalt & \cgatecall{n}{e} \\
    & & & \bnfalt & \cgateret \\

    \codes & \ni & C & \bnfdef & \nats \rightharpoonup \privs \times \commands \\
    \regvals & \ni & R & \bnfdef & \regs \rightarrow \vals \\
    \memories & \ni & M & \bnfdef & \nats \rightarrow \vals \\
    \states & \ni & \Psi & \bnfdef & \error \\
    & & & \bnfalt &
      \begin{array}[t]{lllll}
        \{
        & pc & \bnftypes & \nats \\
        & sp & \bnftypes & \nats \\
        & R & \bnftypes & \regvals \\
        & M & \bnftypes & \memories \\
        & C & \bnftypes & \codes & \}
      \end{array}
  \end{tabular}
  \captionof{figure}{Syntax}
  \label{fig:appendix:syntax:lang}
\end{center}

\figref{fig:appendix:operational} and
\figref{fig:appendix:operational:auxiliary} define the base small-step
operational semantics.
%
We separate this into transitions $\currentop{\Psi}{c} \step \Psi'$ and error transitions $\currentop{\Psi}{c} \step \error$.

\begin{center}
  \judgmentHead{}{\currentop{\Psi}{c} \step \Psi'}
  \begin{mathpar}
    \inferrule
    {
      \Psi.sp \in S_{p_s}
      \\ p_s \lesstrusted p
      \\\\ v = \Psi.M(\Psi.sp)
      \\ R' = R[r \mapsto v]
    }
    {\currentop{\Psi}{\cpop{r}{p}} \step \pcinc{\Psi}[sp \assign \Psi.sp - 1, R \assign R']}

    \inferrule
    {
      v = \immval{\Psi}{e}
      \\ sp' = \Psi.sp + 1
      \\\\ M' = \Psi.M[sp' \mapsto v]
      \\ sp' \in S_{p_s}
      \\ p_s \lesstrusted p
    }
    {\currentop{\Psi}{\cpush{p}{e}} \step \pcinc{\Psi}[sp \assign sp', M \assign M']}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\n' = k(n)
      \\\\ v = \Psi.M(n')
      \\ R' = \Psi.R[r \mapsto v]
    }
    {\currentop{\Psi}{\cload{r}{k}{e}} \step \pcinc{\Psi}[R \assign R']}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\ v = \immval{\Psi}{e'}
      \\\\ n' = k(n)
      \\ M' = \Psi.M[n' \mapsto v]
    }
    {\currentop{\Psi}{\cstore{k}{e}{e'}} \step \pcinc{\Psi}[M \assign M']}

    \inferrule
    {
      v = \immval{\Psi}{e}
      \\ R' = \Psi.R[r \mapsto v]
    }
    {\currentop{\Psi}{\cmov{r}{e}} \step \pcinc{\Psi}[R \assign R']}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\ n' = k(n)
      \\ sp' = \Psi.sp + 1
      \\\\ M' = \Psi.M[sp' \mapsto \Psi.pc + 1]
      \\ sp' \in S_{p_s}
    }
    {\currentop{\Psi}{\ccall{k}{e}} \step \Psi[pc \assign n', sp \assign sp', M \assign M']}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\ n' = k(n)
    }
    {\currentop{\Psi}{\cjmp{k}{e}} \step \Psi[pc \assign n']}

    \inferrule
    {
      n = \Psi.M(\Psi.sp)
      \\\\ n' = k(n)
      \\ \Psi.sp \in S_{p_s}
    }
    {\currentop{\Psi}{\cret{k}} \step \Psi[pc \assign n', sp \assign \Psi.sp - 1]}

    \inferrule
    {
      v = \immval{\Psi}{e}
    }
    {\currentop{\Psi}{\cmov{sp}{e}} \step \pcinc{\Psi}[sp \assign v]}
  \end{mathpar}
  \captionof{figure}{Operational Semantics}
  \label{fig:appendix:operational}
\end{center}

\begin{center}
  \judgmentHead{}{\currentop{\Psi}{c} \step \error}
  \begin{mathpar}
    \inferrule
    {
      \Psi.sp \in S_{p_s}
      \\ p_s \nlesstrusted p
    }
    {\currentop{\Psi}{\cpop{r}{p}} \step \error}

    \inferrule
    {
      \Psi.sp + 1 \in S_{p_s}
      \\ p_s \nlesstrusted p
    }
    {\currentop{\Psi}{\cpush{p}{e}} \step \error}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\ k(n) \text{ undefined}
    }
    {\currentop{\Psi}{\cload{r}{k}{e}} \step \error}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\ k(n) \text{ undefined}
    }
    {\currentop{\Psi}{\cstore{k}{e}{e'}} \step \error}

    \inferrule
    {
      \\ \Psi.sp + 1 \notin S_{p_s}
    }
    {\currentop{\Psi}{\ccall{k}{e}} \step \error}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\ k(n) \text{ undefined}
    }
    {\currentop{\Psi}{\ccall{k}{e}} \step \error}

    \inferrule
    {
      \\ \Psi.sp \notin S_{p_s}
    }
    {\currentop{\Psi}{\cret{k}} \step \error}

    \inferrule
    {
      n = \Psi.M(\Psi.sp)
      \\ k(n) \text{ undefined}
    }
    {\currentop{\Psi}{\cret{k}} \step \error}

    \inferrule
    {
      n = \immval{\Psi}{e}
      \\ k(n) \text{ undefined}
    }
    {\currentop{\Psi}{\cjmp{k}{e}} \step \error}
  \end{mathpar}
  \captionof{figure}{Operational Semantics}
  \label{fig:appendix:operational:errors}
\end{center}

\begin{center}
  \begin{mathpar}
    \inferrule
    {C(\Psi.pc) = (\_, c)}
    {\currentop{\Psi}{c}}

    \inferrule
    {C(\Psi.pc) = (p, c)}
    {\currentcom{\Psi}{c}{p}}

    \inferrule
    {
      \Psi \stepstar \Psi'
      \\\\ \neg \exists \Psi''.~ \Psi' \step \Psi''
      \\ \Psi' \neq \error
    }
    {\Psi \evalsto \Psi'}

    \untrusted \lesstrusted \trusted
  \end{mathpar}

  \[\begin{array}{rcl}
    \immval{\Psi}{v} & \triangleq & v \\
    \immval{\Psi}{r} & \triangleq & \Psi.R(r) \\
    \immval{\Psi}{sp} & \triangleq & \Psi.sp \\
    \immval{\Psi}{pc} & \triangleq & \Psi.pc \\
    \immval{\Psi}{e \oplus e'} & \triangleq & \immval{\Psi}{e} \oplus \immval{\Psi}{e'} \\
    \\
    \pcinc{\Psi} & \triangleq &
    \begin{cases}
      \Psi[pc \assign \Psi.pc + 1] & \text{when } \pi_1(\Psi.C(\Psi.pc)) = \pi_1(\Psi.C(\Psi.pc + 1)) \\
      \error & \text{otherwise}
    \end{cases}
  \end{array}\]
  
  \captionof{figure}{Operational Semantics: Auxiliary Definitions}
  \label{fig:appendix:operational:auxiliary}
\end{center}

\figref{fig:appendix:operational:derived-forms} defines unguarded derived forms for memory operations.

\begin{center}
  \[\begin{array}{rcl}
    \cpop{r}{} & \triangleq & \cpop{r}{\top} \\
    \cpush{}{e} & \triangleq & \cpush{\top}{e} \\
    \cload{r}{}{e} & \triangleq & \cload{r}{id}{e} \\
    \cstore{}{e}{e'} & \triangleq & \cstore{id}{e}{e'} \\
    \cjmp{}{e} & \triangleq & \cjmp{id}{e} \\
    \ccall{}{e} & \triangleq & \ccall{id}{e} \\
    \cret{} & \triangleq & \cret{id} \\
  \end{array}\]
  \captionof{figure}{Derived Forms}
  \label{fig:appendix:operational:derived-forms}
\end{center}

\subsection{Sandbox Properties}

\begin{center}
  \begin{mathpar}
    \inferrule
    {
      \Psi_1 \step \Psi_2
      \\ \currentcom{\Psi_1}{c_1}{p_1}
      \\\\ \currentcom{\Psi_2}{c_2}{p_2}
      \\ p_1 = p_2 = p
    }
    {\Psi_1 \stepp{p} \Psi_2}

    \inferrule
    {\Psi \stepp{p} \Psi'}
    {\Psi \stepbox \Psi'}

    \inferrule
    {\Psi \stepwb \Psi'}
    {\Psi \stepbox \Psi'}

    \inferrule
    {
      \Psi \step \Psi_1 \stepboxstar \Psi_2 \step \Psi'
      \\\\ \currentop{\Psi}{\cgatecall{n}{e}}
      \\ \currentop{\Psi_2}{\cgateret}
    }
    {\Psi \stepwb \Psi'}
  \end{mathpar}
  \captionof{figure}{Well-Bracketed Transitions}
  \label{fig:appendix:well-bracketed-step}
\end{center}

\subsubsection{Integrity}

Integrity is all about maintaining application invariants across calls into the sandbox.
%
These invariants vary significantly from program to program, so to capture this
generality we define $\mathcal{I}$-Integrity and then instantiate it in several
specific instances.

\begin{definition}[$\mathcal{I}$-Integrity]{~}
  Let $\mathcal{I} : \mathit{Trace} \times \mathit{State} \times \mathit{State} \rightarrow \prop$.
  % 
  We say that an SFI transition systems has $\mathcal{I}$-integrity if
  $\Psi_0 \in \programs$, $\pi = \Psi_0 \stepstar \Psi_1$,
  $\currentcom{\Psi_1}{\_}{\trusted}$, and $\Psi_1 \stepwb \Psi_2$ imply that
  $\mathcal{I}(\pi, \Psi_1, \Psi_2)$.
\end{definition}

Informally, callee-save register integrity says that the values of callee-save registers are restored by gated calls into the sandbox:
\begin{definition}[Callee-Save Register Integrity]{~}

  Let $\mathbb{CSR}$ be the list of callee-save registers and define
  \[
    \mathcal{CSR}(\_, \Psi_1, \Psi_2) \triangleq \Psi_1.R(\mathbb{CSR}) = \Psi_2.R(\mathbb{CSR}).
  \]
  %
  If an SFI transition system has $\mathcal{CSR}$-integrity then we say the system has callee-save register integrity.
\end{definition}

\begin{center}
  \begin{align*}
    \operatorname{return-address}_p & : \mathit{Trace} \rightarrow \powerset{\nats}
    \\
    \operatorname{return-address}_p(\Psi_0 \stepstar \currentcom{\Psi}{\ccall{k}{e}}{p} \step \Psi') & \triangleq \operatorname{return-address}_p(\Psi_0 \stepstar \Psi) \cup \{\Psi.sp + 1\}
    \\
    \operatorname{return-address}_p(\Psi_0 \stepstar \currentcom{\Psi}{\cret{k}}{p} \step \Psi') & \triangleq \operatorname{return-address}_p(\Psi_0 \stepstar \Psi) - \{\Psi.sp\}
    \\
    \operatorname{return-address}_p(\Psi_0 \stepstar \currentcom{\Psi}{\cgatecall{n}{e}}{p} \step \Psi') & \triangleq \operatorname{return-address}_p(\Psi_0 \stepstar \Psi) \cup \{\Psi.sp + 1\}
    \\
    \operatorname{return-address}_p(\Psi_0 \stepstar \currentcom{\Psi}{\cgateret}{p} \step \Psi') & \triangleq \operatorname{return-address}_p(\Psi_0 \stepstar \Psi) - \{\Psi.sp\}
    \\
    \operatorname{return-address}_p(\Psi_0 \stepstar \currentop{\Psi}{c} \step \Psi') & \triangleq \operatorname{return-address}_p(\Psi_0 \stepstar \Psi)
    \\
    \operatorname{return-address}_p(\Psi_0 \stepn{0} \Psi_0) & \triangleq \emptyset
  \end{align*}
  \captionof{figure}{Call stack return address calculation}
  \label{fig:appendix:return-address}
\end{center}

\begin{definition}[Return Address Integrity]
  Define
  \begin{align*}
    \mathcal{RA}(\pi, \Psi_1, \Psi_2) \triangleq (\Psi_1.M(\operatorname{return-address}_{\trusted}(\pi)) &= \Psi_2.M(\operatorname{return-address}_{\trusted}(\pi))) \\
    & {}\wedge (\Psi_2.sp = \Psi_1.sp)  \wedge (\Psi_2.pc = \Psi_1.pc + 1)
  \end{align*} 
  \[
  \]
  % 
  If an SFI transition system has $\mathcal{RA}$-integrity then we say the system has return address integrity.
\end{definition}

\subsubsection{Confidentiality}
\label{sec:appendix:confidentiality}

A confidentiality policy is defined by a partial function $\mathbb{C} \in \states \rightharpoonup (\nats \mathrel{+} \regs \rightarrow \privs)$.
%
The domain of $\mathbb{C}$ must include all $\Psi$ such that $\Psi$ is a program
state where the application is making a gated call into the library, that is,
where $\Psi_0.C(\Psi.pc) = (\trusted, \cgatecall{n'}{e})$.
%
$\mathbb{C}$ captures which registers and memory slots are labelled confidential
($\trusted$) or public ($\untrusted$) at a gated call into the sandbox.
%
In the following we use $f|_{X}$ for the restriction of the function $f : A
\rightarrow B$ to a subset $X \subseteq A$.

We say $\Psi =_{\mathbb{C}} \Psi'$ when
\begin{enumerate}
\item $\Psi.pc = \Psi'.pc$
\item $\Psi.sp = \Psi'.sp$
\item $\currentcom{\Psi}{\cgatecall{n}{e}}{\trusted}$ and $\currentcom{\Psi'}{\cgatecall{n}{e}}{\trusted}$
\item $\Psi.R|_{\{r \mid \mathbb{C}(\Psi)(r) = \untrusted\}} = \Psi'.R|_{\{r \mid \mathbb{C}(\Psi')(r) = \untrusted\}}$
\item $\Psi.M|_{\{n \mid \mathbb{C}(\Psi)(n) = \untrusted\}} = \Psi'.M|_{\{n \mid \mathbb{C}(\Psi')(n) = \untrusted\}}$
\end{enumerate}

We then define two notions of observational equivalence.
%
\begin{definition} \label{appendix:call-equivalence}
  We say $\Psi =_{\mathtt{call}\ n} \Psi'$ if
  \begin{enumerate}
  \item $\Psi.M(H_{\untrusted}) = \Psi'.M(H_{\untrusted})$

  \item $\Psi.pc = \Psi'.pc$

  \item $\Psi.sp = \Psi'.sp$

  \item For all $i \in [1, n]$, there exists some $n'$ such that $n' = \Psi.M(\Psi.sp - i) = \Psi'.M(\Psi.sp - i)$.
  \end{enumerate}
\end{definition}

Second, let $r_{ret}$ be the calling convention return register.
%
\begin{definition} \label{appendix:ret-equivalence}
  We say $\Psi =_{\mathtt{ret}} \Psi'$ if
  \begin{enumerate}
  \item $\Psi.M(H_{\untrusted}) = \Psi'.M(H_{\untrusted})$

  \item $\Psi.pc = \Psi'.pc$

  \item There exists some $n$ such that $n = \Psi.R(r_{ret}) = \Psi'.R(r_{ret})$.
  \end{enumerate}
\end{definition}

\begin{definition}[\StrongNI{}]{~}

  We say that an SFI transition system has the \strongni{} property if,
  for all initial configurations and their confidentiality properties $(\Psi_0, \mathbb{C}) \in \programs$,
  traces $\Psi_0 \stepstar \Psi_1 \step \Psi_2 \steplowstar \Psi_3 \step \Psi_4$,
  where $\Psi_1$ is a gated call into the library
  $\currentcom{\Psi_1}{\cgatecall{n}{e}}{\trusted}$,
  and $\Psi_3 \step \Psi_4$ leaves the library and reenters the application
  ($\currentcom{\Psi_4}{\_}{\trusted}$),
  and, for all $\Psi_1'$ such that $\Psi_1 =_{\mathbb{C}}
  \Psi_1'$, we have that $\Psi_1' \step \Psi_2' \steplowstar \Psi_3' \step \Psi_4'$,
  $\currentcom{\Psi_4'}{\_}{\trusted}$, $\Psi_4.pc = \Psi_4'.pc$, and
  \begin{enumerate}
  \item $\Psi_3$ is a gated call to the application ($\currentop{\Psi_3}{\cgatecall{m}{e}}$ and $\currentop{\Psi_3'}{\cgatecall{m}{e}}$) and $\Psi_4 =_{\mathtt{call}\ m} \Psi_4'$ or
  \item $\Psi_3$ is a gated return to the application ($\currentop{\Psi_3}{\cgateret}$ and $\currentop{\Psi_3'}{\cgateret}$) and $\Psi_4 =_{\mathtt{ret}} \Psi_4'$.
  \end{enumerate}
\end{definition}