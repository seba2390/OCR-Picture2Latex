\section{A Gated Assembly Language}
\label{sec:model}

\begin{figure}[t]
  \begin{small}
  \begin{tabular}{@{}>{$}r<{$} >{$}c<{$} >{$}r<{$} >{$}c<{$} >{$}l<{$}}
    & & n & \in & \nats \\
    \privs & \ni & p & \bnfdef & \trusted \bnfalt \untrusted \\
    \vals & \ni & v & \bnfdef & n \\
    \regs & \ni & r & \bnfdef & \mathtt{r}_{n} \bnfalt sp \bnfalt pc \\
    \regions & \ni & k & \in & \nats \rightharpoonup \nats \\

    \expressions & \ni & e & \bnfdef & r \bnfalt v \bnfalt e \oplus e \\

    \commands & \ni & c & \bnfdef & \cpop{r}{p} \bnfalt \cpush{p}{e} \bnfalt \cjmp{k}{e} \bnfalt \cload{r}{k}{e} \bnfalt \cstore{k}{e}{e} \bnfalt \\
              &     &   &         & \cgatecall{n}{e} \bnfalt \cgateret \bnfalt \cmov{r}{e} \bnfalt \ccall{k}{e} \bnfalt \cret{k} \bnfalt \\
              &     &   &         & \cmovlabel{r}{p} \bnfalt \cstorelabel{p}{e} \\
    \codes    & \ni & C & \bnfdef & \nats \rightharpoonup \privs \times \commands \\
    \regvals  & \ni & R & \bnfdef & \regs \rightarrow \vals \\
    \memories & \ni & M & \bnfdef & \nats \rightarrow \vals \\
    \states   & \ni & \Psi & \bnfdef & \error \bnfalt \{ pc \bnftypes \nats, sp \bnftypes \nats, R \bnftypes \regvals, M \bnftypes \memories, C \bnftypes \codes \}
  \end{tabular}
  \end{small}
  \caption{Syntax}
  \label{fig:formalism:syntax:lang}
\end{figure}

We formalize zero-cost transitions via an assembly language, \langname{}, that
captures key notions of an application interacting with a sandboxed library,
focusing on capturing properties of the transitions between the application and
sandboxed library.

\para{Code}
%
\figref{fig:formalism:syntax:lang}
summarizes the syntax of \langname{}:
a \textsc{Risc}-style language with natural
numbers ($\nats$) as the sole data type.
%
Code ($C$) and data ($M$) memory are separated, and, to capture the separation
of application code from sandboxed library code, $C$ is an (immutable) partial
map from $\nats$ to pairs of a privilege ($p$) ($\trusted$ or $\untrusted$) and
a command ($c$), where $\trusted$ and $\untrusted$ are our \emph{security
domains}.

\para{States}
%
Memory is a (total) map from $\nats$
to values ($v$).
%
We assume that the memory is subdivided
into disjoint regions ($M_p$) so that
the application and library have separate memory.
%
Each of these regions is further divided
into a disjoint heap $H_p$ and stack $S_p$.
%
We write $\Psi$ to denote the states
or machine configurations, which comprise
code, memory, and a fixed, finite set of
registers mapping register names $(r_n)$
to values, with a distinguished stack
pointer ($sp$) and program counter ($pc$)
register.
%
We write $\currentcom{\Psi}{c}{p}$
for $\Psi.C(\Psi.pc) = (p, c)$,
that is that the current instruction
is $c$ in security domain $p$.
%
We write $\Psi_0 \in \programs$
to mean that $\Psi_0$ is a valid
initial program state.
%
The definition of validity varies between different SFI techniques (e.g.,
heavyweight transitions make assumptions about the initial state of the
separate stack).

\para{Gated calls and returns}
%
We capture the transitions between the application and the library by defining a
pair of instructions $\cgatecall{n}{e}$ and $\cgateret$, that serve as the
\emph{only} way to switch between the two security domains (that is,
$\cinst{call}$ and $\cinst{ret}$ check that the target is in the same security
domain).
%
The first, $\cgatecall{n}{e}$,
represents a call from the
application into the sandbox
or a callback from the sandbox
to the application with the $n$
annotation representing the number
of arguments to be passed.
%
The second, $\cgateret$, represents
the corresponding return from sandbox
to application or vice-versa.
%
We leave the reduction rule for both
\emph{implementation specific} in order
to capture the details of a given SFI
system's trampolines and springboards.

\para{Memory isolation}
%
\langname{} provides abstract mechanisms
for enforcing SFI memory isolation by
equipping the standard $\mathtt{load}$,
$\mathtt{store}$, $\mathtt{push}$, and
$\mathtt{pop}$ with (optional) statically
annotated checks.
%
To capture different styles of enforcement we model these checks as partial
functions that map a pointer to its new value or are undefined when a particular
address is invalid.
%
This lets us, for instance, capture NaCl's
coarse grained, dynamically enforced
isolation (sandboxed code may read
and write anywhere in the sandbox memory)
by requiring that all loads and stores
are annotated with the check $k(n)|_{n \in M_{\untrusted}} = n$.
%
This captures that NaCl's memory isolation does not remap addresses but traps
when an address is outside the sandbox memory region
($M_{\untrusted}$).\footnote{NaCl implements memory protection differently on
different platforms. The 32-bit implementation traps whereas the 64-bit
implementation masks addresses. We focus on the former.}
%
The rule for $\cinst{load}$ below demonstrates the use of these region
annotations in the semantics.

\para{Control-flow integrity}
%
\langname{} also provides abstract
control-flow integrity enforcement
via annotations on $\mathtt{jmp}$,
$\mathtt{call}$, and $\mathtt{ret}$.
%
These are also enforced dynamically.
%
However, we require that the standard
control flow operations remain within
their own security domain so that
$\mathtt{gatecall}$ and $\mathtt{gateret}$
remain the only way to switch
security domains.

\para{Operational semantics}
%
We capture the dynamic behavior via 
a deterministic small-step operational
semantics ($\Psi \step \Psi'$).
%
The rules are standard; we show the
rule for $\mathtt{load}$ here:
%
\begin{small}
\begin{mathpar}
  \inferrule
  {
    addr = \immval{\Psi}{e}
    \\ addr' = k(addr)
    \\\\ v = \Psi.M(addr')
    \\ R' = \Psi.R[r \mapsto v]
  }
  {\currentop{\Psi}{\cload{r}{k}{e}} \step \pcinc{\Psi}[R \assign R']}
\end{mathpar}
\end{small}
%
$\immval{\Psi}{e}$ evaluates the expression based on the register file and
$\pcinc{\Psi}$ increments $pc$, checking that it remains within the same
security domain and returning an error otherwise.
%
If the function $k(addr)$ is undefined ($addr$ is not within bounds), the
program will step to a distinguished, terminal state $\error$.
%
$\currentop{\Psi}{c}$ is simply shorthand for $\currentcom{\Psi}{c}{p}$ when we
do not care about the security domain.
%
Lastly, we do not include a specific halt command, instead halting when $pc$ is
not in the domain of $C$.


\subsection{Secure transitions}
\label{sec:assembly:security}

Next, we use \langname{} to \emph{declaratively} specify high-level properties
that capture the intended security goals of transition systems.
%
This lets us use \langname{} both as a setting to study zero-cost
transitions and to explore the correctness of implementations of
springboards and trampolines.
%
As a demonstrative example we prove that NaCl-style heavyweight transitions
satisfy the high-level properties (\iftechreport{\secref{appendix:nacl}}{see the
technical appendix~\cite{kolosick2021isolation}}).

\begin{figure}[t]
  \begin{small}
  \begin{mathpar}
    \inferrule
    {
      \Psi_1 \step \Psi_2
      \\ \currentcom{\Psi_1}{c_1}{p_1}
      \\\\ \currentcom{\Psi_2}{c_2}{p_2}
      \\ p_1 = p_2 = p
    }
    {\Psi_1 \stepp{p} \Psi_2}

    \inferrule
    {\Psi \stepp{p} \Psi'}
    {\Psi \stepbox \Psi'}

    \inferrule
    {\Psi \stepwb \Psi'}
    {\Psi \stepbox \Psi'}

    \inferrule
    {
      \Psi \step \Psi_1 \stepboxstar \Psi_2 \step \Psi'
      \\\\ \currentop{\Psi}{\cgatecall{n}{i}}
      \\ \currentop{\Psi_2}{\cgateret}
    }
    {\Psi \stepwb \Psi'}
  \end{mathpar}
  \end{small}
  \caption{Well-Bracketed Transitions}
  \label{fig:well-bracketed-transition}
\end{figure}

\para{Well-bracketed gated calls}
%
SFI systems may allow arbitrary \emph{nesting}
of calls into and callbacks out of the sandbox.
%
Thus, it is insufficient to define that callee-save registers have been properly
restored by simply equating register state upon entry to the sandbox and the
following exit.
%
Instead we make the notion of an entry and its \emph{corresponding} exit
precise, by using \langname{}'s $\mathtt{gatecall}$ and $\mathtt{gateret}$ to
define a notion of \emph{well-bracketed gated calls} that serve as the backbone
of transition integrity properties.
%
A well-bracketed gated call, which we write $\Psi \stepwb \Psi'$
(\figref{fig:well-bracketed-transition}), captures the idea that $\Psi$ is a
gated call from one security domain to another, followed by running in the new
security domain, and then $\Psi'$ is the result of a gated return that balances
the gated call from $\Psi$.
%
This can include potentially recursive but properly bracketed gated calls.
%
Well-bracketed gated calls let us relate the state before a gated call with the
state after the \emph{corresponding} gated return, capturing when the library
has fully returned to the application.

\para{Integrity}
%
Relations between the states before calling into the sandbox and then after the
corresponding return capture SFI transition system \emph{integrity} properties.
%
We identify two key integrity properties that SFI transitions must maintain:

\emph{1. Callee-save register integrity}
%
requires that callee-save registers are restored after returning from a gated
call into the library.
%
This ensures that an attacker cannot unexpectedly modify the private state of
an application function.

\emph{2. Return address integrity}
%
requires that the sandbox
%
\begin{enumerate*}
\item returns to the instruction after the $\mathtt{gatecall}$,
\item does not tamper with the stack pointer, and
\item does not modify the call stack itself.
\end{enumerate*}
%
Together these ensure that an attacker cannot tamper with the application
control flow.

These integrity properties are crucial to ensure that the sandboxed library cannot
break application invariants.
%
To capture them formally, we first define an abstract notion of integrity
across a well-bracketed gated call.
%
This not only allows us to cleanly define the above properties, but also
provides a general framework that can capture integrity properties for different
architectures.


Specifically, we define an integrity property by a predicate $\mathcal{I} :
\mathit{Trace} \times \mathit{State} \times \mathit{State} \rightarrow \prop$
that captures when integrity is preserved across a call ($\prop$ is the type of
propositions).
%
The first argument is a trace, a sequence of steps that our program has taken
before making the gated call.
%
The next two arguments are the states before and after the well-bracketed gated
call.
%
$\mathcal{I}$ defines when these two states are properly related.
%
This leads to the following definition of $\mathcal{I}$-Integrity:

\begin{definition}[$\mathcal{I}$-Integrity]
  Let $\mathcal{I} : \mathit{Trace} \times \mathit{State} \times \mathit{State} \rightarrow \prop$.
  %
  We say that an SFI transition system has $\mathcal{I}$-integrity if
  $\Psi_0 \in \programs$, $\pi = \Psi_0 \stepstar \Psi_1$,
  $\currentcom{\Psi_1}{\_}{\trusted}$, and $\Psi_1 \stepwb \Psi_2$ imply that
  $\mathcal{I}(\pi, \Psi_1, \Psi_2)$.
\end{definition}

\noindent
We instantiate this to define our two integrity properties:

\para{Callee-save register integrity}
%
We define callee-save register integrity as an $\mathcal{I}$-integrity property
that requires the callee-save registers' values to be equal in both states:
%
\begin{definition}[Callee-Save Register Integrity]
  Let $\mathbb{CSR}$ be the callee-save registers and define
  $\mathcal{CSR}(\_, \Psi_1, \Psi_2) \triangleq \Psi_2.R(\mathbb{CSR}) = \Psi_1.R(\mathbb{CSR})$.
  %
  If an SFI transition system has $\mathcal{CSR}$-integrity then we say it has callee-save register integrity.
\end{definition}

\para{Return address integrity}
%
We specify that the library returns to the expected instruction as a relation
between $\Psi_1$ and $\Psi_2$, namely that $\Psi_2.pc = \Psi_1.pc + 1$.
%
Restoration of the stack pointer is similarly specified as
$\Psi_2.sp = \Psi_1.sp$.
%
Specifying call stack integrity is more involved as $\Psi_1$ lacks information
on where return addresses are saved: they look like any other stack data.
%
Instead, return addresses are defined by the history of calls and returns
leading up to $\Psi_1$, which we capture with the trace argument $\pi$.
%
We thus define a function $\oname{return-address}(\pi)$ (\iftechreport{see
\figref{fig:appendix:return-address} in the appendix}{see the technical
appendix~\cite{kolosick2021isolation}}) that computes the locations of
return addresses from a trace.
%
The third clause of return address integrity
is then that these locations' values are
preserved from $\Psi_1$ to $\Psi_2$, yielding:

\begin{definition}[Return Address Integrity]
  \begin{align*}
    \mathcal{RA}(\pi, \Psi_1, \Psi_2) &\triangleq \Psi_2.pc = \Psi_1.pc + 1 \wedge \Psi_2.sp = \Psi_1.sp \\
    & \wedge \Psi_2.M(\oname{return-address}(\pi)) = \Psi_1.M(\oname{return-address}(\pi))
  \end{align*}
  %
  If an SFI transition system has $\mathcal{RA}$-integrity then we say the system has return address integrity.
\end{definition}


\para{Confidentiality}
%
SFI systems must ensure that secrets cannot be leaked to the untrusted
library, i.e., they must provide \emph{confidentiality}.
%
We specify confidentiality as noninterference, which informally states that
``changing secret inputs should not affect public outputs.''
%
In the context of library sandboxing, application data is secret whereas
library data is non-secret (public).\footnote{This could also be extended to
a setting with mutually distrusting components.}
%
To capture this formally, we pair programs with a confidentiality policy,
$\mathbb{C} \in \states \rightharpoonup (\nats \mathrel{+} \regs \rightarrow
\privs)$, that labels all memory and registers as $\trusted$ or $\untrusted$ at
each gated call into the library.
%
These labels form a lattice:
$\untrusted \lesstrusted \trusted$ (non-secret \emph{can} ``flow to'' secret)
and $\trusted \nlesstrusted \untrusted$ (secret \emph{cannot} ``flow to''
non-secret).\footnote{Details can be found in
\iftechreport{\sectionref{sec:appendix:confidentiality}}{the technical
appendix~\cite{kolosick2021isolation}}.}
%

To prove noninterference, that changing secret data does not affect public (or
non-secret) outputs, we need to define public outputs.
%
We over-approximate public outputs as the set of values \emph{exposed} to the
application.
%
This includes all arguments to a $\mathtt{gatecall}$ callback, the return value
when returning to the application via $\mathtt{gateret}$, and all values
stored in the sandboxed library's heap ($H_{\untrusted}$) (which may be
referenced by other returned values).

Alas, this is not enough: in a callback, the application may choose to
declassify secret data.
%
For instance, a sandboxed image decoding library might, after parsing the file
header, make a callback requesting the data to decode the rest of the image.
%
This application callback will then transfer that data (which was previously
confidential) to the sandbox, declassifying it in the transfer.

To account for such intentional declassifications, we follow
\citet{matos_declassification_2005} and define confidentiality as
\emph{disjoint noninterference}.
%
We use $\Psi =_{\mathbb{C}} \Psi'$ to mean that $\Psi$ and $\Psi'$ agree on all values
labeled $\untrusted$ by the confidentiality policy, capturing varying secret inputs.
%
We further write $\Psi =_{\mathtt{call}\ m} \Psi'$ when $\Psi$ and $\Psi'$
agree on all sandboxed heap values, the program counter, and the $m$ arguments
passed to a callback and $\Psi =_{\mathtt{ret}} \Psi'$ when $\Psi$ and
$\Psi'$ agree on all sandboxed heap values, the program counter, and the value
in the return register (written $r_{ret}$).\footnote{Full definitions are in
\iftechreport{\appref{appendix:language-defs} \defref{appendix:call-equivalence} and
\defref{appendix:ret-equivalence}}{the technical appendix~\cite{kolosick2021isolation}}.}
%
This lets us formally define noninterference as follows:

\begin{definition}[\StrongNI{}]{~}

  We say that an SFI transition system has the \strongni{} property if,
  for all initial configurations and their confidentiality properties $(\Psi_0, \mathbb{C}) \in \programs$,
  traces $\Psi_0 \stepstar \Psi_1 \step \Psi_2 \steplowstar \Psi_3 \step \Psi_4$,
  where $\Psi_1$ is a gated call into the library
  ($\currentcom{\Psi_1}{\cgatecall{n}{e}}{\trusted}$),
  and $\Psi_3 \step \Psi_4$ leaves the library and reenters the application
  ($\currentcom{\Psi_4}{\_}{\trusted}$),
  and, for all $\Psi_1'$ such that $\Psi_1 =_{\mathbb{C}}
  \Psi_1'$, we have that $\Psi_1' \step \Psi_2' \steplowstar \Psi_3' \step \Psi_4'$,
  $\currentcom{\Psi_4'}{\_}{\trusted}$, $\Psi_4.pc = \Psi_4'.pc$, and either
  \begin{enumerate*}
  \item $\Psi_3$ is a gated call to the application ($\currentop{\Psi_3}{\cgatecall{m}{e}}$ and $\currentop{\Psi_3'}{\cgatecall{m}{e}}$) and $\Psi_4 =_{\mathtt{call}\ m} \Psi_4'$ or
  \item $\Psi_3$ is a gated return to the application ($\currentop{\Psi_3}{\cgateret}$ and $\currentop{\Psi_3'}{\cgateret}$) and $\Psi_4 =_{\mathtt{ret}} \Psi_4'$.
  \end{enumerate*}
\end{definition}
%
This definition captures that, for any sequence of executing
within the library then returning control to the application, varying
confidential inputs does not influence the public outputs and the library
returns control to the application in the same number of steps.
%
Thus, an SFI system that satisfies \StrongNI{} is guaranteed
to not leak data while running within the sandbox.

We formalize NaCl style heavyweight transitions in
\iftechreport{\appref{appendix:nacl}}{the technical
appendix~\cite{kolosick2021isolation}} and prove that they meet the above secure
transition properties.
%
We discuss our proof that zero-cost Wasm meets the above secure transition
properties in \sectionref{sec:wasm-proof}.
