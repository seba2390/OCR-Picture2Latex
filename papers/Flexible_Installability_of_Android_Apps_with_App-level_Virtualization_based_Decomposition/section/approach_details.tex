\subsection{App Decomposition}


\begin{figure}[!tbp]
    \includegraphics[width=0.95\textwidth]{images/workflow.pdf}
    \caption {App Decomposition Workflow}
    \label{fig:workflow}
\end{figure}


We formally define the terms that are used to describe our approach for app decomposition.

\noindent\textbf{Basics of Android App}.
We first present the definition of an Android app, which is the input of \nickName.
We define $APP=<CLS, RES, OTH>$ to represent an app, where $APP$ is a triple including $CLS$ (i.e., the compiled code), $RES$ (i.e., resources), and $OTH$ (i.e., other resources). 
We define $CLS= ACT\cup OLS \cup POJO$, where $CLS$  is the set of classes in bytecode, including $ACT$ (activities), $OLS$ (other Android components), and $POJO$ (other classes). 
We define $RES=IDR\cup ASSET$, where $RES$ represents the resources of an app, including $IDR$ (resources that reside in \textit{res} folder, and can be referenced with identifiers such as \textit{R.type.resName} in code and \textit{@type/resName} in resource files) and $ASSET$ (resources that reside in \textit{assets} folder, and can be referenced with \textit{AssetManager} object and \textit{loadUrl} method). The former reference can be detected explicitly, while the latter reference can not be detected explicitly\footnote{For example, developers may load a local Web page in \textit{assets} folder with \textit{loadUrl} method in a WebView component. However, the loading of other resources such as CSS files, JS files, and images in \textit{assets} folder is not explicitly specified.}. Therefore, we focus on decomposition of resources in the \textit{res} folder. 
$OLS$ represents other Android components that include services, broadcast receivers, and content providers.
The $OTH$ represents other resources in an APK file that we will pack into the base bundle directly, such as native libraries, \textit{AndroidManifest} file, and \textit{resources.arsc} file.


We define the relationships between code and resources as $Refer\subset CLS\times IDR$ , where $<c,r> \in Refer$ if a class $c\in CLS$ references a resource $r\in IDR$. We build a dependency graph $RG=<IDR, F>$ among resources from $IDR$, in which each node $r_i\in IDR$ denotes a resource and an edge $e(r_i,r_j)\in F$ denotes that $r_i$ references $r_j$. Similarly, $path_{r_i,r_j} \in Path_{RG}$ denotes t!hat there exists a reference path $P=r_ir_1r_2\dots r_j$ such that $<r_i,r_1>\in F$ and for $t=1,2,\dots,j, 1\le j, <r_{t-1}, r_t>\in F$. 

For each class $c_k \in CLS$, its related resources can be defined as $CRRES_{c_k}=\{r\in IDR|<c_k, r>\in Refer \lor \exists r_t\in IDR, <c_k, r_t>\in Refer \land <r_t, r>\in Path_{RG}\}$. 
Each $r\in CRRES_{c_k}$ is either a resource that is directly related to $c_k$ (i.e., $<c_k,r>\in Refer$), or a resource that is referenced by another resource $r_t$ related to $c_k$ (i.e., $<c_k, r_t>\in Refer$ and $<r_t, r>\in Path_{RG}$).

\noindent\textbf{Base Bundle and Feature Bundle}.
Based on the definition of an Android app, we can give the formal definitions of the base bundle and the feature bundle as shown in Definition~\ref{base_bundle} and Definition~\ref{feature_bundle}. 
A base bundle consists of code ($CLS_{base}$), referenced resources ($RES_{base}$), and others ($OTH$). 
Developers can choose a set of activities defined as $SEL=\{a_1, a_2, \dots, a_n\}$ to pack into the base bundle
Based on the chosen activities, we compute the set of \emph{activity-related classes} $ARCLS_{a_i}$.
We consider that a class $c$ such that $c\in POJO$ is required by an activity $ACT$ if there exists a calling relationship between the methods in the $ACT$ and the methods in $c$.
We define that a class consists of a set of methods as $CLS=\{m_i|m_i\in METHOD\}$. 
We define the call graph as $CG=<METHOD, E>$, in which each node $m_i\in METHOD$ denotes a method and an edge $e(m_i,m_j)\in E$ denotes a calling relationship from $m_j$ to $m_j$. $path_{m_i,m_j} \in Path_{CG}$ denotes that there exists a call path $P=m_im_1m_2\dots m_j$ such that $<m_i,m_1>\in E$ and for $t=1,2,\dots,j, 1\le j, <m_{t-1}, m_t>\in E$. For each activity ${a_k}$, we define $ARCLS_{a_k}=a_k\cup\{c\in POJO|\exists m_i\in a_k, m_j\in c, <m_i, m_j>\in Path_{CG}\}$, where $ARCLS_{a_k}$ is the activity-related classes of  ${a_k}$, including the ${a_k}$ and class $c$ such that $c\in POJO$ and $m_i\in a_k, m_j\in c, <m_i, m_j>\in Path_{CG}$. 

Based on activity-related classes, $CLS_{base}$ is defined as the union of $ARCLS_{a_i}$ for $a_i \in SEL$ and the other Android components $OLS$. 
We preserve all the components in $OLS$ since they do not have related resources and usually occupy a small amount of storage.
$RES_{base}$ is defined as the union of class related resources $CRRES_{c_i}$ for each $c_i$ in $CLS_{base}$ and the assets $ASSET$. For each activity $a_k$ thatis  not included in base bundle, we pack its classes $CLS_{feature_{a_k}}$ and resources $RES_{feature_{a_k}}$ as a feature bundle $FEATURE\_BUNDLE_{a_k}$. $CLS_{feature_{a_k}}$ denotes the set of related classes in $ARCLS_{a_k}$ except those classes in $CLS_{base}$. $RES_{feature_{a_k}}$ denotes the set of referenced resources that are in the union of $CRRES_{c_i}$ for each class $c_i$ in $CLS_{feature_{a_k}}$ but not in the base bundle's referenced resources $RES_{base}$.
\setlength{\belowdisplayskip}{0pt} \setlength{\belowdisplayshortskip}{0pt}
\setlength{\abovedisplayskip}{0pt} \setlength{\abovedisplayshortskip}{0pt}
\begin{subequations}
\small
\label{base_bundle}
\begin{align}
	&BASE\_BUNDLE = <CLS_{base}, RES_{base}, OTH> \\
	&CLS_{base} = \{\bigcup_{i=1}^{n} ARCLS_{a_i}\}\cup OLS \\
	&RES_{base} = \{\bigcup_{c_i\in CLS_{base}} CRRES_{c_i}\}\cup ASSET
\end{align}
\end{subequations}
\begin{subequations}
\small
\label{feature_bundle}
\begin{align}
	&FEATURE\_BUNDLE_{a_k} = <CLS_{feature_{a_k}}, RES_{feature_{a_k}}> \\
	&CLS_{feature_{a_k}}  = ARCLS_{a_k}-CLS_{base} \\
	&RES_{feature_{a_k}} = \{\bigcup_{c_i\in CLS_{feature_{a_k}}} CRRES_{c_i}\}-RES_{base}
\end{align}
\end{subequations}

 

\noindent\textbf{Overall Workflow and A Working Example}. 
Figure~\ref{fig:workflow} illustrates the workflow of app decomposition. The input is an APK file $APP$.
Our approach first identifies the resources $RES$ and builds the call graph $CG$ of the code $CLS$ by static analysis. 
For each class $c_i$ in $CLS$, our approach computes the relationships among code and resources based on $CG$ and obtains the referenced resources $CRRES_{c_i}$.
Second, based on the set of activities specified by the developers, our approach decomposes the app into a base bundle and multiple feature bundles as we defined before. 
Figure~\ref{fig:workflow} shows an example of how our approach decomposes an app. Assume that the developers choose the activities $A1$ and $A2$ to pack into the base bundle. 
Then, the activity-related classes ($ARCLS_{A1}$ and $ARCLS_{A2}$) and their related resources ($CRRES_{A1}$ and $CRRES_{A2}$) are computed based on $CG$.
Based on these results, the POJO class $C0$ and the resources $R1$-$R3$ are found to be required by the activities $A1$ and $A2$ and will be packed into the base bundle. 
Since $C0$ and $R2$ have been packed into the base bundle, we will not pack them into the feature bundle that contains the activity $A3$.
Third, since the static analysis based $CG$ may not find all the code and resources required by the chosen activities, our approach further applies an iterative and back-complementary recovery mechanism with recording and replay to supplement missing code and resources for the base bundle and feature bundles. 
During this step, our approach detects that the running base bundle throws out an exception, which indicates the class $C2$ is missing. As such, our approach adds $C2$ back to the base bundle, and repeats this process iteratively until no exceptions are detected. We also allow developers to manually add some classes and resources to a white list.
At last, we repack these selected activities into a base bundle with their dependent code and resources. Similarly, other activities will be packed as feature bundles, respectively.


\noindent\textbf{Iterative and Back-Complementary Recovery Mechanism}. Our approach requires a precise and complete call graph, which is very challenging due to the event-driven nature and virtual calls in Android apps~\cite{Wang16PLDI}\cite{Li17IST}\cite{Li16ISTTA}. 
To alleviate such issue, we devise an iterative and back-complementary recovery mechanism with recording and replay to supplement missing code and resources for the base bundle and feature bundles.

When running a base bundle without certain required classes and resources, a system exception indicates that the required classes or resources cannot be found will be thrown.
Our approach analyzes such exception information to infer missing classes and resources. 
Our approach provides a record-replay tool and a back-complementary recovery tool to automatically complement missing code and resources, repack bundles, launch target activities, and back and forth. 
The back-complementary recovery tool iteratively installs and launches the base bundle, and adds the detected missing code and resources back to base bundle until successfully launching the home page. 
For each feature activity, the developers need to record actions based on the record-replay tool to reach the target activity, such as launching the application, clicking a specific button. 
Then, the back-complementary recovery tool iteratively replays the recorded actions to open the target activity, and collects the logs about missing code and resources. 
Additionally, developers can also manually specify code and resources for the base bundle and feature bundles in a white list if they want. 
This can help reduce the iterations if developers are familiar with the app.


\subsection{App-level Virtualization}

\begin{figure}[!t]
	\centering
    \includegraphics[width=0.7\textwidth]{images/api_virtualization.pdf}
    \caption{Architecture of App-level virtualization} 
    \label{fig:app_level_virtualization}
\end{figure}
\nickName{} provides an app-level virtualization space to take over the management of the whole lifecycle of a decomposed app, including installation and runtime support. The key challenge is to hook the related system services, including \textit{ActivityManagerServiche} (AMS, responsible for managing lifecycles of activities), \textit{PackageManagerService} (PMS, responsible for installation and package info management), and \textit{WindowManagerService} (WMS, responsible for window management, events management and distribution) to deal the whole lifecycle of an Android app at runtime. Although we can use many kinds of existing technologies, such as Xposed~\cite{xposed}, AspectJ~\cite{MP2009Laddad}, CydiaSubstrate~\cite{CydiaSubstrate}, these technologies require either low-level accesses or modifications to the underlying Android OS, resulting in limited deployability and robustness for the decomposed apps.

Android system manages and runs apps with the aforementioned system services via the Binder~\cite{binder}, which is an Android-specific inter-process communication mechanism and remote method invocation system. 
It adopts a client-server model, where each client would have a proxy object to communicate with the server.  
We find that app processes and system services act as both clients and servers to deal with the lifecycle management by cooperation. 
For an Android app, its process holds the clients of system services (e.g., the activity manger, short as AM, is the client of AMS). We can hook these client proxies to deceive system services.

Figure~\ref{fig:app_level_virtualization} shows the architecture of our app-level virtualization framework, \emph{\nickName{} Client}. The \nickName{} client provides a server process that maintains a set of fake services, including VAMS, VPMS, and VWMS corresponding to AMS, PMS, and WMS in the Android OS, respectively. After downloading the base bundle of an app in \nickName{} client, the VPMS will extract and parse the \textit{AndroidManifest.xml} as the PMS does when installing a regular application directly. 
Additionally, we need to address the issue that the Android OS disallow to run an activity that is not registered in the \textit{AndroidManifest.xml} file. 
Hence, \nickName{} client registers many empty stub activities, and invokes the exact lifecycle callbacks of the target activity when running the decomposed apps. 

When end users launch the base bundle, the \nickName{} client forks a new process to load the code of base bundle and inquires the exact launching activity through VPMS. Decomposed apps running in the \nickName{} client are not aware of the existence of the \nickName{} client as if it is running directly in the Android OS. In fact, they interact with our virtualized services, including VAMS, VPMS, and VWMS through the respective hooked virtual clients, including VAM, VPM, and VWM. Then, the \nickName{} client intercepts the message that tells the VAMS to start an activity and pass the info of a stub activity previously registered to AMS. When AMS tries to invoke the callbacks of the stub activity, the \nickName client replaces the stub activity with the exact launching activity of the base bundle to deceive AMS into opening the launching activity. 


\subsection{On-Demand Installation}
\nickName allows end users to download only the base bundle of a decomposed app when they install a new application. 
The \nickName{} client downloads the base bundle, and parses it to obtain the app information as normal installation in the Android OS.
For those explicit intents that will open uninstalled activities, we inject a piece of code by bytecode rewriting~\cite{OOPSLA2012Zhang} before the statements. For those implicit intent, the VPMS will resolve the intent object to find the matched activity. When the end users' operations trigger the navigation to a new activity, the \nickName{} client detects if the activity has resided in the local device. If not, the \nickName{} client initiates a request to download the feature bundle that contains the target activity. After the download, the \nickName{} client extracts all the resources and merges them into the base bundle. Then, the \nickName{} client extracts the code and moves it to the private source code folder of the app so that the application can dynamically load the code with dynamic code loading (DCL) based on \textit{DexClassLoader}.  With both the code and resources dynamically loaded, the application can now navigate to the target activity. Every requested feature bundle is downloaded once, and subsequent visits on the activities in these bundles will load the activities from the local device directly, improving delays and user experiences.
