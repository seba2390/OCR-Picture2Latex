\subsection{Translating {\fg} to {\cg}}
\label{sec:fg-2-cg}

\input{expr-trans-fg-to-cg}

Our goal in translating {\fg} to {\cg} is to show how a fine-grained
IFC type system can be simulated in a coarse-grained one. Our
translation is directed by the type derivations in {\fg} and preserves
typing and semantics. We describe the translation below, followed by
formal properties of the translation. As a convention, we use the
subscript or superscript $s$ to indicate source ({\fg}) elements, and
$t$ to indicate target ({\cg}) elements. Thus $e_s$ denotes a source
expression, whereas $e_t$ denotes a target expression.

The key idea of our translation is to map a source expression $e_s$
satisfying $\vdash_{\pc} e_s: \tau$ to a monadic target expression
$e_t$ satisfying $\vdash e_t: \tslio{\pc}{\bot}{\transFC{\tau}}$. The
$\pc$ used to type the source expression is mapped as-is to the
pc-label of the monadic computation. The type of the source
expression, $\tau$, is translated by the function $\transFC{\cdot}$
that is described below. However---and this is the crucial bit---the
taint label on the translated monadic computation is $\bot$. To get
this $\bot$ taint we use the $\etolabeled$ construct judiciously. Not
setting the taint to $\bot$ can cause a taint explosion in translated
expressions, which would make it impossible to simulate the
fine-grained dependence tracking of {\fg}.

The function $\transFC{\cdot}$ defines how the types of source values
are translated. This function is defined by induction on labeled and
unlabeled source types.

\[
  \begin{array}{lll}
      \transFC{\tbase} & = & \tbase \\

      \transFC{\tunit} & = & \tunit\\

      \transFC{\tau_1 \overset{\llabel_e}{\to} \tau_2} & = &
                                                             \transFC{\tau_1} \to \tslio{\llabel_e}{\bot}{\transFC{\tau_2}} \\

      \transFC{\tau_1 \times \tau_2} & = & \transFC{\tau_1} \times \transFC{\tau_2} \\

      \transFC{\tau_1 + \tau_2} & = & \transFC{\tau_1} + \transFC{\tau_2} \\

      \transFC{\tref ~\tau} & = & \tref ~\llabel ~\transFC{\utype}~~~~\mbox{ when $\tau = \utype^{\llabel}$}\\

      \transFC{\utype^{\llabel}} & = & \tlabeled{\llabel}{\transFC{\utype}}
  \end{array}
\]
%
The translation should be self-explanatory. The only nontrivial case
is the translation of the function type $\tau_1
\overset{\llabel_e}{\to} \tau_2$. A source function of this type is
mapped to a target function that takes an argument of type
$\transFC{\tau_1}$ and returns a monadic computation (the translation
of the body of the source function) that has pc-label $\llabel_e$ and
eventually returns a value of type $\transFC{\tau_2}$.

Given this translation of types, we next define a type
derivation-directed translation of expressions. This translation is
formalized by the judgment $\Gamma \vdash_{\pc} e_s:\tau \leadsto
e_t$. The judgment means that translating the source expression $e_s$,
which has the typing derivation $\Gamma \vdash_{\pc} e_s$, yields the
target expression $e_t$. This judgment is \emph{functional}: For each
type derivation $\Gamma \vdash_{\pc} e_s: \tau$, it yields exactly one
$e_t$.  It is also easily implemented by induction on typing
derivations. The rules for the judgment are shown in
Figure~\ref{fig:fg-2-cg-expr}. The thing to keep in mind while reading
the rules is that $e_t$ should have the type
$\tslio{\pc}{\bot}{\transFC{\tau}}$.

We illustrate how the translation works using one rule,
\rname{\fc-app}. In this rule, we know inductively that the
translation of $e_1$, i.e., $e_{c1}$ has type
$\tslio{\pc}{\bot}{\transFC{(\tau_1 \overset{\llabel_e}{\to}
    \tau_2)^\llabel}}$, which is equal to
$\tslio{\pc}{\bot}{(\tlabeled{\llabel}{(\transFC{\tau_1} \to
    \tslio{\llabel_e}{\bot}{\transFC{\tau_2}})})}$. The translation of
$e_2$, i.e., $e_{c2}$ has type
$\tslio{\pc}{\bot}{\transFC{\tau_1}}$. We wish to construct something
of type $\tslio{\pc}{\bot}{\transFC{\tau_2}}$.

To do this, we bind $e_{c1}$ to the variable $a$, which has the type
$\tlabeled{\llabel}{(\transFC{\tau_1} \to
  \tslio{\llabel_e}{\bot}{\transFC{\tau_2}})}$. Similarly, we bind
$e_{c2}$ to the variable $b$, which has the type
$\transFC{\tau_1}$. Next, we unlabel $a$ and bind the result to
variable $c$, which has the type $\transFC{\tau_1} \to
\tslio{\llabel_e}{\bot}{\transFC{\tau_2}}$. However, due to the
unlabeling, the \emph{taint label on whatever computation we sequence
  after this bind must be at least $\llabel$}. Next, we apply $b$ to
$c$, which yields a value of type
$\tslio{\llabel_e}{\bot}{\transFC{\tau_2}}$. Via subtyping, using the
assumption $\pc \lbelow \llabel_e$, we can weaken this to
$\tslio{\pc}{\llabel}{\transFC{\tau_2}}$. This satisfies the
constraint that the taint label be at least $\llabel$ and is
\emph{almost} what we need, except that we need the taint $\bot$ in
place of $\llabel$.

To reduce the taint back to $\bot$, we use the \emph{defined} {\cg}
function $\coerce$, which has the type $\tslio{\pc}{\llabel}{\tau} \to
\tslio{\pc}{\bot}{\tau}$, when $\tau$ has the form
$\tlabeled{\llabel'}{\tau'}$ with $\llabel \lbelow \llabel'$. This
last constraint is satisfied here since we know that $\tau_2 \searrow
\llabel$. The function $\coerce$ uses $\etolabeled$ internally and is
defined in the figure.

This pattern of using $\coerce$, which internally contains
$\etolabeled$, to restrict the taint to $\bot$ is used to translate
all elimination forms (application, projection, case, etc.). Overall,
our translation uses $\etolabeled$ judiciously to prevent taint from
exploding in the translated expressions.

\textit{Remark.} Readers familiar with monads may note that our
translation from {\fg} to {\cg} is based on the standard
interpretation of the call-by-value $\lambda$-calculus in the
computational $\lambda$-calculus~\cite{moggi91:notions}. Our
translation additionally accounts for the pc and security labels, but
is structurally the same.

\input{fg-to-cg-lr.tex}

\medskip\noindent \textbf{Properties.}  Our translation preserves
typing by construction. This is formalized in the following
theorem. The context translation $\transFC{\Gamma}$ is defined
pointwise on all types in~$\Gamma$.
%
\begin{thm}[Typing preservation]\label{thm:fg-2-cg-typePres}
  If $\Gamma \vdash_\pc e_s: \tau$ in {\fg}, then there is a unique
  $e_t$ such that $\Gamma \vdash_\pc e_s: \tau \leadsto e_t$ and that
  $e_t$ satisfies $\transFC{\Gamma} \vdash e_t:
  \tslio{\pc}{\bot}{\transFC{\tau}}$ in {\cg}.
\end{thm}
An immediate corollary of this theorem is that well-typed source
programs translate to noninterfering target programs (since target
typing implies noninterference in the target).

Next, we show that our translation preserves the meaning of programs,
i.e., it is semantically ``correct''. For this, we define a
\emph{cross-language} logical relation, which relates source values
(expressions) to target values (expressions) at each source type. This
relation has three key properties: (A) A source expression and its
translation are always in the relation
(Theorem~\ref{thm:fg2cg-FundThm}), (B) Related expressions reduce to
related values, and (C) At base types, the relation is the
identity. Together, these imply that our translation preserves the
meanings of programs in the sense that a function from base types to
base types maps to a target function with the same extension.

An excerpt of the relation is shown in
Figure~\ref{fig:crossLangfg2cg}. The relation is defined over source
({\fg}) types, and is divided (like our earlier relations) into a
value relation$\fcUlrvn{\cdot}$, an expression relation
$\fcUlren{\cdot}$, and a heap relation $(n, \heap_s, \heap_t)
\wDefined{\pb} \uWorlds$, which we omit here. The relations specify
when a source value (resp.\ expression, heap) is related to a target
value (resp.\ expression, heap) at a source unary world $\uWorlds$, a
step index $n$ and a partial bijection $\pb$ that relates source
locations to corresponding target locations. The relation actually
mirrors the unary logical relation for {\fg}. The definition of the
expression relation forces property (B) above, while the value
relation at base types forces property (C).

Our main result is again a fundamental theorem, shown below. The
symbols $\vsubstsS$ and $\vsubstsT$ denote unary substitutions in the
source and target, respectively. The relation $\fcUlrvn {\Gamma }$ is
the obvious one, obtained by pointwise lifting of the value relation;
its definition is in the appendix.

%% We close of the open terms by defining appropriate notion of related
%% substitutions like before but this time for a cross-language setting
%% (denoted by $\vsubsts$ described in appendix) and use that prove the
%% Fundamental theorem.

\begin{thm}[Fundamental theorem]\label{thm:fg2cg-FundThm}
If
  $\Gamma \vdash_{\pc} e_s:\tau \leadsto e_t$ 
and
  $(\uWorlds, n, \vsubstsS, \vsubstsT) \in \fcUlrvn  {\Gamma }$,
then
  $(\uWorlds, n, e_s ~ \vsubstsS, e_t ~ \vsubstsT) \in \fclreun {\tau } {\pb}$.
\end{thm}

The proof of this theorem is by induction on the derivation of $\Gamma
\vdash_{\pc} e_s:\tau \leadsto e_t$. This theorem has two important
consequences. First, it immediately implies property (A) above and,
hence, completes the argument that our translation is semantically
correct. Second, the theorem, along with the binary fundamental
theorem for {\cg}, allows us to re-derive the noninterference theorem
for {\fg} (Theorem~\ref{thm:ni-fg}) directly. This re-derivation is
important because it provides confidence that our translation
preserves the meaning of security labels. As a simple counterexample,
it is perfectly possible to translate {\fg} programs to {\cg}
programs, preserving both typing and semantics, by mapping all source
labels to the same target label (say, $\bot$). However, we would not
be able to re-derive the source noninterference theorem using the
target's properties if this were the case.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
