\subsection{The coarse-grained type system, {\cg}}
\label{sec:cg}

\input{cg-typesystem}

Our coarse-grained type system, {\cg}, is a variant of the static
fragment of the hybrid IFC type system
HLIO~\cite{icfp15-HLIO}.\footnote{\update{Differences between {\cg} and HLIO
  and their consequences are discussed in
  Section~\ref{sec:discussion}.}} Like {\fg}, {\cg} also operates on a
  higher-order, eager, call-by-value language with state, but it
  separates pure expressions from impure (stateful) ones at the level
  of types. This is done, as usual, by introducing a monad for state,
  and limiting all state-accessing operations (dereferencing,
  allocation, assignment) to the monad. However, in {\cg}, as in HLIO,
  the monad also doubles as the unit of labeling. Values and types are
  not necessarily labeled individually in {\cg}. Instead, there is a
  confidentiality label on an entire monadic computation. This makes
  {\cg} coarse-grained.

{\cg}'s syntax and type system are shown in
Figure~\ref{fig:cg-ts}. The types include all the usual types of the
simply typed $\lambda$-calculus and, unlike {\fg}, a label is not
forced on every type. There are two special types: $\tslio
{\llabel_1}{\llabel_2}{\tau}$ and $\tlabeled{\llabel}{\tau}$.

The type $\tslio {\llabel_1}{\llabel_2}{\tau}$ is the aforementioned
monadic type of computations that may access the heap (expressions of
other types cannot access the heap), eventually producing a value of
type $\tau$. The first label $\llabel_1$, called the \emph{pc-label},
is a lower bound on the write effects of the computation. The second
label $\llabel_2$, called the \emph{taint label}, is an upper bound on
the labels of all values that the computation has analyzed so far; it
is, for this reason, also an \emph{implicit} label on the output type
$\tau$ of the computation, and on any intermediate values within the
computation.

The type $\tlabeled{\llabel}{\tau}$ explicitly labels a value (of type
$\tau$) with label~$\llabel$. In {\fg}'s notation, this would be
analogous to $\tau^\llabel$. The difference is that this labeling can
be used \emph{selectively} in {\cg}; unlike {\fg}, not every type must
be labeled. Also, the reference type $\tref~\llabel~\tau$ carries an
explicit label $\llabel$ in {\cg}. Such a reference stores a value of
type $\tlabeled{\llabel}{\tau}$. \update{Labels on references are
  necessary to prevent implicit leaks via control dependencies---the
  type system relates the pc-label to the label of the written value
  at every assignment. Similar labels on references were unnecessary
  in {\fg} since every written value always carries a label anyhow.}

\medskip
\noindent\textbf{Typing rules.}  {\cg} uses the standard typing
judgment $\Gamma \vdash e: \tau$. There is no need for a $\pc$ on the
judgment since effects are confined to the monad. {\cg} uses the
typing rules of the simply typed $\lambda$-calculus for the type
constructs $\tbase$, $\tunit$, $\times$, $+$ and $\rightarrow$. We do
not re-iterate these standard rules, and focus here only on the new
constructs. The construct $\eret(e)$ is the monadic return that
immediately returns $e$, without any heap access. Consequently, it can
be given the type $\tslio{\top}{\bot}{\tau}$ (rule
\rname{{\cg}-ret}). The pc-label is $\top$ since the computation has
no write effect, while the taint label is $\bot$ since the computation
has not analyzed any value.

The monadic construct $\ebind(e_1, x.e_2)$ sequences the computation
$e_2$ after $e_1$, binding the return value of $e_1$ to $x$ in
$e_2$. The typing rule for this construct, \rname{{\cg}-bind}, is
important and interesting. The rule says that $\ebind(e_1, x.e_2)$ can
be given the type $\tslio {\llabel} {\llabel_4} {\tau'}$ if $(e_1:
\tslio{\llabel_1}{\llabel_2}{\tau})$, $(e_2:
\tslio{\llabel_3}{\llabel_4}{\tau'})$ and four conditions hold. The
conditions $\llabel \lbelow \llabel_1$ and $\llabel \lbelow \llabel_3$
check that the pc-label of $\ebind(e_1, x.e_2)$, which is $\llabel$,
is below the pc-label of $e_1$ and $e_2$, which are $\llabel_1$ and
$\llabel_3$, respectively. This ensures that the write effects of
$\ebind(e_1, x.e_2)$ are indeed above its pc-label, $\llabel$. The
conditions $\llabel_2 \lbelow \llabel_3$ and $\llabel_2 \lbelow
\llabel_4$ prevent leaking the output of $e_1$ via
the write effects and the output of $e_2$, respectively. Observe how
these conditions together track labels at the level of entire
computations, i.e., coarsely.

Next, we describe rules pertaining to the type
$\tlabeled{\llabel}{\tau}$. This type is introduced using the
expression constructor $\elabel{}$, as in rule
\rname{{\cg}-label}. Dually, if $e: \tlabeled{\llabel}{\tau}$, then
the construct $\eunlabel(e)$ eliminates this label. This construct has
the monadic type $\tslio{\top}{\llabel}{\tau}$. The taint label
$\llabel$ indicates that the computation has (internally) analyzed
something labeled $\llabel$. The pc-label is $\top$ since nothing has
been written.

Rule \rname{{\cg}-deref} says that dereferencing (reading) a location
of type $\tref~\llabel'~\tau$ produces a computation of type
$\tslio{\top}{\bot}{(\tlabeled{\llabel'}{\tau})}$. The type is monadic
because dereferencing accesses the heap. The value the computation
returns is explicitly labeled at $\llabel'$. The pc-label is $\top$
since the computation does not write, while the taint label is $\bot$
since the computation does not analyze the value it reads from the
reference. (The taint label will change to $\llabel'$ if the read value
is subsequently unlabeled.) Dually, the rule \rname{{\cg}-assign}
allows assigning a value labeled $\llabel$ to a reference labeled
$\llabel$. The result is a computation of type
$\tslio{\llabel}{\bot}{\tunit}$. The pc-label $\llabel$ indicates a
write effect at level $\llabel$.

The last typing rule we highlight pertains to a special construct,
$\etolabeled(e)$. This construct transforms $e$ of monadic type
$\tslio{\llabel}{\llabel'}{\tau}$ to the type
$\tslio{\llabel}{\bot}{(\tlabeled{\llabel'}{\tau})}$. This is
perfectly safe since the only way to observe the output of a monad is
by binding its result and that result is explicitly labeled in the
final type. The purpose of using this construct is to reduce the taint
label of a computation to $\bot$. This allows a subsequent
computation, which will \emph{not} analyze the output of the current
computation, to avoid raising its own taint label to
$\llabel'$. Hence, this construct limits the scope of the taint label
to a single computation, and prevents overtainting subsequent
computations. We make extensive use of this construct in our
translation from {\fg} to {\cg}. We note that HLIO's original typing
rule for $\etolabeled$ is different, and does not always allow
reducing the taint to $\bot$. We discuss the consequences of this
difference in Section~\ref{sec:discussion}.

We briefly comment on subtyping for specific constructs in
{\cg}. Subtyping of $\tlabeled{\llabel}{\tau}$ is co-variant in
$\llabel$, since it is always safe to increase a confidentiality
label. Subtyping of $\tslio{\llabel_1}{\llabel_2}{\tau}$ is
contra-variant in the pc-label $\llabel_1$ and co-variant in the taint
label $\llabel_2$ since the former is a lower bound while the latter
is an upper bound.

%% The coarse-grained ({\cg}) type system that we consider is a static
%% fragment of HLIO~\cite{icfp15-HLIO} with three minor changes. Firstly,
%% {\cg} is given a call-by-value semantics (to match the {\fg}'s
%% evaluation strategy) whereas HLIO follows a call-by-name evaluation
%% approach. Secondly, {\cg} does not include the \texttt{label}
%% construct of HLIO. This is because the \texttt{label} construct is
%% same as the \texttt{ret} construct specialized to $\tlabeled$ type,
%% with an additional label check. This label check is not required for
%% {\NI} (our soundness criteria) and is only needed for
%% containment~\cite{haskell11-LIO}, hence we omit it from {\cg}. And
%% lastly, we simplified the HLIO type system by removing the notion of
%% clearance, which is required for discretionary access control and not
%% for IFC.

%% The hallmark of the {\cg} type system is a clear separation between pure and impure types. On the
%% pure side, {\cg} includes types for an effect-free function, product and a sum. Both the intro and
%% the elim forms for these types are free from IFC checks and hence are exactly same as that of a
%% simply typed lambda calculus (STLC). Additionally {\cg} has a type for specifying labeled
%% expressions namely $\tlabeled {\llabel} {\tau}$, where $\llabel$ specifies the confidentiality
%% associated with the type $\tau$. This represents the type of a labeled expression which is evaluated
%% eagerly (in accordance with the call-by-value approach). References serve as the source and sink for
%% data and hence must have a well-defined confidentiality associated with them, this is done by
%% associating a label with the reference type, $\tref ~{\llabel} ~{\tau}$. The label $\llabel$
%% represents the label of the value contained in the reference, in other words a well typed reference
%% of type $\tref ~ {\llabel} ~ {\tau}$ will always contain a value of type
%% $\tlabeled {\llabel} {\tau}$. On the impure side, {\cg} represents effectful computations with a
%% monadic type i.e all computations which can cause effects must be isolated in a monad. And hence
%% $\pc$ (lower-bound on the write effect) is only relevant inside a monad. This is reflected by
%% modeling (effectful) computations using state monad (at the type level) which carries initial and
%% final $\pc$ as the state.  The monadic type is represented by
%% $\tslio {\llabel_i} {\llabel_o} {\tau}$, $\llabel_i$ and $\llabel_o$ describe the initial and the
%% final $\pc$ level, and $\tau$ is the type of the value returned by forcing~\footnote{We use the term
%%   forcing to mean execution of the computation of the monadic type} the computation of this monadic
%% type. It is an invariant of the {\cg} type system that if $e:\tslio {\llabel_i} {\llabel_o} {\tau}$
%% then $\llabel_i \lbelow \llabel_o$, this is enforced by a straight forward well-formedness relation
%% (which we don't describe in this document). Like in the {\fg} type system, $\llabel_i$ is used as a
%% lower-bound on the write-effects (as seen in the \cg-ref and \cg-assign rules, explained later). In
%% addition to that, $\cg$ also has as an explicit representation for an upper-bound on the read
%% effects (the other interpretation of the final $\pc$ i.e $\llabel_o$ in the
%% $\tslio {\llabel_i} {\llabel_o} {\tau}$ type), this is in tandem with the core operational
%% philosophy of {\cg} -- context label must be an upper-bound on the confidentiality of the read
%% secrets.

%% Having explained the various types of the {\cg} type system, we now describe some of its selected
%% type rules from Fig.~\ref{fig:cg-ts} (Note that we have omitted the type rule for pure expressions
%% from Fig.~\ref{fig:cg-ts} as they are completely standard). The typing judgment for the {\cg} type
%% system is given by $\lcontext;\cContext;\Gamma \vdash e:\tau$ where $\lcontext$, $\cContext$ and
%% $\Gamma$ represents the typing environment as in the {\fg} type system. Notice {\cg}'s typing
%% judgment does not carry a global $\pc$ because effects in {\cg} are localized to monads only and are
%% not pervasive like in the {\fg} system. We start with \cg-ret (the intro form for the monadic type),
%% $\eret(e)$ takes an expression of type $\tau$ and returns a computation of type
%% $\tslio {\llabel_i} {\llabel_i} {\tau}$ causing no change to the starting $\pc$ (which is
%% $\llabel_i$). The elim form, $\ebind(e_1,x.e_2)$, for the monadic type represents sequencing of the
%% two computations of types $\tslio {\llabel} {\llabel_1} {\tau}$ and
%% $\tau \to \tslio {\llabel_1} {\llabel'} {\tau'}$ to obtain a computation of type
%% $\tslio {\llabel} {\llabel'} {\tau'}$. $\ebind$ rule is the only place where the {\cg} type system
%% tracks dependencies, this is reflected by typing the continuation in a starting $\pc$ which is the
%% ending $\pc$ of the first computation. The \cg-label type rule describes that if an expression $e$
%% has type $\tau$ then the expression $\elabel {} (e)$\footnote{Note that the $\elabel {} $ construct
%%   does not carry any runtime label. This is because all the enforcement is static in the type system
%%   so carrying runtime labels would be redundant.}  has type $\tlabeled {\llabel} {\tau}$. While
%% $\elabel {} (e)$ represents a pure expression, its dual $\eunlabel (e)$ represents a computation
%% which when forced in a starting $\pc$ of $\llabel_i$ will end up with a ending $\pc$ of
%% $\llabel_i \ljoin \llabel$ where $\llabel$ is the label on the type of $e$. All the rules related to
%% references perform heap related effects and thus all of them have monadic types. \cg-ref and
%% \cg-assign makes sure that the reference created and modified respectively both get values whose
%% confidentiality is above the confidentiality of the starting $\pc$ (lower-bound on the write effect
%% denoted by $\llabel$ in their type rules). Everything we have explained up to now models the
%% conventional coarse-grained tracking, where reading (unlabeling) a secret value by a computation
%% must make the $\pc$ secret for its continuations. This can be a problem especially when the
%% continuation wants to produce a low output which is not dependent on the read secret (as explained
%% earlier in Section~\ref{sec:intro}), referred to as \textit{label creep}. But {\cg} has a construct
%% ($\etolabeled$) which can prevent the $\pc$ from being raised at the cost of returning a labeled
%% value.  $\etolabeled(e)$ coerces an expression ($e$) of type $\tslio {\llabel_i} {\llabel_o} {\tau}$
%% to an expression of type $\tslio {\llabel_i} {\llabel_i} {(\tlabeled {\llabel_o} {\tau})}$. As a
%% result the continuation of $\etolabeled(e)$ is not forced to start in an elevated $\pc$ of
%% $\llabel_o$, instead it can start in $\llabel_i$ and only when the continuation actually unlabels
%% the result of the first expression will the $\pc$ be raised to $\llabel_o$.

%% {\cg} supports a notion of subtyping (Fig.~\ref{fig:cg-subtyping}) which is exactly same as that from STLC for the pure
%% types. $\tlabeled {\llabel} {\tau}$ is covariant in $\llabel$; and
%% $\tslio {\llabel_i} {\llabel_o} {\tau}$ is covariant in $\llabel_i$ and contravariant in
%% $\llabel_o$. This is natural as $\llabel_i$ is used as an lower-bound on the write effects and
%% $\llabel_o$ is used as an upper-bound on the read effects.

%% Finally the soundness of {\cg} type system is stated via the following theorem:

We prove soundness for {\cg} by showing that every well-typed
expression satisfies noninterference. Due to the presence of monadic
types, the soundness theorem takes a specific form (shown below), and
refers to a \emph{forcing semantics}. These semantics operate on
monadic types and actually perform reads and writes on the heap (in
contrast, the pure evaluation semantics simply return suspended
computations for monadic types). The forcing semantics are the
expected ones, so we defer their details to the appendix.

\begin{thm}[Noninterference for {\cg}]
  \label{thm:ni-cg}
  Suppose (1) $\llabel_i \not\lbelow \llabel$, (2)
  $x: \tlabeled{\llabel_i}{\tau} \vdash e: \tslio{\_}{\llabel}{\tbool}$, and (3)
  $v_1, v_2: \tlabeled{\llabel_i}{\tau}$. If both $e[v_1/x]$ and $e[v_2/x]$ terminate when forced,
  then they produce the same value (of type $\tbool$).
\end{thm}

\subsubsection{Semantic model of {\cg}}
%\input{fg-semantic-model}
We build a semantic model of {\cg}'s types. The model is very similar
in structure to the model of {\fg}'s types. We use two
interpretations, unary and binary, and worlds exactly as in {\fg}'s
model. The difference is that since state effects are confined to a
monad in {\cg}, all the constraints on heap updates move from the
expression relations to the value relations at the monadic
types. Owing to lack of space, and the similarity in the structures of
the models, we defer {\cg}'s model and the fundamental theorems to the
appendix.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
