\subsection{The fine-grained type system, {\fg}}
\label{sec:fg}

\input{fg-typesystem}


{\fg} is based on the SLam calculus~\cite{popl98-SLAM}, but uses a
presentation similar to Flow Caml, an IFC type system for
ML~\cite{toplas03-flowcaml}. It works on a call-by-value, eager
language, which is a simplification of ML. The syntax of the language
is shown at the top of Figure~\ref{fig:fg-ts}. The language has all
the usual expected constructs: Functions, pairs, sums, and mutable
references (heap locations). The expression ${!}e$ dereferences the
location that $e$ evaluates to, while ${e_1 := e_2}$ assigns the value
that $e_2$ evaluates to, to the location that $e_1$ evaluates to. The
dynamic semantics of the language are defined by a ``big-step''
judgment $(\heap, e) \ReducesTo{j} (\heap', \val)$, which means that
starting from heap $\heap$, expression $e$ evaluates to value $\val$,
ending with heap $H'$. This evaluation takes $j$ steps. The number of
steps is important only for our logical relations models. The rules
for the big-step judgment are standard, hence omitted here.

Every type $\tau$ in {\fg}, including a type nested inside another,
carries a security label. The security label represents the
confidentiality level of the values the type ascribes. It is also
convenient to define unlabeled types, denoted $\utype$, as shown in
Figure~\ref{fig:fg-ts}.

\medskip
\noindent\textbf{Typing rules.}  {\fg} uses the typing judgment
$\Gamma \vdash_\pc e: \tau$. As usual, $\Gamma$ maps free variables of
$e$ to their types. The judgment means that, given the types for free
variables as in $\Gamma$, $e$ has type $\tau$. The annotation $\pc$ is
also a label drawn from $\lattice$, often called the ``program
counter'' label. This label is a \emph{lower bound} on the write
effects of $e$. The type system ensures that any reference that $e$
writes to is at a level $\pc$ or higher. This is necessary to prevent
information leaks via the heap. A similar annotation, $\llabel_e$,
appears in the function type $\tau_1 \fto \tau_2$. Here, $\llabel_e$
is a lower bound on the write effects of the body of the function.

{\fg}'s typing rules are shown in Figure~\ref{fig:fg-ts}. We describe
some of the important rules. In the rule for case analysis
({{\fg}-case}), if the case analyzed expression $e$ has label
$\llabel$, then both the case branches are typed in a $\pc$ that is
\emph{joined} with $\llabel$. This ensures that the branches do not
have write effects below $\llabel$, which is necessary for IFC since
the execution of the branches is control dependent on a value (the
case condition) of confidentiality $\llabel$. Similarly, the type of
the result of the case branches, $\tau$, must have a top-level label
at least $\llabel$. This is indicated by the premise $\tau \searrow
\llabel$ and prevents implicit leaks via the result. The relation
$\tau \searrow \llabel$, read ``$\tau$ protected at
$\llabel$''~\cite{popl99-DCC}, means that if $\tau =
\utype^{\llabel'}$, then $\llabel \lbelow \llabel'$.

The rule for function application ({{\fg}-app}) follows similar
principles. If the function expression $e_1$ being applied has type
$(\tau_1 \fto \tau_2)^{\llabel}$, then $\llabel$ must be below
$\llabel_e$ and the result $\tau_2$ must be protected at $\llabel$ to
prevent implicit leaks arising from the identity of the function that
$e_1$ evaluates to.

In the rule for assignment ({{\fg}-assign}), if the expression
$e_1$ being assigned has type $(\tref~ \tau)^\llabel$, then $\tau$
must be protected at $\pc \ljoin \llabel$ to ensure that the written
value (of type $\tau$) has a label above $\pc$ and $\llabel$. The
former enforces the meaning of the judgment's $\pc$, while the latter
protects the identity of the reference that $e_1$ evaluates to.

All introduction rules such as those for $\lambda$s, pairs and sums
produce expressions labeled $\bot$. This label can be weakened
(increased) freely with the subtyping rule {{\fg}sub-label}. The
other subtyping rules are the expected ones, e.g., subtyping for
unlabeled function types $\tau_1 \fto \tau_2$ is co-variant in
$\tau_2$ and contra-variant in $\tau_1$ and $\llabel_e$
(contra-variance in $\llabel_e$ is required since $\llabel_e$ is a
\emph{lower} bound on an effect). Subtyping for $\tref~\tau$ is
invariant in $\tau$, as usual.

%% {\fg} (a variant of FlowCaml~\cite{toplas03-flowcaml}) is a fine-grained IFC type system for a
%% call-by-value $\lambda$-calculus with sums, products and mutable references. Along with that it also
%% has label polymorphic type ($\forall \alpha. (\llabel_e, \tau)$) and constraint type
%% ($c \cRightarrow \tau$).

%% Being a fine-grained IFC type system, all {\fg} types are annotated with a label, indicating the
%% confidentiality of the value inhabited by the type. Along with a label on the type, {\fg} also uses
%% a special label called as the program counter label (denoted by $\pc$), to prevent leaks via
%% side-effects. $\pc$ denotes a lower-bound on the level of write-effects a well-typed expression can
%% perform on evaluation. For expressions which represent suspended computations like a $\lambda$ term,
%% such a lower-bound on the suspended effects of the function body is indicated by an additional
%% annotation ($\llabel_e$) on the arrow type ($\tau_1 \fto \tau_2$). Similar annotation also exists
%% for label polymorphic and constraint types. The (label) polymorphic type
%% ($\forall \alpha. (\llabel_e, \tau)$) represents the type of a computation which is parameterized by
%% a label i.e $\tau$ can have $\alpha$ free in it. A term of (label) polymorphic type can be used
%% (eliminated) with an application of a label and hence represents a suspended computation.
%% Constraint type ($c \cRightarrow \tau$) represents a suspended computation which can be eliminated
%% only when the constraints (represented by $c$ in its type) can be discharged. $\pc$ is a tracked
%% globally in the typing judgment which has the following form
%% $\lcontext; \cContext; \Gamma \vdash_\pc e: \tau$. The judgment intuitively says that, an expression
%% $e$ of type $\tau$ is well-typed under $\pc$ and a type environment represented by the triple
%% $\lcontext$ (a set of a label variables), $\cContext$ (a set of label constraints) and $\Gamma$ (a
%% mapping from a variable to its type). The type rules also use a judgment of the form
%% $\lcontext;\cContext \vdash \tau \searrow \llabel$ to indicate that
%% $\lcontext;\cContext \models \llabel \lbelow \llabel'$ where $\tau = \utype^{\llabel'}$.

%% {\fg} type rules track these labels (labels on individual types and $\pc$) and perform the necessary
%% checks to make sure that no information leaks via direct or indirect flows. The type rules are
%% symmetric in their treatment of the introduction (intro for short) and elimination (elim for short)
%% forms of the various types. All intro forms like \fg-lam, \fg-prod always type check the consequent
%% at the corresponding base type with a $\bot$ label (subtyping (\fg-sub) can be used to raise the
%% label if required). And all elim forms ensure that the type of the consequent is always protected at
%% the level of type being eliminated (indicated by the $\tau \searrow \llabel$ check in rules like
%% \fg-case). The full set of rules is described in Fig.~\ref{fig:fg-ts}, we only describe specific
%% rules here. \fg-lam uses the lower-bound on the suspended effects (indicated by $\llabel_e$ on
%% $\tau_1 \fto \tau_2$) of the function body to type check its premise (in accordance with the
%% intuition described above). For this to be sound, \fg-app makes sure that the $\pc$ (in which the
%% function is applied) and the label of the function itself (indicated by $\llabel$) both are below
%% the effect label of the function i.e $\llabel_e$.  the intro and elim forms for label polymorphic
%% and constraint type follow a similar convention. Since {\fg} can allow some portion of code to
%% execute conditionally on the choice of a secret via $\ecase$ expression, this can lead to indirect
%% leaks. For instance, consider a value $\val:(\tunit^\bot + \tunit^\bot)^\top$ and assume that the
%% location in $x$ does not contain the value $42$ to begin with. The expression
%% $\ecase(\val, -. (), -. x := 42)$, case analyzes $\val$ and return $()$ in both cases but assigns x
%% to $42$ only in one of the branches. If the attacker can observe the value of $x$ after the
%% execution then it would leak the value of $\val$ to the attacker ($\einl ()$ when $x$ is not $42$
%% and $\einr ()$ otherwise). To prevent such leaks \fg-case type checks the two branches in
%% $\pc \ljoin \llabel$ instead of just $\pc$. Finally we comment a bit on the type rules for
%% references. \fg-ref and \fg-assign rules makes sure that $\tau \searrow \pc$, this check embodies
%% the definitional use of $\pc$ as being a lower-bound on the write effects.

%% Subtyping (described in Fig.~\ref{fig:fg-sub}) in {\fg} is used to permit the upward flow of
%% information from lower to higher confidentiality. Such up-classification is safe as it only makes
%% the information more confidential (and not vice versa, which is insecure). this can be seen in the
%% {\fg}sub-label rule, which allows subtyping by allowing lower confidential type to a higher
%% confidential type. Subtyping is covariant everywhere except in the argument position and the effect
%% label of arrow type, where it is contravariant (label polymorphic and constraint type follow the
%% same convention). This is because if we have an expression of type
%% $({\tnat}^H {\overset{H}\to} \tunit^H)^L$, where the function may produce effects at or above $H$.
%% This implies a weaker statement that the function may produce effects at or above $L$ too. Hence we
%% also have $({\tnat}^H {\overset{L}\to} \tunit^H)^L$. A function argument appears as an assumption in
%% the function type, and strengthening an assumption amounts to weakening the guarantee.  If an
%% expression of type $({\tnat}^H {\overset{H}\to} \tunit^H)^L$ does not leak information despite
%% receiving $H$ input. Then the function will not leak even if it is given a $L$ input. Hence,
%% $({\tnat}^H {\overset{H}\to} \tunit^H)^L \subtype ({\tnat}^L {\overset{H}\to} \tunit^H)^L$.

The main meta-theorem of interest to us is soundness. This theorem
says that every well-typed expression is \emph{noninterferent}, i.e.,
the result of running an expression of a type labeled low is
independent of substitutions used for its high-labeled free
variables. This theorem is formalized below. Note that we work here
with what is called termination-insensitive noninterference; we
briefly discuss the termination-sensitive variant in
Section~\ref{sec:discussion}.
\begin{thm}[Noninterference for {\fg}]
    \label{thm:ni-fg}
  Suppose (1) $\llabel_i \not\lbelow \llabel$, (2)
  $x : \utype^{\llabel_i} \vdash_\pc e: \tbool^\llabel$, and (3)
  $ v_1, v_2: \smash{\smash{\utype}^{\smash{\llabel}_i}}$. If both $e[v_1/x]$ and $e[v_2/x]$
  terminate, then they produce the same value (of type $\tbool$).
\end{thm}

By definition, noninterference, as stated above is a relational
(binary) property, i.e., it relates two runs of a program. Next, we
show how to build a semantic model of {\fg}'s types that allows
proving this property.

\subsubsection{Semantic model of {\fg}}\label{sec:fg-sem}
\input{fg-semantic-model}
We now describe our semantic model of {\fg}'s types. We use this model
to show that the type system is sound (Theorem~\ref{thm:ni-fg}) and
later to prove the soundness of our translations. Our semantic model
uses the technique of step-indexed Kripke logical
relations~\cite{DBLP:conf/popl/AhmedDR09} and is more directly based
on a model of types in a different domain, namely, incremental
computational complexity~\cite{DBLP:conf/icfp/CicekP016}. In
particular, our model captures all the invariants necessary to prove
noninterference.

The central idea behind our model is to interpret each type in two
different ways---as a set of values (unary interpretation), and as a
set of pairs of values (binary interpretation). The binary
interpretation is used to relate \emph{low}-labeled types in the two
runs mentioned in the noninterference theorem, while the unary
interpretation is used to interpret \emph{high}-labeled types
independently in the two runs (since high-labeled values may be
unrelated across the two runs). What is high and what is low is
determined by the level of the observer (adversary), which is a
parameter to our binary interpretation.

\textit{Remark.} Readers familiar with earlier models of IFC type
systems~\cite{popl98-SLAM,popl99-DCC,esop99-PER-IFC} may wonder why we
need a unary relation, when prior work did not. The reason is that we
handle an effect (mutable state) in our model, which prior work did
not. In the absence of effects, the unary model is unnecessary. In the
presence of effects, the unary relation captures what is often called
the ``confinement lemma'' in proofs of noninterference---we need to
know that while the two runs are executing high branches
independently, neither will modify low-labeled locations.

\medskip
\noindent \textbf{Unary interpretation.}
%
The unary interpretation of types is shown in
Figure~\ref{fig:ulr-fg}. The interpretation is actually a Kripke
model. It uses \emph{worlds}, written $\uWorld$, which specify the
type for each valid (allocated) location in the heap. For example,
$\uWorld(a) = \tbool^H$ means that location $a$ should hold a high
boolean. The world can grow as the program executes and allocates more
locations. A second important component used in the interpretation is
a \emph{step-index}, written $m$
or~$n$~\cite{esop06-SILR}. Step-indices are natural numbers, and are
merely a technical device to break a non-well-foundedness issue in
Kripke models of higher-order state, like this one. Our use of
step-indices is standard and readers may ignore them.

The interpretation itself consists of three mutually inductive
relations---a \emph{value relation} for types (labeled and unlabeled),
written $\Ulrv {\tau}$; an \emph{expression relation} for labeled
types, written $\Ulre {\tau}$; and a \emph{heap conformance relation},
written $(n,\heap) \wDefined{} \uWorld$. These relations are
well-founded by induction on the step indices $n$ and types. This is
the only role of step-indices in our model.

The value relation $\Ulrv {\tau}$ defines, for each type, which values
(at which worlds and step-indices) lie in that type. For base types
$\tbase$, this is straightforward: All syntactic values of type
$\tbase$ (written $\llbracket \tbase \rrbracket$) lie in $\Ulrv
{\tbase}$ at any world and any step index. For pairs, the relation is
the intuitive one: $(v_1,v_2)$ is in $\Ulrv{\tau_1 \times \tau_2}$ iff
$v_1$ is in $\Ulrv{\tau_1}$ and $v_2$ is in $\Ulrv{\tau_2}$. The
function type $\tau_1 \fto \tau_2$ contains a value $\lambda x.e$ at
world $\theta$ if in any world $\theta'$ that extends $\theta$, if $v$
is in $\Ulrv{\tau_1}$, then $(\lambda x.e)\ v$ or, equivalently,
$e[v/x]$, is in the \emph{expression relation} $\lreu {\tau_2}
{\llabel_e}$. We describe this expression relation below. Importantly,
we allow for the world $\theta$ to be extended to $\theta'$ since
between the time that the function $\lambda x.e$ was created and the
time that the function is applied, new locations could be
allocated. The type $\tref~\tau$ contains all locations $a$ whose type
according to the world $\theta$ matches $\tau$. Finally, security
labels play no role in the unary interpretation, so $\Ulrv
{\utype^{\llabel}} = \Ulrv {\utype}$ (in contrast, labels play a
significant role in the binary interpretation).

The expression relation $\Ulre {\tau}$ defines, for each type, which
expressions lie in the type (at each $\pc$, each world $\uWorld$ and
each step index $n$). The definition may look complex, but is
relatively straightforward: $e$ is in $\Ulre {\tau}$ if for any heap
$\heap$ that conforms to the world $\theta$ such that running $e$
starting from $\heap$ results in a value $\val'$ and a heap $\heap'$,
there is a some extension $\theta'$ of $\theta$ to which $\heap'$
conforms and at which $v'$ is in $\Ulrv{\tau}$. Additionally, all
writes performed during the execution (defined as the locations at
which $\heap$ and $\heap'$ differ) must have labels above the program
counter, $\pc$. In simpler words, the definition simply says that $e$
lies in $\Ulre {\tau}$ if its resulting value is in $\Ulrv{\tau}$, it
preserves heap conformance with worlds and, importantly, its write
effects are at labels above $\pc$. (Readers familiar with proofs of
noninterference should note that the condition on write effects is our
model's analogue of the so-called ``confinement lemma''.)

The heap conformance relation $(n,\heap) \wDefined{} \uWorld$ defines
when a heap $\heap$ conforms to a world $\uWorld$. The relation is
simple; it holds when the heap $\heap$ maps every location to a value
in the semantic interpretation of the location's type given by the
world $\uWorld$.


\medskip
\noindent \textbf{Binary interpretation.}
%
The binary interpretation of types is shown in
Figure~\ref{fig:blr-fg}. This interpretation relates two executions of
a program with different inputs. Like the unary interpretation, this
interpretation is also a Kripke model. Its worlds, written $\world$,
are different, though. Each world is a triple $\world = (\uWorld_1,
\uWorld_2, \pb)$. $\uWorld_1$ and $\uWorld_2$ are unary worlds that
specify the types of locations allocated in the two executions. Since
executions may proceed in sync on the two sides for a while, then
diverge in a high-labeled branch, then possibly re-synchronize, and so
on, some locations allocated on one side may have analogues on the
other side, while other locations may be unique to either side. This
is captured by $\pb$, which is a \emph{partial bijection} between the
domains of $\uWorld_1$ and $\uWorld_2$. If $(a_1, a_2) \in \pb$, then
location $a_1$ in the first run corresponds to location $a_2$ in the
second run. Any location not in $\pb$ has no analogue on the other
side.

As before, the interpretation itself consists of three mutually
inductive relations---a \emph{value relation} for types (labeled and
unlabeled), written $\Blrv {\tau}$; an \emph{expression relation} for
labeled types, written $\Blre {\tau}$; and a \emph{heap conformance
  relation}, written $(n, \heap_1, \heap_2) \wDefined{\attacker}
\world$. These relations are all parametrized by the level of the
observer (adversary), $\attacker$, which is an element of $\lattice$.

The value relation $\Blrv {\tau}$ defines, for each type, which pairs
of values from the two runs are related by that type (at each world,
each step-index and each adversary). At base types, $\tbase$, only
identical values are related. For pairs, the relation is the intuitive
one: $(v_1,v_2)$ and $(v_1',v_2')$ are related in $\Blrv{\tau_1 \times
  \tau_2}$ iff $v_i$ and $v_i'$ are related in $\Blrv{\tau_i}$ for $i
\in \{1,2\}$. Two values are related at a sum type only if they are
both left injections or both right injections. At the function type
$\tau_1 \fto \tau_2$, two functions are related if they map values
related at the argument type $\tau_1$ to expressions related at the
result type $\tau_2$. For technical reasons, we also need both the
functions to satisfy the conditions of the \emph{unary} relation. At a
reference type $\tref~\tau$, two locations $a_1$ and $a_2$ are related
at world $\world = (\uWorld_1, \uWorld_2, \pb)$ only if they are
related by $\pb$ (i.e., they are correspondingly allocated locations)
and their types as specified by $\uWorld_1$ and $\uWorld_2$ are equal
to $\tau$.

Finally, and most importantly, at a labeled type $\utype^{\llabel}$,
$\Blrv{\utype^{\llabel}}$ relates values depending on the ordering
between $\llabel$ and the adversary $\attacker$. When $\llabel \lbelow
\attacker$, the adversary can see values labeled $\llabel$, so
$\Blrv{\utype^{\llabel}}$ contains exactly the values related in
$\Blrv{\utype}$. When $\llabel \not\lbelow \attacker$, values labeled
$\llabel$ are opaque to the adversary (in colloquial terms, they are
``high''), so they can be arbitrary. In this case,
$\Blrv{\utype^{\llabel}}$ is the cross product of the \emph{unary}
interpretation of $\utype$ with itself. This is the only place in our
model where the binary and unary interpretations interact.

The expression relation $\Blre {\tau}$ defines, for each type, which
pairs of expressions from the two executions lie in the type (at each
world $\world$, each step index $n$ and each
adversary~$\attacker$). The definition is similar to that in the unary
case: $e_1$ and $e_2$ lie in $\Blre{\tau}$ if the values they produce
are related in the value relation $\Blrv{\tau}$, and the expressions
preserve heap conformance.

The heap conformance relation $(n, \heap_1, \heap_2)
\wDefined{\attacker} \world$ defines when a pair of heaps $\heap_1$,
$\heap_2$ conforms to a world $\world=(\uWorld_1, \uWorld_2,
\pb)$. The relation requires that any pair of locations related by
$\pb$ have the same types (according to $\uWorld_1$ and $\uWorld_2$),
and that the values stored in $\heap_1$ and $\heap_2$ at these
locations lie in the binary value relation of that common type.

\medskip
\noindent \textbf{Meta-theory.}  The primary meta-theoretic property
of a logical relations model like ours is the so-called
\emph{fundamental theorem}. This theorem says that any expression
syntactically in a type (as established via the type system) also lies
in the semantic interpretation (the expression relation) of that
type. Here, we have two such theorems---one for the unary
interpretation and one for the binary interpretation.

To write these theorems, we define unary and binary interpretations of
contexts, $\Ulrv{\Gamma}$ and $\Blrv{\Gamma}$, respectively. These
interpretations specify when unary and binary substitutions conform to
$\Gamma$. A unary substitution $\vsubsts$ maps each variable to a
value whereas a binary substitution $\vsubstp$ maps each variable to
two values, one for each run.
\begin{mathpar}
  \begin{array}{@{}l@{\,}l@{\,}l@{}}
    \Ulrv {\Gamma} & \triangleq &
    \begin{array}[t]{@{}l@{}}
      \{(\uWorld, n, \vsubsts) ~|~  \dom(\Gamma) \subseteq \dom(\vsubsts) \wedge
                                  \forall x \in \dom(\Gamma). \\
~~~~~~~~~~~~~~~~(\uWorld, n, \vsubsts(x)) \in \Ulrv {\Gamma(x)}
       \}
    \end{array}\\
%
  \Blrv {\Gamma} & \triangleq &
  \begin{array}[t]{@{}l@{}}
    \{(\world, n, \vsubstp) ~|~
    \dom(\Gamma) \subseteq \dom(\vsubstp) \wedge \forall x \in
    \dom(\Gamma). \\
~~~~~~~~~~~~    (\world, n, \pi_1(\vsubstp(x)), \pi_2(\vsubstp(x)))
    \in \Blrv {\Gamma(x)} \}
    \end{array}
%
  \end{array}
\end{mathpar}

\begin{thm}[Unary fundamental theorem]
\label{thm:fundUnary-fg}
If $\Gamma \vdash_{\pc} e:\tau$
and $(\uWorld, n, \vsubsts) \in \Ulrv {\Gamma }$, then
$(\uWorld, n, e ~ \vsubsts) \in \lreu {\tau} {\pc}$.
\end{thm}

\begin{thm}[Binary fundamental theorem]
  \label{thm:fundBinary-fg}
  If $\Gamma \vdash_{\pc} e:\tau$ and $(\world, n, \vsubstp) \in \Blrv
  {\Gamma}$, then $(\world, n, e ~ (\vsubstp \proj{1}), e ~ (\vsubstp
  \proj {2})) \in \Blre {\tau} $, where $\vsubstp\proj{1}$ and
  $\vsubstp\proj{2}$ are the left and right projections of $\gamma$.
\end{thm}

The proofs of these theorems proceed by induction on the given
derivations of $\Gamma \vdash_{\pc} e:\tau$. The proofs are tedious,
but not difficult or surprising. The primary difficulty, as with all
logical relations models, is in setting up the model correctly, not in
proving the fundamental theorems.

{\fg}'s noninterference theorem (Theorem~\ref{thm:ni-fg}) is a simple
corollary of these two theorems.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
