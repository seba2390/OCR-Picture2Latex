\section{Discussion}
\label{sec:discussion}

\noindent \update{\textbf{Practical implications.}} \update{Our
  results establish that a coarse-grained IFC type system that labels
  at the granularity of entire computations can be as expressive as a
  fine-grained IFC type system that labels every individual value, if
  the coarse-grained type system has a construct like $\etolabeled$ to
  limit the scope of taints. It is also usually the case that a
  coarse-grained type system burdens a programmer less with
  annotations as compared to a fine-grained type system. This leads to
  the conclusion that, in general, there is merit to preferring
  coarse-grained IFC type systems with taint-scope limiting constructs
  over fine-grained IFC type systems. In a coarse-grained type system,
  the programmer can benefit from the reduced annotation burden and
  simulate the fine-grained type system when the fine-grained labeling
  is absolutely necessary for verification. Since our embedding of the
  fine-grained type system in the coarse-grained type system is
  compositional, it can be easily implemented in the coarse-grained
  type system as a library of macros, one for each construct of the
  language of the fine-grained type system.}


%% One can use macros
%% to simplify the top level expression translation. For instance, the
%% {\fc-app} rule from Figure~\ref{fig:fg-2-cg-expr}, can be simplified
%% as follows:

%% \begin{displaymath}
%%   \inferrule
%%   {
%%     \Gamma \vdash_{\pc} e_1: (\tau_1 \fto \tau_2)^{\llabel}
%%     \leadsto
%%     e_{c1}
%%     \\
%%     \Gamma \vdash_{\pc} e_2:\tau_1
%%     \leadsto
%%     e_{c2}
%%     \\
%%     \lattice \vdash  \llabel \ljoin \pc \lbelow \llabel_e \\
%%     \lattice \vdash \tau_2 \searrow \llabel
%%   }
%%   {
%%     \Gamma \vdash_{\pc} e_1 ~ e_2:\tau_2
%%     \leadsto
%%     \appCG \; e_{c1} \; e_{c2}
%%   }
%% \end{displaymath}

%% The simplified rule uses a macro $\appCG \; e_1' \; e_2'$ which is defined as

%% \noindent{$\coerce(\ebind(e_{1}', a. \ebind (e_{2}', b. \ebind(\eunlabel ~ a, c. (c ~ b)))))$}

\medskip
\noindent\textbf{Original HLIO.} The original HLIO
system~\cite{icfp15-HLIO}, from whose static fragment {\cg} is
adapted, differs from {\cg} in the interpretation of the labels
$\llabel_1$ and $\llabel_2$ in the monadic type
$\tslio{\llabel_1}{\llabel_2}{\tau}$. {\cg} interprets these labels as
the pc-label and the taint label, respectively. HLIO interprets these
labels as the \emph{starting taint} and the \emph{ending taint} of the
computation. This implies an \emph{invariant} that $\llabel_1 \lbelow
\llabel_2$ and makes HLIO more restrictive that {\cg}. The relevant
consequence of this difference is that the rule for $\etolabeled$
cannot always lower the final taint to $\bot$. HLIO's rule is:
\[   \inferrule
   { \Gamma \vdash e: \tslio{\llabel}{\llabel'}{\tau} }
   {
    \Gamma \vdash \etolabeled(e)
   		: \tslio{\llabel}{\llabel}{(\tlabeled{\llabel'}{\tau})}
   }
   \rname{{\cg}-toLabeled}
\]
This restrictive rule makes it impossible to translate from {\fg} to
HLIO in the way we translate from {\fg} to {\cg}. In
fact,~\cite{siglog17-ifcComp} already explains how this restriction
makes a translation from {\fg} to the static fragment of HLIO very
difficult. Our observation here is that HLIO's restriction, inherited
from a prior system called LIO, is not important for statically
enforced IFC and eliminating it allows a simple embedding of a
fine-grained IFC type system.

Nonetheless, we did investigate further whether we can embed {\fg}
into the static fragment of the unmodified HLIO. The answer is still
affirmative, but the embedding is complex and requires nontrivial
quantification over labels. Part II of our appendix contains a
complete account of this embedding (in fact, the appendix contains a
parallel account of all our results using the original HLIO in place
of {\cg}).

\update{HLIO also has two constructs, getLabel and labelOf, that allow
  reflection on labels. However, these constructs are meaningful only
  because HLIO uses hybrid (both static and dynamic) enforcement and
  carries labels at runtime. In a purely static enforcement, such as
  {\cg}'s, labels are not carried at runtime, so reflection on them is
  not meaningful.}

\medskip
\noindent \textbf{Full abstraction.}  Since our translations preserve
typed-ness, they map well-typed source programs to noninterfering
target programs. However, an open question is whether they preserve
contextual equivalence, i.e., whether they are fully
abstract. Establishing full abstraction will allow translated source
expressions to be freely co-linked with target expressions. We haven't
attempted a proof of full abstraction yet, but it looks like an
interesting next step. \update{We note that since our dynamic
  semantics (big-step evaluation) are not cognizant of IFC (which is
  enforced completely statically), it may be sufficient to generalize
  our translations to simply-typed variants of FG and CG, and prove
  those fully abstract.}

\medskip
\noindent \textbf{Other IFC properties.}  Our current setup is geared
towards proving \emph{termination-insensitive} noninterference, where
the adversary cannot observe nontermination. We believe that the
approach itself and the equivalence result should generalize to
termination-sensitive noninterference, but will require nontrivial
changes to our development. For example, we will have to change our
binary logical relations to imply co-termination of related
expressions and, additionally, modify the type systems to track
nontermination as a separate effect.

Another relevant question in whether our equivalence result can be
extended to type systems that support declassification and, more
foundationally, whether our logical relations can handle
declassification. This is a nuanced question, since it is unclear
hitherto how declassification can be given a compositional semantic
model. We are working on this problem currently.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
