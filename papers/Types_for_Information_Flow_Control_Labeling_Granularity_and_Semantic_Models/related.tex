\section{Related work}
\label{sec:related}

We focus on related work directly connected to our
contributions---logical relations for IFC type systems and language
translations that care about IFC.

\medskip \noindent \textbf{Logical relations for IFC type systems.}
Logical relations for IFC type systems have been studied before to a
limited extent. Sabelfeld and Sands develop a general theory of models
of information flow types based on partial-equivalence relations
(PERs), the mathematical foundation of logical
relations~\cite{esop99-PER-IFC}. However, they do not use these models
for proving any specific type system or translation sound. The pure
fragment of the SLam calculus was proven sound (in the sense of
noninterference) using a logical relations argument~\cite[Appendix
  A]{popl98-SLAM}. However, to the best of our knowledge, the relation
and the proof were not extended to mutable state. The proof of
noninterference for Flow Caml~\cite{toplas03-flowcaml}, which is very
close to SLam, considers higher-order state (and exceptions), but the
proof is syntactic, not based on logical relations. The dependency
core calculus (DCC)~\cite{popl99-DCC} also has a logical relations
model but, again, the calculus is pure. The DCC paper also includes a
state-passing embedding from the IFC type system of Volpano, Irvine
and Smith~\cite{jcs96-volpanoSmith}, but the state is
first-order. \update{Mantel \emph{et al.} use a security criterion
  based on an indistinguishability relation that is a PER to prove the
  soundness of a flow-sensitive type system for a concurrent
  language~\cite{DBLP:conf/csfw/MantelSS11}.  Their proof is also
  semantic, but the language is first-order.} In contrast to these
prior pieces of work, our logical relations handle higher-order state,
and this complicates the models substantially; we believe we are the
first to do so in the context of IFC.

Our models are based on the now-standard step-indexed Kripke logical
relations~\cite{DBLP:conf/popl/AhmedDR09}, which have been used
extensively for showing the soundness of program verification
logics. Our model for {\fg} is directly inspired by Cicek \emph{et
  al.}'s model for a pure calculus of incremental
programs~\cite{DBLP:conf/icfp/CicekP016}. That calculus does not
include state, but the model is structurally very similar to our model
of {\fg} in that it also uses a unary and a binary relation that
interact at labeled types. Extending that model with state was a
significant amount of work, since we had to introduce Kripke
worlds. Our model for {\cg} has no direct predecessor; we developed it
using ideas from our model of {\fg}. (DCC is also coarse-grained and
uses a labeled monad to track dependencies, but its model is quite
different from ours in the treatment of the monadic type.)

\medskip \noindent \textbf{Language translations that care about IFC.}
Language translations that preserve information flow properties appear
in the DCC paper. The translations start from SLam's pure fragment and
the type system of Volpano, Irvine and Smith and go into DCC. The
paper also shows how to recover the noninterference theorem of the
source of a translation from properties of the target, a theorem we
also prove for our translations.
%
Barthe \emph{et al.}~\cite{DBLP:journals/cl/BartheRB07} describe a
compilation from a high-level imperative language to a low-level
assembly-like language. They show that their compilation is type and
semantics preserving. They also derive noninterference for the source
from the noninterference of the target.
%
Fournet and
Rezk~\cite{popl08-cryptoIFC} describe a compilation from an IFC-typed
language to a low-level language where confidentiality and integrity
are enforced using cryptography. They prove that well-typed source
programs compile to noninterfering target programs, where the target
noninterference is defined in a computational sense.
%
Algehed and Russo~\cite{plas17-DCCinHaskell} define an embedding of
DCC into Haskell. They also consider an extension of DCC with state
but, to the best of our knowledge, they do not prove any formal
properties of the translation.

%% On the semantic models side,

%% DCC~\cite{popl99-DCC} presents a category-theoretic model for a type system with a monad.

%% - The monad in DCC is used for associating labels with types as opposed to the monad used in our
%% {\cg} type system where we use it for tracking effects.

%% - the core DCC calculus does not handle state based effects like we do (but show an embedding of a
%% IFC type system with first order effects - Volpano and smith~\cite{jcs96-volpanoSmith})

%% \medskip

%% SLAM~\cite{popl98-SLAM}

%% - presents a set theoretic model for a fine-grained IFC enforcement in a denotational
%% setting. Although they have a calculus which handles heap based effects but their model only covers
%% the pure language. Our model on the hand is based on operational interpretation covering full
%% higher-order state.

%% - They only have a unary interpretation for types and use that to define a (family of) relation of
%% pairs of values indexed by types describing set of related values of that type. We on the other hand
%% give two different interpretations to the types - unary and binary.

%% \medskip

%% PER model~\cite{esop99-PER-IFC}

%% - Presents a Partial Equivalence Relation (PER) based model for IFC types.  PERs are symmetric and
%% transitive relations which represent a meet sem-lattice. And they use PERs to give a relational
%% interpretation to types, this is done in a denotaitonal setting like SLAM.

%% - We on the other hand have logical predicates and logical relational, not sure how they are
%% different from PERs yet (what abt reflexivity ?)


%% % DCC~\cite{popl99-DCC} presents a categorical
%% % model for a dependence analysis using monadic types for labeling. Sands and
%% % Sabelfeld~\cite{esop99-PER-IFC} present a PER(Partial Equivalence Relation) based model for IFC. Our
%% % model is based on Kripke step-indexed logical relations which we encode in basic set theory and
%% % higher-order logic. In the setting of cost analysis (which is also a form of dependence analysis),
%% % Relcost~\cite{popl17-relcost} presents a set-theoretic and step-indexed logical relation model for a
%% % language without heap effects.

%% On the translations side, translations between different computational models have been of interest
%% to computer science from the early 70s - Plotkin~\cite{tcs75-cbvAndcbn} presented translations
%% between call-by-name and call-by-value models of $\lambda$-calculus in a pure setting. Later such
%% translations were studied under variations with linearity~\cite{tcs95-CbvCbnLin}, etc. In the
%% context of dependence analysis too DCC~\cite{popl99-DCC} presents embedding of various dependence
%% calculi into DCC. Barthe et al.~\cite{DBLP:journals/cl/BartheRB07} describe a type preserving
%% compilation from a high-level imperative language to low-level assembly-like language. They show
%% that their compilation is type and semantics preserving. Using this, these results they also derive
%% the {\NI} of the source. Our soundness criteria is similar to theirs, however our translation is
%% type-directed while theirs is syntax-directed.


%% \medskip

%% Fournet et al.~\cite{popl08-cryptoIFC}

%% - Study compilation of an imperative language with IFC types to a probabilistic language with
%% cryptographic primitives.

%% - They prove the soundness of their translation by showing type preservation and functional
%% correctness of the translated program.

%% - They also prove computational soundness of the translation (not very clear to me right now)

%% - But they dont prove full abstraction

%% \medskip

%% Russo et al.~\cite{plas17-DCCinHaskell}

%% - explore embedding of DCC into Haskell mainly focusing on the embedding of the non-standard bind
%% operator of the DCC's T monad

%% - they also explore how to handle effects in DCC. And show that effects which can be given a
%% functional representation are amenable to being embedded in DCC like outputs, state, error handling

%% - They don't have any formal correctness proofs







% The translations that come closest to ours are the ones
% present in \cite{popl99-DCC} and \cite{plas17-DCCinHaskell}, however none of them study the question
% of expressiveness across varying granularity of dependence analysis.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
