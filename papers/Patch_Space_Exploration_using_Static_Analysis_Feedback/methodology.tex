\section{Methodology}

This section describes how bugs are detected, how patches are synthesised using probabilistic context free grammars
and subsequently classified into equivalence classes according to the effect they have on the footprint of the buggy program.

\subsection{Bug Detection}
We build our approach on top of \pulse \cite{pulse-link}, an industry-grade static analysis tool 
which soundly detects memory safety violations. \pulse uses the latest advances in Incorrectness Separation Logic (ISL), a logic tailored to reason about the presence of bugs for heap-manipulating programs. \pulse first abstracts the C input program to an intermediate language, the Smallfoot Intermediate Language (SIL),
and then runs an abstract interpretation engine to check for safety bugs.

\noindent \emph{\bf Program model.} A SIL core set of expressions and commands is depicted in \autoref{fig:lang}. A program in SIL is a sequence of procedures, and a procedure is a composition of heap manipulating commands and standard commands, such as allocation, deallocation, conditionals, etc. The storage model comprises a stack and a heap, where the stack is a function from the set of program and logical variables to values, and the heap is a partial function from symbolic heap locations to values. 
A state thus models a stack and a heap, and together with an environment which tracks the values associated with program and logical variables it models a \pulse world.

\noindent \emph{\bf The abstract domain (\domaindetect).} The abstract domain on which \pulse operates when symbolically executing the SIL commands is depicted in \autoref{fig:logic}: a symbolic heap $\Delta$ comprises a spatial term \mcode{k} and a pure, first order logical formula, $\pi$ to account for pointer aliasing and non-heap information. 
%
The spatial term 
$\emp$ is an assertion to denote an empty heap,  \mcode{\pointsto{v}{X}}  is the points-to assertion for the program variable \mcode{v}, while 
 \mcode{ \pointsto{Y}{X}} is the points-to for logical variables.  \mcode{ \dealloc{X}} denotes memory deallocation, and  the separation logic conjunction \mcode{  k \sep k}  denotes disjoint sub-heaps. 
 %
 An abstract state $\Phi$ is defined as a pair of a program path $\pi$ and a symbolic heap $\Delta$.
 
\noindent \emph{\bf Bug detection.} 
\pulse uses summaries (specifications) of predefined instructions to infer the summary (specification) of a given piece of code \cite{Le2022}. 
%
At the core of \pulse is the ISL (under-approximate) triple  $\isltriple{\Phi_\textit{pre}}{c}{\epsilon:\Phi_\mathit{post}}$ which asserts that any final state satisfying $\Phi_\mathit{post}$ is reachable by executing $c$ starting from an initial state satisfying $\Phi_\mathit{pre}$. Furthermore, the exit condition $\epsilon$ indicates either a normal termination, i.e. $\ok$, or a buggy one, i.e. $\err$.
The pair $(\Phi_\textit{pre}, \epsilon:\Phi_\mathit{post})$ describes the effect $c$ has on one program path, 
and a set $F$ (\autoref{fig:logic}) of such effects describes the memory footprint of $c$ where each effect in the set corresponds to a unique program path.


\noindent \emph{\bf Bug description.} A bug report in \pulse comprises the information $\epsilon$ about the bug kind, e.g. null dereference, and the culprit statement  $c$, e.g. the statement which dereferences a null pointer. On top, we record the summary of the method which contains the bug, $F$, and  the path $\pi$ on which the bug manifests. 
A bug is defined in terms of the following tuple:
\\
\centerline{$b ~::=~ \langle \epsilon,  \pi, c, F \rangle$.}

For a bug $b$ we will often refer to an element of the tuple using the dot notation, e.g. $b.F$. The same notation is used throughout the paper for other kinds of tuples as well. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% PROGRAMMING LANGUAGE %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure*}[t]
\[
\;\;\;\;\;\;\;\;\;\;\;
{\small
\begin{array}{l r c l}
 \\[2pt]
 \text{Variables} \qquad v & \multicolumn{3}{l}{
  \text{Alpha-numeric identifiers} \qquad {x, y    }
   \qquad\qquad\
  \text{Locations} \qquad {\textit{loc}    }
  \qquad\quad~
   \text{Pointers} ~~ ptr ~~ ::= ~~ v \mid \nullc}
 \\[10pt]
 \text{Boolean Expression} & b & ::= &
 \True \mid  \False \mid  b ~\vee~ b \mid   b ~\wedge~ b \mid  \neg b \mid x ~\textit{op}_r~ x \mid  \textit{ptr} ~ \textit{op}_p  ~ \textit{ptr}
 \\[2pt]
 \text{Relational Operator} & \textit{op}_r & ::= &  <  ~\mid~ <= ~\mid~ == ~\mid~  !\!\!= ~\mid~ > ~\mid~ >= 
  \qquad\qquad\qquad
   \text{Pointers Operator} ~~~ \textit{op}_p ~~ ::=~~ ==  ~\mid~ !\!\!=
 \\[2pt]
 \text{Heap Manipulation} & s & ::= & v \asgn p \mid  v \asgn [ \textit{ptr} ] \mid  [ \textit{ptr} ] \asgn  \textit{ptr}  \mid   \textit{ptr}  = \malloc{} \mid  \free{v} 
 \\[2pt]
 \text{Commands} &
 c & ::= &
            s 
            \mid x :=  f(\many{x})
            \mid c; c 
            \mid \ite{b}{c}{c}
            \mid \whilez(b) \{c\}
\mid \retz~  \textit{x}  \mid \retz~  \textit{ptr} \mid \gotoz ~ \textit{label}
 \\[10pt]     
 \text{Patch} &
  P & ::= & \text{INSERT} ~c~\textit{loc} ~\mid~   \text{COND} ~\False~\textit{loc}   
\end{array}
}
\]
\vspace{-0.5em}
\caption{Core (Simplified) Programming Language.}
\label{fig:lang}
\end{figure*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%% ASSERTION LANGUAGE %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\begin{figure}[t]
\vspace{-0.8em}
 \centering
%
\[
\!\!\!\!\!\!\!\!\!\!\!\!
{  \small
\begin{array}{l l c l}
 \text{Exit condition} & \epsilon  & ::=& \{\ok,\err, abort\} \\
 \text{Pure term} & \pi  & ::= & b
 \\
 \text{Spatial term} &\mcode{k} & ::= &
 \mcode{\emp \mid \pointsto{v}{X}}
 \mcode{\mid \pointsto{Y}{X}}
 \mcode{\mid \dealloc{X}}
  \mid  \mcode{  k \sep k}
 \\
 \text{Symbolic heap} & \Delta & ::= & \mcode{ k \wedge \pi}
 \\
 \text{State} & \Phi& ::= & \pi; \Delta \mid \exists X.\pi;\Delta
 \\
 \text{Effect} & E & ::= & (\Phi, \epsilon: \Phi)  
 \\
 \text{Footprint} & F & ::= &  \mathit{Set}(E)  
\end{array}
}
\]
%
\vspace{-0.5em}
\caption{Abstract domain for bug detection (\domaindetect).}
\vspace{-1em}
\label{fig:logic}
\end{figure}


\subsection{Patch Synthesis with Probabilistic CFGs}
In this work, we employ a synthesis mechanism based on \emph{probabilistic context free grammars (PCFG)} tailored for our approach to APR.
%
In a CFG, a non-terminal symbol may be expanded in \emph{n} different ways,  
e.g. a command $c$ in \autoref{fig:lang} may be expanded in 8 different ways.
In a PCFG, each production rule comes annotated with a probability $p$, denoting the probability of this rule being selected, with the proviso that 
the sum of probabilities of all  \emph{n} production rules should be 1, e.g. 
$\sum_{i=1}^8 p_i =1$ for the production rules of command $c$.

In our approach, instead of annotating the production rules with one probability, 
we do so with a pair of probabilities denoted by  $\langle p^\pi, p^e \rangle$, with the same proviso holding 
separately for each probability in the pair, e.g. $\sum_{i=1}^8 p^\pi_i =1$ and  $\sum_{i=1}^8 p^e_i =1$ for the production rules of command $c$.
This design choice was made so as to be able to navigate the search space of patches from two different dimensions in parallel: 
finding patches with a high-probability of affecting only the path on which the bug was found (corresponding to probability $p^\pi$), 
and finding patches with a high-probability of having an effect on the heap state which fixes the considered bug (corresponding to probability $p^e$). 

Assuming these pair of probabilities are set for each production rule,
(we detail in \autoref{subsec:learnprob} how the probabilities are learnt),
we generate patches by simply traversing the grammar and choosing 
production rules based on the product of $ p^\pi * p^e$, since we consider
the event of generating a patch which affects the buggy path and the event 
of generating a patch with the correct memory effect to be independent of each other.
To avoid the risk of leading to a very large (possibly infinite) parsing tree, we bound the size of the 
tree to a height $h$. 
However, this poses the risk of generating syntactically incorrect patches when 
the height $h$ is reached. To avoid this issue, choosing 
the next production rule is a function of the rule's given probability and height: 
if the height of the generated tree is $h$, we prioritise production rules which lead to syntactically correct patches regardless of their probability; else, the probability is the sole deciding factor in choosing the next production rule.  

\subsection{Patch Clustering}\label{ssec:clustering}

To reduce the cost of patch validation we progressively refine the 
solution space by identifying classes of \emph{equivalent patches}, and proceed
with only validating one representative patch per class. 
%
Two patches are equivalent if we can show that they lead to patched programs 
which have equivalent memory footprints, or, stated differently, they have the
same effect when applied on the buggy program. 
%
Given an ISL triple $\isltriple{\Phi_{\textit{pre}}}{\textit{fnc}}{\epsilon:\mathit{\Phi_{\textit{post}}}}$, 
the memory footprint of $\mathit{fnc}$ is described by the two memory snapshots/states, $\mathit{\Phi_{\textit{pre}}}$ and ${\epsilon:\mathit{\Phi_{\textit{post}}}}$, respectively. 
%
Reasoning about equivalent memory footprints would require
reasoning about equivalent ISL formulas, which in turn requires ISL logic entailment checking. 
%
To break the dependency of the bug domain and make our approach agnostic to the bug detector, we design a meta abstraction on top of ISL in order to describe a simpler memory snapshot. 
%
\autoref{fig:equiv} describes the meta domain \domainequiv~
used for equivalence checking, while,
defined as a recursive function $\mathit{abs}$,
\autoref{fig:transform} introduces some of the main abstraction rules for translating a state from ISL to  \domainequiv.
A memory snapshot in \domainequiv~ is described by a tuple $\phi$ comprising
a path $\pi$ in first order logic, 
a set of allocated 
symbolic memory cells \allocset, a set of deallocated 
symbolic memory cells \deallocset, and a set of pointer aliases \aliasset.
An effect is a tuple $e$ which comprises the exit condition $\epsilon$
and two memory snapshots ${\phi_\text{pre}}$ and ${\phi_\text{post}}$, corresponding to the 
inferred precondition and postcondition, respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%%%%% EQUIVALNECE LANGUAGE %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\begin{figure}[t]
 \centering
%
\[
\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!
{  \small
\begin{array}{l l c l}
 \text{Allocated symbolic heaps} & \multicolumn{3}{l}{\mcode{H} \subseteq \mathit{Loc}}
 \\
 \text{Deallocated symbolic heaps} & \multicolumn{3}{l}{\mcode{D} \subseteq \mathit{Loc}}
  \\
  \text{Aliases} & \multicolumn{3}{l}{\mcode{A} \subseteq	\mathbb{P}(\mathit{Vars} \times \mathit{Vars)}}
 \\
 \text{State} & \phi & ::= & \mcode{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}}
 \\
 \text{Effect} & e & ::= & \mcode{\footprint{\epsilon}{\ret}{\phi_\text{pre}}{\phi_\text{post}}}
 \\
 \text{Footprint} &\mathcal{F} & ::= & \mathit{Set}(e)
\end{array}
}
\]
%
\vspace{-0.5em}
\caption{Abstract domain for equivalence checking (\domainequiv).}
\vspace{0.3em}
\label{fig:equiv}
\end{figure}

\begin{figure*}[h]
{\footnotesize
\begin{mathpar}
		\collectrule{Fun}{
		}{
			\collectfn
			{{\pi; \Delta}}{\_} 
			\eqdef
			\collectfn{\Delta}{\metatriple{\pi}{\epsilon}{\ret}{\emptyset}{\emptyset}{\emptyset}}
		}   
	
					\collectrule{Fun}{
													}{\collectfn
													{\mcode{p_1=p_2 }}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}} 
													\eqdef
													{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset \cup\{(p_1,p_2)\} }} 
													}    
													\\
        	\collectrule{Fun}{
            {\metatriple{\_}{\epsilon}{\ret}{\allocset'}{\deallocset'}{\aliasset'}} := \collectfn{k}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}}
        	\quad
            {\metatriple{\_}{\epsilon}{\ret}{\_}{\_}{\aliasset''}} := \collectfn{\pi'}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}}
			}{\collectfn
			{\mcode{k \wedge \pi'}}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}} 
			\eqdef
			{\metatriple{\pi}{\epsilon}{\ret}{ \allocset'}{ \deallocset'}{\aliasset' \cup \aliasset''}}
		}   
		\\
	        	\collectrule{Fun}{
	        	{\metatriple{\pi}{\epsilon}{\ret}{\allocset_1}{\deallocset_1}{\aliasset_1}} := \collectfn{k_1}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}} 
	        	\quad
	            {\metatriple{\pi}{\epsilon}{\ret}{\allocset_2}{\deallocset_2}{\aliasset_2}} := \collectfn{k_2}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}} 
				}{\collectfn
				{\mcode{k_1 \sep k_2}}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}} 
				\eqdef
				{\metatriple{\pi}{\epsilon}{\ret}{\allocset_1 \cup \allocset_2}{\deallocset_1 \cup \deallocset_2}{\aliasset_1 \cup \aliasset_2}} 
			}      
			\\
				\collectrule{Fun}{
				}{\collectfn
				{\mcode{ \pointsto{Y}{X}}}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}} 
				\eqdef
				{\metatriple{\pi}{\epsilon}{\ret}{\allocset \cup\{Y\}}{\deallocset}{\aliasset}} 
				}    
				
				\collectrule{Fun}{
								}{\collectfn
								{\mcode{\dealloc{X} }}{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset}} 
								\eqdef
								{\metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset \cup \{Y\}}{\aliasset}} 
								}      
\end{mathpar}}
\caption{Abstract domain transformation (\domaindetect $\rightarrow$ \domainequiv).}
\vspace{-1em}
\label{fig:transform}
\end{figure*}

Given the meta domain \domainequiv ~we can now define  indistinguishable (meta-)effects in terms of indistinguishable states.
\begin{definition}[Indistinguishable states]
Two states $\phi_1$ and $\phi_2$ are said to be indistinguishable, denoted by $\phi_1 \approx \phi_2$  if and only if the following condition holds:

\centerline{
$\phi_1.\pi \Leftrightarrow \phi_2.\pi ~\wedge$
$\phi_1.H = \phi_2.H ~\wedge $ 
$\phi_1.D = \phi_2.D.$
}
\noindent where the equality on sets is defined modulo the alias information stored in $\phi_1.A$ and  $\phi_2.A$, respectively. 
\end{definition}

\begin{definition}[Indistinguishable meta-effects]
Two meta effects $e_1$ and $e_2$ are said to be indistinguishable, denoted by $e_1 \approx e_2$,  if and only if the following condition holds:

\centerline{
 $e_1.\epsilon = e_2.\epsilon ~\wedge$
 $e_1.\text{pre} \approx e_2.\text{pre} ~\wedge$
 $e_1.\text{post} \approx e_2.\text{post} $
}
\end{definition}

So far we talked about a memory footprint as if it comprises a single pair of pre- and post-conditions. However, programs are often ascribed multiple such pairs to account
for different behaviours on different program paths. A memory footprint is thus a disjunction of pair of states in ISL, $F$ in \autoref{fig:logic}, which corresponds to a set of effect tuples in the meta-domain \domainequiv, $\mathcal{F}$ in \autoref{fig:equiv}. We define indistinguishable footprints as follows: 

\begin{definition}[Indistinguishable footprints]
Two footprints $\mathcal{F}_1$ and $\mathcal{F}_2$ are said to be indistinguishable, denoted by $\mathcal{F}_1 \approx \mathcal{F}_2$, if and if the following condition holds:

\centerline{$\forall e_1 \in \mathcal{F}_1, \exists e_2 \in \mathcal{F}_2: ~ e_1 \approx e_2$.}
\end{definition}
In other words, two footprints are indistinguishable if they have indistinguishable meta-effects on each path.  
Equivalent patches are now simply defined as:
\begin{definition}[Equivalent patches]
Two patches $P_1$ and $P_2$ which lead to footprints $F_1$ and $F_2$, respectively, 
when applied to the same buggy program, are said to be equivalent  if and only if their corresponding 
footprint meta-abstractions, that is,  $\mathcal{F}_1$ and $\mathcal{F}_2$, respectively, are indistinguishable:
$\mathcal{F}_1 \approx \mathcal{F}_2$.
\end{definition}

We use the above definition of equivalent patches to
progressively partition the search space into classes of equivalent patches. 
The benefit of this partitioning is that we only need to validate one
patch per class of plausible patches.
Given a bug $b$, a class of plausible patches is one where all 
patches $P$ meet the following condition:

\centerline{$\forall e \in P.\mathcal{F} : (e.\text{post}.\pi \Rightarrow b.\pi ) \Rightarrow e.\epsilon = \ok$}
In other words, the path on which the bug manifested 
is now labelled with an $\ok$ exit condition, i.e. the bug is fixed. 

\subsection{Learning Probabilities}\label{subsec:learnprob}

Starting from a PCFG with a uniform distribution (with regards to the pair of 
probabilities), we ascribe probabilities to this PCFG with the aim of
increasing the likelihood of mostly navigating search spaces of plausible patches. 

We adopt a strategy where we reward the production rules which lead to 
a patch that impacts the path the bug manifests on and those which
lead to a patch that affects the bug's memory footprint.  
%
Let us assume that the PCFG stores weights instead of probabilities
where weight is an integer indicating the total number of rewards a production rule 
 has received---we use a $\textit{token}$ as the measurement unit.
%
The rewards then carry different weights, depending on how \emph{close} the generated 
patch is to fixing the bug. 
%
At a high level,  $ p^\pi$ receives a minimal reward, e.g. 1 token, when the patch affects
the path on which the bug manifests but also other paths. 
$ p^\pi$ receives a maximal reward, e.g. 3 tokens, when the patch affects the entire path on which the bug manifests, while the memory footprint on the other paths remains unchanged.
%
Similarly, $p^e$ is minimally rewarded if the current patch affects the bug's memory footprint without fixing the bug or by fixing the bug and introducing a new one. $p^e$ is maximally rewarded when the patch fixes the bug without introducing new bugs. 
The production rules used to generate a patch are updated according to the above rewarding strategy, before we normalise the weights back into probabilities:
 $p_{c,i} = w_{c,i} / \sum_{j=1}^{n}w_{c,j}$ for the $i^\textit{th}$ production rule of a symbol $c$ with $n$ alternative rules.



\subsection{Patch Location and Ingredients}\label{ssec:location}
\pulse reports the location where the bug manifests, but we would like a fix at its source. For this purpose we adopt and further adapt 
the Spectrum Based Fault Localization or SBFL \cite{sbfl} to static analysis settings.
SBFL requires test suite to generate pass/fail program traces. 
We collect this information from the program's specification which comprises both safe and buggy paths, thus feeding
SBFL with a comprehensive ``test suite" to cover all possible paths discovered by static analysis. 
The patch ingredients such as variables are computed by a simple taint analysis starting from the culprit object. Other ingredients such as constants and labels are collected within the same function scope as the fix location.

\subsection{Putting it all together} 
Now that we have identified most phases of our approach to APR, we
outline how they are interconnected in \autoref{alg:main}. Given a buggy program 
 $\mathcal{P}$, the algorithm populates a map $M$ with classes of plausible patches for the bugs detected by 
 \pulse (line 4). For each bug $b$, it determines the location where the patch should be inserted
 and collects the ingredients for the patch synthesis (lines 6-7). 
 Starting from a uniform distribution 
 of a PCFG $G$ (line 8), the synthesis of each new patch (line 10) triggers
 a refinement of the patch equivalence classes and an update of the probabilities (line 11). Lastly, we validate only the classes of plausible patches (lines 12-13) 
 by choosing a patch representative per class - we use a simple ranking metric which solely takes into account the size of the patch's AST.
 
 
\begin{algorithm}[t]
	\caption{\algo{Main}}
	\label{alg:main}
	\textbf{Input}:  a buggy program $\mathcal{P}$\\
	\textbf{Output}: a map M from bugs to sets of patches \\
	M $\leftarrow$ InitMap()\\
   $B$ = detect the bugs in $\mathcal{P}$   \\
   \For{ $b \in B$ }{
   	loc $\leftarrow$  determine the fix location for $b$\\
   $\mathcal{I}$ $\leftarrow$  collect vars and constants in $\mathcal{P}$ related to $b$\\
   G $\leftarrow$  a PCFG with terminals $\mathcal{I}$ and uniform distrib. \\
   $\mathcal{C}$  $\leftarrow$  $\emptyset$ \\
     \While{$P$ = \normalfont{synthesise a patch using} $G, \mathcal{I}$,\,\normalfont{loc}}{
     $\mathcal{C}$,G $\leftarrow$  \textsc{RefineEquivClasses}($\mathcal{C}$,$P$,G,$b$)}
   $\mathcal{C}'$ $\leftarrow$ filter $\mathcal{C}$ for classes of plausible patches;\\
   $\mathcal{C}''$ $\leftarrow$ validate $\mathcal{C'}$ picking one patch per class;\\
   M $\leftarrow$ update M with $b \rightarrow$ rank($\mathcal{C}''$)
    }
\end{algorithm}   

\begin{algorithm}[t]
	\caption{\algo{RefineEquivClasses}}
	\label{alg:equivclasses}
	\textbf{Input}:  a set of existing patch clusters $\mathcal{C}$, a patch $P$, a PCFG $G$, a bug $b$\\
	\textbf{Output}: updated patch clusters $\mathcal{C}$, updated PCFG $G$ \\
   \For{  {cls} $\in$ {$\mathcal{C}$}}{
   \If{$P.\mathcal{F} - b.\mathcal{F} = \normalfont{\text{summary}}(\textit{cls})$}{
   $\mathcal{C}$ $\leftarrow$ add patch $P$ to the class \textit{cls} of $\mathcal{C}$\\
   G $\leftarrow$ update $G$ according to $P$ and $\textit{cls}$
   }}
  \If{$P \notin\,\mathcal{C}$}{$\mathcal{C},~ \textit{cls}$ $\leftarrow$ add $P$ to a new class in $\mathcal{C}$\\
   G $\leftarrow$ update $G$ according to $P$ and $\textit{cls}$
   }
\end{algorithm}

With each new patch 
the equivalence classes are refined as depicted 
in \autoref{alg:equivclasses}. We mentioned in \autoref{ssec:clustering} that two patches are equivalent if their footprints are indistinguishable. Put differently, given a bug $b$, two of its patches are equivalent 
if they affect the buggy program in which $b$ manifests in the same way. To this purpose, we define a distance relation between a patch and a bug as the symmetric set difference between the sets of allocated and deallocated symbolic heaps for each effect in $P$ and its corresponding effect in $b$:

\centerline{$P.\mathcal{F}-b.\mathcal{F} \eqdef \{e_P - e_b | e_P \in P.\mathcal{F} ~\text{and}~ e_b \in b.\mathcal{F} \}$ }
\noindent where $e_P - e_b$, the difference between effects, tracks how the exit condition changed,  $e_P.\epsilon \rightarrow e_b.\epsilon$, the difference between pre-conditions, and 
the difference between post-conditions. 
$P.\mathcal{F}$ and $b.\mathcal{F}$ are the result of recursively applying the abstraction function $\textit{abs}$ over 
$P.{F}$ and $b.{F}$, respectively.
The difference between states is defined as follows:

\centerline{$\phi - \phi_b \eqdef  \{ (\pi, \allocset \ominus \allocset_b, \deallocset \ominus \deallocset_b, \aliasset \cup \aliasset_b)~ |~ \pi \Rightarrow \pi_b ~\text{and}$ }
\qquad\qquad{\raggedright $ \metatriple{\pi}{\epsilon}{\ret}{\allocset}{\deallocset}{\aliasset} = \phi ~\text{and}~ \metatriple{\pi_b}{\epsilon}{\ret}{\allocset_b}{\deallocset_b}{\aliasset_b} = \phi_b$ \}}

It is this distance definition, namely $P.\mathcal{F}-b.\mathcal{F}$, that is used as
class summary to determine patch equivalence (line 4 in \autoref{alg:equivclasses}). 
A benefit of refining the patch equivalence this way is that it allows us to compute the rewards for the PCFG at the equivalence class level, instead of computing them separately for each synthesised patch (line 6 and line 9). 

\setlength{\textfloatsep}{4pt}
