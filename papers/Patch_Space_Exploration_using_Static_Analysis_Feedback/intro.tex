

\section{Introduction}
\label{sec:intro}

Despite decades of efforts put into avoiding or mitigating memory safety errors (which are errors in handling memory in native programming languages such as C), recent surveys show that this class of issues still accounts for two of the three most dangerous software weaknesses reported in 2021 \cite{cwe-2021}. 
For example, reports show that  60\% of the high severity security vulnerabilities and millions of user-visible crashes in Android are due to incorrect memory handling, while Google announced that 70\% of all security bugs in Chrome in 2020 are memory safety issues.
Given the ever increasing reliance on and complexity of software, if left unattended, memory safety bugs in legacy code will continue to prevail and would negatively impact the user experience and trust in software. Therefore, providing the tools and technologies to fix such bugs in a timely and efficient manner is a critical endeavour.

\noindent{\bf \emph{Approaches-to-APR}}. 
Advances in automated program repair (APR) techniques \cite{LPR19} show promise
in dealing with the problem of bug repair.
These techniques predominantly use test cases as a specification of program correctness. However, tests are rarely exhaustive, providing only a loose correctness specification, thus making  such techniques  prone to over-fitting to the test data. Furthermore, this conventional generate-and-validate approach assumes the following sequence of steps for each patch candidate: select a patch from a pre-defined search space and validate it for correctness by running the patched program against the given test cases. Repeated for each plausible patch and given a sufficiently large search space, this process turns out to be quite expensive. 

\footpatch \cite{TonderG18} and \saver \cite{HongLLO20}, the state of the art techniques for repairing memory safety bugs, reduce the reliance on test suites for patch validation in favour of using the advances in static analysis to determine the correctness of patches. \footpatch demonstrates that this direction is a promising one, managing to generate fixes for large codebases. \saver further increases the effectiveness of static-analysis based repair by designing a novel representation of the program called object flow graph, which summarizes the programâ€™s
heap-related behavior using static analysis, resulting in a methodology which generates only safe fixes. 

\noindent{\bf \emph{Our-approach-to-APR}}. In this paper, we present a scalable and sound methodology to fixing memory related bugs without the need of test cases or developer intervention. Similar to the state of the art in repairing memory errors, our approach relies on existing sophisticated static analysis tools for finding a semantically rich class of memory bugs. Different from the current state of the art, our approach replaces the conventional patch synthesis followed by test-based validation with a novel synthesis and validation technique which works in tandem towards: efficiently navigating the search space of plausible patches, 
and achieving high repairability with a generic synthesis engine that does not rely on bug-specific fixing strategies.
To achieve this we adapt the advances of Incorrectness Separation Logic (ISL) \cite{Le2022,Raad2020} for precise bug finding 
to the problem of automated program repair. 

In a nutshell, our approach relies on ISL to describe the semantic effect the patch has on the symbolic heap, and to choose correct patches. Since the search space might be quite large, we propose to categorise patches into \emph{equivalence classes} based on their semantic effect, and subsequently only validate one representative patch per class. 
Furthermore, to increase the likelihood of producing mostly correct patches, the synthesis 
checks how ``close'' a patch is to fixing the bug by checking the patch's effect on the bug, and focuses on search spaces which have a high chance of producing plausible patches. 
In particular, we describe the entire space of solutions using a probabilistic context free grammar and learn which of its production rules are most likely to be involved in a plausible patch. 
This allows for a generic, yet efficient synthesis engine, which is not constrained by custom bug templates or specifications. 
\vspace{1em}

The contributions of this work are as follows:
\begin{itemize}
\item a {\em scalable} approach for static analysis driven repair; the approach partitions large search spaces into semantic effect based equivalence classes, enabling \emph{efficient validation} and scalability;

\item a \emph{generic} APR engine based on static analysis which does not require  bug specific templates or specifications to fix a given bug; instead it relies on the feedback from the analyser to understand what a bug and its correct patch are.

\item an \emph{effective} navigation of the solution space based on probabilistic context free grammars, which favours the production rules with higher chance of deriving a plausible patch;
 
\item an \emph{open source} tool, \tool, which implements our approach to fixing memory safety issue. 
\end{itemize}
