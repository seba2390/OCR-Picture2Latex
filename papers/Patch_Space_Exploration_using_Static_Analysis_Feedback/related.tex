\section{Related Work}
{\bf Automated Program Repair.}
Many program repair techniques have been studied in the last decade, largely  for the purpose of fixing logical-errors. Recently it has recieved attention in fixing security vulnerabilities~\cite{senx,extractfix}, race conditions~\cite{hippodrome}, intelligent tutoring~\cite{clara} etc. Program repair techniques can be classified into semantic repair~\cite{angelix,CPR}, search based repair~\cite{genprog,par} or learning based repair~\cite{prophet, sequencer}. Search based repair techinques are known as generate and validate techniques, which heuristically search for a candidate patch in a space of program edits and validate to find a correct patch. Generally, validation is done using dynamic analysis with the aid of a test-suite.  \tool  uses static analysis to validate the generated patches. Using a logic based semantic reasoning, \tool provides additional evidence of correctness for the generated patches, thereby avoiding the patch over-fitting problem~\cite{Qi15,Smith15} as well. 
Fixing memory errors has been studied previously using dynamic analysis~\cite{extractfix,senx,durieux17}, static analysis~\cite{Qing15,Junhee18,TonderG18,HongLLO20,Junhee2022} and combination of both~\cite{Hua16}. Dynamic approaches require a running test case as a witness for the memory error, and have been shown to be effective in fixing buffer-overflows~\cite{extractfix,senx}, null pointer dereference errors~\cite{durieux17}. Our work is closely related to static analysis based repair of memory errors~\cite{TonderG18,HongLLO20}. FootPatch~\cite{TonderG18} generates patches for heap property violations detected using Infer~\cite{infer}. Similarly, SAVER~\cite{HongLLO20} generates safe patches for memory errors detected by Infer~\cite{infer} and was shown to be scalable for larger programs. In both techniques, the patch generated is directly tied to the class of error reported by the static analyser. In contrast, \tool uses a generalized grammar to synthesise patches of arbirary types. Using a probabilistic grammar \tool can dynamically adjust the probabilities to guide the search to correctly identify repair templates which leads to finding more plausible patches. 


{\bf Equivalence Classes.} Equivalence relations have been shown to benefit many search problems involving large search spaces such as mutation testing~\cite{rene14,Ma16,Bo17} and compiler testing~\cite{vu14,Sun16}. Recently, it was demonstrated to be effective for APR as well~\cite{MechtaevGTR18}. Equivalence relations can be used to explore larger patch spaces more efficiently. Value based test-equivalence used in~\cite{MechtaevGTR18}, partitions the patch space based on runtime values observed during test executions. In contrast, \tool defines a equivalence relation based on effect analysis.


{\bf Probabilistic Grammar.} Augmenting probabilities with grammar production rules has been shown to be useful in program synthesis~\cite{bhaisaheb23,Ruyi20} and software fuzzing~\cite{Eberlein20,Soremekun22}. Using a probabilistic grammar a software fuzzer can generate inputs based on production rule prioritization. In particular, previous work~\cite{Soremekun22} has shown that evolving a probabilistic grammar can direct the search towards interesting inputs by favouring specific production rules. In contrast, \tool uses a probabilistic grammar to generate program edits rather than program inputs. It evolves the probabilities to find a plausible patch by prioritizing the most promising production rules. 
