\section{A Quantum-Classical Construction}
\label{sec:scheme}

\subsection{The One-Qubit Quantum Cryptosystem}
\label{sec:xi}
We introduce our novel single qubit secret-key quantum cipher $\Xi$ in Algorithm \ref{alg:xi}. Note that the secret key is given by the enclosing hFE cipher. The scheme is proven correct in Theorem \ref{thm:xi-correct} under the appropriate unitary map.

\begin{algorithm}[h]
\caption{The Scheme $\Xi = (\mathcal{QE},\mathcal{QD})$, given the secret-key bit $s$, Bloch-sphere equatorial-position $\theta$, message-bit $b$}
\label{alg:xi}
\begin{algorithmic}[1]

\Procedure{$\mathcal{QE}_{s,\theta}(b)$}{}
\State Prepare $\ket{s}$ from $s$ and $\ket{b}$ from $b$.
\State Sample bit $r \Leftarrow \udist(\{0,1\})$.
\State Return $(\ket{c_0},\ket{c_1}) = (\mathcal{H}^\theta_r\ket{s},\mathcal{H}^\theta_r\ket{b})$.
\EndProcedure

\Procedure{$\mathcal{QD}_{s,\theta}(\ket{c_0},\ket{c_1})$}{}
\State Obtain $\ket{r} = (\mathcal{H}^\theta_s)^\dagger\ket{c_0}$.
\State Prepare $r$ from $\ket{r}$ (by measurement, with probability 1).
\State Obtain $\ket{b} = (\mathcal{H}^\theta_r)^\dagger\ket{c_1}$.
\State Prepare $b$ from $\ket{b}$ (by measurement, with probability 1).
\State Return $b$.
\EndProcedure

\end{algorithmic}
\end{algorithm}

\begin{theorem} [The Quantum Encryption Unitary Map and $\Xi$ Correctness]
\label{thm:xi-correct}
\[ \text{Let } \mathcal{H}^\theta_u := \frac{1}{\sqrt{2}}
\begin{bmatrix}
    1 & 1 \\
    (-1)^u e^{i\theta} & (-1)^{u+1} e^{i\theta} \\
\end{bmatrix}
\text{be the unitary map in scheme $\Xi$.} \]
\noindent Then $\forall \theta,u,v, \mathcal{H}^\theta_u\ket{v} = \mathcal{H}^\theta_v\ket{u}$, and scheme $\Xi$ (in Algorithm \ref{alg:xi}) is correct.
\end{theorem}
\begin{proof}
First, it is an easy verification that 
$\forall \theta,u, (\mathcal{H}^\theta_u)^\dagger\mathcal{H}^\theta_u = \mathcal{H}^\theta_u(\mathcal{H}^\theta_u)^\dagger = \mathbb{I}$. 
Next we have $\mathcal{H}^\theta_u \ket{v} = \frac{1}{\sqrt{2}} \colvec{1}{(-1)^{u \oplus v}e^{i\theta}} = \mathcal{H}^\theta_v \ket{u}$. Finally, to show that the scheme is correct, \\
$\mathcal{QD}_{s,\theta}(\mathcal{QE}_{s,\theta}(b)) = \mathcal{QD}_{s,\theta}(\mathcal{H}^\theta_r\ket{s},\mathcal{H}^\theta_r\ket{b})$
$ = ((\mathcal{H}^\theta_s)^\dagger\mathcal{H}^\theta_r\ket{s},(\mathcal{H}^\theta_?)^\dagger\mathcal{H}^\theta_r\ket{b})$ \\
$ = ((\mathcal{H}^\theta_s)^\dagger\mathcal{H}^\theta_s\ket{r},(\mathcal{H}^\theta_?)^\dagger\mathcal{H}^\theta_r\ket{b})$
$ = (\ket{r},(\mathcal{H}^\theta_?)^\dagger\mathcal{H}^\theta_r\ket{b})$ \\
$ = (\mathcal{H}^\theta_r)^\dagger\mathcal{H}^\theta_r\ket{b}  = \ket{b} = b $ with probability 1, \\
as we obtain the inverting map of $\mathcal{H}^\theta_r\ket{b}$ after recovering $r$.
\end{proof}

\noindent Note that encrypting the randomness under the secret is equivalent to \emph{encrypting the secret under the randomness } - a unique property of the unitary map $\mathcal{H}^\theta_u$.

\subsection{The hFE Scheme}
\label{sec:pi}

Our message (plaintext) length $|m|$ will be greater that or equal to the security parameter. Furthermore, $|m| = Q \in$ \poly. 
We will use $\Sigma = \{ \sigma:\{0,1\}^\lambda \rightarrow \{0,1\}^Q | \text{ } \sigma \text{ is injective} \}$ as part of the functionality index space. Note $|\Sigma| \in $ \expo. Our scheme is given in Algorithm \ref{alg:pi}.

\begin{algorithm}[h]
\caption{The Scheme $\Pi = (\setup,\kgen,\enc,\dec)$, given $k \in \{0,1\}^\lambda, m \in \{0,1\}^Q$, oracle access to $\Xi = (\mathcal{QE},\mathcal{QD})$}
\label{alg:pi}

\begin{algorithmic}

\Procedure{$\setup$}{$1^\lambda,\Sigma$}
\State Sample $a = (\sigma,\kappa_Q) \Leftarrow \udist(\Sigma,\{0,1\}^\lambda)$
\State Return $msk = a$
\EndProcedure

\Procedure{$\kgen_a$}{$k$}
\State Let $\sigma(\kappa_Q) = (s_1,s_2,...,s_Q)$
\State Obtain $\delta \leftarrow \sigma(\kappa_Q) - \sigma(k)$.
\State If $\exists q \in [Q]$ such that $\delta = -\frac{Q-q+1}{2}$ or $\delta = \frac{Q-q}{2}$ \\ return $sk = (s_1,s_2,...,s_q,\bot,\bot,...,\bot)$.
\State Otherwise return $sk = \vec\bot$.
\EndProcedure

\Procedure{$\enc^{\mathcal{QE}}_a$}{$m$}
\State Let $\sigma(\kappa_Q) = (s_1,s_2,...,s_Q)$
\State $\forall j \in [Q], (\ket{c_{j,0}}, \ket{c_{j,1}}) \leftarrow \mathcal{QE}_{s_j,\theta_j}(m_j)$ where $\theta_j = \frac{2 \pi j}{Q}$
\State Return $\ket{\vec c} = (\ket{c_{j,0}}, \ket{c_{j,1}})_{j \in [Q]}$
\EndProcedure

\Procedure{$\dec^{\mathcal{QD}}$}{$sk,\ket{\vec c}$}
\State Let $sk = (s_1,s_2,...,s_q,\bot, \bot, ..., \bot)$ 
\State $\forall j \in [q],  m_j \leftarrow \mathcal{QD}_{s_j,\theta_j}(\ket{c_{j,0}}, \ket{c_{j,1}})$ where $\theta_j = \frac{2 \pi j}{Q}$
\State Return $m_1m_2m_3...m_q$
\EndProcedure

\end{algorithmic}
\end{algorithm}

\noindent We will also use the following nomenclature for our correctness and security proofs.

\begin{definition}
\label{def:key-f}
We say that an arbitrary key $k = \kappa_q$ if there exists (exactly one) $q \in [Q]$ such that $\sigma(\kappa_Q) - \sigma(k) = -\frac{Q-q+1}{2}$ or 
$\sigma(\kappa_Q) - \sigma(k) = \frac{Q-q}{2}$. Also, the function $f_{\kappa_q}$ induced by key $\kappa_q$ is $f_{\kappa_q}(m) = m_1m_2...m_q$.
\end{definition}
\noindent Intuitively, $\kappa_q$ reveals the first $q$-bits of the message, and there is exactly one such $\kappa_q$.

\subsubsection*{Correctness and Positional Secrecy} 
Given for a message $m$, a particular user has key $\kappa_q$, \\
$\dec^{\mathcal{QD}}(\kgen_a(\kappa_q),\enc^{\mathcal{QE}}_a(m)) 
= \dec^{\mathcal{QD}}(s_1s_2...s_q, (\mathcal{QE}_{s_j,\theta_j}(m_j))_{j \in [Q]}) \\
= m_1m_2...m_q$ with probability 1. \\
The different positions of the cipher-qubit on the Bloch sphere equator allow recovery of different subsequences of the message, a notion we call positional secrecy. More formally, let $\eta:\{0,1\}^Q \rightarrow \{0,1\}^Q$ be a permutation that is pre-decided, or optionally is the output of \setup. Then we use $\mathcal{QE}$ to encrypt $m_{\eta(j)}$ under $s_j,\theta_j$. This results in key $\kappa_q$ recovering the $q$-subsequence induced by $\eta$ (rearranging the message bits so that the indices are in order): \\
$\dec^{\mathcal{QD}}(\kgen_a(\kappa_q),\enc^{\mathcal{QE}}_a(m)) 
= \dec^{\mathcal{QD}}(s_1s_2...s_q, (\mathcal{QE}_{s_j,\theta_j}(m_{\eta(j)}))_{j \in [Q]}) \\
= m_{\eta(1)}m_{\eta(2)}...m_{\eta(q)}$ with probability 1. \\



