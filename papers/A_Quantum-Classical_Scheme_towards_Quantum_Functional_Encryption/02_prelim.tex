\section{Preliminaries}
\label{sec:prelim}

In this section, we define the syntax and the definitions used for presenting our cryptosystem and establishing it's correctness and security.

\subsection{Notation}
\label{subsec:notation}

Let \secu be the security parameter. Let \poly, \expo, \negl, \nonegl \text{ } denote the set of all polynomial, exponential, negligible, and non-negligible functions on \secu respectively. We will sometimes abuse notation and place these function classes in place of functions that belong to these classes. \\
\noindent Let $\{ \ket{0},\ket{1} \}$ be the computational basis for our QPT algorithms. For both our QPT and PPT algorithms, we will use \texttt{A$^O$} to denote that \texttt{A} has oracle access to \texttt{$O$}. We will use $\udist(V)$ to denote uniform distribution on universe $V$.

\subsection{Correctness Definitions}
\label{subsec:cordef}

We begin by defining the functionality to be realized and the structure of our scheme. These definitions are inspired from \cite{fe}, but modified appropriately.

\begin{definition}[Functionality]
A functionality $F$, given $a \in A$, defined over $(K,M)$ is a function $F_a: K \times M \rightarrow \{0, 1\}^*$ describable as a deterministic Turing Machine. We call $A$ the functionality-index space, $M$ the message space, and $K \cup \{ \aleph \}$ the key space. \\
We introduce $\aleph$ to allow $\forall a \in A, \forall m \in M, F_a(\aleph,m) = |m|$.
\end{definition}

\begin{definition}[Hybrid FE Scheme]
A hybrid Functional Encryption (hFE) scheme $(\Pi,\Xi)$ for a functionality $F$, given functionality-index $a$, defined over $(K,M)$, is a tuple of PPT algorithms $\Pi = (\setup,\kgen,\enc,\dec)$ and a secret-key quantum encryption scheme $\Xi = (\mathcal{QE},\mathcal{QD})$ where \enc and \dec have oracle access to \qenc and \qdec respectively. \\
\newpage
\noindent This scheme must satisfy the following correctness condition given $A, \forall k \in K, \forall m \in M$: \\
\vspace*{-10pt}
\begin{enumerate}
\item $msk \leftarrow$ \setup$(1^\lambda,A)$
\item $sk \leftarrow$ \texttt{KeyGen$_{msk}$}$(k)$
\item $\ket{c} \leftarrow$ \texttt{Enc$_{msk}^\mathcal{QE}$}$(m)$
\item $n \leftarrow$ \texttt{Dec$^\mathcal{QD}$}$(sk,\ket{c})$
\end{enumerate}
It is mandated that $msk$ contains $a$, and $n = F_a(k,m)$ with probability 1.
\end{definition}
Note that that hardwiring of the master-secret allows only oracle access to \kgen and \enc. This allows any user to encrypt any message $m$ via an oracle call to get the quantum cipher-text. However in our proofs of security the adversary has only oracle access to \kgen and \enc. Thus the above definition is limited but sound. \\

\subsection{Security Definitions}
\label{subsec:secdef}

We give definitions for quantum IND-secure encryptions, and quantum entropic indistinguishability first. Note that they are reproduced from their original sources.

\begin{definition}[IND-Security, Definition 7, \cite{compsec}]
\label{def:ind-sec}
A secret-key quantum scheme $(\mathcal{QE},\mathcal{QD})$ with secret $s$, has indistinguishable encryptions, or is IND-secure, if for every QPT adversary $(\mathcal{M},\mathcal{D})$, \\
$ \lvert Pr[ \mathcal{D} \{ (\mathcal{QE}_s \otimes \textbf{1}_E) (\rho_{ME}) \} = 1] - Pr[ \mathcal{D} \{ (\mathcal{QE}_s \otimes \textbf{1}_E) (\ket{0}\bra{0}_M \otimes \rho_E) \} = 1] \\ \le $ \negl. \\
where $\rho_{ME} \leftarrow \mathcal{M}(1^\lambda), \rho_E = \textbf{Tr}_M(\rho_{ME})$ and the probabilities are taken over the internal randomness of $\mathcal{QE,M,D}$.
\end{definition}

\begin{definition}[Entropic Indistinguishability, Definition 3, \cite{entsec}]
\label{def:ent-ind}
An encryption scheme with superoperator $\mathcal{E}$ is said to be $(t,\epsilon)$-indistinguishable if for all (density) operators $\rho$ such that $H_\infty(\rho) \geq t$ we have 
$ \lvert\lvert \mathcal{E}(\rho) - \frac{1}{d}\mathbb{I}\rvert\rvert_{tr} \le \epsilon $. Here $d$ is the size of the message space.
\end{definition}

\noindent We next give security definitions for classical functional ciphers adopted from \cite{fesec} in the context of our quantum-classical scheme. Note that superscripts are not exponentiations but indexes. Also 
$\forall b, \texttt{Enc}_{msk,b}(m^0,m^1) = \texttt{Enc}_{msk}(m^b),\\ \texttt{KeyGen}_{msk,b}(f^0,f^1) = \texttt{KeyGen}_{msk}(f^b)$.

\begin{definition}[Valid Message-Privacy Adversary, Definition 2.3, \cite{fesec}]
\label{def:vmpa}
A polynomial-time algorithm $\mathcal{A}$ is a valid message-privacy adversary if for all private-key functional encryption schemes $(\setup,\kgen,\enc,\dec)$ and for all $\lambda \in \mathbb{N}, b \in \{ 0,1 \}$ and for all $f$ and $(m^0,m^1)$ with which $\mathcal{A}$ queries oracles \kgen and $\texttt{Enc}_{msk,b}$ respectively, we have $f(m^0) = f(m^1)$.
\end{definition}

\begin{definition}[Full Message Privacy, Definition 2.4, \cite{fesec}]
\label{def:fmp}
A private-key functional encryption scheme $(\setup,\kgen,\enc,\dec)$ is fully message private if for any valid message-privacy adversary $\mathcal{A}$: \\
$ \lvert Pr[  \mathcal{A}^{\texttt{KeyGen}_{msk}(\cdot),\texttt{Enc}_{msk,0}(\cdot,\cdot)}(\lambda) = 1] - Pr[ \mathcal{A}^{\texttt{KeyGen}_{msk}(\cdot),\texttt{Enc}_{msk,1}(\cdot,\cdot)}(\lambda) = 1] \rvert \\ \le $ \negl.
\end{definition}

\begin{definition}[Valid Function-Privacy Adversary, Definition 3.1, \cite{fesec}]
\label{def:vfpa}
A polynomial-time algorithm $\mathcal{A}$ is a valid function-privacy adversary if for all private-key functional encryption schemes $(\setup,\kgen,\enc,\dec)$ and for all $\lambda \in \mathbb{N}, b \in \{ 0,1 \}$ and for all $(f^0,f^1)$ and $(m^0,m^1)$ with which $\mathcal{A}$ queries oracles $\texttt{KeyGen}_{msk,b}$ and $\texttt{Enc}_{msk,b}$ respectively, we have 
$|m^0| = |m^1|, |f^0| = |f^1|, \text{ and } f^0(m^0) = f^1(m^1)$ where $|\cdot|$ denotes the length of description.
\end{definition}

\begin{definition}[Full Function Privacy, Definition 3.2, \cite{fesec}]
\label{def:ffp}
A private-key functional encryption scheme $(\setup,\kgen,\enc,\dec)$ is fully message private if for any valid function-privacy adversary $\mathcal{A}$: \\
$ \lvert Pr[  \mathcal{A}^{\texttt{KeyGen}_{msk,0}(\cdot),\texttt{Enc}_{msk,0}(\cdot,\cdot)}(\lambda) = 1] - Pr[ \mathcal{A}^{\texttt{KeyGen}_{msk,1}(\cdot),\texttt{Enc}_{msk,1}(\cdot,\cdot)}(\lambda) = 1] \rvert \\ \le $ \negl.
\end{definition}

\noindent Finally we give a scheme security definition from the seminal work \cite{fe}. This has been updated to make the functionality index a part of the comparison (so that we are comparing the same function).

\begin{definition}[Weak Simulation Security, Definition 5, \cite{fe}]
\label{def:wss}
A functional encryption scheme $(\setup,\kgen,\enc,\dec)$ is weakly simulation-secure if for all polynomial-time algorithms (\texttt{Msg},\texttt{Adv}) there exists a polynomial-time algorithm \texttt{Sim} such that the distribution ensembles given in Algorithm \ref{alg:simsec} are computationally indistinguishable.
\end{definition}

\begin{algorithm}[h]
\caption{Weak-Simulation Security Game}
\label{alg:simsec}
  \begin{multicols}{2}
    \begin{algorithmic}[Real]
      \State $msk = a \leftarrow$ \setup$(1^\lambda,A)$
      \State $(\vec m, \tau) \leftarrow \texttt{Msg}(1^\lambda)$
      \State $\ket{\vec c} \leftarrow \texttt{Enc}_{msk}(\vec m)$ via an oracle call
      \State $\alpha \leftarrow \texttt{Adv}^{\texttt{KeyGen}_{msk}(\cdot)}(\ket{\vec c}, \tau)$
      \State Let $(y_1,y_2,...,y_l)$ be the \texttt{Adv} queries
      \State Output real dist. $(a,\vec m, \tau, \alpha, y_1, ..., y_l)$
    \end{algorithmic}
    \columnbreak
    \begin{algorithmic}[Ideal]
     \State Give Functionality-Index $a$ from $A$.
     \State $(\vec m, \tau) \leftarrow \texttt{Msg}(1^\lambda)$
     \State $\alpha \leftarrow \texttt{Sim}^{F_a(\cdot, \vec m)}(1^\lambda, \tau, F_a(\aleph,\vec m))$
     \State Let $(y_1,y_2,...,y_l)$ be the \texttt{Sim} queries to $F_a$
     \State Output ideal dist. $(a,\vec m, \tau, \alpha, y_1, ..., y_l)$
    \end{algorithmic}
  \end{multicols}
\end{algorithm}