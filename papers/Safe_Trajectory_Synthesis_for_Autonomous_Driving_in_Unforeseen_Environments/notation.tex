\section{PRELIMINARIES}
\label{sec:notation}

This section introduces necessary notation for this paper, and formalizes the dynamics and assumptions using to describe the problem of interest.
This paper makes substantial use of semidefinite programming theory and sums of squares programming \cite{lasserre2009moments}.

\subsection{Notation}

The following notation is adopted throughout the remainder of the paper: 
Sets are italicized and capitalized.
The boundary of a set $K$ is $\partial K$.
Finite truncations of the set of natural numbers are \mbox{$\N_n:=\{1,\ldots,n\}$}.
The set of continuous functions on a compact set $K$ are $\mathcal C(K)$.
The Lebesgue measure on $K$ is denoted by $\lambda_K$.
We let $y_{K}$ denote the Lebesgue moments of $\lambda_K$.
The $i$-th component of a vector $v \in \R^n$ is denoted by $v_i$.
% The set of continuous and absolutely continuous functions on a compact set $K$ are represented as $\mathcal C(K)$ and $\mathcal C_{ab}(K)$ respectively.
The ring of polynomials in $x$ is $\R[x]$, and the degree of a polynomial is the degree of its largest multinomial; 
the degree of the multinomial $x^\alpha,\,\alpha\in \N^n$ is $|\alpha|=\|\alpha\|_1$; and $\R_d[x]$ is the set of polynomials in $x$ with degree $d$.
Let $\text{vec}(p)$ denote the vector of coefficients of $p \in \R[x]$.

\subsection{Low and High-Fidelity Vehicle Models}

Let an autonomous vehicle by described by:
\begin{equation}
\label{eq:big_dyn}
\dot{x}(t) = f(t,x(t),u(t))
\end{equation}
where $f:[0,T] \times X \times U \to \R^n$, $T > 0$, $ X \subset \R^n$ and $U \subset \R^m$. 
The objective of this paper is to design safe trajectories for this autonomous vehicle which may be high dimensional and challenging to optimize over in real-time.
Our approach relies upon generating parameterized trajectories using a second, lower-dimensional model for this autonomous vehicle that shares a common set of states, $X_s \subset \R^{n_s}$ with $X_s \subset X$.
This model is described as:
\begin{equation}
\label{eq:small_dyn}
\begin{bmatrix}\dot{x}_s(t) \\ \dot{k}(t) \end{bmatrix} = \begin{bmatrix}  f_s(t,x_s(t),k(t)) \\ 0 \end{bmatrix}
\end{equation}
where the parameters, $k(t)$, do not evolve after initialization and are drawn from a set $K \subset \R^p$. 

\begin{ex}
\label{ex:model}
Consider a dynamic unicycle model:
\begin{equation}
\begin{bmatrix} \dot{x}(t) \\ \dot{y}(t) \\ \dot{\theta}(t) \\ \ddot{\theta}(t) \\ \dot{v}(t) \end{bmatrix} = \begin{bmatrix} v(t)\cos\left(\theta(t)\right) \\ v(t)\sin\left(\theta(t)\right) \\ \dot{\theta}(t) \\ u_1(t) \\ u_2(t) \end{bmatrix}
\end{equation}	
where $x$ and $y$ represent position; $\theta$ and $\dot{\theta}$ represent heading and yaw rate, both relative to the initial condition of the vehicle; and $v$ represents the longitudinal speed. 
The inputs are $u_1$ for steering and $u_2$ for throttle or braking.
Consider a low-fidelity, trajectory-producing model with shared states $\begin{bmatrix} x & y & \theta \end{bmatrix}^T$ such that:
\begin{equation}\label{eq:dubins_dyn}
\begin{bmatrix} \dot{x}(t) \\ \dot{y}(t) \\ \dot{\theta}(t) \end{bmatrix} = \begin{bmatrix} k_2\cos\left(\theta(t)\right) \\ k_2\sin\left(\theta(t)\right) \\ k_1 \end{bmatrix}
\end{equation}
with the trajectory parameters that are steering rate $k_1$ and speed $k_2$.
The unicycle model ``adds'' mass to the Dubins car.
% This example will be carried through the remainder of the paper.
\end{ex}

For the sake of convenience, the dynamics of the shared states, $X_S$, in the high dimensional model are assumed to be described by the first $n_s$ coordinates of $f$ throughout this paper. 
Let the controlled vehicle be represented as a compact set $X_0 \subset X_s$, typically a bounding box around the vehicle.
We make the following assumptions to ensure the well-posedness of the subsequent problem formulation. 
\begin{assum} \label{ass:set}
The sets $U$ and $X$ are compact and suppose $K,X_0,$ and $X_s$ have the following representation:
\begin{align}
K &= \left\{ k \in \R^p \mid h_{K_i}(k) \geq 0, ~ \forall i \in \{ 1,\ldots, n_K\} \right\}, \label{eq:ass_2_1}\\
X_0 &= \left\{ x_s \in \R^{n_s} \mid h_{0_i}(x_s) \geq 0, ~ \forall i \in \{ 1,\ldots, n_0\} \right\},  \label{eq:ass_2_2} \\
X_s &= \left\{ x_s \in \R^{n_s} \mid h_{X_i}(x_s) \geq 0, ~ \forall i \in \{ 1,\ldots, n_{X_s}\} \right\}. \label{eq:ass_2_3}
\end{align}
\end{assum}

The objective of this paper is to optimize over trajectories using the lower complexity dynamical model which are then followed by the high dimensional vehicle model. 
Unfortunately this tracking cannot be done perfectly. 
The higher fidelity model can select a controller, $u_k: [0,T] \times X \to \R^m$, to follow the generated trajectory which is parameterized by $k \in K$ (e.g. using a PID control loop); however there may still be a gap between the generated pair of trajectories.
To describe this error as a function of time, we make the following assumption:
\begin{assum}\label{ass:error_func}
There exists a bounded function $g: [0,T] \times X_s \to X_s $ such that:
\begin{align}\label{eq:error_func}
\max_{x \in A_{x_s}} \, \left|f_i(t,x,u_k(t,x) - f_{s,i}(t,x_s,k)\right| \leq g_i(t,x_s),
\end{align}
for all $x_s \in X_s$, $t \in [0,T]$, $k \in K$, and $i \in \{1,\ldots,n_s \}$, where $A_{x_s} := \{ x \in X \mid x_i = x_{s,i} \forall i \in \{1,\ldots,n_s \} \}$.
\end{assum}
In other words, the error in the shared states is bounded by $g$.
Though this paper does not describe a formal method to construct such a $g$, in the instance of polynomial, rational, or trigonometric dynamics, such a $g$ can be found numerically by applying Sums-of-Squares programming as we describe in Section \ref{sec:implementation}. 

\begin{ex}
For the unicycle model in Example \ref{ex:model}, $u_k$ can be a proportional velocity controller for the yaw rate and speed:
\begin{align}
\ddot{\theta}(t) = u_1(t) = 20\cdot(\dot{\theta}(t) - \dot{\theta}_\text{des}) \\
\dot{v}(t) = u_2(t) = 10\cdot(v(t) - v_\text{des})
\end{align}
where $(\dot{\theta}_\text{des}, v_\text{des})$ map to a $k_1$ and $k_2$ in the parameter space for the Dubins car model described in Equation \eqref{eq:dubins_dyn}.
Given this $u_k$ one can generate a $g$ that overapproximates the error when transitioning from top speed to a complete stop in the $v$ dimension; and when switching from turning full-left to turning full-right (or vice-versa) in the $\dot{\theta}$ dimension. 
Such a $g$, illustrated in Figure \ref{fig:error_dynamics}, could be:
\begin{equation}
\label{eq:g_definition}
g(t,x,y,\theta) = \begin{bmatrix}
v_\text{err}(t)\cdot(1 - \frac{1}{2}\theta^2)  \\
v_\text{err}(t)\cdot(\theta - \frac{1}{6}\theta^3) \\
\dot{\theta}_\text{err}
\end{bmatrix}
\end{equation}
where $v_\text{err}(t) = (t-1)^2$ and $\dot{\theta}_\text{err}(t) = (t-1)^4$.
%The Dubins car is able to make these changes instantaneously, unlike the unicycle. This is illustrated in Figure \ref{fig:error_dynamics}.
\end{ex}

\begin{figure}
\centering
\includegraphics[width=1\columnwidth]{error_dynamics.pdf}
\caption{An example of the worst-case error dynamics. 
The top subplot shows the $(x,y)$ trajectories of a Dubins car (grey) and unicycle model (blue), beginning at $(-0.75,0)$ and ending at the corresponding stars. Both trajectories begin at full speed (1 [m/s]) and then emergency brake at $t = 1$. The resulting velocity profile, with the same color scheme, is shown in the middle subplot. In addition, the Dubins car begins its trajectory with $\dot{\theta} = +0.5$ [rad/s], whereas the unicycle begins at $0$ [rad/s] and must catch up. At $t = 1$, the Dubins car switches instantaneously to turning at $-0.5$ [rad/s], as shown in the bottom subplot. The red dashed line in the middle and bottom subplots is the error function $g$ that overapproximates the worst-case possible error between the Dubins car and unicycle with a polynomial.}
\label{fig:error_dynamics}
\end{figure}

As a result of this assumption, the dynamics can be rewritten in a form amenable to computing the flow of the system $f_s$ while subject to error dynamics:
\begin{align}
\label{eq:error_low_model}
\dot{x}_s(t) = f_s(t,x_s(t),k) + g(t,x_s(t),k)~d(t)
\end{align}
where $d(t) \in [-1,1]$ for each $ t \in [0,T]$ can be chosen to describe the worst-case error behavior.
This use of $d$ is discussed further in Section \ref{subsec:FRS}.
To understand the gap between lower and higher dimensional models, we rely upon a pair of linear operators. 
First, the linear operator $\Lf:C^1\big([0,T] \times X_s \times K \big) \to C\big( [0,T] \times X_s \times K \big)$ on a test function $v$ as:
\begin{equation}
\Lf v(t,x_s,k) = \frac{\partial v}{\partial t}(t,x_s,k) + \sum_{i = 1}^{n_s} \frac{\partial v}{\partial x_{i,s}}(t,x_s,k) f_{i,s}(t,x_s,k).
\end{equation}
Next, define the linear operator $\Lg:C^1\big([0,T] \times X_s \times K \big) \to C\big( [0,T]\times X_s \times K\big)$ as:
\begin{equation}
\Lg v(t,x_s,k)  = \sum_{i = 1}^{n_s} \frac{\partial v}{\partial x_{i,s}}(t,x_s,k) g_{i}(t,x_s).
\end{equation}
Note that these linear operators are useful in summarizing the evolution of a system as we describe in Section \ref{subsubsec:FRS_computation}.

%In general, creating $g$ to accurately capture all variation between $f$ and $f_s$ as a function of $x_s$ and $k$ is impractical. We overapproximate the error by considering the worst case scenario.

%As a further note, $g$ can be crafted more broadly, to include other disturbances besides modeling error, such as from sensors and the environment.
%However, that is outside the scope of this paper, and will be treated in future works.
%This requires that the unshared states are bounded for all $t \in \T$, but this is given because $X$ is compact.

\subsection{Sensing, Planning, and Braking Time Horizons}
\label{subsec:time}

Next, we define a sensing, planning, and braking time horizon whose relationships are formalized in the next section to ensure the safety of the autonomous vehicle. 
To construct these definitions, we begin by formalizing obstacles: 
\begin{defn}
An \emph{obstacle} is any portion of $X_s$ that must be avoided by the vehicle.
In general, obstacles are represented as closed subsets of $X_s$.
Obstacles are assumed to be static in the system's local reference frame and are defined as:
\begin{equation}
X_{\text{obs}} = \left\{ x_s \in \R^{n_s} \mid h_{\text{obs}_i}(x_s) \geq 0 , \forall i \in \{1,\ldots,n_{\text{obs}} \} \right\}.
\label{eq:X_obs}
\end{equation}
\end{defn}
Obstacles can be other vehicles, the edges of the road, pedestrians, etc.
A trajectory is \emph{safe} if it does not intersect with an obstacle.
These obstacles are assumed to enter the scene as follows:
\begin{assum}\label{ass:sense}
During operation, obstacles always enter $X_s$ from outside, i.e., any obstacle's trajectory relative to the system must begin outside of, and may pass through, $\partial X_s$.
In addition, let the system be limited to a scalar top speed, denoted $\dot{x}_{s,\text{max}}$.
Then, this assumption requires that obstacles are sensed at a minimum sensor horizon $D_\text{sense} := \dot{x}_{s,\text{max}}\cdot T_\text{sense}$.
\end{assum}
$T_\text{sense}$ is a sensor time horizon that is to be determined, as a safety condition that we describe in the next section. 

Next, we assume that the time to process sensor information and plan a trajectory is bounded and known:
\begin{assum}\label{ass:plan_and_scan}
The time required to process sensor data and perform trajectory planning has a finite upper bound $\tau_\text{plan}$.
\end{assum}
Specific sensor processing to detect obstacles is outside of the scope of this paper, but in practice most modern obstacle detectors, working from camera, lidar, or radar, have a bounded processing time \cite{johnson2016driving,liu2016ssd}.
Though we do not prove that the trajectory planning time is bounded, the convex optimization based implementation that we utilize has a processing time that takes several seconds, at most, in practice as we describe in Section \ref{sec:implementation}.

\begin{rem}\label{rem:plan}
To understand how this $\tau_\text{plan}$ can be used, suppose the vehicle is planning as quickly as possible and executing a trajectory beginning at $t=0$ . 
While executing this trajectory, the vehicle can plan its next trajectory which is applied beginning at $t = \tau_{\text{plan}}$. 
The initial condition for this next trajectory is computed by the vehicle by forward integrating $f$ over the time interval $[0,\tau_{\text{plan}}]$.
This process can be repeated recursively to replan trajectories. 
\end{rem}

%For the unicycle example, we have chosen $\tau_\text{plan} = 0.5$ s.

Finally, in certain instances it may be impossible to reach a desired position safely.
For these scenarios, we must assume that there exists a braking maneuver which can stop the car:
\begin{assum}\label{ass:brake}
There exists a family of braking trajectory parameters $K_b \subseteq K$ such that, without deviating from the spatial component of a pre-planned trajectory, $\dot{x}_s = 0$ in a finite amount of time $\tau_b(x_s) \in \R_+$ for each $x_s \in X_s$.
In addition, this stopped state can be held indefinitely.
\end{assum}
In other words, the vehicle is able to brake and stop along any trajectory it is following.
It follows from Assumption \ref{ass:brake} that there is a maximum braking time for the system, i.e. there exists $\tau_\text{stop} \in \R_+$ such that $\tau_b(x_s) \leq \tau_\text{stop}$ for all $x_s \in X_s$.
%Let the system have some `top speed' denoted $\dot{x}_{s,\text{max}}$.
%Typically, $\tau_\text{stop} = \tau_b(\dot{x}_{s,\text{max}})$.
This braking time is used to construct planning and sensing time horizons to guarantee safety.

%For the unicycle example, the top speed is limited to $2$ m/s, and $\tau_\text{stop}$ is 0.5 s.

