
\documentclass{article} % For LaTeX2e
\usepackage{iclr2023_conference,times}

% Optional math commands from https://github.com/goodfeli/dlbook_notation.
\input{math_commands.tex}

\usepackage{hyperref}
\usepackage{url}

\usepackage{times}
\usepackage{latexsym}
\usepackage{CJKutf8}
\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{booktabs}
\usepackage{bbm}
\usepackage{amssymb}% http://ctan.org/pkg/amssymb
\usepackage{pifont}% http://ctan.org/pkg/pifont
%\newcommand{\cmark}{\ding{52}}%
%\newcommand{\xmark}{\ding{56}}%
\usepackage{stfloats}
\usepackage{multicol}
\usepackage{float}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{multirow}
\usepackage{array}
\newcommand{\PreserveBackslash}[1]{\let\temp=\\#1\let\\=\temp}
\newcolumntype{C}[1]{>{\PreserveBackslash\centering}p{#1}}
\newcolumntype{R}[1]{>{\PreserveBackslash\raggedleft}p{#1}}
\newcolumntype{L}[1]{>{\PreserveBackslash\raggedright}p{#1}}
\usepackage{diagbox}
%\usepackage[noend]{algpseudocode}
%\usepackage{algorithmicx,algorithm}
%\usepackage{arydshln}
%\usepackage{booktabs}
%\usepackage{amsfonts}
%\usepackage{bbm}
\usepackage{mathtools}
%\usepackage{hyperref}
%\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\algnewcommand{\Initialize}[1]{%
  \State \textbf{Initialize:}
  \Statex \hspace*{\algorithmicindent}\parbox[t]{.8\linewidth}{\raggedright #1}
}
\algnewcommand{\Inputs}[1]{%
  \State \textbf{Inputs:}
  \Statex \hspace*{\algorithmicindent}\parbox[t]{.8\linewidth}{\raggedright #1}
}
\algnewcommand{\Outputs}[1]{%
  \State \textbf{Outputs:}
  \Statex \hspace*{\algorithmicindent}\parbox[t]{.8\linewidth}{\raggedright #1}
}

\algnewcommand{\IfThen}[2]{% \IfThen{<if>}{<then>}
  \State \algorithmicif\ #1\ \algorithmicthen\ #2}

\usepackage{caption}



%\title{StateFormer: Enhancing Transformer with Multi-State Representations for Simultaneous Machine Translation}
\iclrfinalcopy
\title{Hidden Markov Transformer for \\Simultaneous Machine Translation}

% Authors must not appear in the submitted version. They should be hidden
% as long as the \iclrfinalcopy macro remains commented out below.
% Non-anonymous submissions will be rejected without review.


\author{Shaolei Zhang \textsuperscript{\rm 1,2},
    Yang Feng \textsuperscript{\rm 1,2}\thanks{ \ \ Corresponding author: Yang Feng.} \\
\textsuperscript{\rm 1}{Key Laboratory of Intelligent Information Processing} \\ $\;\:$Institute of Computing Technology, Chinese Academy of Sciences (ICT/CAS)\\
\textsuperscript{\rm 2}{University of Chinese Academy of Sciences, Beijing, China}\\
$\;\:$\texttt{\{\href{mailto:zhangshaolei20z@ict.ac.cn}{zhangshaolei20z},\href{mailto:fengyang@ict.ac.cn}{fengyang}\}@ict.ac.cn}}
% \And
% Ji Q. Ren \& Yevgeny LeNet \\
% Department of Computational Neuroscience \\
% University of the Witwatersrand \\
% Joburg, South Africa \\
% \texttt{\{robot,net\}@wits.ac.za} \\
% \AND
% Coauthor \\
% Affiliation \\
% Address \\
% \texttt{email}
% }

% The \author macro works with any number of authors. There are two commands
% used to separate the names and addresses of multiple authors: \And and \AND.
%
% Using \And between authors leaves it to \LaTeX{} to determine where to break
% the lines. Using \AND forces a linebreak at that point. So, if \LaTeX{}
% puts 3 of 4 authors names on the first line, and the last on the second
% line, try using \AND instead of \And before the third author name.

\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

%\iclrfinalcopy % Uncomment for camera-ready version, but NOT for submission.
\begin{document}


\maketitle

\begin{abstract}
Simultaneous machine translation (SiMT) outputs the target sequence while receiving the source sequence, and hence learning when to start translating each target token is the core challenge for SiMT task. However, it is non-trivial to learn the optimal moment among many possible moments of starting translating, as the moments of starting translating always hide inside the model and can only be supervised with the observed target sequence. In this paper, we propose a \emph{Hidden Markov Transformer} (\emph{HMT}), which treats the moments of starting translating as hidden events and the target sequence as the corresponding observed events, thereby organizing them as a hidden Markov model. HMT explicitly models multiple moments of starting translating as the candidate hidden events, and then selects one to generate the target token. During training, by maximizing the marginal likelihood of the target sequence over multiple moments of starting translating, HMT learns to start translating at the moments that target tokens can be generated more accurately. Experiments on multiple SiMT benchmarks show that HMT outperforms strong baselines and achieves state-of-the-art performance\footnote{$\;\:$Code is available at \url{https://github.com/ictnlp/HMT}}.
\end{abstract}

\section{Introduction}
Recently, with the increase of real-time scenarios such as live broadcasting, video subtitles and conferences, simultaneous machine translation (SiMT) attracts more attention \citep{Cho2016,gu-etal-2017-learning,ma-etal-2019-stacl,Arivazhagan2019}, which requires the model to receive source token one by one and simultaneously generates the target tokens. For the purpose of high-quality translation under low latency, SiMT model needs to learn when to start translating each target token \citep{gu-etal-2017-learning}, thereby making a wise decision between waiting for the next source token (i.e., READ action) and generating a target token (i.e., WRITE action) during the translation process.

However, learning when to start translating target tokens is not trivial for a SiMT model, as the moments of starting translating always hide inside the model and we can only supervise the SiMT model with the observed target sequence \citep{dualpath}. Existing SiMT methods are divided into fixed and adaptive in deciding when to start translating. Fixed methods directly decide when to start translating according to pre-defined rules instead of learning them \citep{dalvi-etal-2018-incremental,ma-etal-2019-stacl,multipath}. Such methods ignore the context and thus sometimes force the model to start translating even if the source contents are insufficient \citep{zheng-etal-2020-simultaneous}. Adaptive methods dynamically decide READ/WRITE actions, such as predicting a variable to indicate READ/WRITE action \citep{Arivazhagan2019,Ma2019a,miao-etal-2021-generative}. However, due to the lack of clear correspondence between READ/WRITE actions and the observed target sequence \citep{zhang-feng-2022-gaussian}, it is difficult to learn precise READ/WRITE actions only with the supervision of the observed target sequence \citep{alinejad-etal-2021-translation,dualpath,indurthi-etal-2022-language}.


To seek the optimal moment of starting translating each target token that hides inside the model, an ideal solution is to clearly correspond the moments of starting translating to the observed target sequence, and further learn to start translating at those moments that target tokens can be generated more accurately.
To this end, we propose \emph{Hidden Markov Transformer} (\emph{HMT}) for SiMT, which treats the moments of starting translating as hidden events and treats the translation results as the corresponding observed events, thereby organizing them in the form of hidden Markov model \citep{10.2307/2238772,1165342,wang-etal-2018-neural-hidden}.
As illustrated in Figure \ref{fig:case}, HMT explicitly produces a set of states for each target token, where multiple states represent starting translating the target token at different moments respectively (i.e., start translating after receiving different numbers of source tokens). Then, HMT judges whether to select each state from low latency to high latency. Once a state is selected, HMT will generate the target token based on the selected state. 
For example, HMT produces 3 states when generating the first target token to represent starting translating after receiving the first 1, 2 and 3 source tokens respectively (i.e., $\mathbf{h}_{\leq 1}$, $\mathbf{h}_{\leq 2}$ and $\mathbf{h}_{\leq 3}$). Then during the judgment, the first state is not selected, the second state is selected to output `\textit{I}' and then the third state is not considered anymore, thus HMT starts translating `\textit{I}' when receiving the first 2 source tokens.
During training, HMT is optimized by maximizing the marginal likelihood of the target sequence (i.e., observed events) over all possible selection results (i.e., hidden events). In this way, those states (moments) which generate the target token more accurately will be selected more likely, thereby HMT effectively learns when to start translating under the supervision of the observed target sequence.
Experiments on English$\rightarrow$Vietnamese and German$\rightarrow$English SiMT benchmarks show that HMT outperforms strong baselines under all latency and achieves state-of-the-art performance.

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{case.pdf}
    \caption{Illustration of hidden Markov Transformer. HMT explicitly produces $K\!=\!3$ states for each target token to represent starting translating the target token when receiving different numbers of source tokens respectively (where $\mathbf{h}_{\leq n}$ means starting translating when receiving the first $n$ source tokens). Then, HMT judges whether to select each state from low latency to high latency (i.e., from left to right). Once a state is selected, HMT will translate the target token based on the selected state. }
    \label{fig:case}
\end{figure}


\section{Related Work}
Learning when to start translating is the key to SiMT. Recent SiMT methods fall into fixed and adaptive. For fixed method, \citet {ma-etal-2019-stacl} proposed a wait-k policy, which first READs $k$ source tokens and then READs/WRITEs one token alternately. \citet{multipath} proposed an efficient training for wait-k policy, which randomly samples different $k$ between batches. \citet{zhang-feng-2021-icts} proposed a char-level wait-k policy. \citet{zheng-etal-2020-simultaneous} proposed adaptive wait-k, which integrates multiple wait-k models heuristically during inference. \citet{guo-etal-2022-turning} proposed post-evaluation for the wait-k policy. \citet{zhang-etal-2022-wait} proposed wait-info policy to improve wait-k policy via quantifying the token information. \citet{zhang-feng-2021-universal} proposed a MoE wait-k to learn multiple wait-k policies via multiple experts. For adaptive method, \citet{gu-etal-2017-learning} trained an READ/WRITE agent via reinforcement learning. \citet{Zheng2019b} trained the agent with golden actions generated by rules. \citet{zhang-feng-2022-gaussian} proposed GMA to decide when to start translating according to the predicted alignments. \citet {Arivazhagan2019} proposed MILk, which uses a variable to indicate READ/WRITE and jointly trains the variable with monotonic attention \citep{LinearTime}. \citet{Ma2019a} proposed MMA to implement MILk on Transformer. \citet{liu-etal-2021-cross} proposed CAAT for SiMT to adopt RNN-T to the Transformer architecture. \citet{miao-etal-2021-generative} proposed GSiMT to generate READ/WRITE actions, which implicitly considers all READ/WRITE combinations during training and takes one combination in inference. \citet{zhang-feng-2022-information} proposed an information-transport-based policy for SiMT. 

Compared with the previous methods, HMT explicitly models multiple possible moments of starting translating in both training and inference, and integrates two key issues in SiMT, `learning when to start translating' and `learning translation', into a unified framework via the hidden Markov model.

\section{Hidden Markov Transformer}
\label{sec:stateformer}

To learn the optimal moments of starting translating that hide inside the SiMT model, we propose hidden Markov Transformer (HMT) to organize the `moments of starting translating' and `observed target sequence' in the form of hidden Markov model. By maximizing the marginal likelihood of the observed target sequence over multiple possible moments of starting translating, HMT learns when to start translating. We will introduce the architecture, training and inference of HMT following.



\subsection{Architecture}


Hidden Markov Transformer (HMT) consists of an encoder and a hidden Markov decoder. Denoting the source sequence as $\mathbf{x}\!=\!\left ( x_{1},\cdots ,x_{J} \right )$ and the target sequence as $\mathbf{y}\!=\!\left ( y_{1},\cdots ,y_{I} \right )$, a unidirectional encoder \citep{Arivazhagan2019,Ma2019a,miao-etal-2021-generative} is used to map $\mathbf{x}$ to the source hidden states $\mathbf{h}\!=\!\left ( h_{1},\cdots ,h_{J} \right )$. Hidden Markov decoder explicitly produces a set of states for $y_{i}$ corresponding to starting translating $y_{i}$ at multiple moments, and then judges which state is selected to output the target token. Specifically, as shown in Figure \ref{fig:model}, hidden Markov decoder involves three parts: state production, translation and selection.

\textbf{State Production} 
When translating $y_{i}$, HMT first produces a set of $K$ states $\mathbf{s}_{i}\!=\!\left \{ s_{i,1},\cdots ,s_{i,K} \right \}$ to represent starting translating $y_{i}$ when receiving different numbers of source tokens respectively. Then, we set the \emph{translating moments} $\mathbf{t}_{i}\!=\!\left \{ t_{i,1},\cdots ,t_{i,K} \right \}$ for these states, where state $s_{i,k}$ is required to start translating $y_{i}$ when receiving the first $t_{i,k}$ source tokens $\mathbf{x}_{\leq t_{i,k}}$.


\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{model.pdf}
    \vspace{-0.2in}
    \caption{The architecture of hidden Markov decoder.}
    \label{fig:model}
\end{figure}


\setlength{\columnsep}{11pt}
\begin{wrapfigure}{r}{0.33\textwidth}
\begin{center}
\advance\leftskip+1mm
  \vspace{-0.2in} 
 \includegraphics[width=1.74in]{path_setting.pdf}
   \vspace{-0.05in} 
  \caption{Setting of translating moment $\mathbf{t}$ (e.g., $L\!=\!1$, $K\!=\!4$). %Each purple square is a state $s_{i,k}$, representing that translates $y_{i}$ when receiving first $t_{i,k}$ source tokens.
  }\label{fig:pathsetting}
\vspace{-0.1in} 
\end{center}
\end{wrapfigure} 
To set the suitable $\mathbf{t}$ for states, we aim to pre-prune those unfavorable translating moments, such as translating $y_{1}$ after receiving $x_{J}$ or translating $y_{I}$ after receiving $x_{1}$ \citep{laf,dualpath}. Therefore, as shown in Figure \ref{fig:pathsetting}, we introduce a wait-$L$ path as the lower boundary and a wait-$(L\!+\!K\!-\!1)$ path as the upper boundary accordingly \citep{Zheng2019a}, and then consider those suitable moments of starting translating within this interval, where $L$ and $K$ are hyperparameters. Formally, the translating moment $t_{i,k}$ of the state $s_{i,k}$ is defined as:
\begin{gather}
    t_{i,k}=\min\left\{ L+\left ( i-1 \right )+\left ( k-1 \right ), \left| \mathbf{x}\right|\right\}. \label{eq:translating moment}
\end{gather}
%Taking Figure \ref{fig:pathsetting} as an example, when translating $y_{3}$, HMT produces 4 states $s_{3,1}$, $s_{3,2}$, $s_{3,3}$ and $s_{3,4}$, which represent starting translating $y_{3}$ when receiving the first 3, 4, 5 and 6 source tokens, respectively. Then when translating $y_{4}$, 4 states $s_{4,1}$, $s_{4,2}$, $s_{4,3}$ and $s_{4,4}$ represent starting translating $y_{4}$ when receiving the first 4, 5, 6 and 7 source tokens.


\textbf{Translation} The representations of $K$ states for each target token are initialized via upsampling the target inputs $K$ times, and then calculated through $N$ Transformer decoder layers, each of which consists of three sub-layers: self-attention between states, cross-attention and feed-forward network.

For self-attention between states, state $s_{i,k}$ can pay attention to the state \vspace{-0.1mm}$s_{j,k^{'}}$ of all previous target tokens (i.e., $j\!\leq \!i$), while ensuring that \vspace{-0.1mm}$s_{j,k^{'}}$ starts translating no later than $s_{i,k}$ (i.e., $t_{j,k^{'}}\!\leq \!t_{i,k}$) to avoid future source information leaking from $s_{j,k^{'}}$ to $s_{i,k}$. The self-attention from $s_{i,k}$ to \vspace{-0.1mm}$s_{j,k^{'}}$ is:
\begin{small}\begin{gather}
    \mathrm{SelfAtt}\left ( s_{i,k},s_{j,k^{'}} \right )=\begin{cases}
\vspace{-1mm}\mathrm{softmax}\left ( \frac{s_{i,k}\!\mathbf{W}^{Q}\left (s_{j,k^{'}}\!\mathbf{W}^{K}  \right )^{\top}}{\sqrt{d}} \right ) & \text{ if }\; j\leq i \;\text{and}\; t_{j,k^{'}}\leq t_{i,k} \\
0 & \text{ otherwise } 
\end{cases}, \label{eq:self-attn}
\end{gather}\end{small}where $\mathbf{W}^{Q}$ and $\mathbf{W}^{K}$ are learnable parameters. Owing to the self-attention between states, HMT can capture more comprehensive state \vspace{-0.1mm}representations by considering different moments of starting translating. For cross-attention, since state $s_{i,k}$ starts translating when receiving the first $t_{i,k}$ source tokens, $s_{i,k}$ can only focus on the source hidden state $h_{j}$ with $j\!\leq\! t_{i,k}$, calculated as:
\vspace{-0.15mm}
\begin{small}\begin{gather}
    \mathrm{CrossAtt}\left ( s_{i,k},h_{j} \right )=\begin{cases}
\vspace{-0.9mm}\mathrm{softmax}\left ( \frac{s_{i,k}\!\mathbf{W}^{Q}\left (h_{j}\!\mathbf{W}^{K}  \right )^{\top}}{\sqrt{d}} \right ) & \text{ if }\; j\leq  t_{i,k} \\
0 & \text{ otherwise } 
\end{cases}.
\end{gather}\end{small}\vspace{-0.15mm}Through $N$ decoder layers, we get the final representation of state $s_{i,k}$. Accordingly, the translation probability of $y_{i}$ from the state $s_{i,k}$ is calculated based on its final representation:
\begin{gather}
    p\!\left (y_{i}\mid \mathbf{x}_{\leq t_{i,k}},\mathbf{y}_{<i}  \right )=\mathrm{softmax}\left ( s_{i,k}\!\mathbf{W}^{O} \right ), \label{eq:translation}
\end{gather}
where $\mathbf{W}^{O}$ are learnable parameters and $\mathbf{y}_{<i}$ are the previous target tokens.

\textbf{Selection} After getting the final representations of states, in order to judge whether to select state $s_{i,k}$ to generate $y_{i}$, HMT predicts a confidence $c_{i,k}$ of selecting state $s_{i,k}$. The confidence $c_{i,k}$ is predicted based on the final state representation of $s_{i,k}$ and the received source contents:
\begin{gather}
    c_{i,k}=\mathrm{sigmoid}\left ( \left [ \,\overline{\mathbf{h}}_{\leq t_{i,k}}\!: s_{i,k} \right ]\!\mathbf{W}^{S} \right ), \label{eq:bik}
\end{gather}
\vspace{-1mm}where $\overline{\mathbf{h}}_{\leq t_{i,k}}\!=\!\frac{1}{t_{i,k}}\sum_{j=1}^{t_{i,k}} h_{j}$ is the average pooling result on the hidden states of the received source tokens, $\left [ :\right ]$ is concatenating operation and $\mathbf{W}^{S}$ are learnable parameters.
In inference, HMT judges whether to select the state from $s_{i,1}$ to $s_{i,K}$. If $c_{i,k}\!\geq\! 0.5$ (i.e., achieving enough confidence), HMT selects the state $s_{i,k}$ to generate $y_{i}$. Otherwise HMT moves to the next state $s_{i,k+1}$ and repeats the judgment. Note that we set $c_{i,K}\!=\!1$ to ensure that HMT starts translating before the last state $s_{i,K}$.


\subsection{Training}
\label{sec:training}

Since when to start translating is hidden inside the model while the target sequence is observable, HMT treats when to start translating target tokens (i.e., which states are selected) as hidden events and treats target tokens as the observed events. Further, HMT organizes them in the form of hidden Markov model, thereby associating the moment of starting translating with the observed target token.
Formally, for hidden events, we denoted which states are selected as $\mathbf{z}\!=\!\left ( z_{1},\cdots ,z_{I} \right )$, where $z_{i}\!\in \! \left[1,K \right]$ represents selecting state $s_{i,z_{i}}$ to generate $y_{i}$. Then, following the HMM form, we introduce the \emph{transition probability} between selections and the \emph{emission probability} from the selection result.

\emph{Transition probability} expresses the probability of the selection $z_{i}$ conditioned on the previous selection $z_{i-1}$, denoted as $p\!\left ( z_{i}\mid z_{i-1}  \right )$. Since HMT judges whether to select states from $s_{i,1}$ to $s_{i,K}$ (i.e., from low latency to high latency), \vspace{-0.2mm}$s_{i,k+1}$ can be selected only if the previous state $s_{i,k}$ is not selected. Therefore, the calculation of $p\!\left ( z_{i}\mid z_{i-1}  \right )$ consists of two parts\footnote{Please refer to Appendix \ref{sec:transition} for detailed instructions of the transition probability between selections.}: (1) $s_{i,z_{i}}$ is confident to be selected, and (2) \vspace{-0.3mm}those states whose translating moment between $t_{i-1,z_{i-1}}$ and $t_{i,z_{i}}$ (i.e., those states that were judged before $s_{i,z_{i}}$) are not confident to be selected, calculated as\footnote{We add a selection $z_{0}$ with $p\!\left ( z_{0} \right )\!=\!1$ before $z_{1}$ to indicate that no source tokens are received at the beginning of translation, i.e., $t_{0,z_{0}}\!=\!0$. Therefore, $p\!\left ( z_{1}\mid z_{0}  \right )$ is the initial probability of the selection in HMT.}:
\vspace{-0.1mm}
\begin{gather}
    p\!\left ( z_{i}\mid z_{i-1}  \right )=\begin{cases}
\vspace{-2mm}c_{i,z_{i}}\times \;\;\; \underset{t_{i-1,z_{i-1}}\leq t_{i,l}<t_{i,z_{i}}\;\;\;\;\;\;\;\;}{\prod_{\,l}} \!\!\!\!\!\!\!\!\!\!\!\left ( 1\!-\!c_{i,l} \right )& \text{ if } t_{i,z_{i}}\geq  t_{i-1,z_{i-1}} \\
0 & \text{ if } t_{i,z_{i}}< t_{i-1,z_{i-1}}
\end{cases}. \label{eq:transition}
\vspace{-0.1mm}
\end{gather}
\emph{Emission probability} expresses the probability of the observed target token $y_{i}$ from the selected state $s_{i,z_{i}}$, i.e., the translation probability in Eq.(\ref{eq:translation}). For clarity, we rewrite it as $p\!\left (y_{i}\mid \mathbf{x}_{\leq t_{i,z_{i}}},\mathbf{y}_{<i},z_{i}  \right )$ to emphasize the probability of HMT generating the target token $y_{i}$ under the selection $z_{i}$.


\textbf{HMM Loss} To learn when to start translating, we train HMT by maximizing the marginal likelihood of the target sequence (i.e., observed events) over all possible selection results (i.e., hidden events), thereby HMT will give higher confidence to selecting those states that can generate the target token more accurately. Given the transition probabilities and emission probabilities, the marginal likelihood of observed target sequence $\mathbf{y}$ over all possible selection results $\mathbf{z}$ is calculated as:
\begin{gather}
    p\!\left ( \mathbf{y}\mid \mathbf{x} \right )=\sum_{\mathbf{z}}p\!\left ( \mathbf{y}\mid \mathbf{x},\mathbf{z} \right ) \times p\!\left ( \mathbf{z} \right ) =\sum_{\mathbf{z}}\prod_{i=1}^{\left| \mathbf{y}\right|}p\!\left (y_{i}\mid \mathbf{x}_{\leq t_{i,z_{i}}},\mathbf{y}_{<i},z_{i}  \right )\times p\!\left ( z_{i}\mid z_{i-1}  \right ). \label{eq: hmm}
\end{gather}
We employ dynamic programming to reduce the computational complexity of marginalizing all possible selection results, and detailed calculations refer to Appendix \ref{sec:dp}.
Then, HMT is optimized with the negative log-likelihood loss $\mathcal{L}_{hmm}$:
\begin{gather}
    \mathcal{L}_{hmm}=-\mathrm{log}\; p\!\left ( \mathbf{y}\mid \mathbf{x} \right ).
\end{gather}

\textbf{Latency Loss} Besides, we also introduce a latency loss $\mathcal{L}_{latency}$ to trade off between translation quality and latency. $\mathcal{L}_{latency}$ is also calculated by marginalizing all possible selection results $\mathbf{z}$:
\begin{gather}
    \mathcal{L}_{latency}= \sum _{\mathbf{z}} p\!\left ( \mathbf{z}  \right )\times \mathcal{C}\!\left(\mathbf{z}\right)
    =\sum _{\mathbf{z}} \prod_{i=1}^{\left| \mathbf{y}\right|} p\!\left ( z_{i}\mid z_{i-1}  \right )\times \mathcal{C}\!\left(\mathbf{z}\right),
\end{gather}
\vspace{-0.9mm}where $\mathcal{C}\!\left(\mathbf{z}\right)$ is a function to measure the latency of a given selection results $\mathbf{z}$, calculated by the average lagging \citep{ma-etal-2019-stacl} relative to the lower boundary: $\mathcal{C}\!\left(\mathbf{z}\right)=\frac{1}{\left|\mathbf{z} \right|}  \sum _{i=1}^{\left|\mathbf{z} \right|} \left ( t_{i,z_i}-t_{i,1} \right )$.


\textbf{State Loss} We additionally introduce a state loss $\mathcal{L}_{state}$ to encourage HMT to generate the correct target token $y_{i}$ no matter which state $z_{i}$ is selected (i.e., no matter when to start translating), thereby improving the robustness on the selection. Since $K$ states are fed into the hidden Markov decoder in parallel during training, $\mathcal{L}_{state}$ is calculated through a cross-entropy loss on all states:
\begin{gather}
    \mathcal{L}_{state}=- \frac{1}{K} \sum_{i=1}^{\left| \mathbf{y}\right|}\sum_{z_{i}=1}^{K}\mathrm{log}\:p\!\left (y_{i}\mid \mathbf{x}_{\leq t_{i,z_{i}}},\mathbf{y}_{<i},z_{i} \right ).
\end{gather}

Finally, the total loss $\mathcal{L}$ of HMT is calculated as:
\begin{gather}
\mathcal{L}=\mathcal{L}_{hmm}+\lambda_{latency}\mathcal{L}_{latency}+\lambda_{state}\mathcal{L}_{state},
\end{gather}
where we set $\lambda_{latency}=1$ and $\lambda_{state}=1$ in our experiments.

\begin{algorithm}[t]
\small
\caption{Inference Policy of Hidden Markov Transformer}\label{alg}
\begin{algorithmic}[1]
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\Require Source sequence $\mathbf{x}$; Translating moments $\mathbf{t}$; Number of states $K$.
\renewcommand{\algorithmicrequire}{\textbf{Output:}}
\Require Translated sequence $\hat{\mathbf{y}}$.
\renewcommand{\algorithmicrequire}{\textbf{Init:}}
\Require Received source sequence $\hat{\mathbf{x}}\!=\!\left [\,  \right ]$, source index $j\!=\!0$; Translated sequence $\hat{\mathbf{y}}\!=\!\left [\left< \mathrm{bos}\right>  \right ]$, target index $i\!=\!1$.
\While{$\;\hat{y}_{i-1}\neq \left< \mathrm{eos}\right>$}
    \If{$\;\left|\hat{\mathbf{x}}\right|< t_{i,1}\;$} \textcolor{gray}{\Comment{To reach the low boundary}}
        \State Wait for source tokens until $\left|\hat{\mathbf{x}}\right|= t_{i,1}$; $\;\;\;$ $j \leftarrow t_{i,1}$;
        \EndIf
    \For{$k\leftarrow$ 1 to $K$}
        \If{$\;\left|\hat{\mathbf{x}}\right|> t_{i,k}\;$} \textbf{continue}; \textcolor{gray}{\Comment{Skip $s_{i,k}$ if its translating moment $t_{i,k}$ is less than $\left|\hat{\mathbf{x}}\right|$}}
        \EndIf
        \State Calculate representation of state $s_{i,k}$ and its confidence $c_{i,k}$ according to Eq.(\ref{eq:bik});
        \If{$\;c_{i,k} \geq 0.5\;$} \textcolor{blue}{\Comment{Select $\Rightarrow$ \texttt{WRITE}}}
            \State Translate target token $\hat{y}_{i}$ according to Eq.(\ref{eq:translation});  %\textcolor{blue}{\Comment{\texttt{WRITE}}}
            \State $\hat{\mathbf{y}}\leftarrow \hat{\mathbf{y}}+\hat{y}_{i}$ ;$\;\;\;$ $i \leftarrow i+1$;
            \State \textbf{Break};
        \Else \textcolor{red}{\Comment{Unselect $\Rightarrow$ \texttt{READ}}}
            \State Wait for the next source token $x_{j+1}$;% \textcolor{red}{\Comment{\texttt{READ}}}
            \State $\hat{\mathbf{x}}\leftarrow \hat{\mathbf{x}}+x_{j+1}$ ;$\;\;\;$  $j \leftarrow j+1$;
        \EndIf
    \EndFor
\EndWhile
   
\State \textbf{return} $\hat{\mathbf{y}}$;
\end{algorithmic}
\end{algorithm}

\subsection{Inference}
\label{sec:inference}

In inference, HMT judges whether to select each state from low latency to high latency based on the confidence, and once a state is selected, HMT generates the target token based on the state representation. Specifically, denoting the current received source tokens as $\hat{\mathbf{x}}$, the inference policy of HMT is shown in Algorithm \ref{alg}.
When translating $\hat{y}_{i}$, HMT judges whether to select the state from $s_{i,1}$ to $s_{i,K}$, so HMT will wait at least $t_{i,1}$ source tokens to reach the lower boundary (line 2). During judging, if the confidence $c_{i,k}\!\geq\!0.5$, HMT selects state $s_{i,k}$ to generate $\hat{y}_{i}$ (i.e., WRITE action) according to Eq.(\ref{eq:translation}), otherwise HMT waits for the next source token (i.e., READ action) and moves to the next state $s_{i,k+1}$. We ensure that HMT starts translating $\hat{y}_{i}$ before the last state $s_{i,K}$ (i.e., before reaching the upper boundary) via setting $c_{i,K}\!=\!1$. Note that due to the monotonicity of the moments to start translating in SiMT, state $s_{i,k}$ will be skipped and cannot be selected (line 5) if its translating moment $t_{i,k}$ is less than the number of received source tokens $\left| \hat{\mathbf{x}} \right|$ (i.e., the moment of translating $\hat{y}_{i-1}$), which is in line with the transition between selections in Eq.(\ref{eq:transition}) during training.

\section{Experiments}

\subsection{Datasets}

We conduct experiments on the following datasets, which are the widely used SiMT benchmarks.

\textbf{IWSLT15\footnote{\url{nlp.stanford.edu/projects/nmt/}} English $\!\rightarrow \!$ Vietnamese (En$\rightarrow$Vi)} (133K pairs) We use TED tst2012 (1553 pairs) as the validation set and TED tst2013 (1268 pairs) as the test set. Following the previous setting \citep{Ma2019a,zhang-feng-2021-universal}, we replace the token whose frequency is less than 5 by $\left \langle unk \right \rangle$, and the vocabulary sizes of English and Vietnamese are 17K and 7.7K, respectively.

\vspace{-2mm}

\textbf{WMT15\footnote{\url{statmt.org/wmt15/translation-task.html}} German $\!\rightarrow\! $ English (De$\rightarrow$En)} (4.5M pairs) We use newstest2013 (3000 pairs) as the validation set and newstest2015 (2169 pairs) as the test set. BPE \citep{sennrich-etal-2016-neural} is applied with 32K merge operations and the vocabulary of German and English is shared.

\subsection{Experimental Settings}
We conduct experiments on several strong SiMT methods, described as follows.

{\bf Full-sentence MT} \citep{NIPS2017_7181} Transformer model waits for the complete source sequence and then starts translating, and we also apply uni-directional encoder for comparison.

\vspace{-2mm}

{\bf Wait-k} \citep{ma-etal-2019-stacl} Wait-k policy first waits for $k$ source tokens, and then alternately translates one target token and waits for one source token.

\vspace{-2mm}

{\bf Multipath Wait-k} \citep{multipath} Multipath Wait-k trains a wait-k model via randomly sampling different $k$ between batches, and uses a fixed $k$ during inference.

\vspace{-2mm}

{\bf Adaptive Wait-k} \citep{zheng-etal-2020-simultaneous} Adaptive Wait-k trains a set of wait-k models (e.g., from wait-1 to wait-13), and heuristically composites these models during inference.

\vspace{-2mm}

{\bf MoE Wait-k\footnote{\url{github.com/ictnlp/MoE-Waitk}}} \citep{zhang-feng-2021-universal} Mixture-of-experts (MoE) Wait-k applies multiple experts to learn multiple wait-k policies respectively, and also uses a fixed $k$ during inference.

\vspace{-2mm}

{\bf MMA\footnote{\url{github.com/facebookresearch/fairseq/tree/main/examples/simultaneous_translation}}} \citep{Ma2019a} Monotonic multi-head attention (MMA) predicts a variable to indicate READ/WRITE action, and trains this variable through monotonic attention \citep{LinearTime}.

\vspace{-2mm}

{\bf GMA\footnote{\url{github.com/ictnlp/GMA}}} \citep{zhang-feng-2022-gaussian} Gaussian multi-head attention (GMA) introduces a Gaussian prior to learn the alignments in attention, and decides when to start translating based on the aligned positions.

\vspace{-2mm}

{\bf GSiMT} \citep{miao-etal-2021-generative} Generative SiMT (GSiMT) generates a variable to indicate READ/WRITE action. GSiMT considers all combinations of READ/WRITE actions during training and only takes one combination of READ/WRITE actions in inference.

\vspace{-2mm}

{\bf HMT} The proposed hidden Markov Transformer, described in Sec.\ref{sec:stateformer}.

\textbf{Settings} All systems are based on Transformer \citep{NIPS2017_7181} from Fairseq Library \citep{ott-etal-2019-fairseq}. Following \citet{Ma2019a} and \citet{miao-etal-2021-generative}, we apply Transformer-Small (4 heads) for En$\rightarrow$Vi, Transformer-Base (8 heads) and Transformer-Big (16 heads) for De$\rightarrow$En. Due to the high training complexity, we only report GSiMT on De$\rightarrow$En with Transformer-Base, the same as its original setting \citep{miao-etal-2021-generative}. The hyperparameter settings are reported in Appendix \ref{app:hyperparameter}.


\textbf{Evaluation} For SiMT performance, we report BLEU score \citep{papineni-etal-2002-bleu} for translation quality and Average Lagging (AL) \citep{ma-etal-2019-stacl} for latency. AL measures the token number that outputs lag behind the inputs. For comparison, we adjust $L$ and $K$ in HMT to get the translation quality under different latency, and the specific setting of $L$ and $K$ are reported in Appendix \ref{app:numerical}

\subsection{Main Results}

\begin{figure}[t]
\centering
\subfigure[En$\rightarrow$Vi, Transformer-Small]{
\includegraphics[width=0.316\textwidth]{main_en_vi_small.pdf} \label{fig:main1}
}
\subfigure[De$\rightarrow$En, Transformer-Base]{
\includegraphics[width=0.316\textwidth]{main_de_en_base_al.pdf} \label{fig:main2}
}
\subfigure[De$\rightarrow$En, Transformer-Big]{
\includegraphics[width=0.316\textwidth]{main_de_en_big_al.pdf} \label{fig:main3}
}
\vspace{-0.1in}
\caption{Translation quality (BLEU) against latency (AL) of HMT and previous SiMT methods.}
\label{fig:main}
\end{figure}

We compare HMT with the existing SiMT methods in Figure \ref{fig:main}, where HMT outperforms the previous methods under all latency.
Compared with fixed methods Wait-k, Multipath Wait-k and MoE Wait-k, HMT has obvious advantages as HMT dynamically judges when to start translating and thereby can handle complex inputs \citep{Arivazhagan2019}. Compared with adaptive methods, HMT outperforms the current state-of-the-art MMA and GSiMT, owing to two main advantages. First, HMT models the moments of starting translating, which has stronger corresponding correlations with the observed target sequence compared with READ/WRITE action \citep{zhang-feng-2022-gaussian}. Second, both MMA and GSiMT can only consider one combination of READ/WRITE actions in inference \citep{Ma2019a,miao-etal-2021-generative}, while HMT can consider multiple moments of starting translating in both training and inference as HMT explicitly produces multiple states for different translating moments.
Furthermore, the performance of MMA and GSiMT will drop at some latency \citep{Ma2019a}, which is mainly because considering too many combinations of READ/WRITE actions in training may cause mutual interference \citep{multipath,zhang-feng-2021-universal,pmlr-v139-wu21e}. HMT pre-prunes those unfavorable moments of starting translating via the proposed boundaries, thereby achieving more stable and better performance under all latency. 





\subsection{Training and Inference Speeds}

\setlength{\columnsep}{11pt}
\begin{wraptable}{r}{7.75cm}
\vspace{-3.5mm}
\caption{Training and inference speeds of HMT.}
\label{table:speed}
\vspace{-0.07in} 
\advance\leftskip+1mm
\small
\centering
\begin{tabular}{L{0.5cm}c|c|cc} \hline
                      \textbf{Systems}    &          & \textbf{\#Para.} & \begin{tabular}[c]{@{}c@{}}\textbf{Training}\\ \textbf{(s/batch)}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{Inference}\\ \textbf{(s/token)}\end{tabular} \\ \hline
\multicolumn{2}{l|}{Full-sentence MT} & 60.9M & 0.204                                                        & 0.0097                                                        \\
\multicolumn{2}{l|}{Wait-k}           & 60.9M & 0.205                                                        & 0.0108                                                        \\
\multicolumn{2}{l|}{MMA}              & 62.5M & 2.112                                                        & 0.0647                                                        \\
\multicolumn{2}{l|}{GSiMT}            & 60.9M & 5.090                                                        & 0.0247                                                        \\ \hline
\multirow{3}{*}{HMT}      & $L\!=\!2$, $K\!=\!4$      & 60.9M & 0.531                                                        & 0.0204                                                        \\
                          & $L\!=\!5$, $K\!=\!6$      & 60.9M & 0.730                                                        & 0.0162                                                        \\
                          & $L\!=\!9$, $K\!=\!8$      & 60.9M & 1.051                                                        & 0.0142  \\\hline                                                     
\end{tabular}
\vspace{-0.2in} 
\end{wraptable}
We compare the training and inference speeds of HMT with previous methods on De$\rightarrow$En with Transformer-Base, and the results are reported in Table \ref{table:speed}. All speeds are evaluated on NVIDIA 3090 GPU.

\textbf{Training Speed} Compared with the fixed method Wait-k, the training speed of HMT is slightly slower as it upsamples the target sequence by $K$ times. Given the obvious performance improvements, we argue that the slightly slower training speed than the fixed method is completely acceptable. Compared with adaptive methods MMA and GSiMT that compute the representation of the variable to indicate READ/WRITE circularly \citep{Ma2019a,miao-etal-2021-generative}, the training speed of HMT has obvious advantages owing to computing representations of multiple states in parallel. Besides, compared to GSiMT considering all possible READ/WRITE combinations, the proposed lower and upper boundaries of the translating moments also effectively speed up HMT training.

\textbf{Inference Speed} Compared with MMA which adds more extra parameters to predict \vspace{-0.5mm}READ/WRITE action in each attention head \citep{Ma2019a}, HMT only requires few extra parameters ($\textbf{W}^{S}$ in Eq.(\ref{eq:bik})) and thereby achieves faster inference speed. Compared with GSiMT, which needs to calculate the target representation and generate READ/WRITE each at each step \citep{miao-etal-2021-generative}, HMT pre-prunes those unfavorable translating moments and only judges among the rest valuable moments, thereby improving the inference speed. Note that as the lower boundary $L$ increases, HMT can prune more candidate translating moments and thus make the inference much faster.


\section{Analysis}
We conducted extensive analyses to study the specific improvements of HMT. Unless otherwise specified, all the results are reported on De$\rightarrow$En test set with Transformer-Base.

\subsection{Ablation Study}
\label{sec:ablation}

\begin{table}[t]
\small
\begin{minipage}[t]{0.37\textwidth}
\vspace{0pt}
\caption{Ablation study of HMM loss, including marginalizing all possible selections or only optimizing the most probable selection result.}
\label{table:ab1}
\vspace{-0.07in}
\centering
\begin{tabular}{l|cc}
\hline
                                                                  & \textbf{AL} & \textbf{BLEU} \\ \hline
\begin{tabular}[c]{@{}l@{}}Marginalizing all \\ possible selections\end{tabular}  & \textbf{3.46}        & \textbf{29.29}         \\ \hline
\begin{tabular}[c]{@{}l@{}}Optimizing most \\ probable selection\end{tabular} & 1.77        & 24.02         \\ \hline
\end{tabular}
\end{minipage}
\hspace{0.04\textwidth}
\begin{minipage}[t]{0.27\textwidth}
\vspace{0pt}
\centering
\caption{Ablation study of the weight $\lambda_{latency}$ of latency loss $\mathcal{L}_{latency}$.}
\label{table:ab2}
\vspace{-0.05in}
\begin{tabular}{c|cc} \hline
$\lambda_{latency}$   & \textbf{AL} & \textbf{BLEU} \\ \hline
0.0 & 6.66        & 30.07         \\
0.5 & 4.12        & 29.80         \\
1.0 & \textbf{3.46}       & \textbf{29.29}         \\
1.5 & 2.10        & 26.65         \\
2.0 & 2.00        & 25.94         \\\hline
\end{tabular}
\end{minipage}
\hspace{0.04\textwidth}
\begin{minipage}[t]{0.255\textwidth}
\vspace{0pt}
\centering
\caption{Ablation study of the weight $\lambda_{state}$ of state loss $\mathcal{L}_{state}$.}
\label{table:ab3}
\vspace{-0.05in}
\begin{tabular}{c|cc} \hline
$\lambda_{state}$   & \textbf{AL}   & \textbf{BLEU}  \\ \hline
0.0 & 3.24          & 27.74          \\
0.5 & 3.47          & 29.10          \\
1.0 & \textbf{3.46} & \textbf{29.29} \\
1.5 & 3.46          & 29.16          \\
2.0 & 3.58          & 29.21         \\\hline
\end{tabular}
\end{minipage}
\end{table}

We conduct multiple ablation studies, where $L\!=\!3$ and $K\!=\!6$ are applied in all ablation studies.

\textbf{HMM Loss} HMT learns when to start translating by marginalizing all possible selection results during training. To verify its effectiveness, we compare the performance of marginalizing all possible selections and only optimizing the most probable selection in Table \ref{table:ab1}, where the latter is realized by replacing $\sum_{\mathbf{z}}$ in Eq.(\ref{eq: hmm}) with $\mathrm{Max}_{\mathbf{z}}$. Under the same setting of $L\!=3$ and $K\!=\!6$, only optimizing the most probable selection makes the model fall into a local optimum \citep{miao-etal-2021-generative} of always selecting the first state, resulting in latency and translation quality close to wait-3 policy. Marginalizing all possible selections effectively enables HMT to learn when to start translating from multiple possible moments, achieving a better trade-off between translation quality and latency.

\textbf{Weight of Latency Loss} Table \ref{table:ab2} reports the performance of HMT on various $\lambda_{latency}$. The setting of $\lambda_{latency}$ affects the trade-off between latency and translation quality. Too large (i.e., $2.0$) or too small (i.e., $0.0$) $\lambda_{latency}$ sometimes makes the model start translating when reaching the upper or lower boundary, while moderate $\lambda_{latency}$ achieves the best trade-off. Note that HMT is not sensitive to the setting of $\lambda_{latency}$, either $\lambda_{latency}\!=\!0.5$ or $\lambda_{latency}\!=\!1.0$ can achieve the best trade-off, where the result with $\lambda_{latency}\!=\!0.5$ is almost on the HMT line in Figure \ref{fig:main2}.

\textbf{Weight of State Loss} Table \ref{table:ab3} demonstrates the effectiveness of the introduced state loss $\mathcal{L}_{state}$. $\mathcal{L}_{state}$ encourages each state to generate the correct target token, which can bring about 1.5 BLEU improvements. In addition, the translation quality of HMT is not sensitive to the weight $\lambda_{state}$ of state loss, and various $\lambda_{state}$ can bring similar improvements.


\subsection{How Many States are Better?}
\setlength{\columnsep}{12pt}
\begin{wraptable}{r}{5cm}
\vspace{-3.5mm}
\caption{HMT performance with various states number $K$. }
\label{table:translating moments}
\vspace{-0.05in}
\advance\leftskip+1mm
\small
\centering
%\vspace{0pt}
\begin{tabular}{L{0.9cm}|cc|cc} \hline
                                                                          & $L$          & $K$          & \textbf{AL}            & \textbf{BLEU}           \\ \hline
\multirow{4}{*}{\begin{tabular}[l]{@{}l@{}}Low\\ latency\end{tabular}}    & 4          & 1          & 2.57          & 25.57         \\
                                                                            & 3          & 2          & 2.15          & 26.07         \\
                                                                          & \textbf{2} & \textbf{4} & \textbf{2.20} & \textbf{27.60} \\
                                                                          & 1          & 6          & 2.28          & 25.69          \\ \hline
\multirow{4}{*}{\begin{tabular}[l]{@{}l@{}}Middle\\ latency\end{tabular}} & 7          & 1          & 5.86          & 28.20          \\
                                                                            & 6          & 4          & 4.90          & 30.14          \\
                                                                          & \textbf{5} & \textbf{6} & \textbf{4.74} & \textbf{30.29} \\
                                                                          & 4          & 8          & 4.69          & 29.35          \\ \hline
\multirow{4}{*}{\begin{tabular}[l]{@{}l@{}}High\\ latency\end{tabular}}   & $\!\!$11         & 1          & 9.71          & 30.36          \\
                                                                            & $\!\!$10         & 6          & 9.06          & 31.32          \\
                                                                          & \textbf{9} & \textbf{8} & \textbf{8.36} & \textbf{31.45} \\
                                                                          & 8          & $\!\!$10         & 8.27          & 31.36   \\\hline      
\end{tabular}
\vspace{-0.2in} 
\end{wraptable}

HMT produces a set of $K$ states for each target token to capture multiple moments of starting translating. To explore how many states are better, we report the HMT performance under various $K$ in Table \ref{table:translating moments}, where we adopt different lower boundaries $L$ (refer to Eq.(\ref{eq:translating moment})) to get similar latency for comparison.

The results show that considering multiple states is significantly better than considering only one state ($K\!=\!1$), demonstrating that HMT finds a better moment to start translating from multiple states. For multiple states, a larger state number $K$ does not necessarily lead to better SiMT performance, and HMT exhibits specific preferences of $K$ at different latency levels. Specifically, a smaller $K$ performs better under low latency, and the best $K$ gradually increases as the latency increases. This is because translating moments with a large gap may interfere with each other during training \citep{multipath,future-guided,zhang-feng-2021-universal}, where the gap is more obvious at low latency. Taking $K\!=\!6$ as an example, the gap between READ 1 tokens/6 tokens (i.e., low latency) is more obvious than READ 10 tokens/15 tokens (i.e., high latency), as the latter contains more overlaps on the received source tokens. Owing to the proposed boundary for translating moments, HMT can avoid the interference via setting suitable $K$ for different latency levels. Further, compared with GSiMT directly considering arbitrary READ/WRITE combinations during training \citep{miao-etal-2021-generative}, HMT pre-prunes those unfavorable moments and thereby achieves better performance.


\subsection{Superiority of Attention between States}
\label{sec:self-attn}

\setlength{\columnsep}{12pt}
\begin{wraptable}{r}{5.7cm}
\vspace{-3.5mm}
\caption{Performance with various modes of self-attention in HMT.}
\label{table:attn}
\vspace{-0.05in} 
\advance\leftskip+1mm
\small
\centering
\begin{tabular}{cc|cc} \hline
\textbf{Training} & \textbf{Inference} & \textbf{AL}   & \textbf{BLEU}  \\\hline
Multiple      & Multiple       & \textbf{3.46} & \textbf{29.29} \\
Multiple      & Max       & 3.37 & 28.99 \\
Multiple      & Selected  & 3.42 & 28.83 \\\hline
Max      & Max       & 3.30 & 28.66 \\
Max      & Selected  & 3.36 & 28.46 \\ \hline
\end{tabular}
\vspace{-0.2in} 
\end{wraptable}
Self-attention between states (in Eq.(\ref{eq:self-attn})) enables HMT to consider multiple moments of starting translating and thereby capture comprehensive state representations. To verify the effectiveness of self-attention between states, we compare the performance of paying attention to multiple states or only one state of each target token. To this end, we apply three modes of self-attention, named \emph{Multiple}, \emph{Max} and \emph{Selected}. `Multiple' is the proposed self-attention in HMT that the state can attend to multiple states of previous target tokens. `Max' means that the state can only attend to one state with the maximum translating moments of each target token. `Selected' means that the state can only attend to the selected state used to generate each target token, which is the most common inference way in the existing SiMT methods (i.e., once the SiMT model decides to start translating, subsequent translations will pay attention to the target representation resulting from this decision.) \citep{ma-etal-2019-stacl,Ma2019a}. Note that all modes of attention need to avoid information leakage between states, i.e., satisfying $ t_{j,k^{'}}\leq t_{i,k}$ in Eq.(\ref{eq:self-attn}). The detailed introduction of these attention refer to Appendix \ref{app:attn}.

As shown in Table \ref{table:attn}, using `Multiple' in both training and inference achieves the best performance. Compared with `Max' which focuses on the state with the maximum translating moment (i.e., containing most source information), `Multiple' brings 0.65 BLEU improvements via considering multiple different translating moments \citep{zhang-feng-2021-universal}. In inference, considering multiple states with different translating moments can effectively improve the robustness as SiMT model may find that it made a wrong decision at the previous step after receiving some new source tokens \citep{zheng-etal-2020-opportunistic}. For `Selection', if SiMT model makes a wrong decision on when to start translating, subsequent translations will be affected as they can only focus on this selected state. Owing to the attention between states, HMT allows subsequent translations to focus on those unselected states, thereby mitigating the impact of uncertain decisions and bringing about 0.46 BLEU improvements. 

\subsection{Quality of Selection}

\setlength{\columnsep}{10pt}
\begin{wrapfigure}{r}{0.3\textwidth}
\begin{center}
\advance\leftskip+1mm
  \vspace{-0.225in} 
 \includegraphics[width=1.55in]{confidence_acc.pdf}
   \vspace{-0.05in} 
  \caption{Token accuracy with predicted confidence.}\label{fig:token acc}
\vspace{-0.2in} 
\end{center}
\end{wrapfigure}
HMT judges whether to select state $s_{i,k}$ by predicting its confidence $c_{i,k}$. To verify the quality of the selection based on predicted confidence, we calculated the token accuracy under different confidences in Figure \ref{fig:token acc}. There is an obvious correlation between confidence and token accuracy, where HMT learns higher confidence for those states that can generate the target tokens more accurately. Especially in inference, since HMT selects state $s_{i,k}$ to generate the target token when its confidence $c_{i,k}\!\geq \!0.5$, HMT learns to start translating at the moments that can generate target tokens with more than 60\% accuracy on average, thereby ensuring the translation quality.


\setlength{\columnsep}{10pt}
\begin{wrapfigure}{r}{0.3\textwidth}
\begin{center}
\advance\leftskip+1mm
  \vspace{-0.3in} 
 \includegraphics[width=1.55in]{prob_bleu.pdf}
   \vspace{-0.05in} 
  \caption{BLEU score with probability of selection result.}\label{fig:prob_bleu}
\vspace{-0.3in} 
\end{center}
\end{wrapfigure}
Besides token accuracy, we further analyse the relationship between translation quality and selection result over the whole sequence. We report the BLEU score \vspace{-1mm}under different probabilities of selection result $p\!\left (\mathbf{z}  \right )$ in Figure \ref{fig:prob_bleu}, where we apply $p\!\left (\mathbf{z}  \right )^{\frac{1}{\left|\mathbf{z} \right|}}$ to avoid the target length $\left|\mathbf{z} \right|$ influencing $p\!\left (\mathbf{z}  \right )$. The selection results with higher probability always achieve higher BLEU scores, showing that training by marginal likelihood encourages HMT to give a higher probability to the hidden sequence (i.e., selection result over the whole sequence) that can generate the high-quality observed target sequence.


\section{Conclusion}

In this paper, we propose hidden Markov Transformer (HMT) for SiMT, which integrates learning when to start translating and learning translation into a unified framework. Experiments on multiple SiMT benchmarks show that HMT outperforms the strong baselines and achieves state-of-the-art performance. Further, extensive analyses demonstrate the effectiveness and superiority of HMT.

\subsubsection*{Acknowledgments}
We thank all the anonymous reviewers for their insightful and valuable comments.


\bibliography{iclr2023_conference}
\bibliographystyle{iclr2023_conference}

\newpage 

\appendix


\section{Calculation of Transition Probability}
\label{sec:transition}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.86\textwidth]{transition.pdf}
    \caption{An example to depict the calculation of transition probability $p\!\left ( z_{i}\mid z_{i-1}  \right )$. }
    \label{fig:transition}
\end{figure}

We give the transition probability $p\!\left ( z_{i}\mid z_{i-1}  \right )$ between selection results in Sec.\ref{sec:training}, and here we describe the calculation of transition probability in more detail.

First of all, a specific selection $z_{i}$ represents translating $y_{i}$ when receiving first $t_{i,z_{i}}$ source tokens through the state $s_{i,z_{i}}$. Similarly, selection $z_{i-1}$ represents translating $y_{i-1}$ when receiving first $t_{i-1,z_{i-1}}$ source tokens through the state $s_{i-1,z_{i-1}}$. Due to the monotonicity of the moment to start translating in SiMT, it is not possible to transfer from $z_{i-1}$ to $z_{i}$ if $t_{i-1,z_{i-1}}>t_{i,z_{i}}$. Then for $t_{i-1,z_{i-1}}\leq t_{i,z_{i}}$, since HMT judges whether to select each state one by one (from $s_{i,1}$ to $s_{i,K}$) and starts translating if a state is selected, the premise of the transition from $z_{i-1}$ to $z_{i}$ is that all states whose translating moment belongs to $[t_{i-1,z_{i-1}}, t_{i,z_{i}})$ are not confident to be selected, and $s_{i,z_{i}}$ is confident to be selected. As the example shown in Figure \ref{fig:transition}, the transition probability $p\!\left ( z_{3}=4\mid z_{2}=3  \right )$ from $z_{2}$ to $z_{3}$ consists of the probability of unselecting $s_{3,2}$ and $s_{3,3}$, and the probability of selecting $s_{3,4}$. 

Formally, the transition probability $p\!\left ( z_{i}\mid z_{i-1}  \right )$ is calculated as:
\begin{gather}
    p\!\left ( z_{i}\mid z_{i-1}  \right )=\begin{cases}
c_{i,z_{i}}\times \;\;\; \underset{t_{i-1,z_{i-1}}\leq t_{i,l}<t_{i,z_{i}}\;\;\;\;\;\;\;\;}{\prod_{\,l}} \!\!\!\!\!\!\!\!\!\!\!\left ( 1\!-\!c_{i,l} \right )& \text{ if } t_{i,z_{i}}\geq  t_{i-1,z_{i-1}} \\
0 & \text{ if } t_{i,z_{i}}< t_{i-1,z_{i-1}}
\end{cases}.
\end{gather}


\section{Dynamic Programming in HMT}
\label{sec:dp}

HMT treats which states are selected (i.e, when to start translating) as hidden events and the target tokens as observed events, and organizes the generation of the target sequence as a hidden Markov model. During training, HMT is optimized by maximizing the marginal likelihood of the target sequence (i.e., observed events) over all possible selection results (i.e., hidden events):
\begin{align}
    p\!\left ( \mathbf{y}\mid \mathbf{x} \right )&=\sum_{\mathbf{z}}p\!\left ( \mathbf{y}\mid \mathbf{x},\mathbf{z} \right ) \times p\!\left ( \mathbf{z} \right ) \\
    &=\sum_{\mathbf{z}}\prod_{i=1}^{\left| \mathbf{y}\right|}p\!\left (y_{i}\mid \mathbf{x}_{\leq t_{i,z_{i}}},\mathbf{y}_{<i}, z_{i}  \right )\times p\!\left ( z_{i}\mid z_{i-1}  \right ).
\end{align}


We apply dynamic programming (a.k.a. forward algorithm in HMM) to calculate the marginal likelihood efficiently \citep{10.2307/2238772}.
Formally, we introduce the intermediate variable $\alpha_{i}\left(k\right)$ to represent the probability of selecting the $k^{th}$ state $s_{i,k}$ when generating the first $i$ target tokens $\mathbf{y}_{\leq i}$, defined as:
\begin{gather}
    \alpha_{i}\left(k\right)=p\!\left(\mathbf{y}_{\leq i}, z_{i}=k \mid \mathbf{x}\right).
\end{gather}

\textbf{Initialization} The initial $\alpha_{1}\left(k\right)$ is calculated as:
\begin{gather}
    \alpha_{1}\left(k\right)=\pi_{k} \times p\!\left (y_{1}\mid \mathbf{x}_{\leq t_{1,k}},\mathbf{y}_{<1},z_{1}=k  \right ),
\end{gather}
where $\pi_{k}=p\!\left ( z_{1}\!=\!k  \right )$ is the initial probability of selecting $s_{1,k}$. In the implementation, we add a certain selection $z_{0}$ with $p\!\left ( z_{0}  \right )\!=\!1$ before $z_{1}$ to indicate that no source tokens are received at the beginning of translation, i.e., $t_{0,z_{0}}\!=\!0$. Accordingly, the initial probability $p\!\left ( z_{1} \right )$ is calculated via the transition probability from $z_{0}$ to $z_{1}$.

\textbf{Recursion} Following, $\alpha_{i}\left(k\right)$ is calculated by summing over the extensions of all transitions from the previous step's selection to the current selection. Therefore, $\alpha_{i}\left(k\right)$ is calculated as the following recursion form:
\begin{gather}
    \alpha_{i}\left(k\right)=\sum_{k^{'}=1}^{K} \alpha_{i-1}\left(k^{'}\right) \times p\!\left ( z_{i}=k\mid z_{i-1}=k^{'}  \right ) \times p\!\left (y_{i}\mid \mathbf{x}_{\leq t_{i,k}},\mathbf{y}_{<i},z_{i}=k  \right ).
\end{gather}


\textbf{Termination} Finally, the marginal likelihood of the target sequence over all possible selection results is calculated as:
\begin{gather}
    p\!\left ( \mathbf{y}\mid \mathbf{x} \right )= \sum_{k=1}^{K} \alpha_{I}\left(k\right).
\end{gather}

\section{Expanded Analyses}

\subsection{Specific Improvements of Policy and Translation}

\setlength{\columnsep}{12pt}
\begin{wrapfigure}{r}{0.35\textwidth}
\begin{center}
\advance\leftskip+1mm
  \vspace{-0.25in} 
 \includegraphics[width=1.81in]{policy_vs_translation.pdf}
   \vspace{-0.1in} 
  \caption{Specific improvements brought by HMT architecture and inference policy.}\label{fig:policy_vs_translation}
\vspace{-0.2in} 
\end{center}
%\vspace{-3mm}
\end{wrapfigure}
The proposed HMT integrates the two key issues in SiMT `learning when to start translating' (i.e., inference policy) and `learning translation' (i.e., translation capability) into a unified framework. Since HMT explicitly models multiple moments of starting translating in both training and inference, HMT architecture can flexibly cooperate with other inference policies, such as wait-k policy \citep{ma-etal-2019-stacl}, which allows us to learn the specific improvements brought by HMT architecture and inference policy. Specifically, we report the results of `HMT architecture + Wait-k inference' in Figure \ref{fig:policy_vs_translation}, where wait-k inference for HMT architecture is realized by forcing HMT to always select the last state. 

By comparison, for wait-k inference, HMT architecture has stronger translation capability due to the comprehensive consideration of multiple translating moments, thereby bringing about 0.8 BLEU improvements. Further, compared to wait-k inference, HMT inference learns more accurate moments to start translating and brings about 2.8 BLEU improvements on average. In particular, the improvements brought by the inference policy are more obvious at low latency, as the precise translating moments are more important for SiMT under low latency \citep{Arivazhagan2019}.


\subsection{Ablation Study on Threshold of Confidence}

\setlength{\columnsep}{12pt}
\begin{wrapfigure}{r}{0.35\textwidth}
\begin{center}
\advance\leftskip+1mm
  \vspace{-0.25in} 
 \includegraphics[width=1.81in]{delta.pdf}
   \vspace{-0.1in} 
  \caption{HMT performance under various thresholds $\delta$ of confidence.}\label{fig:delta}
\vspace{-0.3in} 
\end{center}
%\vspace{-3mm}
\end{wrapfigure}
In inference, HMT will select state $s_{i,k}$ to generate $y_{i}$ when its confidence $c_{i,k}\geq0.5$, where $0.5$ can be regarded as the confidence threshold that HMT believes that the state can generate the correct target token. Figure \ref{fig:token acc} also proves that the state with higher confidence can generate the target token more accurately. To study the effect of the confidence threshold in HMT, we show the HMT performance under different confidence thresholds $\delta$ in Figure \ref{fig:delta}, where HMT will select state $s_{i,k}$ to generate $y_{i}$ when its confidence $c_{i,k}\geq \delta$ in inference.

In inference, moderate confidence thresholds, such as $\delta\!=\!0.4$ and $\delta\!=\!0.5$, achieve similar SiMT performance, indicating that HMT is not sensitive to the setting of the confidence threshold. Furthermore, as the confidence threshold decrease to $0.2$, HMT starts translating much earlier, resulting in a slight decrease in translation quality. As the threshold increases to $0.8$, the latency of HMT increases, but the improvement in translation quality is not obvious, which indicates that $0.5$ confidence is enough to generate the correct target token for the state in HMT.




\subsection{Case Study}


We conduct case studies on two difficult De$\rightarrow$En cases in Figure \ref{fig:case2124} and Figure \ref{fig:case378}, where the word order difference between German and English is more challenging for SiMT model (i.e., the verb in German always lags behind) \citep{ma-etal-2019-stacl,zhang-feng-2021-universal}. We show the specific inference process of HMT and visualize the outputs of all states (including selected, unselected and not considered.) to illustrate that HMT successfully learns when to start translating.


\begin{figure}[h]
\centering
\subfigure[Inference process of HMT. `State' records the currently considered state, and HMT selects the current state and starts translating the target token when its corresponding confidence is greater than $0.5$. The outputs marked in red strikethrough represent potential outputs for those states that are not selected.]{
\includegraphics[width=0.985\textwidth]{case2124.pdf} \label{fig:case2124_1}
}
\subfigure[Visualization of all state outputs with their cross-attention to the received source tokens. For the outputs, the outputs marked in red represent unselected states, the outputs marked in blue represent the selected states, and the outputs marked in gray represent the states that are not considered in inference (i.e., those states after the selected state, or the states whose translating moment is earlier than the moment of translating the previous target token). For the cross-attention, the numerical values in the squares report the cross-attention weight, and blank squares indicate that those source tokens have not been received when translating the target token.]{
\includegraphics[width=0.985\textwidth]{cands2124.pdf} \label{fig:case2124_2}
}
\caption{Case study of \#2124 in De$\rightarrow$En test set, where we apply HMT with $L\!=\!2$ and $K\!=\!4$.}
\label{fig:case2124}
\end{figure}

\textbf{Case with Word Order Difference} As shown in Figure \ref{fig:case2124}, `\textit{auf	der	Liste}' in German is at the beginning of the sentence, while the corresponding translation `\textit{on the list}' is at the end in English. For this case, HMT decides not to select states $s_{1,1}$, $s_{1,2}$ and $s_{1,3}$ because their confidences are less than 0.5, especially the outputs of these states also prove that these moments are not good to start translating. Then, HMT generates `\textit{There}' at state $s_{1,4}$. Similar situations also occur when generating `\textit{celebrities}' and `\textit{on}'. 
Figure \ref{fig:case2124_2} shows more specific outputs for all states and their cross-attention on the received source tokens, where each state corresponds to a moment of starting translating. By selecting one state from $K$ states, HMT effectively finds the optimal moment to start translating, i.e., the moment that can generate the correct target token with lower latency. In particular, those unselected states (i.e., less confidence) tend to produce incorrect translations, while the selected states can produce correct translations by paying attention to the newly received source contents. About this, we already present a statistical analysis between confidence and token accuracy in Figure \ref{fig:token acc}. Further, the selected state always tends to be the earliest state that can generate the correct translation, i.e., the state with lower latency.


\begin{figure}[h]
\centering
\subfigure[Inference process of HMT.]{
\includegraphics[width=0.985\textwidth]{case378.pdf} \label{fig:case378_1}
}
\subfigure[Visualization of all state outputs with their cross-attention to the received source tokens.]{
\includegraphics[width=0.985\textwidth]{cands378.pdf} \label{fig:case378_2}
}
\caption{Case study of \#378 in De$\rightarrow$En test set, where we apply HMT with $L\!=\!3$ and $K\!=\!6$.}
\label{fig:case378}
\end{figure}
\newpage

\textbf{Case that Verb Lags Behind} Figure \ref{fig:case378} gives a more complex case as the verb `\textit{erwarten}' and `\textit{passierte}' in German lag behind, which requires the SiMT model to accurately judge when to start translating \citep{grissom-ii-etal-2014-dont,ma-etal-2019-stacl}. In HMT, when the verb has not been received, the states always get lower confidence, so HMT can start translating the corresponding `\textit{expect}' and `\textit{happened}' after receiving the source verb. Besides, the cross-attention in Figure \ref{fig:case378_2} shows that HMT generates the correct translations at state $s_{4,4}$ and $s_{11,2}$ because they pay attention to the received verb `\textit{erwarten}' and `\textit{passierte}' \citep{zhang-feng-2021-modeling-concentrated}, proving the effectiveness of predicting confidence according to the target representation and received source contents.
 
\subsection{Effect of State Loss $\mathcal{L}_{state}$}

\begin{figure}[h]
\centering
\subfigure[HMT without the state loss $\mathcal{L}_{state}$. Translation result: `\textit{my first choice was to train the army.}'. The green box marks the incorrect translation, where the correct translation should be `\textit{in}' but the model generated `\textit{the}'.]{
\includegraphics[width=0.98\textwidth]{cands912_wo-state-loss.pdf} \label{fig:case912_1}
}
\subfigure[HMT with the state loss $\mathcal{L}_{state}$. Translation result: `\textit{my first choice was to train in the army.}'.]{
\includegraphics[width=0.98\textwidth]{cands912.pdf} \label{fig:case912_2}
}
\caption{Effect of the proposed state loss $\mathcal{L}_{state}$. We apply HMT with $L\!=\!3$ and $K\!=\!6$ and visualize the state outputs of case \#912 in De$\rightarrow$En test set (Source: `\textit{meine erste Wahl war eine Ausbildung in der Armee.}'; Reference: `\textit{my first choice was to go in the army.}'). The outputs marked in red represent unselected states, the outputs marked in blue represent the selected states, and the outputs marked in gray represent the states that are not considered in inference. The numerical values in the squares report the cross-attention weight, and blank squares indicate that those source tokens have not been received when translating the target token.}
\label{fig:case912}
\end{figure}

For HMT training (refer to Sec.\ref{sec:training}), we propose the state loss $\mathcal{L}_{state}$ to encourage HMT to generate the correct target token no matter which state is selected (i.e., no matter when to start translating), and the ablation study in Sec.\ref{sec:ablation} demonstrates the improvements brought by the state loss. To further study the effect of state loss $\mathcal{L}_{state}$, we visualize the state outputs of case \#912 with and without $\mathcal{L}_{state}$ in Figure \ref{fig:case912}.

When removing the state loss $\mathcal{L}_{state}$ in training, those states that are selected with lower probability hardly learn to generate the correct target token, because the emission probability from these states may contribute little to the marginal likelihood of the target sequence. As shown in Figure \ref{fig:case912_1}, some later states incorrectly generate `\textit{I}' when generating the first target token, and some states generate `\textit{was}' when generating the third target token, etc. Although in most cases HMT will not select these states during inference, when the selection is slightly uncertain, the model may output the incorrect target token, such as generating `\textit{the}' instead of `\textit{in}' (marked with the green box in Figure \ref{fig:case912_1}). As shown in Figure \ref{fig:case912_2}, with the state loss $\mathcal{L}_{state}$, multiple states in HMT all can learn to generate the correct target token, no matter when to start translating the target token. Therefore, HMT can still generate the correct target token even if it makes the wrong decision in the selection, thereby improving the robustness on the selection.


\subsection{Quality of Policy}

The quality of the policy directly affects the SiMT performance, and a good policy should ensure that the model receives its corresponding source token before translating each target token, thereby achieving high-quality translation. Following \citet{dualpath}, we calculate the proportion of the ground-truth aligned source tokens received before translating for the evaluation of the policy quality. We apply RWTH\footnote{\url{https://www-i6.informatik.rwth-aachen.de/goldAlignment/}} De$\rightarrow$En alignment dataset and perform force-decoding\footnote{Force-decoding: we force the model to generate the ground-truth target token, thereby comparing the translating moments with the ground-truth alignments} to get the moments of translating each target token. Specifically, we denote the ground-truth aligned source position\footnote{For many-to-one alignment, we choose the last source position in the alignment.} of $y_{i}$ as $a_{i}$, and use $g_{i}$ to record the translating moments of $y_{i}$ (i.e., the number of received source tokens when translating $y_{i}$). Given the alignment $a_{i}$ and translating moment $g_{i}$, the proportion of aligned source tokens received before translating is calculated as:
\setlength{\columnsep}{15pt}
\begin{wrapfigure}{r}{0.38\textwidth}
\begin{center}
\advance\leftskip+1mm
\vspace{-0.1in}
 \includegraphics[width=2in]{rw_sufficient.pdf}
 \vspace{-0.03in} 
  \caption{Quality of the policy in HMT. We calculate the proportion of aligned source tokens received before translating in various policies.}\label{fig:rw_sufficient}
   \vspace{-1in} 
\end{center}
\end{wrapfigure}
\begin{align}
    \text{Proportion}=&\; \frac{1}{\left | \mathbf{y} \right | }\sum_{i=1}^{\left | \mathbf{y} \right | }\mathbbm{1}_{a_{i}\leq g_{i}},\\
    \text{where}\;\;     \mathbbm{1}_{a_{i}\leq g_{i}}=&\; \begin{cases}
1, &  a_{i}\leq g_{i} \\
0, &  a_{i}> g_{i}
\end{cases}.
\end{align}



The evaluation results are shown in Figure \ref{fig:rw_sufficient}. Compared with previous policies, HMT receives more aligned source tokens before translating under the same latency, which demonstrates that HMT can make more precise decisions on when to start translating. Owing to the superiority of policy, HMT can receive more aligned source tokens and thereby achieve higher translation quality than previous methods under the same latency. 


\subsection{Why Self-attention between States?}
\label{app:attn}

\begin{figure}[h]
\centering
\subfigure[Multiple]{
\includegraphics[width=0.303\textwidth]{attn1.pdf} \label{fig:attn1}
}\quad
\subfigure[Max]{
\includegraphics[width=0.303\textwidth]{attn2.pdf} \label{fig:attn2}
}\quad
\subfigure[Selected]{
\includegraphics[width=0.303\textwidth]{attn3.pdf} \label{fig:attn3}
}
\vspace{-0.1in}
\caption{Schematic diagram of self-attention between states in HMT, named `Multiple'. We also propose two variants, `Max' and `Selected', to demonstrate the superiority of `Multiple' attention mode. The schematic diagram shows an example of HMT with $L=1$ and $K=4$, where the translating moments of states for $y_{3}$ and $y_{4}$ are $\mathbf{t}_{3}=(3,4,5,6)$ and $\mathbf{t}_{4}=(4,5,6,7)$, respectively.}
\label{fig:attn}
\end{figure}

HMT applies self-attention among all states based on Eq.(\ref{eq:self-attn}), and here we explain why HMT applies this attention pattern in more depth. For comparison, we introduce three modes of self-attention in Sec.\ref{sec:self-attn}, named Multiple, Max and Selected:
\begin{itemize}
    \item \textbf{Multiple}: The self-attention mode between states in HMT. In `Multiple', the state can pay attention to multiple states of previous target tokens. Taking Figure \ref{fig:attn1} as an example, when translating $y_{4}$, state $s_{4,3}$ can pay attention to $s_{3,1}$, $s_{3,2}$, $s_{3,3}$ and $s_{3,4}$ of $y_{3}$, meanwhile state $s_{4,3}$ also pay attention to $s_{4,1}$, $s_{4,2}$, $s_{4,3}$ of $y_{4}$.
    \item \textbf{Max}: In Max, the state can pay attention to one state of each target token, which has the maximum translating moment. Taking Figure \ref{fig:attn2} as an example, when translating $y_{4}$, state $s_{4,3}$ can only pay attention to $s_{3,4}$ of $y_{3}$, as $t_{3,4}=6$ is the state with the maximum translating moments that $s_{4,3}$ ($t_{4,3}=6$) can pay attention to. Meanwhile, state $s_{4,3}$ pay attention to $s_{4,1}$, $s_{4,2}$, $s_{4,3}$ of $y_{4}$ as well.
    \item \textbf{Selected}: The most common attention mode in the existing SiMT methods. In `Selected', the state can pay attention to the selected state used to generate the previous target token. Once the SiMT model determines WRITE (i.e., selects a state), subsequent translations will only depend on this target representation. Taking Figure \ref{fig:attn3} as an example, assuming that $s_{3,3}$ has been selected to generate $y_{3}$, subsequent $s_{4,2}$, $s_{4,3}$ and $s_{4,4}$ can only focus on the representation of $s_{3,3}$. Note that $s_{4,1}$ cannot focus on $s_{3,3}$ as $t_{3,3}>t_{4,1}$.
\end{itemize}

\textbf{Multiple v.s. Max} The results reported in Table \ref{table:attn} show that `Multiple' brings 0.65 BLEU improvements compared with `Max'. The maximum translating moments that `Multiple' and `Max' can focus on are the same (in both `Multiple' and `Max', state $s_{4,3}$ can pay attention to $s_{4,3}$ with $t_{3,4}=6$.), but `Multiple' can also consider those states that start translation earlier, such as $s_{3,1}$, $s_{3,2}$ and $s_{3,3}$. Comprehensively considering the representation of multiple states helps `Multiple' make more precise judgments and get more accurate state representations \citep{zhang-feng-2021-universal}. Furthermore, in `Max', the current state always focuses on one previous state with the largest translating moment, regardless of which state is selected to generate the previous target token. For example, even if $s_{4,2}$ is selected to generate $y_{3}$, state $s_{4,3}$ still only pays attention to $s_{4,3}$ in `Max', where ignoring the previous selected state $s_{4,2}$ will disturb the dependency of $y_{4}$ on $y_{3}$ and thereby affect the translation quality. Therefore, owing to more comprehensive attention to multiple states, the proposed `Multiple' attention mode achieves better performance.

\textbf{Multiple v.s. Selected} `Selected' is the most commonly used attention mode of the current SiMT method, i.e., once a WRITE action is decided, subsequent target tokens can only pay attention to the representation of this state \citep{ma-etal-2019-stacl,Arivazhagan2019,Ma2019a}. The reason for applying `Selected' attention mode is that the previous methods can only retain a unique translating moment and corresponding representation for each target token in inference, unlike HMT which can explicitly model multiple translating moments for each target token. Keeping the only target representation of the selected translating moment is susceptible to inaccurate decisions \citep{zheng-etal-2020-opportunistic}. Assuming that the model selects the state $s_{3,3}$ to generate $y_3$, but this decision is not necessarily completely accurate, it may be more reasonable to use $s_{3,2}$ or $s_{3, 4}$ to generate $y_3$. `Selected' requires subsequent states to only focus on the representation of $s_{3,3}$, which may cause translation errors. `Multiple' allows the following states to focus on multiple states, including those not selected, and thereby make comprehensive decisions to achieve better results.

In conclusion, `Max' ignores the previous selected state, `Selected' only considers the selected state, while the proposed `Multiple' attention mode pays attention to all previous states and keeps training and inference matching. Therefore, `Multiple' performs best among these three attention modes.


\section{Hyperparameter}
\label{app:hyperparameter}

Table \ref{table:hyperparameter} gives the hyperparameter settings of HMT.

\begin{table}[h]
\small
\centering
\caption{Hyperparameters of HMT.}
\label{table:hyperparameter}
\vspace{-0.05in}
\begin{tabular}{lccc} \hline
\textbf{Hyperparameters}          & \begin{tabular}[c]{@{}c@{}}\textbf{En$\rightarrow$Vi}\\      \textbf{Transformer-Small}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{De$\rightarrow$En}\\      \textbf{Transformer-Base}\end{tabular} & \begin{tabular}[c]{@{}c@{}}\textbf{De$\rightarrow$En}\\      \textbf{Transformer-Big}\end{tabular} \\ \hline
encoder-layers          & 6                                                                                           & 6                                                                                    & 6                                                                                   \\
encoder-attention-heads & 4                                                                                           & 8                                                                                    & 16                                                                                  \\
encoder-embed-dim       & 512                                                                                         & 512                                                                                  & 1024                                                                                \\
encoder-ffn-embed-dim   & 1024                                                                                        & 2048                                                                                 & 4096                                                                                \\
decoder-layers          & 6                                                                                           & 6                                                                                    & 6                                                                                   \\
decoder-attention-heads & 4                                                                                           & 8                                                                                    & 16                                                                                   \\
decoder-embed-dim       & 512                                                                                         & 512                                                                                  & 1024                                                                                \\
decoder-ffn-embed-dim   & 1024                                                                                        & 2048                                                                                 & 4096                                                                                \\
dropout                 & 0.3                                                                                         & 0.3                                                                                  & 0.3                                                                                 \\
optimizer               & adam                                                                                        & adam                                                                                 & adam                                                                                \\
adam-$\beta$                  & (0.9, 0.98)                                                                                 & (0.9, 0.98)                                                                          & (0.9, 0.98)                                                                         \\
clip-norm               & 0                                                                                           & 0                                                                                    & 0                                                                                   \\
lr                      & 2e-4                                                                                        & 5e-4                                                                                 & 5e-4                                                                                \\
lr-scheduler            & inverse\_sqrt                                                                               & inverse\_sqrt                                                                        & inverse\_sqrt                                                                       \\
warmup-updates          & 4000                                                                                        & 4000                                                                                 & 4000                                                                                \\
warmup-init-lr          & 1e-7                                                                                        & 1e-7                                                                                 & 1e-7                                                                                \\
weight-decay            & 0.0001                                                                                      & 0.0001                                                                               & 0.0001                                                                              \\
label-smoothing         & 0.1                                                                                         & 0.1                                                                                  & 0.1                                                                                 \\
max-tokens              & 16000                                                                                       & 8192$\times$4                                                                               & 8192$\times$4      \\\hline                                                                       
\end{tabular}
\end{table}


\section{Numerical Results with More Metrics}
\label{app:numerical}

\subsection{Latency Metrics}
Besides Average Lagging (AL) \citep{ma-etal-2019-stacl}, we additionally use Consecutive Wait (CW) \citep{gu-etal-2017-learning}, Average Proportion (AP) \citep{Cho2016} and Differentiable Average Lagging (DAL) \citep{Arivazhagan2019} to evaluate the latency of HMT. We denote the number of waited source tokens before translating $y_{i}$ as $g_{i}$ (i.e., the moment to start translating $y_{i}$), and the calculations of these latency metrics are as follows.

\textbf{Consecutive Wait (CW)} \citep{gu-etal-2017-learning} evaluates the average number of source tokens waited between two target tokens. Given $g_{i}$, CW is calculated as:
\begin{gather}
    \mathrm{CW}=\frac{\sum_{i=1}^{\left | \mathbf{y} \right |} (g_{i}-g_{i-1})}{\sum_{i=1}^{\left | \mathbf{y} \right |}\mathbbm{1}_{g_{i}-g_{i-1}>0}},
\end{gather}
where $\mathbbm{1}_{g_{i}-g_{i-1}>0}$ counts the number of $g_{i}-g_{i-1}>0$.

\textbf{Average Proportion (AP)} \citep{Cho2016} evaluates the proportion between the number of received source tokens and the total number of source tokens. Given $g_{i}$, AP is calculated as:
\begin{gather}
    \mathrm{AP}=\frac{1}{\left | \mathbf{x} \right | \left | \mathbf{y} \right |}\sum_{i=1}^{\left | \mathbf{y} \right |} g_{i}.
\end{gather}

\textbf{Average Lagging (AL)} \citep{ma-etal-2019-stacl} evaluates the average number of tokens that target outputs lag behind the source inputs. Given $g_{i}$, AL is calculated as:
\begin{gather}
    \mathrm{AL}= \frac{1}{\tau }\sum_{i=1}^{\tau}g_{i}-\frac{i-1}{\left | \mathbf{y} \right |/\left | \mathbf{x} \right |},\;\;\;\; \mathrm{where} \;\;\tau = \underset{i}{\mathrm{argmin}}\left ( g_{i}= \left | \mathbf{x} \right |\right ).
\end{gather}

\textbf{Differentiable Average Lagging (DAL)} \citep{Arivazhagan2019} is a differentiable version of average lagging. Given $g_{i}$, DAL is calculated as:
\begin{gather}
\mathrm{DAL}= \frac{1}{\left | \mathbf{y} \right | }\sum\limits_{i=1}^{\left | \mathbf{y} \right |}g^{'}_{i}-\frac{i-1}{\left | \mathbf{x} \right |/\left | \mathbf{y} \right |},\;\;\;\;\mathrm{where} \;\;g^{'}_{i}= \left\{\begin{matrix}
g_{i} & i=1\\ 
 \mathrm{max}\left (g_{i},g^{'}_{i-1}+ \frac{\left | \mathbf{x} \right |}{\left | \mathbf{y} \right |} \right )& i>1
\end{matrix}\right..
\end{gather}

\subsection{Numerical Results}

We adjust $L$ and $K$ in HMT (refer to Eq.(\ref{eq:translating moment})) to get the translation quality under different latency. For clarity, we present the numerical results of HMT with the specific setting of hyperparameters $L$ and $K$ in Table \ref{table:envi_small_res}, Table \ref{table:deen_base_res} and Table \ref{table:deen_big_res}.
Note that for comparison, we set $L\!=\!-1$ to get the translation quality of HMT under extremely low latency ($\text{AL}\!<\!1$, i.e., the outputs lagging the inputs less than 1 token on average) on De$\rightarrow$En. When setting $L\!=\!-1$, we constrain the translating moment $t_{i,k}$ of all states to be at least 1, i.e., $t_{i,k}=\max\left\{\min\left\{ L+\left ( i-1 \right )+\left ( k-1 \right ), \left| \mathbf{x}\right|\right\},1\right\}$. Therefore, all states will start translating after receiving at least 1 source token.

\begin{table}[h]
\small
\centering
\caption{Numerical results of HMT on En$\rightarrow$Vi with Transformer-Small.}
\label{table:envi_small_res}
\vspace{-0.05in}
\begin{tabular}{cc|cccc|c} \hline
\multicolumn{7}{c}{\textit{\textbf{IWSLT15 En$\rightarrow$Vi $\;\;\;\;$  Transformer-Small}}}                                  \\\hline
$L$ & $K$ & \textbf{CW} & \textbf{AP} & \textbf{AL} & \textbf{DAL} & \textbf{BLEU} \\ \hline
1          & 2          & 1.15        & 0.64        & 3.10        & 3.72         & 27.99         \\
2          & 2          & 1.22        & 0.67        & 3.72        & 4.38         & 28.53         \\
4          & 2          & 1.24        & 0.72        & 4.92        & 5.63         & 28.59         \\
5          & 4          & 1.53        & 0.76        & 6.34        & 6.86         & 28.78         \\
6          & 4          & 1.96        & 0.83        & 8.15        & 8.71         & 28.86         \\
7          & 6          & 2.24        & 0.89        & 9.60        & $\!\!\!$10.12        & 28.88        \\\hline
\end{tabular}
\end{table}




\begin{table}[h]
\small
\centering
\caption{Numerical results of HMT on De$\rightarrow$En with Transformer-Base.}
\label{table:deen_base_res}
\vspace{-0.05in}
\begin{tabular}{cc|cccc|c} \hline
\multicolumn{7}{c}{\textit{\textbf{WMT15 De$\rightarrow$En $\;\;\;\;$ Transformer-Base}}}                                   \\ \hline
$L$ & $K$ & \textbf{CW} & \textbf{AP} & \textbf{AL} & \textbf{DAL} & \textbf{BLEU} \\ \hline
-1         & 4          & 1.58        & 0.52        & 0.27        & 2.41         & 22.52         \\
2          & 4          & 1.78        & 0.59        & 2.20        & 4.53         & 27.60         \\
3          & 6          & 2.06        & 0.64        & 3.46        & 6.38         & 29.29         \\
5          & 6          & 1.85        & 0.69        & 4.74        & 6.95         & 30.29         \\
7          & 6          & 2.03        & 0.74        & 6.43        & 8.35         & 30.90         \\
9          & 8          & 2.48        & 0.79        & 8.36        & $\!\!\!$10.09        & 31.45         \\
11         & 8          & 3.02        & 0.83        & $\!\!\!$10.06       & $\!\!\!$11.57        & 31.61         \\
13         & 8          & 3.73        & 0.86        & $\!\!\!$11.80       & $\!\!\!$13.08        & 31.71        \\\hline
\end{tabular}
\end{table}

\begin{table}[h]
\small
\centering
\caption{Numerical results of HMT on De$\rightarrow$En with Transformer-Big.}
\label{table:deen_big_res}
\vspace{-0.05in}
\begin{tabular}{cc|cccc|c} \hline
\multicolumn{7}{c}{\textit{\textbf{WMT15 De$\rightarrow$En $\;\;\;\;$ Transformer-Big}}}                                   \\ \hline
$L$ & $K$ & \textbf{CW} & \textbf{AP} & \textbf{AL} & \textbf{DAL} & \textbf{BLEU} \\ \hline
-1 & 4 & 1.65 & 0.52 & 0.06  & 2.43  & 22.70 \\
2  & 4 & 1.79 & 0.60 & 2.19  & 4.50  & 27.97 \\
3  & 6 & 2.04 & 0.64 & 3.46  & 6.30  & 29.91 \\
5  & 6 & 1.88 & 0.69 & 4.85  & 7.07  & 30.85 \\
7  & 6 & 2.06 & 0.74 & 6.56  & 8.47  & 31.99 \\
9  & 8 & 2.47 & 0.79 & 8.34  & $\!\!\!$10.10 & 32.28 \\
11 & 8 & 2.98 & 0.83 & $\!\!\!$10.12 & $\!\!\!$11.58 & 32.46 \\
13 & 8 & 3.75 & 0.86 & $\!\!\!$11.78 & $\!\!\!$13.09 & 32.58        \\\hline
\end{tabular}
\end{table}

\end{document}