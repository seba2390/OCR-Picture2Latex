\section{Tractable Cases}\label{sec:tractable}


In this section, we investigate under which circumstances the problem of finding an optimal contract in Bayesian principal-agent settings is computationally tractable.
%
In particular, we show that the problem is solvable in polynomial time when either the number of agent's types $\ell$ or the number of outcomes $m$ is small.
%
Formally, we exhibit two algorithms that run in polynomial time when $\ell$ and $m$, respectively, are kept constant.


Let us remark that, as a byproduct of Theorem~\ref{thm:hard_label}, we also get that, even when the agent has a constant number of actions, it is \textsf{NP}-hard to approximate the contract-design problem up to within any given constant factor.
%
Specifically, the theorem implies that, for any $\rho \ge 1$, there exists a constant $k_\rho \in \mathbb{N}$ that depends on $\rho$ such that the problem is \textsf{NP}-hard to approximate up to within a multiplicative loss $\rho$ even when restricted to Bayesian principal-agent settings with $|A| \leq k_\rho$. 
%
However, the constant number of actions $k_\rho$ required for the hardness increases as the multiplicative approximation loss $\rho$ increases.
%
We leave as an open problem determining whether there are or not algorithms providing reasonable approximation guarantees with a small number of agent's actions.


\subsection{Constant Number of Types}

The crucial observation grounding our result is that the hardness of the problem of designing an optimal contract in Bayesian principal-agent settings stems from the difficulty of finding, among the exponentially-many possibilities, the tuple of agent's actions (one per type) that need to be incentivized.
%
Instead, given a tuple $\left( a_\theta \right)_{\theta \in \Theta}$ defining an agent's action $a_\theta \in A$ for each type $\theta \in \Theta$, a contract that implements $a_\theta$ for every type $\theta \in \Theta$ and maximizes the overall principal's expected utility can be obtained by the following linear program:
%
\begin{subequations}\label{lp:min_pay}
	\begin{align}
		\min_{p \in \mathbb{R}^m} & \quad  \sum_{\theta \in \Theta} \mu_\theta \sum_{\omega \in \Omega} p_\omega F_{\theta,a_\theta,\omega}\\
		\textnormal{s.t. } & \sum_{\omega \in \Omega} p_\omega F_{\theta,a_\theta,\omega} -c_{\theta,a_\theta} \ge \sum_{\omega \in \Omega} p_\omega F_{\theta,a,\omega} -c_{\theta,a} & \forall \theta \in \Theta, \forall a \in A \label{eq:incentive}\\
		&p_\omega \ge 0 & \forall \omega \in \Omega,
	\end{align} 
\end{subequations}
%
where, for the ease of notation, we identify a contract with a vector $p \in \mathbb{R}^m$ whose components are the payments $p_\omega$ for $\omega \in \Omega$ defining the contract.
%
Notice that, given that the agent's actions are fixed, the objective function to be minimized is the expected payment from the principal to the agent (as the principal's reward is fixed).
%
Constraints~\eqref{eq:incentive} ensure that each action $a_\theta$ is IC for an agent of type $\theta \in \Theta$ (recall that IR is ensured by Assumption~\ref{ass:ir}).

The following proposition shows that an optimal contract can be found by enumerating all the possible $n^\ell$ tuples of actions $\left( a_\theta \right)_{\theta \in \Theta}$, selecting the one that gives the highest optimal value for Problem~\eqref{lp:min_pay} (and the corresponding contract).
%
As an immediate consequence, we get that, when the number of agent's types $\ell$ is kept constant, then the overall running time of the resulting algorithm is polynomial in the size of the problem instance.~\footnote{The proofs of Theorem~\ref{prop:types} and Theorem~\ref{thm:outcomes} are deferred to the Appendix.}

\begin{restatable}{theorem}{propositionTypes}\label{prop:types}
	There exists an algorithm running in time polynomial in $n^\ell$ and $m$ that finds an optimal contract in any Bayesian principal-agent instance given as input.
\end{restatable}

%\begin{proof}
%	%
%	The algorithm works by solving Problem~\eqref{lp:min_pay} for every possible tuple $\left( a_\theta \right)_{\theta \in \Theta}$ in the set $\bigtimes_{\theta \in \Theta} A$.
%	%
%	Then, it picks the tuple (and the corresponding contract obtained by solving Problem~\eqref{lp:min_pay} for it) that results in the highest optimal value for Problem~\eqref{lp:min_pay}.
%	%
%	We prove the correctness of the algorithm by showing that the returned contract, identified by a vector $ p^\star \in \mathbb{R}^m$, must provide the principal with an expected utility at least as large as that of any other contract.
%	%
%	Let us take an arbitrary contract identified by vector $p \in \mathbb{R}^m$, and let $\left( a_\theta \right)_{\theta \in \Theta}$ be a tuple such that, for every $\theta \in \Theta$, the contract implements action $a_\theta$ for an agent of type $\theta$.
%	%
%	Then, by solving Problem~\eqref{lp:min_pay} for $\left( a_\theta \right)_{\theta \in \Theta}$, the algorithm finds a contract incentivizing the same tuple of agent actions and requiring the principal an expected payment smaller than or equal to that of $p$.
%	%
%	Notice that, since the contract found by solving the LP in Problem~\eqref{lp:min_pay} may lie on the boundary of its feasible region, there could be other tuples of agent actions that are incentivized by the contract.
%	%
%	However, by using the assumption that the agent always breaks ties in favor of the principal, we can conclude that the tuple of agent actions that is actually played must provide the principal with an expected reward greater than or equal to that obtained for $\left( a_\theta \right)_{\theta \in \Theta}$.
%	%
%	Thus, we can conclude that $p^\star$ provides the principal with an expected revenue greater than or equal to that of $p$, while requiring a smaller or equal payment, showing the correctness of the algorithm.
%	%
%	Finally, notice that the algorithm solves $n^\ell$ different LPs, one for each tuple in $\bigtimes_{\theta \in \Theta} A$.
%	%
%	The LPs have $m$ variables and $\ell \cdot n$ constraints, and, thus, they can be solved in time polynomial in $n$, $m$, and $\ell$.
%	%
%\end{proof}



\subsection{Constant Number of Outcomes}

The crucial insight underlying the polynomial-time algorithm is that, when the number of outcomes is kept constant, it is sufficient to search for an optimal contract in a polynomially-sized set of possible candidates.
%
For the ease of notation, we let $P \coloneqq \mathbb{R}_+^m$ be the set of vectors identifying all the possible contracts, where, given $p \in \mathbb{R}_+^m$, we denote with $p_\omega$ the vector component defining the payment associated to outcome $\omega \in \Omega$.
%
Moreover, for every agent's action $a \in A$ and agent's type $\theta \in \Theta$, we let $P(a,\theta) \subseteq P$ be the set identifying all the contracts that implement action $a$ for an agent of type $\theta$.
%
Formally, the set $P(a, \theta)$ is characterized by the following set of inequalities representing IC constraints:
%
\begin{equation}\label{eq:hyperplane}
	\sum_{\omega \in \Omega} p_\omega F_{\theta,a,\omega} -c_{\theta,a} \ge \sum_{\omega \in \Omega} p_\omega F_{\theta,a',\omega} -c_{\theta,a'} \quad \forall a' \in A : a' \neq a.
\end{equation}
%
Additionally, for every tuple of agent's actions $\textbf{a} = \left( a_\theta \right)_{\theta \in \Theta} \in \bigtimes_{\theta \in \Theta} A$, we let $P (\textbf{a}) \coloneqq \bigcap_{\theta \in \Theta} P(a_\theta, \theta)$ be the set identifying all the contracts that implement action $a_\theta$ for each agent's type $\theta \in \Theta$.
%
Finally, we let $P^\star \coloneqq \bigcup_{\textbf{a} \in \bigtimes_{\theta \in \Theta} A} \mathcal{V} (P(\textbf{a}))$, where $\mathcal{V}(P(\textbf{a}))$ denotes the set of vertices of polytope $P(\textbf{a})$.

The following theorem shows that, given any Bayesian principal-agent setting, there always exists an optimal contract belonging to the set $P^\star$ and that $P^\star$ has size bounded by a polynomial in $n^m$ and $\ell^m$.
%
Thus, whenever the number of outcomes $m$ is kept constant, an optimal contract can be computed in time polynomial in the size of the instance.


 \begin{restatable}{theorem}{theoremOutcomes}\label{thm:outcomes}
	There exists an algorithm running in time polynomial in $n^m$ and $\ell^m$ that finds an optimal contract in any Bayesian principal-agent instance given as input.
\end{restatable}

%\begin{proof}
%	The proof involves two steps.
%	%
%	\paragraph{First Step} We show that, for any contract defined by a vector $p \in P$, there exists another contract identified by a vector $p^\star \in P^\star$ providing the principal with an expected utility greater than or equal to that obtained for $p$.
%	%
%	Let $\textbf{a}=(a_\theta)_{\theta \in \Theta} \in \bigtimes_{\theta \in \Theta} A$ be a tuple of agent actions such that the contract $p$ implements action $a_\theta$ for every type $\theta \in \Theta$.
%	%
%	Let us define $p^\star \in P$ as the optimal solution of the LP in Problem~\eqref{lp:min_pay} for the tuple $(a_\theta)_{\theta \in \Theta}$.
%	%
%	Noticing that the objective of Problem~\eqref{lp:min_pay} is to minimize a linear function over the polytope $P(\textbf{a})$, we can assume w.l.o.g. that the vector $p^\star$ is a vertex of the polytope, \emph{i.e.}, that $p^\star \in \mathcal{V} (P(\textbf{a}))$.
%	%
%	Notice that, since $p^\star$ lies on a vertex of the feasible region of the LP, then there might be other tuples of agent actions that are incentivized by the contract identified by $p^\star$.
%	%
%	However, given the assumption that the agent breaks ties in favor of the principal, these would provide the principal with an expected reward greater than or equal to that obtained for $(a_\theta)_{\theta \in \Theta}$.
%	%
%	Thus, we can conclude that $p^\star$ has expected reward greater than or equal to that of $p$, while requiring a smaller or equal payment, proving the first step.
%	
%	\paragraph{Second Step}
%	%
%	We show that the size of $P^\star$ can be bounded by a polynomial in $n^m$ and $\ell^m$.
%	%
%	For any tuple of agent actions $\textbf{a}=(a_\theta)_{\theta \in \Theta} \in \bigtimes_{\theta \in \Theta} A$, the set $P(\textbf{a})$ is an $m$-dimensional polytope, and, thus, each vertex in $\mathcal{V}(P(\textbf{a}))$ is determined by the intersection of exactly $m$ hyperplanes among those defining it.
%	%
%	Each polytopes $P(\textbf{a})$ is characterized by a subset of the hyperplanes defining the sets $P(a,\theta)$ for $a \in A$ and $\theta \in \Theta$.
%	%
%	After removing duplicates, we can conclude that, for each $\theta \in \Theta$, there are at most $\binom{n}{2}$ hyperplanes resulting from Constraints~\ref{eq:hyperplane}, which are those defining the boundaries between the sets $P(a,\theta)$ and $P(a',\theta)$, for any pair of actions $a, a' \in A$ such that $a' \neq a$.
%	%
%	Moreover, there are $m$ hyperplanes resulting from non-negativity constraints, namely $p_\omega \geq 0$ for every $\omega \in \Omega$.
%	%
%	As a result, each polytope $P(\textbf{a})$ is defined by a subset of the same set of at most $\ell n^2 + m$ hyperplanes.
%	%
%	Hence, each vertex in $P^\star$ is obtained as the intersection of exactly $m$ of these at most $\ell n^2 + m$ hyperplanes and we can conclude that there are at most $\binom{\ell n^2+m}{m}$ vertices in $P^\star$.
%	%
%	%The same reasoning can be applied for any tuple of agent actions $\textbf{a}=(a_\theta)_{\theta \in \Theta} \in \bigtimes_{\theta \in \Theta} A$, proving that the size of $P^\star$ is $O\left( n^\ell \binom{\ell n^2+m}{m} \right)$.
%	In conclusion, to find an optimal contract it is sufficient that the algorithm enumerates all the vertices in $P^\star$, which requires time polynomial in $n^m$ and $\ell^m$.
%	%
%\end{proof}



