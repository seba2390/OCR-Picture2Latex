\vspace{-1.5em}
\section{Preliminaries}
\vspace{-1em}

We denote by $\Nset$, $\Nset_0$, $\Zset$, and $\Rset$ the sets of all positive
integers, non-negative integers, integers and real numbers, respectively.
For any infinite word $w=b_0b_1\dots$ over an alphabet $\Sigma$, we denote by $\infset{w}$ the set of symbols % (i.e., $b_i$'s) 
in $\Sigma$ that occur infinitely often in $w$.
%Given a finite word $w=b_0\dots b_n$ ($n\ge 0$), the last symbol $b_n$ is denoted by $\lastloc{w}$.

%
%\subsection{Basic Concepts for Clock Valuations, Clock Constraints and Clock Equivalences}
%
A \emph{clock} is a variable for a nonnegative real number. Below we fix a finite set $\clocks$ of clocks.

\smallskip \noindent{\em Clock Valuations.}
%Let $\clocks$ be a finite set of \emph{clocks}.
A \emph{clock valuation} is a function $\nu:\clocks\rightarrow [0,\infty)$. The set of clock valuations
is denoted by $\val{\clocks}$.
Given a clock valuation $\nu$, a subset $X\subseteq\clocks$ of clocks and a non-negative real number $t$, we let (i) $\reset{\nu}{X}$ be the clock valuation such that $\reset{\nu}{X}(x)=0$ for $x\in X$ and $\reset{\nu}{X}(x)=\nu(x)$ otherwise, and (ii) $\add{\nu}{t}$ be the clock valuation such that $(\add{\nu}{t})(x)=\nu(x)+t$ for all $x\in\clocks$.
We denote by $\zero$ the clock valuation such that $\zero(x)=0$ for $x\in\clocks$.

\smallskip \noindent{\em Clock Constraints.} The set $\clcons{\clocks}$ of \emph{clock constraints}  over $\clocks$ is generated by the following grammar:
$
\phi:=~\true~\mid~x\le d~\mid ~c\le x~\mid~x+c\le y+d~\mid ~\neg\phi~\mid~\phi\wedge\phi
$
where $x,y\in\clocks$ and $c,d\in\Nset_0$.
We write $\false$ for a short hand of $\neg\true$.
The satisfaction relation $\models$ between valuations $\nu$ and clock constraints $\phi$ is defined through substituting every $x\in\clocks$ appearing in $\phi$ by $\nu(x)$ and standard semantics for logical connectives.
For a given clock constraint $\phi$, we denote by $\sat{\phi}$ the set of all clock valuations that satisfy $\phi$.

%\smallskip \noindent{\em Clock Equivalence.} Consider a nonnegative integer $N$ such that
%%which acts a threshold for relevant clock values:
%values held by clocks are treated equivalent if they both exceed $N$.
%With such a threshold, the standard notion of clock equivalence~\cite{DBLP:journals/tcs/AlurD94} is an equivalence relation $\sim_N$ over $\val{\clocks}$ as follows: for any two clock valuations $\nu,\nu'$, $\nu\sim_N\nu'$ iff the following conditions hold:
%\begin{compactitem}
%\item for all $x\in\clocks$, $\nu(x)>N$ iff $\nu'(x)> N$;
%\item for all $x\in\clocks$, if $\nu(x)\le N$ then (i) $\intp{\nu(x)}=\intp{\nu'(x)}$ and (ii) $\fracp{\nu(x)}>0$ iff $\fracp{\nu'(x)}>0$;
%\item for all $x,y\in\clocks$, if $\nu(x),\nu(y)\le N$ then it holds that $\fracp{\nu(x)}\Join \fracp{\nu(y)}$ iff $\fracp{\nu'(x)}\Join \fracp{\nu'(y)}$ for $\Join\in\{<,=,>\}$.
%\end{compactitem}
%Equivalence classes of $\sim_N$ are called \emph{regions}.
%%The equivalence class that contains a given clock valuation $\nu$ is denoted by $\evclass{\nu}_{\sim_N}$.
%%We simply write $\evclass{\nu}_{\sim}$ if $N$ is clear from the context.
\vspace{-1.5em}
\subsection{Probabilistic Timed Automata}
\vspace{-0.6em}

%\smallskip \noindent{\em Discrete Probability Distributions.}
A \emph{discrete probability distribution} over a countable non-empty set $U$ is a function $q:U\rightarrow[0,1]$ such that $\sum_{z\in U}q(z)=1$.
The \emph{support} of $q$ is defined as $\supp{q}:=\{z\in U\mid q(z)>0\}$.
We denote the set of discrete probability distributions over $U$ by $\dist{U}$.
%For $u \in U$, we let $\mu_u$ be the \emph{Dirac distribution at $u$} which assigns probability 1 to $u$.

\vspace{-0.6em}
\begin{definition}[Probabilistic Timed Automata~\cite{DBLP:journals/fmsd/NormanPS13}]
A \emph{probabilistic timed automaton} (PTA) $\pta$ is a tuple
\begin{equation}\label{eq:pta}
\pta=\left(\locs, \loc^*, \clocks, \acts, \inv, \enab,  \prob, \ap, \lbfunc\right)
\end{equation}
where :
% $\locs$ is a finite set of \emph{locations},
% $\loc^*\in\locs$ is the \emph{initial} location,
% $\clocks$ is a finite set of \emph{clocks},
% $\acts$ is a finite set of \emph{actions},
% $\inv:\locs\rightarrow\clcons{\clocks}$ is an \emph{invariant condition},
% $\enab:\locs\times\acts\rightarrow\clcons{\clocks}$ is an \emph{enabling condition},
% $\prob:\locs\times\acts\rightarrow\dist{2^{\clocks}\times\locs}$ is a \emph{probabilistic transition function},
% $\ap$ is a finite set of \emph{atomic propositions} and 
% $\lbfunc:\locs\rightarrow 2^{\ap}$ is a \emph{labelling function}.
\begin{compactitem}
\item $\locs$ is a finite set of \emph{locations};
\item $\loc^*\in\locs$ is the \emph{initial} location;
\item $\clocks$ is a finite set of \emph{clocks};
\item $\acts$ is a finite set of \emph{actions};
\item $\inv:\locs\rightarrow\clcons{\clocks}$ is
%a function which assigns to every location
an \emph{invariant condition};
\item $\enab:\locs\times\acts\rightarrow\clcons{\clocks}$ is an \emph{enabling condition};
\item $\prob:\locs\times\acts\rightarrow\dist{2^{\clocks}\times\locs}$ is a \emph{probabilistic transition function};
\item $\ap$ is a finite set of \emph{atomic propositions};
\item $\lbfunc:\locs\rightarrow 2^{\ap}$ is a \emph{labelling function}.
\end{compactitem}
\end{definition}
% \vspace{-0.8em}
%
W.l.o.g, we consider that both $\acts$ and $\ap$ is disjoint from $[0,\infty)$. Below we fix a PTA $\pta$.
% in the form (\ref{eq:pta}). 
The semantics of PTAs is as follows.

\smallskip \noindent{\em States and Transition Relation.}
A \emph{state} of $\pta$ is a pair $(\loc, \nu)$ in $\locs\times\val{\clocks}$ such that $\nu\models \inv(\loc)$.
The set of all states is denoted by $\states_\pta$.
The \emph{transition relation} $\trans$ consists of all triples $((\loc,\nu),a,(\loc',\nu'))$ satisfying
the following conditions:
\begin{compactitem}
\item $(\loc,\nu), (\loc',\nu')$ are states and $a\in\acts\cup [0,\infty)$;
\item if $a\in [0,\infty)$ then $\nu+\tau\models \inv(\loc)$ for all $\tau\in [0, a]$ and $(\loc',\nu')=(\loc,\nu+a)$;
\item if $a\in\acts$ then $\nu\models\enab(\loc,a)$ and there exists a pair $(X, \loc'')\in\supp{\prob(\loc,a)}$ such that $(\loc',\nu')=(\loc'',\reset{\nu}{X})$.
\end{compactitem}
By convention, we write $\tran{s}{a}{s'}$ instead of $(s,a,s')\in\trans$.
We omit `$\pta$' in `$\states_\pta$' if the underlying context is clear.

\smallskip \noindent{\em Probability Transition Kernel.}
The \emph{probability transition kernel} $\probk$ is the function $\probk:\states\times\acts\times\states\rightarrow[0,1]$ such that
\vspace{-0.3cm}
\begin{align*}
    & \probk((\loc,\nu),a,(\loc',\nu'))
        = 
        & \begin{cases}
            1 &
                \mbox{if }\tran{(\loc,\nu)}{a}{(\loc',\nu')}\mbox{ and } a\in [0,\infty)\\
            \sum_{Y\in B}\prob(\loc,a)(Y,\loc') &
                \mbox{if }\tran{(\loc,\nu)}{a}{(\loc',\nu')}\mbox{ and } a\in\acts \\
            0 &
                \mbox{otherwise}
        \end{cases}
\end{align*}
where $B:=\{X\subseteq\clocks\mid \nu'=\reset{\nu}{X}\}$.

\smallskip \noindent{\em Well-formedness.} We say that $\pta$ is \emph{well-formed} if for every state $(\loc,\nu)$ and action $a\in\acts$ such that $\nu\models\enab(\loc,a)$ and every $(X,\loc')\in \supp{\prob(\loc,a)}$, one has that $\reset{\nu}{X}\models\inv(\loc')$.
The well-formedness is to ensure that when an action is enabled, the next state after taking this action will always be legal. In the following, we always assume that the underlying PTA is well-formed. Non-well-formed PTAs can be repaired into well-formed PTAs~\cite{DBLP:journals/iandc/KwiatkowskaNSW07}.

\smallskip \noindent{\em Paths.}
A \emph{finite path} $\fnpath$ (under $\pta$) is a finite sequence
$
\left\langle s_0,a_0,s_1,\dots,a_{n-1},s_n\right\rangle~~(n\ge 0)
$
in
$\states\times{\left((\acts\cup[0,\infty))\times \states\right)}^*$
such that (i) $s_0=(\loc^*,\zero)$,
(ii) $a_{2k}\in [0,\infty)$ (resp. $a_{2k+1}\in \acts$) for all integers $0\le k\le \frac{n}{2}$ (resp. $0\le k\le \frac{n-1}{2}$) and
(iii) for all $0\le k\le n-1$, $\tran{s_k}{a_k}{s_{k+1}}$.
The length $\length{\fnpath}$ of $\fnpath$ is defined by $\length{\fnpath}:=n$.
An \emph{infinite path} (under $\pta$) is an infinite sequence
$
\left\langle s_0,a_0,s_1,a_1,\dots\right\rangle
$
in
${\left(\states\times(\acts\cup[0,\infty))\right)}^\omega$
such that for all $n\in\Nset_0$, the prefix $\left\langle s_0,a_0,\dots,a_{n-1},s_n\right\rangle$ is a finite path.
The set of finite (resp. infinite) paths  under $\pta$ is denoted by $\fnpaths{\pta}$ (resp. $\infpaths{\pta}$).

\smallskip \noindent{\em Schedulers.}
A \emph{(deteterministic) scheduler} is a function $\sigma$ from the set of finite paths into $\acts\cup [0,\infty)$ such that for all finite paths $\fnpath=s_0a_0\dots s_n$,
(i) $\sigma(\fnpath)\in\acts$ (resp. $\sigma(\fnpath)\in  [0,\infty)$) if $n$ is odd (resp. even) and (ii)
there exists a state $s'$ such that $\tran{s_n}{\sigma(\fnpath)}{s'}$.

\smallskip\noindent{\em Paths under Schedulers.}
A finite path $s_0a_0\dots s_n$ \emph{follows} a scheduler $\sigma$ if for all $0\le m< n$, $a_m=\sigma\left(s_0a_0\dots s_m\right)$.
An infinite path $s_0a_0s_1a_1\dots$ \emph{follows} $\sigma$ if for all $n\in\Nset_0$, $a_n=\sigma\left(s_0a_0\dots s_n\right)$.
The set of finite (resp. infinite) paths following a scheduler $\sigma$ is denoted by $\fnpaths{\pta,\sigma}$ (resp. $\infpaths{\pta,\sigma}$).
We note that the set $\fnpaths{\pta,\sigma}$ is countably infinite from definition.

\smallskip \noindent{\em Probability Spaces under Schedulers.}
Let $\sigma$ be any scheduler.
The probability space w.r.t $\sigma$ is defined as
$
(\Omega^{\pta,\sigma}, \mathcal{F}^{\pta,\sigma}, \probm^{\pta,\sigma})
$
where (i) $\Omega^{\pta,\sigma}:=\infpaths{\pta,\sigma}$, (ii) $\mathcal{F}^{\pta,\sigma}$ is the smallest sigma-algebra generated by all cylinder sets induced by finite paths for which
a finite path $\fnpath$ induces the cylinder set $\cyl(\fnpath)$ of all infinite paths in $\infpaths{\pta,\sigma}$ with $\fnpath$ being their (common) prefix,
and (iii) $\probm^{\pta,\sigma}$ is the unique probability measure such that for all finite paths $\fnpath=s_0a_0\dots a_{n-1}s_n$ in $\fnpaths{\pta,\sigma}$,
\vspace{-0.8em}
\[
\textstyle{\probm^{\pta,\sigma}(\cyl(\fnpath))=\prod_{k=0}^{n-1} \probk(s_k, \sigma(s_0a_0\dots a_{k-1}s_k), s_{k+1}).}
\]
\vspace{-0.8em}
For details see~\cite{DBLP:journals/tcs/KwiatkowskaNSS02}.
%Intuitively, the probability space under $\sigma$ is induced by a Markov chain where the state space is $\fnpaths{\pta,\sigma}$ and the one-step probability transition matrix is determined by $\probk$ and $\sigma$.

\smallskip \noindent{\em Zenoness and Time-Divergent Schedulers.}
An infinite path $\infpath=s_0a_0s_1a_1\dots$ is \emph{zeno} if $\sum_{n=0}^\infty d_n<\infty$, where $d_n:=a_n$ if $a_n\in [0,\infty)$ and $d_n:=0$ otherwise.
Then a scheduler $\sigma$ is \emph{time divergent} if $\probm^{\pta,\sigma}(\{\pi\mid\pi\mbox{ is zeno}\})=0$.
In the following, we only consider time-divergent schedulers.
The purpose is to eliminate non-realistic zeno behaviours (i.e., performing infinitely many actions within a finite amount of time).
\vspace{-3em}
%\smallskip \noindent{\color{red}\em Reachability.} An infinite path $\infpath=(\loc_0,\nu_0)a_0(\loc_1,\nu_1)a_1\dots$ is said to \emph{visit} a subset $U\subseteq\locs$ of locations \emph{eventually} if there exists $n\in\Nset_0$ such that $\loc_n\in U$. The set of infinite paths in $\infpaths{\pta,\sigma}$ that visit $U$ eventually is denoted by $\omgpaths{\pta,\sigma}{U}$.
%From the fact that the set $\fnpaths{\pta,\sigma}$ is countably-infinite, $\omgpaths{\pta,\sigma}{U}$ is measurable since it is a countable union of cylinder sets.
\begin{figure}[]
    \centering
    \begin{minipage}[t]{0.5\linewidth}  
        \centering  
        \resizebox{1\textwidth}{!}{
            \input{example_pta}
        }
        \caption{A Simple Task-Processing Example}
        \label{fig:pta}
    \end{minipage}
    \begin{minipage}[t]{0.45\linewidth}  
        \centering
        \resizebox{1\textwidth}{!}{
            \input{example_dta}
            }
        \caption{A DTRA Specification}
        \label{fig:dta}
    \end{minipage}
\end{figure}  

% \begin{figure}
%     \centering
%     \resizebox{.5\textwidth}{!}{
%         \input{example_pta}
%         }
%     \caption{A Simple Task-Processing Example}
%     \label{fig:pta}
% \end{figure}

In the following example, we illustrate a PTA which models a simple task-processing example.

\begin{example}\label{ex:pta}
Consider the PTA depicted in Figure~\ref{fig:pta}.
$\WORK{\alpha},\WORK{\beta}$ are locations
and $x$ is the only clock. Below each location first comes (vertically) its invariant condition and then the set of labels assigned to the location. For example, $\inv(\WORK{\alpha})=x \le 10$
and $\lbfunc(\WORK{\alpha})=\{ \alpha \}$.
The two dots together with their corresponding solid line and dashed arrows refer to two actions $\tau_\alpha,\tau_\beta$ with their enabling conditions and transition probabilities given by the probabilistic transition function.
For example, the upper dot at the right of $\WORK{\alpha}$ refers to the action $\tau_\alpha$ for which $\enab(\WORK{\alpha}, \tau_\alpha)=\true$, $\prob(\WORK{\alpha}, \tau_\alpha)(\{x\},\WORK{\alpha})=0.1$, and $\prob(\WORK{\alpha}, \tau_\alpha)(\{x\},\WORK{\beta})=0.9$.
% \begin{compactitem}
% \item $\enab(\WORK{\alpha}, \tau_\alpha)=\true$, and
% \item $\prob(\WORK{\alpha}, \tau_\alpha)(\{x\},\WORK{\alpha})=0.1$, and
% \item $\prob(\WORK{\alpha}, \tau_\alpha)(\{x\},\WORK{\beta})=0.9$.
% \end{compactitem}
The PTA models a faulty machine which processes two different kinds of jobs (i.e., $\alpha,\beta$) in an alternating fashion.
If the machine fails to complete the current job, then it will repeat processing the job until it completes the job.
For job $\alpha$, the machine always processes the job within $10$ time units (cf. the invariant condition $x\le 10$), but may fail to complete the job with probability $0.1$;
Analogously, the machine always processes the job $\beta$ within $15$ time units (cf. the invariant condition $x\le 15$), but may fail to complete the job with probability $0.2$.
Note that we omit the initial location in this example.
\end{example}
%
%In the following, we introduce the notion of \emph{rewards} (or \emph{costs}) over PTAs.
%
%\begin{definition}[Rewards for PTAs]
%A \emph{reward structure} for the PTA $\pta$ is a pair of functions $(\rcum,\rinst)$ such that $\rcum: \locs\rightarrow [0,\infty)$ is a function assigning to every location a rate at which rewards are accumulated as time elapses in that location, while $\rinst: \locs\times\acts\rightarrow [0,\infty)$ assigns to each location-action pair an instantaneous reward when the action is taken at that location).
%The one-step reward function $\ronestep:\locs\times\acts\rightarrow [0,\infty)$ is defined by:
%\[
%\ronestep(\loc, a)=
%\begin{cases}
%\rinst(\loc, a) & \mbox{if }a\in\acts \\
%a\cdot \rcum(\loc) & \mbox{ if }a\in [0,\infty)
%\end{cases}\enskip.
%\]
%\end{definition}

%In this paper, we focus on \emph{cumulative reward} over paths.

%\smallskip \noindent{\em Cumulative Reward.} Let $U\subseteq\locs$. We define the \emph{cumulative reward function} $\accum{U}$ (until $U$ is reached) on $\infpaths{\pta}$ such that for any infinite path $\infpath=(\loc_0,\nu_0)a_0(\loc_1,\nu_1)a_1\dots$,
%\[
%\accum{U}(\infpath)=
%\begin{cases}
%\sum_{k=0}^{n^*-1} \ronestep(\loc_k, a_k) & \mbox{if }\{n\mid \loc_n\in U\}\ne\emptyset\mbox{ and }n^*=\min\{n\mid \loc_n\in U\}\\
%\infty & \mbox{otherwise}
%\end{cases}\enskip.
%\]

%\smallskip \noindent{\em Repeated Reachability.} Let $\sigma$ be any scheduler for $\pta$.
%Consider a subset $U$ of $\locs$. An infinite path $(\loc_0,\nu_0)a_0(\loc_1,\nu_1)a_1\dots$ is said to \emph{visit} $U$ \emph{infinitely often} if the set $\{n\in\Nset_0\mid \loc_n\in U\}$ is infinite.
%The set of all infinite paths visiting $U$ infinitely often is denoted by $\omgpaths{\pta,\sigma}{U}$.
\vspace{-1.5em}
\subsection{Timed Automata}
\vspace{-0.6em}
\begin{definition}[Timed Automata ~\cite{DBLP:journals/tse/DonatelliHS09,DBLP:journals/corr/abs-1101-3694,DBLP:conf/hybrid/Fu13}]
A \emph{timed automaton} (TA)
%(NTA)
$\nta$ is a tuple
\begin{equation}\label{eq:nta}
\nta=(\cstates,\alphabet,\dtclocks,\rules)
\end{equation}
where
\begin{compactitem}
\item $\cstates$ is a finite set of \emph{modes}; %and $\dtloc^*$ is the \emph{initial} mode;
\item $\alphabet$ is a finite \emph{alphabet} of \emph{symbols} disjoint from $[0,\infty)$;
\item $\dtclocks$ is a finite set of \emph{clocks};
\item $\rules\subseteq \cstates\times\alphabet\times\clcons{\dtclocks}\times 2^{\dtclocks}\times \cstates$ is a finite set of \emph{rules}.
\end{compactitem}
% \end{definition}
% \begin{definition}[Deterministic Timed Automata (DTAs)~\cite{DBLP:journals/tse/DonatelliHS09,DBLP:journals/corr/abs-1101-3694,DBLP:conf/hybrid/Fu13}]
% A NTA $\dta=(\cstates,\alphabet,\clocks,\rules)$ is called \emph{deterministic} iff
$\dta$ is a \emph{deterministic} TA (DTA) if the following holds:
\begin{compactenum}
\item ({\em determinism}) for $(\dtloc_i,b_i,\phi_i,X_i,\dtloc'_i)\in\rules$ ($i\in\{1,2\}$), if $(\dtloc_1,b_1)=(\dtloc_2,b_2)$ and $\sat{\phi_1}\cap \sat{\phi_2}\ne\emptyset$ then $(\phi_1,X_1,\dtloc'_1)=(\phi_2,X_2,\dtloc'_2)$;
\item ({\em totality}) for all $(q,b)\in \cstates\times\Sigma$ and $\nu\in\val{\clocks}$, there exists $(q,b,\phi,X,q')\in\rules$ such that $\nu\models \phi$.
\end{compactenum}
\end{definition}
Informally, A TA is deterministic if there is always exactly one rule applicable for the timed transition. 
We do not incorporate invariants in TAs as we use TAs as language acceptors. 

Below we illustrate the semantics of TAs. We fix a TA $\dta$ in the form (\ref{eq:nta}).

%Below we fix a DTA $\dta$ in the form~(\ref{eq:dta}). Given $q\in\cstates$, $\nu\in\val{\clocks}$ and $b\in\Sigma$, the triple $(\dtphi{q}{b}{\nu},\dtx{q}{b}{\nu},\dtq{q}{b}{\nu})\in\clcons{\clocks}\times 2^{\clocks}\times\cstates$ are determined such that $\left(\dtloc,b,\dtphi{q}{b}{\nu},\dtx{q}{b}{\nu},\dtq{q}{b}{\nu}\right)\in\rules$ is the unique rule satisfying $\nu\models \dtphi{q}{b}{\nu}$.


\smallskip\noindent{\em Configurations and One-Step Transition Relation.}
A \emph{configuration} is a pair $(\dtloc,\nu)$, where $\dtloc\in \cstates$ and $\nu\in\val{\dtclocks}$.
The \emph{one-step transition relation}
\[
\Rightarrow~\subseteq~ (\cstates \times \val{\dtclocks}) \times (\alphabet\cup [0,\infty)) \times (\cstates \times \val{\dtclocks})
\]
%\[
%    \kappa
%        :
%        (\cstates \times \val{\clocks}) \times (\alphabet\cup [0,\infty))
%        \rightarrow
%        \cstates \times \val{\clocks}
%\]
is defined by: $((\dtloc,\nu),a,(\dtloc',\nu'))\in\Rightarrow$ iff
either (i) $a\in [0,\infty)$ and $(\dtloc',\nu')=(\dtloc,\nu+a)$
or (ii) $a\in\alphabet$ and there exists a rule $(q,a,\phi,X,q')\in\Delta$
such that $\nu\models\phi$ and $\nu'=\reset{\nu}{X}$.
%$
%    \trfunc((\dtloc,\nu),a)
%        := \left(
%            \dtq{q}{a}{\nu},\reset{\nu}{\dtx{q}{a}{\nu}}
%        \right)
%$
%for $a \in \alphabet$;
%$
%    \trfunc((\dtloc,\nu),a)
%        :=(
%            \dtloc,\nu+a
%        )
%$ for $a \in [0,\infty)$.
For the sake of convenience, we write $\dtatr{(\dtloc,\nu)}{a}{(\dtloc',\nu')}$
instead of $((\dtloc,\nu),a,(\dtloc',\nu'))\in\Rightarrow$.
Note that if $\dta$ is deterministic, then there is a unique $(\dtloc',\nu')$ such that
$\dtatr{(\dtloc,\nu)}{a}{(\dtloc',\nu')}$ given any $(\dtloc,\nu), a$.



\smallskip
\noindent{\em Infinite Timed Words and Runs.}
An \emph{infinite timed word} is an infinite sequence $w=\{a_n\}_{n\in\Nset_0}$ such that
$
    a_{2n}      \in [0,\infty)
    \mbox{ and }
    a_{2n+1}    \in \alphabet
$
for all $n$;
the infinite timed word $w$ is \emph{time-divergent} if $\sum_{n\in\Nset_0}a_{2n}=\infty$.
A \emph{run} of $\dta$ on an infinite timed word $w=\{a_n\}_{n\in\Nset_0}$
%over $\acts\cup [0,\infty)$ (i.e., $a_n\in \acts\cup [0,\infty)$ for all $n$)
with \emph{initial configuration} $(\dtloc,\nu)$,
%denoted by $\run{\dta}{\dtloc,\nu}{w}$,
is an infinite
sequence $\xi=\{\left(\dtloc_n,\nu_n,a_n\right)\}_{n\in\Nset_0}$
satisfying that $(\dtloc_0,\nu_0)=(\dtloc,\nu)$ and $\dtatr{(\dtloc_n,\nu_n)}{a_n}{(\dtloc_{n+1},\nu_{n+1})}$
for all $n\in\Nset_0$;
%%%%%
the \emph{trajectory}
%$\traj{ \run{\dta}{\dtloc,\nu}{w} }$
$\traj{ \xi }$
of the run
%$\run{\dta}{\dtloc,\nu}{w}$
$\xi$
is defined as an infinite word over $\cstates$ such that
%$\traj{ \run{\dta}{\dtloc,\nu}{w} } := q_0 q_1 \dots$~.
$\traj{ \xi } := q_0 q_1 \dots$~.
Note that if $\dta$ is deterministic, then there is a unique run on every infinite timed word.
%%%%%

Below we illustrate the acceptance condition for TAs.
We consider Rabin acceptance condition as the infinite acceptance condition.

%Now we illustrate the acceptance condition for DTAs. In this paper, we focus on infinite acceptance condition.
% Finite case is trivial and we also support it in our tool.
% \vspace{-0.8em}
% \begin{definition}[Finite Acceptance Criterion]
% Let $F\subseteq\cstates$ be a set of \emph{final} modes.
% An infinite word $w$ is \emph{(finitely) accepted} by $\dta$ w.r.t the \emph{initial configuration} $(\dtloc,\nu)$ and $F$ if $\run{\dta}{\dtloc,\nu}{w}=\{(\dtloc_n,\nu_n,a_n)\}_{n\in\Nset_0}$ satisfies that $\dtloc_n\in F$ for
% some $n\in\Nset_0$.
% \end{definition}

%%%%%
\vspace{-0.5em}
\begin{definition}[Rabin Acceptance Condition \cite{DBLP:books/daglib/0020348}]
A TA with \emph{Rabin acceptance condition} (TRA) is a tuple
\begin{equation}\label{eq:tra}
    \dta=(\cstates,\alphabet,\dtclocks,\rules,\rabin)
\end{equation}
where $(\cstates,\alphabet,\dtclocks,\rules)$ is a TA and $\rabin$ is a finite
set of pairs
$
    \rabin
        = \{
            (H_1,K_1 ),
            \dots,
            (H_n,K_n)
        \}
$ representing a Rabin condition for which
$H_i$ and $K_i$ are subsets of $\cstates$ for all $i\le n$.
$\dta$ is a \emph{deterministic} TRA (DTRA) if $(\cstates,\alphabet,\dtclocks,\rules)$ is a DTA.
A set $\cstates' \subseteq \cstates $ is \emph{Rabin-accepting} by $\rabin$,
written as the predicate $\accept{\cstates'}{\rabin}$,
if there is $ 1 \leq i \leq n$ such that $ \cstates' \cap H_i= \emptyset $
and $ \cstates' \cap K_i \neq \emptyset $. An infinite timed word $w$ is \emph{Rabin-accepted} by
$\dta$ with \emph{initial configuration} $(\dtloc,\nu)$ iff there exists a run $\xi$ of $(\cstates,\alphabet,\dtclocks,\rules)$ on $w$ with $(\dtloc,\nu)$ such that
$
%    \mbox{ }
    \infset{
%        \traj{
%            \run{\dta}{(\dtloc,\nu)}{w}
%        }
         \traj{\xi}
    }
$ is Rabin-accepting by $\rabin$.
\end{definition}

% \begin{figure}
%     \centering
%     \resizebox{.5\textwidth}{!}{
%         \input{example_dta}
%         }
%     \caption{A DTRA Specification}
%     \label{fig:dta}
% \end{figure}

\begin{example}\label{ex:dta}
Consider the DTRA depicted in Figure~\ref{fig:dta}.
%which works as a specification for the PTA in Example~\ref{ex:pta}.
The alphabet of this DTRA is the powerset of atomic propositions in Figure~\ref{fig:pta}.
 % (i.e.$2^{\{\alpha,\beta\}}$). 
In the figure, $\INIT,\q{\alpha},\q{\beta}$ and $\FAIL$ are modes with the Rabin condition
$
    \rabin
    =
    \{
        (\{ \FAIL \},
        \{
            \q{\alpha},
            \q{\beta}
        \})
    \}
$, $y$ is a clock and arrows between modes are rules.
$C_\gamma,W_\gamma$ ($\gamma\in\{\alpha,\beta\}$) are undetermined integer constants.
For example, there are four rules emitting from $\q{\alpha}$:
\begin{align*}
(\q{\alpha}, \{ \alpha \}, y \le C_\alpha,\emptyset, \q{\alpha}),& ~(\q{\alpha}, \{ \beta \}, y \le W_\beta, \{ y \}, \q{\beta}),\\
(\q{\alpha}, \{ \alpha \}, C_\alpha<y,\emptyset, \FAIL),& ~(\q{\alpha}, \{ \beta \}, W_\beta<y, \emptyset, \FAIL).
\end{align*}
$\INIT$ is the initial mode to read the first symbol upon which transiting to either $\q{\alpha}$ or $\q{\beta}$.
$\FAIL$ is a deadlock mode from which all rules go to itself.
Note that the rules of the DTRA does not satisfy the totality condition.
However, we assume that all missing rules lead to the mode $\FAIL$ and does not affect the Rabin acceptance condition.
The mode $\q{\alpha}$ does not reset the clock $y$ until it reads $\beta$.
Moreover, $\q{\alpha}$ does not transit to $\FAIL$ only if the time spent within a maximal consecutive segment of $\alpha$'s (in an infinite timed word) is no greater than $C_\alpha$ time units (cf. the rule $(\q{\alpha}, \{ \alpha \}, y \le C_\alpha,\emptyset, \q{\alpha})$) and the total time from the start of the segment until $\beta$ is read (the time within a maximal consecutive segment of $\alpha$'s plus the time spent on the last $\alpha$ in the segment) is no greater than $W_\beta$
(cf. the rule $(\q{\alpha}, \{ \beta \}, y \le W_\beta, \{ y \}, \q{\beta})$).
The behaviour of the mode $\q{\beta}$ can be argued similar to that of $\q{\alpha}$ 
where the only difference is to flip $\alpha$ and $\beta$.
From the Rabin acceptance condition, the DTRA specifies a property on infinite timed words that the time spent within a maximal consecutive segment of $\alpha$'s (resp. $\beta$'s) and the total time until $\beta$ (resp. $\alpha$) is read
always satisfy the conditions specified by $\q{\alpha}$ (resp. $\q{\beta}$).
\end{example}
%%%%%

%\begin{definition}[Finite Acceptance Condition]
%A TA with \emph{finite acceptance condition} (TFA) is a tuple
%\begin{equation}\label{eq:tfa}
%    \dta=(\cstates,\alphabet,\dtclocks,\rules,\fstates)
%\end{equation}
%where $(\cstates,\alphabet,\dtclocks,\rules)$ is a TA and $\fstates$ is a subset of $\cstates$
%representing the set of \emph{final} modes.
%$\dta$ is a deterministic TFA (DTFA) if $(\cstates,\alphabet,\dtclocks,\rules)$ is a DTA.
%An infinite timed word $w$ is \emph{finitely-accepted} by
%$\dta$ with \emph{initial configuration} $(\dtloc,\nu)$ if there exists a run $\xi$ of $(\cstates,\alphabet,\dtclocks,\rules)$ on $w$ with $(\dtloc,\nu)$ such that some final mode in $\fstates$ appear in the infinite word
%$
%%    \mbox{ }
%    \infset{
%%        \traj{
%%            \run{\dta}{(\dtloc,\nu)}{w}
%%        }
%         \xi
%    }
%$.
%\end{definition}

%\begin{remark}\label{rmk:facc}
%Finite acceptance condition is a special case of Rabin acceptance condition.
%Given a TFA in the form~(\ref{eq:tfa}), one can transform it into an equivalent TRA by first removing all rules emitting from final modes,
%then making all final modes ``absorbing'' through adding self-loop rules $(q,b,\true,\emptyset,q)$ for all final modes $q$ and symbols $b$, and finally setting the Rabin condition $\rabin$ to be the singleton set $\{(\emptyset, \fstates)\}$.
%\end{remark}

%Then we present Rabin acceptance condition which requires an infinite word to visit some modes only finitely often and some other modes infinitely often.

%\begin{definition}[Rabin Acceptance Condition]
%Let $\Gamma=\{(E_i,F_i)\}_{i\in I}$ be a finite collection of set pairs indexed by $I$ such that $E_i,F_i\subseteq\cstates$ for all $i\in I$.
%An infinite word $w$ is \emph{infinitely accepted} by $\dta$ w.r.t the \emph{initial configuration} $(\dtloc,\nu)$ and $\Gamma$ if $\run{\dta}{\dtloc,\nu}{w}=\{(\dtloc_n,\nu_n,a_n)\}_{n\in\Nset_0}$ satisfies that there exists $i\in I$ such that $\cstates'\cap E_i=\emptyset$ and $\cstates'\cap F_i\ne\emptyset$, where
%$\cstates':=\{\dtloc\in\cstates\mid \dtloc=\dtloc_n \mbox{ for infinitely many }n\mbox{'s}\}$.
%\end{definition}
