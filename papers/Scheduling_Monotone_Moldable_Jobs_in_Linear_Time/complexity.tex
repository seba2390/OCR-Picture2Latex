\section{\cclass{NP}-Completeness of Monotone Moldable Job Scheduling}
\label{sec:hardness}

In this section we discuss Theorem~\ref{thm:np-complete}.
To be precise, we consider the problem of deciding
whether a given instance of scheduling monotone moldable jobs can be scheduled with makespan at most~$d$,
where $d$ is also part of the input.

\begin{proof}[Proof of Theorem~\ref{thm:np-complete}]
We first argue that the problem is in \cclass{NP}
by giving a nondeterministic polynomial procedure for solving the problem:
first, guess the number of processors allotted to each job in an optimal schedule.
Since these numbers are at most~$m$, we can guess them one bit at a time in $n \log m$ steps.
Afterwards, we guess the order in which the jobs start.
This is a list of $n$ numbers in $\setrange{1}{n}$,
which can be encoded in $n \log n$ bits.
Again, we can guess this encoding in $n \log n$ steps.
We now use list scheduling to schedule the jobs in this order
while respecting the previously guessed processor counts.
This procedure is clearly possible in polynomial time and uses $n (\log m + \log n)$ (binary) guessing steps.

\begin{figure}[b]
  \centering
  \begin{tikzpicture}[x=0.75cm,y=0.4cm]
    \tikzset{container/.style={fill=gray!10}}

    \draw[|->,>=latex] (-1.5,0) -- (-1.5,6.5) node[midway,sloped,above] {\small Time};

	  \pnode[name=S,draw=none,fill=none]{width=8,height=6}{}
	  \drawschedule{S}
 	  \draw[|-|] (S.south west) -- (S.north west) node[pos=0,left] {\footnotesize $0$} node[pos=1,left] {\footnotesize $nB$};
    \draw[<->,>=latex] (0,-1) -- node[below] {$m$} (8,-1);
 	  
 	  \newcommand{\joblist}[5]{%
  	  \pnode[name=#11,container]{align left=#2,align bottom=(S.south),width=1,height=#3}{}
	    \pnode[name=#12,container]{above of=#11,height=#4}{}
  	  \pnode[name=#13,container]{above of=#12,height=#5}{}
  	  \pnode[name=#14,container]{above of=#13,align top=(S.north)}{}
  	}
  	
  	\joblist{A}{(S.west)}{2.0}{1.3}{1.7}
  	\joblist{B}{(A1.east)}{1.4}{1.5}{1.8}
  	\joblist{C}{(B1.east)}{1.7}{1.6}{1.2}
  	\coordinate (E1) at (5,0);
  	\node at (4,3) {$\cdots$};
  	\joblist{F}{(E1.east)}{1.3}{1.2}{1.7}
  	\joblist{G}{(F1.east)}{1.9}{1.5}{1.3}
  	\joblist{H}{(G1.east)}{1.6}{1.3}{1.6}
	\end{tikzpicture}
  \caption{Structure of a schedule with makespan~$nB$}
  \label{fig:optimal-schedule}
\end{figure}

We give a reduction from \pname{$4$-Partition} to prove that our scheduling problem is strongly \cclass{NP}-hard.
Recall that an instance of \pname{$4$-Partition} contains a set~$A = \setirange{a}{1}{4n}$ of natural numbers and a number~$B$,
and remains \cclass{NP}-hard even when all numbers are strictly between $\frac{B}{5}$ and~$\frac{B}{3}$~\cite{garey79}.
We construct an instance of the scheduling problem as follows.
First, we assume that $\sum_{i = 1}^{4n} a_i = nB$,
otherwise we output a trivial no-instance.
Next, we scale the numbers such that~$a_i \geq 2$ for each~$i \in \setrange{1}{4n}$.
The number of machines will be~$m = n$.
Now we create a job~$j_i$ for each number~$a_i$, which has processing time~$\ptm{j_i}{k} = m a_i - k + 1$.
Note that these functions are monotonically decreasing.
Also~$m a_i \geq 2m > 2k$ for each~$k < m$ and therefore the work satisfies
\begin{equation}
  \label{eq:reduction-monotone}
  \begin{aligned}
    \work{j_i}{k+1} &= (k+1) \times \ptm{j_i}{k+1} \\
    &= (k+1)(m a_i + 1) - (k+1)^2 \\
    &= k (m a_i + 1) - k^2 + (m a_i + 1) - 2k - 1 \\
    &= \work{j_i}{k} + m a_i - 2k
    > \work{j_i}{k} \dpunct{,}
  \end{aligned}
\end{equation}
i.e~the jobs are strictly monotone.
The target makespan is~$d = nB$.
It remains to show that this is indeed a reduction,
i.e.~that a schedule with makespan~$nB$ exists if and only if the instance of \pname{$4$-Partition} is a yes-instance.

First assume that there is a schedule with makespan~$d$.
The total work of all jobs is at least~$\sum_{i = 1}^{4n} \work{j_i}{1} = \sum_{i = 1}^{4n} m a_i = m d$.
Due to the strict monotony, our schedule must allot exactly one processor to each job,
and all machines have load~$d$,
see \cref{fig:optimal-schedule} for an example of such a schedule.
The numbers corresponding to the jobs on one machine sum up to~$B$,
and because they are strictly between $\frac{B}{5}$ and~$\frac{B}{3}$,
there are exactly four such numbers.
Therefore, there is a solution to the instance of \pname{$4$-Partition}.

On the other hand, if the instance of \pname{$4$-Partition} is a yes-instance,
a schedule as depicted in \cref{fig:optimal-schedule} is easily constructed from a solution.
\end{proof}

This shows that scheduling monotone jobs is \cclass{NP}-hard in the strong sense.
Furthermore, using a complexity result for \pname{$4$-Partition}~\cite{jansen13b},
there is no algorithm that solves this problem exactly in time~$2^{\Landau{<}{n}} \times \clen{I}^{\Landau{<=}{1}}$,
unless the Exponential Time Hypothesis fails.
