\documentclass[12pt,a4paper]{article}

%%% Grundlegendes
\usepackage{etex}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[american]{babel}

%%% Anderer Kram
\usepackage{tikz}
\usetikzlibrary{boxes}
\usetikzlibrary{calc,arrows.meta}

%%% Layout
\usepackage[hmargin=3.25cm,vmargin=2.5cm]{geometry}
\usepackage{setspace}
\spacing{1.15}
\usepackage{enumitem}
\setlist[enumerate,1]{leftmargin=*,label={\textnormal{(\roman*)}},topsep=0.5ex}
\usepackage{booktabs}


%%% Mathe
\usepackage{amssymb,amsmath}
\usepackage[swapvars]{moremath}
\newcommand{\dpunct}[1]{\text{#1}}
\newdelimcommand{clen}{\lVert}{\rVert}
\usepackage{mathtools}
\mathtoolsset{
  mathic=true,% Italics correction im Mathemodus
}
\usepackage{complex}
\renewrobustcmd{\pname}[1]{{\normalfont\scshape #1}}
\newcommand{\dif}{\mathop{\mathrm{d}}\!}
\newcommand{\od}[2]{\frac{\dif #1}{\dif #2}}

%%% Theoremumgebungen
\usepackage{amsthm}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}

% Scheduling notation
% Variables
\newcommand{\size}[2][a]{\fcall[#1]{\operatorname{size}}{#2}} % Number of required machines for job #2 (parallel tasks)
\newcommand{\ptm}[3][a]{\fcall[#1]{\operatorname{t}_{#2}}{#3}} % Processing time of job #2 with #3 machines (malleable tasks)
\newcommand{\work}[3][a]{\fcall[#1]{\operatorname{w}_{#2}}{#3}} % Work of job #2 with #3 machines (malleable tasks)
\newcommand{\procnum}[3][a]{\fcall[#1]{\gamma_{#2}}{#3}} % Least number of machines for job #2 to finish in less than #3
% Three field notation
% #1 (opt.) Machine count, #2 Machine environment, #3 job characteristics, #4 objective function
\newcommand{\schedprob}[4][]{\ensuremath{\langle\mathrm{#2}#1\,|\,#3\,|\,#4\rangle}}
% Flags for job characteristics
\newcommand{\para}{\mathrm{size}}
\newcommand{\mall}{\mathrm{any}}
\newcommand{\monotone}{\mathrm{monotone}}
\newcommand{\pmtn}{\mathrm{pmtn}}
\newcommand{\migr}{\mathrm{migr}}
\newcommand{\precc}{\mathrm{prec}}

% Knapsack problems
\newcommand{\KP}[3][]{\fcall{\operatorname{KP}\ifstrequal{#1}{1}{^{(1)}}{}\ifstrequal{#1}{2}{^{(2)}}{}}{#2, #3}}
\newcommand{\KPOPT}[3][a]{\fcall[#1]{\operatorname{OPT_{KP}}}{#2, #3}}
\newcommand{\KPCOPT}[2][a]{\fcall[#1]{\operatorname{OPT}}{#2}}
\newcommand{\s}[2][1]{\fcall[#1]{\operatorname{s}}{#2}}  % Size of item
\newcommand{\pr}[2][1]{\fcall[#1]{\operatorname{p}}{#2}} % Profit of item


%%% Referenzen
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage[capitalize]{cleveref}


%%% Algorithmen
\let\chapter\section
\usepackage[ruled,vlined,linesnumbered]{algorithm2e}
\crefname{algocf}{Algorithm}{Algorithms}
\crefname{algocfline}{line}{lines}
\DontPrintSemicolon
\SetKwSty{textbf}
\SetFuncSty{texttt}
\SetArgSty{}
\SetDataSty{textsf}
\newcommand{\FnCall}[2]{\FuncSty{#1(}#2\FuncSty{)}}
\SetCommentSty{textit}
\SetKwComment{tpy}{\# }{}
\newcommand{\Comment}[1]{\tpy*[h]{#1}}
\SetKw{KwBreak}{break}
\SetKwInOut{Input}{Input}


\title{Scheduling Monotone Moldable Jobs in Linear Time\footnote{%
  Research was in part supported by German Research Foundation (DFG) project JA 612/16-1.
}}
\author{Klaus Jansen \and Felix Land}


\begin{document}
\maketitle


\begin{abstract}
  A moldable job is a job that can be executed on an arbitrary number of processors,
  and whose processing time depends on the number of processors allotted to it.
  A moldable job is monotone if its work doesn't decrease
  for an increasing number of allotted processors.
  We consider the problem of scheduling monotone moldable jobs to minimize the makespan.
  
  We argue that for certain compact input encodings
  a polynomial algorithm has a running time polynomial in $n$ and $\log m$,
  where n is the number of jobs and m is the number of machines.
  We describe how monotony of jobs can be used to counteract the
  increased problem complexity that arises from compact encodings,
  and give tight bounds on the approximability of the problem with compact encoding:
  it is \cclass{NP}-hard to solve optimally, but admits a PTAS.
  
  The main focus of this work are efficient approximation algorithms.
  We describe different techniques to exploit the monotony of the jobs for better running times,
  and present a $(\frac{3}{2}+\epsilon)$-approximate algorithm
  whose running time is polynomial in $\log m$ and $\frac{1}{\epsilon}$,
  and only linear in the number~$n$ of jobs.
\end{abstract}

\input{introduction}
\input{complexity}
\input{fptas}
\input{approximation}
\input{conclusion}

\bibliographystyle{plain}
\bibliography{bibliography}

\end{document}
