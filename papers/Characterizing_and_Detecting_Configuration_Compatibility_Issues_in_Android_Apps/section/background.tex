\section{Background \& Motivation}
\label{sec:2}
\sethlcolor{yellow}
\begin{figure}[t]
	\centering
	\includegraphics[width=0.5\textwidth]{./img/frameworkprocess.pdf}
	\caption{
		{Code snippets adapted from \texttt{ColorStateList} in the Android framework to process the attribute \texttt{android:color} among API level 21, 22 and 23.}}
	\label{fig:frameworkprocess}
	
\end{figure}


\subsection{Processing XML Configuration Files in Android}

XML configuration files are an indispensable part of Android projects.
In general, there are two types of XML configuration files: (1) manifest files (\texttt{AndroidManifest.xml}) that provide the essential runtime information for Android apps, (2) resource XML files (located in the \texttt{/res/} folder) that are commonly used to define an app's user interfaces~\cite{xu2018deeprefiner}.
The Android framework provides a flexible configuration environment that can accept substantially different attributes (e.g., 1,435 different attributes at API level 30).
As the Android framework evolves, compatibility issues arise from inconsistent handling of these attributes and their values among different API levels. 

A popular Android app typically consists of a few hundred XML configuration files. Each is processed as the following steps by the Android framework.

\textbf{Parsing.}
The Android framework uses \texttt{XmlPullParser} to parse all the XML tags in configuration files and return an \texttt{AttributeSet} or \texttt{TypedArray} object for each XML tag.
In particular, \texttt{AttributeSet} and \texttt{TypedArray} are two classes defined in the Android framework to store each XML attribute value as a key-value pair.
The framework provides APIs to trigger the parsing process and returns a newly created \texttt{AttributeSet} or \texttt{TypedArray} object, such as \hytt{getXml()} in Line 1 of Figure~\ref{fig:frameworkprocess}.

\textbf{Loading.}
\texttt{AttributeSet} and \texttt{TypedArray} define APIs (e.g., \texttt{AttributeSet\#getAttributeIntValue()} and \texttt{TypedArray\#getBoolean()}) that take configuration attributes as parameters and return the corresponding attribute values in predefined formats. We refer to these APIs as \textbf{configuration APIs}. In the loading step, the attribute values in the \texttt{AttributeSet} and \texttt{TypedArray} objects are loaded to some program variables using the configuration APIs. 

\textbf{Usage.} The variables are processed by the Android framework to represent the app's runtime behavior.

Configuration compatibility issues can occur when there are inconsistent implementations in the above steps
 among the different Android API levels.

\subsection{Motivating Example}
\label{sec:motivating_example}
\sethlcolor{yellow}
\begin{figure}[t]
	\centering
	\includegraphics[width=0.5\textwidth]{./img/reproduce.pdf}
	\caption{{Reproduction steps for the issue as shown in Figure~\ref{fig:configurationfile}.}}
	\label{fig:reproduce}
\end{figure}
It is generally difficult for developers to identify compatibility issues from many XML configuration files in their apps, especially for those issues that can only be triggered under specific conditions.
Figure~\ref{fig:reproduce} shows a test case that can manifest the issue illustrated in Figure~\ref{fig:configurationfile}.
To this end, developers should first let the app load a website containing a time picker as Figure~\ref{fig:reproduce}(a) shows, and then choose the corresponding input field to open the problematic time picker as listed in Figure~\ref{fig:configurationfile}.
It took the developers one month to detect and fix the above issue.
The issue was caused by the inconsistent processing of \texttt{android:color} in the Android framework among API levels 21, 22, and 23.
The different implementations of these API levels are shown in Figure~\ref{fig:frameworkprocess}. First, at API levels 21 and 22, the configuration API \texttt{AttributeSet\#getAttributeIntValue()} in Line 7 is invoked to load \texttt{android:color}, whose value affects the array \texttt{mSpec} in Line 8. However, there is a defect in the Android framework at API level 21. It accesses an illegal index of the array \texttt{mSpec} in Line 12, causing the app to crash. At API level 22, we did not witness the crash as the Android framework has fixed the processing of \texttt{android:color}, as shown in Line 13. 
Second, %the configuration API that loads \texttt{android:color} has been changed to \texttt{TypedArray\#getColor()} (in Line 19) at API level 23. 
the configuration API \texttt{AttributeSet\#getAttributeIntValue()} fails to load the attribute values in the style format (i.e., Line 7 of Figure~\ref{fig:frameworkprocess}). 
As a result, the style format attribute value \texttt{?android:attr/textColorSecondary} defined in \texttt{android:color} (Line 6 of Figure~\ref{fig:configurationfile}) is ignored, causing the inconsistent look-and-feel as Figures~\ref{fig:reproduce}(b) and (c) show.

The above example shows how the code changes in the Android framework induce configuration compatibility issues.
However, it is non-trivial to automatically identify such code changes.
For example, at API level 22, the statement of loading the \texttt{android:color} attribute value (Line 7 of Figure~\ref{fig:frameworkprocess}) is guarded by a condition in Line 4 as shown in Figure~\ref {fig:frameworkprocess}. An accurate analysis of the loading behavior therefore requires path-sensitivity.
However, since path-sensitive analysis is expensive, it cannot be scaled to the whole Android framework that contains a large amount of code (i.e., 4M+ LOC of API level 30) with long-term update history (i.e., 566K+ commit changes until April 2021). 
To provide insights for automatically identifying such code changes and facilitating issue detection, we conducted an empirical study (Section~\ref{sec:3}) on real-world issues to understand the common patterns of code changes that can induce configuration compatibility issues.

