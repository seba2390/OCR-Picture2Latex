\section{Threats to Validity}

{\textbf{Keywords for dataset collection.} When collecting configuration compatibility issues, we used two sets of keywords related to API levels and XML files. Although different apps may use different app-specific terms to refer to the same concepts,   such app-specific terms are hard to collect. Besides, using app-specific terms as keywords can return many irrelevant results. Therefore, our dataset was collected primarily using the above two groups of general keywords, which retrieves 196 configuration compatibility issues.
}

\textbf{Generality of our empirical findings.}
In this paper, we studied the configuration compatibility issues in the Android apps and further proposed \textsc{ConfDroid} to facilitate automatic issue detection.
Our empirical findings may not be generalized to other types of software systems.
We chose Android as our study platform because it is representative of a popular system supporting a high degree of configurability in thousands of attributes.
The open-source Android framework code provides a nice foundation for us to
study the root causes of configuration compatibility issues.

\textbf{Empirical subject selection.}
%We selected  as our empirical dataset to study
%configuration compatibility issues.
The findings from the issues in the open-source Android app can be biased to the subjects selected in our empirical study.
We mitigated the threat by selecting a significant number of issues and apps.
As a result, the study was based on 196 issues from 43 open source apps that are popular and well-maintained.

\textbf{Evolving Android framework versions.} The Android API
levels that we studied may become obsolete over time. It is a threat
common to most studies based on Android. To mitigate the
threat, we base our study on the latest API levels.

{\textbf{Manual inspections and developers' feedbacks.} We manually inspected our evaluation to validate issues detected by \textsc{ConfDroid}. The manual process can be subject to errors. We also submitted the validated ones to the original app developers for their feedback. 
However, several issue reports are still pending. This is most likely because some developers tend to be less responsive to the issue reports in the issue tracker. To address the threat that our reported issues may not be real ones, our manual process involves validating detection rules and issuing warnings through actual executions. We also make our validation steps and artifacts publicly available~\cite{confdroid}.}

\section{Related Work}

\subsection{Software Misconfigurations}
There are plenty of works~\cite{rabkin2011static, xu2013not
,behrang2015users,xu2016early, dong2016orplocator, chen2020understanding,
toman2016staccato} on detecting software misconfigurations.
For example,
Behrang et al.~\cite{behrang2015users} proposed  \textsc{SCIC} to study the attributes that cannot take effects because of software evolution.
%Xu et al.\cite{xu2016early} proposed \textsc{PCheck} that analyzes source code for early detection of latent configuration errors.
Dong et al.~\cite{dong2016orplocator} proposed \textsc{ORPLocator} to detect
inconsistencies between documentations and configuration attributes in system
code.
Recently, Chen et al.~\cite{chen2020understanding} proposed
\textsc{cDep} to extract attribute dependencies from source code.
Although these approaches can be adapted to detect compatibility issues
across multiple system versions, the proposed path-insensitive analyses are ineffective for the Android framework. It is because the loading of configuration attributes in the Android framework is commonly guarded
by variables defined in the same configuration class. In contrast,
\textsc{ConfDroid} conducts intra-class level path-sensitive analysis for
more precise detection of compatibility issues.

There are works studying misconfigurations caused by system evolution~\cite{zhang2014configuration, zhang2021evolutionary}.
For example, Zhang et al.~\cite{zhang2014configuration} proposed a technique for debugging software misconfigurations induced by software evolution.
However, the technique requires developers to provide test cases to manifest
such issues, limiting its applicability.
Recently, Zhang et al.~\cite{zhang2021evolutionary} conducted an empirical study to understand how the configuration design and implementation evolve in cloud systems.
The study does not provide a technique for issue detection.
\textsc{ConfDroid} fills the gap by incorporating automated techniques to
extract issue-detection rules, which can be readily deployed at \textsc{Lint}
for issue detection.

There are also a few related works~\cite{attariyan2012x,
rabkin2011precomputing, zhang2013automated, zhang2015proactive } on automated
software misconfiguration diagnosis.
However, their research goal is to help understand the root causes of known
software misconfigurations. Their application scenario differs from
that of \textsc{ConfDroid} where the misconfigurations are unknown.

\subsection{Android Compatibility Issues}
A few studies have been conducted on Android compatibility issues.
For example, Wei et al.~\cite{wei2016taming,wei2018understanding} studied the root causes, symptoms, and fixing
practices of Android compatibility issues.
Huang et al.~\cite{huang2018understanding} studied compatibility issues in Android callback APIs.
Hu et al.~\cite{hu2018tale} found Android compatibility issues in the WebView component.
Cai et al.~\cite{cai2019large} studied the compatibility issues occurring at
installation time and runtime.
Xia et al.~\cite{xiaandroid} studied the practice of app developers to
handle Android compatibility issues.
These studies do not cover the common root causes and patterns of Android
configuration compatibility issues, which are prevalent and can cause severe
consequences in Android apps.

Researchers have proposed a set of tools to detect Android compatibility issues.
First, dynamic-based approaches~\cite{fazzini2017automated,ki2019mimic} can
generate tests to identify app GUI inconsistencies across Android devices.
These approaches adopt a random test generation strategy, which is ineffective in triggering the inconsistencies within the huge search space of an
app's configuration attributes.
Second, existing static-based approaches~\cite{wei2016taming,wei2019pivot,huang2018understanding,li2018cid,li2018elegant,he2018understanding,wei2018understanding} take a set of predefined patterns to facilitate compatibility issue detection in Android apps.
However, their approaches can only be leveraged to detect issues caused by
problematic API invocations. These approaches are inapplicable for the detection
of configuration compatibility issues in Android apps.
Besides, \textsc{Lint}~\cite{lint}, a popuplar static-based bug detection tool
in the industry~\cite{wei2017oasis}, can only detect configuration compatibility
issues due to the introduction of new attributes.
In comparison, \textsc{ConfDroid} encodes common issue patterns to extract detection rules from the Android framework.
The evaluation results show that such rules can detect issues that were
previously unknown to app developers.

\section{Conclusion \& Future Work}
%Configuration compatibility issues in Android apps are prevalent and can cause severe consequences.
To help app developers tackle configuration compatibility issues, in this study, we first collected 196 configuration compatibility issues to empirically understand the common root causes and patterns of such issues.
Based on the findings, we further proposed \textsc{ConfDroid}, which encodes common issue patterns to automatically extract detection rules for configuration compatibility issues.
The results show that the rules extracted by \textsc{ConfDroid} can facilitate detecting issues that were previously unknown to app developers.
In the future, we plan to investigate automated repair techniques for configuration compatibility issues in Android apps.
We also plan to design a technique that can facilitate automated validation of configuration compatibility issue to minimise manual efforts.

\section*{Acknowledgment}
We sincerely thank anonymous reviewers for their valuable comments.
This work was supported by the National Natural Science Foundation of China (Grant No. 61932021, No. 61802164 and No. 62002125), Hong Kong RGC/GRF (Grant No. 16211919), Hong Kong RGC/RIF (Grant No. R5034-18), and Guangdong Basic and Applied Basic Research Foundation (Grant No. 2021A1515011562). Huaxun Huang was supported by the Hong Kong PhD Fellowship Scheme. Lili Wei was supported by the Hong Kong RGC Postdoctoral Fellowship Scheme.
