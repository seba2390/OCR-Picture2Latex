\section{ConfDroid Approach}
\label{sec:4}
In this section, we illustrate \textsc{ConfDroid}, which extracts detection rules for configuration compatibility issues. 
\textsc{ConfDroid} is built based on a novel configuration constraint that models how the attribute values specified in the XML configuration files can be processed by configuration APIs in the Android framework.
To overcome the limitations of existing static-based approaches (see Section~\ref{sec:motivating_example}), \textsc{ConfDroid} performs symbolic execution, which follows the control flows that can affect the invocations of configuration APIs, to extract configuration constraints more precisely.
Detection rules can be subsequently derived by comparing the differences of extracted configuration constraints among API levels.

\subsection{Android Configuration Constraint Model}
\label{sec:4.1}
Our empirical study found that the majority (158/196) of issues were induced by the inconsistent handling
of configuration APIs (Type 1 and Type 2) for a single attribute among API levels. The inconsistencies
can lead to \textit{failures in loading
attributes with specific data format under certain
XML tags at some API levels}.
Motivated by these findings, we formulate constraints that govern configuration
APIs, called \textbf{Android configuration constraints}.
Formally, an Android configuration constraint is defined as a tuple
$\{\mathcal{A},\mathcal{X}, \mathcal{F}\}$.
Specifically, $\mathcal{A}$ stands for the attribute to be loaded by the configuration API,
$\mathcal{X}$ is the XML tag where the attribute $\mathcal{A}$ is located; and
$\mathcal{F}$ stands for the data format that can be assigned to $\mathcal{A}$.
An Android configuration constraint is extracted when
\textsc{ConfDroid} finds a
program path in the Android framework that can invoke the configuration API to
load the attribute $\mathcal{A}$ with data format $\mathcal{F}$ under the
XML tag $\mathcal{X}$.
Rules for issue detection can then be identified by comparing the
differences in Android configuration constraints among API levels.

A constraint $\{\mathcal{A}, \mathcal{X}, \mathcal{F}\}$ for a configuration
API is extracted as follows.  $\mathcal{A}$ can be inferred from the
parameter identifying the attribute to be loaded in the configuration API call;
$\mathcal{X}$ can be inferred from the return values of the configuration API
call, such as \texttt{XmlPullParser\#getName()} in the program path (e.g., Line 4 of Figure~\ref{fig:frameworkprocess}).
$\mathcal{F}$ can be inferred from
the configuration API used to load $\mathcal{A}$ since each configuration API can only load attribute values in a specific group of data formats.
Note that one configuration API can generate multiple constraints if it can support loading attribute values in different data formats.
For example, as the code snippets in Figure~\ref{fig:frameworkprocess} show, by
analyzing the program paths to the configuration APIs
\texttt{getAttributeIntValue()} and
\texttt{getColor()}, we can obtain the following constraints
between API levels 22 and 23.
\\
\textbf{API level 22:}\\
$\{\texttt{android:color}, \texttt{item}, \texttt{int}\}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,                  (1)$\\
\textbf{API level 23:} \\
$\{\texttt{android:color}, \texttt{item}, \texttt{int}\} \,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,(2)$\\
$\{\texttt{android:color}, \texttt{item}, \texttt{styled\_int}\}\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,(3)$\\

As the API descriptions in Android Developers~\cite{androiddevelopers} shows, comparing to \texttt{getAttributeIntValue()}, the configuration API \texttt{getColor()} can load integer attribute values in the style format, an additional Android configuration constraint for \texttt{android:color} (Equation 3) is extracted at API level 23.

\subsection{\textsc{ConfDroid} Overview}
We propose \textsc{ConfDroid} to identify Android configuration constraints, which can be inferred from configuration API invocations in the Android framework to model the common issue patterns (Type 1 and Type 2). 
The identified constraints can be further refined into a set of compatibility detection rules based on the differences among the identified constraints across different API levels.

To identify Android configuration constraints, we prefer using static analysis to dynamic analysis. Using dynamic analysis for the purpose is expensive due to the large search space of possible test inputs. For example, a dynamic approach needs to generate an XML file as given in Figure~\ref{fig:configurationfile} to reach the configuration API in Line 7 of Figure~\ref{fig:frameworkprocess}. The file generation involves searching for (1) the tree hierarchies of XML configuration elements (e.g., \texttt{<item>} is set as a child of \texttt{<selector>}), (2) the XML elements embedding the concerned attributes (e.g., \texttt{android:color} should only be set in \texttt{<item>}), and (3) other necessary configuration settings to avoid crash when parsing XML files (e.g., \texttt{android:state\_activated} in Line 5). In contrast, static analysis enables us to compare the approximated behaviors of these APIs without actually generating valid test inputs.
	
However, the existing techniques~\cite{rabkin2011static,behrang2015users,dong2016orplocator,chen2020understanding} analyze configuration APIs by conducting path-insensitive analysis, which can be somewhat inaccurate and miss incompatible configuration APIs without considering the if-conditions (e.g., Line 6 in Figure~\ref{fig:frameworkprocess}). Therefore, a path-sensitive analysis is necessary to obtain $\{\mathcal{A},\mathcal{X},\mathcal{F}\}$ by solving path constraints triggering configuration APIs with the constraint solver. Symbolic execution is a powerful path-sensitive analysis technique. Yet, an exhaustive symbolic execution is expensive and cannot scale to the size of the Android framework. In addition, the path constraints triggering the configuration APIs can be complex as the Android framework codebase is mixed with components compiled to native code. To tackle the above challenges, \textsc{ConfDroid} performs backward symbolic execution from the call site of configuration APIs. This is based on a trimmed version of an inter-procedural control flow graph, which is built by pruning the statements that are not needed to infer the Android configuration constraints (Section~\ref{sec:building-ICFG}). The trimmed-ICFGs are designed to not only address the scalability by reducing the number of program paths and complex conditions to be analyzed, but also preserve reasonable accuracy while conducting path-sensitive analysis. We illustrate the details of backward symbolic execution and trimmed-ICFGs in the following parts.

To summarize, \textsc{ConfDroid} works as follows.
\begin{itemize}
	\item \textsc{ConfDroid} builds \textbf{a trimmed version of interprocedural control flow graphs (trimmed-ICFGs)} for the Android framework code. We choose to build the trimmed-ICFGs for scalability (Section~\ref{sec:building-ICFG}).
	\item \textsc{ConfDroid} performs \textbf{backward symbolic execution} on the trimmed-ICFGs to extract Android configuration constraints (Section~\ref{sec:extract-configuration-constraint}).
	\item \textsc{ConfDroid} \textbf{generates detection rules} by comparing the differences of Android configuration constraints among different API levels (Section~\ref{sec:generate-rule}).
\end{itemize}

\subsection{Building Trimmed ICFG}
\label{sec:building-ICFG}
\textsc{ConfDroid} performs analysis over a trimmed version of an
inter-procedural control flow graph, which is denoted as $ICFG^T$, to ensure
the scalability.
Our idea to build such an $ICFG^T$ is inspired by the observation that the code
changes triggering compatibility issues in \textit{unavailable configuration
APIs} and \textit{inconsistent configuration APIs} primarily reside in the class that invokes the configuration APIs to load the incompatibility-inducing
attributes.
Therefore, \textsc{ConfDroid} builds an $ICFG^T$ for each class that invokes configuration APIs by combining the call graph and each method's control flow graph within the class.
The strategy limits the extraction of Android configuration constraints to
intra-class analysis. 
However, such a strategy does not pose a significant impact on the process of configuration constraint extraction and detection rule generation (Section~\ref{sec:discussion}).
%We will discuss the impact of this limitation in Section~\ref{sec:discussion}.

\subsection{Extracting Android Configuration Constraints}
\label{sec:extract-configuration-constraint}
\begin{algorithm}[t]
	\caption{Extracting Android Configuration Constraints}
	\DontPrintSemicolon
	\label{alg:1}

	\KwInput{$ICFG^T$: The trimmed-ICFG for the Android framework}
	\KwOutput{$ACC$: Android configuration constraints}
	$ACC \leftarrow []$\;
	\ForEach{$tgtStmt \in ICFG^T$ }{
		%$worklist \leftarrow \{(tgtStmt, \textsc{True})\}$\;
		add $(tgtStmt, \textsc{True})$ to $worklist$\;
		\While{\rm $worklist$ is not empty}{
			remove $(s',\phi_{post})$ from $worklist$\;
			\ForEach{\rm $s$ with an edge $(s,s')$ in $ICFG^T$}{
					$\phi_{pre} \leftarrow \phi_{pre} \vee trans(s, \phi_{post})$ \;
					\If{\rm $\phi_{pre} \neq \textsc{False}$}{
					add $(s, \phi_{pre})$ into $worklist$\;
				}
			}

	    }
		\ForEach{\rm $\pi$ of $tgtStmt$}{
			$acc \leftarrow refineACC(\pi)$\;
			add $acc$ to $ACC$\;
		}
	}
	\Return{ACC}\;
\end{algorithm}

Taking the generated trimmed-ICFGs~$ICFG^T$ as inputs,
\textsc{ConfDroid} extracts Android configuration constraints by analyzing
program paths to the target statements that contain the invocation of
configuration APIs (Algorithm~\ref{alg:1}).
Specifically, it takes the following two steps to extract Android
configuration constraints.
First, starting from each target statement $tgtStmt$, \textsc{ConfDroid} performs backward symbolic execution from the trimmed-ICFG $ICFG^T$ generated in Section~\ref{sec:building-ICFG} to extract the path constraint $\pi$ (Line 3-9).
Such a path constraint $\pi$ is a first-order logic formula that records (1) the conditions that should be satisfied to invoke the target statement, and (2) the configuration API invocation in the target statement (Line 3-9).
Unlike forward symbolic execution, backward symbolic execution saves on testing efforts by only exploring relevant program statements to reach the target statements.
Then, the path constraints will be further refined as a set of Android configuration constraints with the help of SMT solver Z3~\cite{z3} (Line 10-12).

\textbf{Extracting path constraints.}
\label{sec:extract-conf-constraint}
For each target statement $tgtStmt$ with configuration API invocations, \textsc{ConfDroid} computes the path constraints $\pi$ by performing backward symbolic execution along $ICFG^T$.
Specifically, the analysis will maintain the symbolic states $\phi_{pre}(s)$ and $\phi_{post}(s)$ representing the precondition and postcondition of $s$ in $ICFG^T$.
The symbolic states are computed iteratively along $ICFG^T$ with the symbolic state transformer $trans$, as defined in Table~\ref{tab:wp}, from $\phi_{post}(s)$~to~$\phi_{pre}(s)$.
After computing $trans(s, \phi_{post})$ for a statement $s$ and $\phi_{post}$, the algorithm merges the result with $\phi_{pre}$ that is already presented before the statement $s$ (Line 7).
In the presence of loops, we analyze them twice to ensure that the algorithm terminates and traverses the back edge of the loop at least once.
The path constraint $\pi$ is obtained from $\phi_{pre}$ of the statements $s$ that are the entry points of $ICFG^T$.

Taking the first code snippet in Figure~\ref{fig:frameworkprocess} as an
example,
\textsc{ConfDroid} will analyze the target statement in Line 7, and compute its path constraint $\pi$ along the path (7,6,5,4,3) as follows:

\begin{itemize}
	\item $\phi_{pre}$ in Line 7, $tgtStmt=attrs.getAttributeIntValue\\(i,color)$;
	\item $\phi_{pre}$ in Line 6, $tgtStmt = attrs.getAttributeIntValue\\(i,\,color) \wedge i = R.attr.color$;
	\item $\pi = \phi_{pre}$ in Line 3 (entry point), $tgtStmt = getXml().getAttributeIntValue(i,\,color) \wedge  i = R.attr.color \wedge getXml().getName().equals(``item")$;
\end{itemize}

\begin{table}[t]
	  \begin{threeparttable}[b]
		\caption{Specification of symbolic state transformer $trans$ for Java statements.}
	\label{tab:wp}
	\begin{tabular}{p{3.5cm}|p{4.5cm}}
		\toprule
		$statement$ & $trans(statement, \phi)$ \\ \midrule
		$tgtStmt$  & $\phi \wedge tgtStmt$ \\
		$x = op\, y$& $\phi[y/x]$     \\
		$x = y\, op \, z$ & $\phi[(y \, op \, z)/ x]$      \\
		$x = api(y_1, ..., y_n)$&  $\phi[api(y_1, ..., y_n)/ x]$    \\
		$x.y = z$&   $\phi[z/x.y]$   \\
		$arr[i] = x$&$\phi[x/arr[i]]$ \\
		\textbf{if} $c$ (branch condition) & $\phi \wedge c$ \\
		\bottomrule
	\end{tabular}
   \begin{tablenotes}
	\item $*$ The string APIs modelled by Z3 (e.g., \texttt{String\#equals()}) are considered as $op$ instead of $api$.
	\item $*$ $\phi[x/y]$ means replacing the symbolic variable $x$ in the symbolic state $\phi$ by $y$.
	\end{tablenotes}
	\end{threeparttable}
\end{table}

\textbf{Refining Android configuration constraints.}
\textsc{ConfDroid} further refines the path constraints $\pi$ as Android configuration constraints $acc$ with the help of SMT solver Z3~\cite{z3} (Line 10-12).
First, \textsc{ConfDroid} checks whether the target statements are reachable by the path constraints.
To achieve this, \textsc{ConfDroid} substitutes API calls in the path constraints to symbolic variables according to the return types.
\textsc{ConfDroid} will declare any variables whose data formats are not modeled in Z3 as integer variables and replace constants (e.g., \texttt{null}) in the path constraints as integers in queries of Z3.
The target statement is reachable if its associated path constraint is decided to be satisfiable by Z3.

\textsc{ConfDroid} then calculates $\mathcal{A}$ and $\mathcal{X}$ from the path constraints $\pi$.
$\mathcal{A}$ is calculated from the parameter identifying the attribute to be loaded in the API call (i.e., $i$ in Line 7 of Figure~\ref{fig:frameworkprocess}). 
$\mathcal{X}$ is calculated as the return value of the API call \texttt{XmlPullParser\#getName()}. 
Note that $\mathcal{X}$ will be assigned as the class name where $\pi$ locates when the concrete value of $\mathcal{X}$ cannot be identified, because the Android framework allows app developers using the class names as XML tags.
\textsc{ConfDroid} then leverages Z3 to infer all the possible values of the above symbolic variables for $\mathcal{A}$ and $\mathcal{X}$.
We set the time budget as one minute to Z3 for each symbolic variable.
\textsc{ConfDroid} discards the cases when (1) the value of symbolic variables for $\mathcal{A}$ or $\mathcal{X}$ are undecidable, or (2) \textsc{ConfDroid} cannot obtain all possible values of symbolic variables for $\mathcal{A}$ or $\mathcal{X}$ within the time budget.
Such a strategy does not pose significant problems to the accuracy of Android configuration constraint extraction. Since those discarded cases only account for 1.8\% (29/1534) when applied to API level 30 (Section~\ref{sec:discussion}).

Next, to infer the value of $\mathcal{F}$, we manually built a map between each configuration API and its supported data format based on its API descriptions. \textsc{ConfDroid} further uses the map of configuration APIs with their supported data formats to analyze $\mathcal{F}$ for $tgtStmt$.
Finally, \textsc{ConfDroid} extracts Android configuration constraints $acc$ with all the possible combinations of $\mathcal{A}$, $\mathcal{X}$ and $\mathcal{F}$.

\subsection{Generating Detection Rules}
\label{sec:generate-rule}
Detection rules are further inferred by comparing the differences in Android configuration constraints between the two adjacent API levels $l_1$ and $l_2$ ($l_1<l_2$) as follows.
\begin{itemize}
	\item \textsc{ConfDroid} reports a rule of \textit{attribute loading change} if an attribute $\mathcal{A}$ of the XML tag $\mathcal{X}$ can be loaded at the API level $l_1$ only but not $l_2$ (or at $l_2$ only but not $l_1$).
	The rules falling into this type are induced by unavailable configuration APIs (Type 1 in Section \ref{sec:RQ1}).
	\item \textsc{ConfDroid} reports a rule of \textit{data format change} if there are inconsistencies in the supported data formats $\mathcal{F}$ for an attribute $\mathcal{A}$ of the XML tag $\mathcal{X}$ between $l_1$ and $l_2$.
	The rules falling into this type are induced by inconsistent configuration APIs (Type 2 in Section \ref{sec:RQ1}).
\end{itemize}

For example, by comparing the differences of Android configuration constraints as shown in Section \ref{sec:4.1}, 
\textsc{ConfDroid} generates a rule of data format change as follows.
$$ \left\{
\begin{aligned}
	\textbf{Attribute:\,\,} & \texttt{android:color}&
	\textbf{XML tag:\,\,} & \texttt{item} \\
	\textbf{Data format:\,\,} & \texttt{styled\_int}&
	\textbf{API level:\,\,} & [22,23] \\
\end{aligned}
\right\}.
$$

The above rule indicates that assigning the attribute value in the styled integer format to
\texttt{android:color} under the XML tag \texttt{<item>} can trigger
compatibility issues between API levels 22 and 23.

\subsection{Discussion}
\label{sec:discussion}
The accuracy of detection rules extracted by \textsc{ConfDroid} can be affected by the limitations of conducting backward symbolic execution to infer Android configuration constraints.
First, \textsc{ConfDroid} performs an intra-class level backward symbolic execution, which can cause $\mathcal{A}$ and $\mathcal{X}$ in Android configuration constraints identified inaccurately.
Second, \textsc{ConfDroid} discards cases where  values of $\mathcal{A}$ and $\mathcal{X}$ cannot be inferred due to the inabilities of Z3.
Therefore, false positive rules occur when an Android configuration constraint cannot find the equivalent one at other API levels due to the limitations of our analysis.
Plus, false negative rules are incurred when \textsc{ConfDroid} fails to generate Android configuration constraints for the evolved attributes.
However, \textsc{ConfDroid} only discards 1.9\% (29/1534) of the configuration API
call sites at API level 30, indicating the
insignificant impact on the inference of Android configuration constraints due
to the intra-class level symbolic execution and the inabilities of Z3.
Although we cannot draw a whole picture of all the cases of Android
configuration evolutions, we find that \textsc{ConfDroid} is only unable to
generate Android configuration constraints for 21.0\% (301/1435) attributes at
API level 30. These constraints are accountable for the false negatives in the
warnings reported by \textsc{ConfDroid} (Section~\ref{sec:rq3}).

%We measured the impact of the above limitations as follows.
%First, from the 1,505 configuration APIs that were successfully handled by \textsc{ConfDroid} at API level 30, we performed manual validation on 200 randomly sampled configuration APIs regarding 488 Android configuration constraints.
%An Android configuration constraint is considered valid if we can find online
%references to show the attribute $\mathcal{A}$ with data
%format $\mathcal{F}$ can be specified in the XML tag $\mathcal{X}$.
%We only failed to validate four Android configuration constraints regarding two configuration APIs.