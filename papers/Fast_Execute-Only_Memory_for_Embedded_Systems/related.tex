%==============================================================================
\section{Related Work}
\label{sec:related}
%==============================================================================

%
% XOM support on embedded devices.
%

Two other XOM implementations exist for ARM microcontrollers.
uXOM~\cite{uXOM:UsenixSec19}
provides XOM for ARM Cortex-M systems by transforming loads into
special unprivileged load
instructions and configuring the MPU to make the code region unreadable by
unprivileged loads.  uXOM similarly transforms stores to
protect the memory-mapped MPU configuration registers.  Since
some loads and stores do not have unprivileged counterparts,
transforming them requires the compiler to insert additional instructions,
causing the majority of uXOM's overhead.  {\System} is more
efficient in both performance (0.33\% compared to uXOM's 7.3\%) and code
size (5.89\% compared to uXOM's 15.7\%) as no such transformation is needed.
A trade-off for {\System} is the code size limit on some ARMv7-M
devices; we envision no such limit on ARMv8-M.
% PCROP
PCROP~\cite{STM32F4:PCROP:Manual} is a programmable feature of the flash
memory which prevents the flash memory from being read out and modified by
application code but still allows code in the flash memory to execute.
However, PCROP is only available on some
STMicroelectronics devices and cannot be used for other types of memory.
In contrast, {\System} relies on the MPU
and DWT features~\cite{ARMv7-M:Manual,ARMv8-M:Manual} which can
be found on most conforming devices
and can protect code stored in any type of memory.

%
% XOM support on other platforms.
%

Hardware-assisted XOM has been explored on other architectures.
The AArch64~\cite{ARMv8-A:Manual} and RISC-V~\cite{RISC-V:Priv:Manual}
page tables natively support XO permissions.
NORAX~\cite{NORAX:Oakland17} enables XOM for
commercial-off-the-shelf binaries on AArch64 that have constant islands
using static binary
instrumentation and runtime monitoring.
Various approaches~\cite{HideM:CODASPY15,Readactor:Oakland15,%
ExOShim:ICCWS16,KHide:CNS16,XOM-Switch:BlackHatAsia18,IskiOS:ArXiv19} leverage
features of the MMU on Intel x86 processors~\cite{X86:Intel:Manual}
to implement XOM.
None of these approaches are applicable on ARM embedded devices
lacking an MMU.  Lie et al.~\cite{XOM:ASPLOS00} proposed an
architecture with memory encryption to mimic XOM, but it only
provides probabilistic guarantees and cannot be directly applied to
current embedded systems.
Compared to solutions for systems lacking native hardware XOM support,
{\System} is faster as it has nearly no overhead.

%
% Software-emulated XOM.
%

Software can emulate XOM.  XnR~\cite{XnR:CCS14}
maintains a sliding window of currently executing code pages and
keeps only these pages accessible.
It still allows read accesses to a subset of code pages
and may incur higher overhead for a smaller sliding
window size due to frequent page permission changes.
LR$^2$~\cite{LR2:NDSS16} and kR\^{}X~\cite{kR^X:EuroSys17} instrument
all load instructions to prevent them from reading the code
segment.  While these software XOM approaches can generally be ported
to embedded devices,
they can be bypassed by attacker-manipulated control flow and
are less efficient than hardware-assisted XOM~\cite{uXOM:UsenixSec19}.

%
% Other protections on embedded systems.
%

There are also methods of hardening embedded systems.
Early versions of SAFECode~\cite{DKAL:TECS05} enforced spatial and
temporal memory safety on embedded applications, and
nesCheck~\cite{nesCheck:ASIACCS17} uses static analysis to build
spatial memory safety for simple nesC~\cite{nesC:PLDI03} applications
running on TinyOS~\cite{TinyOS:ASPLOS00}.
{\System} enforces weaker protection than
memory safety but supports arbitrary C programs (unlike SAFECode and nesCheck)
and does not rely on heavy static analysis like nesCheck.
RECFISH~\cite{RECFISH:ECRTS19},
$\mu$RAI~\cite{uRAI:NDSS20}, and Silhouette~\cite{Silhouette:UsenixSec20}
mitigate control-flow hijacking attacks on embedded systems.  They
protect forward-edge control flow using coarse-grained CFI~\cite{CFI:CCS05} and
backward-edge control flow by using either a protected shadow
stack~\cite{SoK:SS:Oakland19} or a return address encoding mechanism.
EPOXY~\cite{EPOXY:Oakland17} randomizes the order of functions and the
location of a modified safe stack from CPI~\cite{CPI:OSDI14} to resist
control-flow hijacking attacks on bare-metal microcontrollers.  These
systems do not enforce XOM and are still vulnerable to forward-edge
corruptions; they can incorporate {\System}'s techniques to mitigate
forward-edge attacks with negligible additional overhead.
