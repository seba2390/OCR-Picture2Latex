%==============================================================================
\section{Threat Model and System Assumptions}
\label{sec:threat}
%==============================================================================

We assume a buggy but unmalicious application running on an embedded
device with memory safety vulnerabilities that allow a
remote attacker to read or write arbitrary memory locations.  The
attacker wants to either steal proprietary application code
for purposes like reverse engineering or learn the application code
layout in order to launch code reuse attacks such as
Return-into-libc~\cite{Ret2Libc:RAID11}
and
Return-Oriented Programming (ROP)~\cite{ROP:TOISS12} attacks.
Physical and offline attacks are
out of scope as we believe such attacks can be stopped by orthogonal
defenses~\cite{IoT:DAC15,IoTSec:CN18}.
Our threat model also assumes the application code and data is
diversified, using techniques such as those in
EPOXY~\cite{EPOXY:Oakland17}.  Therefore, remotely tricking the buggy
application into reading its code content becomes a reasonable choice
for the attacker.

We assume that the target embedded device supports MPU
and DWT with enough configurable MPU regions and DWT comparators.  We
assume that the device is running a single bare-metal application
statically linked with libraries, boot sequences, and exception
handlers.  The application is assumed to run in privileged mode, as
Section~\ref{sec:bg:isa} dictates.  For ARMv8-M devices with TrustZone-M,
the application is assumed to reside in the non-secure world, while
software in the secure world is trusted.
