%==============================================================================
\section{Implementation}
\label{sec:impl}
%==============================================================================

We built our {\System} prototype for the ARMv7-M architecture.  Our
prototype provides MPU and DWT configurations as a run-time component
written in C and executed at the end of the device boot sequence.
We implemented constant island removal as a
simple intermediate representation (IR) pass in the LLVM 10.0
compiler~\cite{LLVM:CGO04}.  The constant island removal pass
simply uses the existing {\tt -mexecute-only} option in
LLVM's Clang front-end and passes it along to the link-time optimization
(LTO) code generator.  Our prototype runs the constant island removal
pass when linking the IR of the application, libraries (e.g., newlib and
compiler-rt), and MPU and DWT configurations; this
ensures that all code has no constant islands.  Our prototype adds
88~source lines of C++ code to LLVM and has 177~source
lines of C~code in the {\System} run-time.  We leave the {\System}
implementation on ARMv8-M for future work.

Different ARM microcontrollers support different numbers of MPU
regions and DWT comparators, and the maximum ranges of their
DWT comparators may vary.
Our prototype runs on an STM32F469
Discovery board which supports up to 8~MPU
regions~\cite{STM32CortexM4:Manual} and 4~DWT
comparators~\cite{STM32F469I-DISCO:Manual}.  Each DWT
comparator can only watch over a maximum address range of 32~KB
(a maximal mask value of 15), limiting
our prototype to the following two options:

\begin{inparaenum}
\item
  Use all 4~DWT comparators to support a maximum code size of
  128~KB; the application must run in unprivileged mode in order
  for the critical system registers to be write-protected.

\item
  Configure one DWT comparator to write-protect the DWT registers
  ({\tt 0xE0001000} -- {\tt 0xE0001FFF}) and another to
  write-protect the SCB ({\tt 0xE000ED00} -- {\tt 0xE000ED8F}) and
  {\tt DEMCR} ({\tt 0xE000EDFC}). This protects a maximum code size
  of 64~KB using the remaining 2~DWT comparators.
\end{inparaenum}

To accommodate a wider range of applications on our board with less
performance loss, our prototype automatically chooses one option over
the other based on the application code size.  It rejects an application
if the code size exceeds our board's 128~KB limit.

While our {\System} prototype only supports single bare-metal
embedded applications, {\System} can also support multiple applications
running on an embedded real-time operating system (RTOS) such as Amazon
FreeRTOS~\cite{FreeRTOS:Amazon}.  On embedded systems, the application
and RTOS kernel code is linked into a single shared code
segment.  {\System} can protect this code segment with little adaptation.
