%\documentclass[conference,a4paper,onecolumn]{IEEEtran}
\documentclass[journal,twocolumn]{IEEEtran}
\IEEEoverridecommandlockouts
\usepackage{amsthm}
\usepackage{arydshln}
\usepackage{multirow}
\usepackage{calc}
\usepackage{blkarray}
\usepackage{url}
\theoremstyle{definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{claim}{Claim}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
%\newtheorem{example}[theorem]{Example}
\newtheorem{example}{Example}
\newtheorem{remark}{Remark}
\newtheorem{definition}{Definition}
\usepackage{graphicx,cite}
\usepackage{dblfloatfix}

\usepackage{blindtext, graphicx, amsfonts,amssymb,multirow,epstopdf}
\usepackage{dsfont}


\ifCLASSINFOpdf

\else

\fi

\usepackage[cmex10]{amsmath}
%\usepackage{algorithm}
\usepackage[linesnumbered,ruled]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily{#1}}
\SetCommentSty{mycommfont}
%
%\usepackage{algorithm}
%\usepackage{algorithmic}
%\usepackage[]{algorithm2e}
\hyphenation{op-tical net-works semi-conduc-tor}
\newcommand{\calA}{\mathcal{A}}
\newcommand{\calC}{\mathcal{C}}
\newcommand{\calV}{\mathcal{V}}
\newcommand{\calU}{\mathcal{U}}
\newcommand{\calN}{\mathcal{N}}
\newcommand{\calP}{\mathcal{P}}
\newcommand{\calS}{\mathcal{S}}
\newcommand{\calD}{\mathcal{D}}
\newcommand{\calT}{\mathcal{T}}
\newcommand{\calI}{\mathcal{I}}
\newcommand{\calH}{\mathcal{H}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\calB}{\mathcal{B}}

\newcommand{\bfg}{\mathbf{g}}
\newcommand{\bfb}{\mathbf{b}}
\newcommand{\bfv}{\mathbf{v}}
\newcommand{\bfGamma}{\mathbf{\Gamma}}
\newcommand{\bfu}{\mathbf{u}}
\newcommand{\bfc}{\mathbf{c}}
\newcommand{\bfT}{\mathbf{T}}
\newcommand{\bfG}{\mathbf{G}}
\newcommand{\bfS}{\mathbf{S}}
\newcommand{\bfI}{\mathbf{I}}
\newcommand{\bfP}{\mathbf{P}}
\newcommand{\bfC}{\mathbf{C}}
\newcommand{\bfD}{\mathbf{D}}
\newcommand{\bfA}{\mathbf{A}}
\newcommand{\bfB}{\mathbf{B}}
\newcommand{\bfE}{\mathbf{E}}
\newcommand{\bfF}{\mathbf{F}}
\newcommand{\bfzr}{\mathbf{0}}
\newcommand{\bfoe}{\mathbf{1}}
\newcommand{\aditya}[1]{\marginpar{+}{\bf Aditya's remark}: {\em #1}}
\newcommand{\litang}[1]{\marginpar{+}{\bf Li's remark}: {\em #1}}
\renewcommand{\qedsymbol}{$\blacksquare$}

\pagestyle{plain}
\begin{document}

	%
	% paper title
	% can use linebreaks \\ within to get better formatting as desired
%	\title{Further Result on Coded Caching with Low Subpacketization Levels}
	%\title{Low Subpacketization Schemes for Coded Caching}
%\title{Reduced Subpacketization Schemes for Coded Caching from Linear Block Codes}
	\title{Coded Caching Schemes with Reduced Subpacketization from Linear Block Codes}
	% author names and affiliations
	% use a multiple column layout for up to three different
	% affiliations
\author{\IEEEauthorblockN{Li Tang and Aditya Ramamoorthy\\}
		\IEEEauthorblockA{Department of Electrical and Computer Engineering\\
		Iowa State University\\
		Ames, IA 50010\\
			Emails:\{litang, adityar\}@iastate.edu}
	\thanks{This work was supported in part by the National Science Foundation by grants CCF-1718470, CCF-1320416 and CCF-1149860. This paper was presented in part at the 2016 IEEE Workshop on Network Coding and Applications (NetCod) and at the 2017 IEEE International Symposium on Information Theory (ISIT).}}
	
	
	\maketitle
\begin{abstract}
Coded caching is a technique that generalizes conventional caching and promises significant reductions in traffic over caching networks.
However, the basic coded caching scheme requires that
each file hosted in the server be partitioned into a large number
(i.e., the subpacketization level) of non-overlapping subfiles. From
a practical perspective, this is problematic as it means that prior
schemes are only applicable when the size of the files is extremely
large. In this work, we propose coded caching schemes based on combinatorial structures called resolvable designs.
These structures can be obtained in a natural manner from linear block codes whose generator matrices possess certain rank properties.
We obtain several schemes with subpacketization levels substantially lower than the basic scheme at the cost of an increased rate. Depending on the system parameters, our approach allows
us to operate at various points on the subpacketization level vs. rate tradeoff.
%We demonstrate that several schemes with subpacketization levels that are exponentially smaller than the basic scheme can be obtained.
\end{abstract}
\begin{IEEEkeywords}
coded caching, resolvable designs, cyclic codes, subpacketization level
\end{IEEEkeywords}
\section{Introduction}
\label{sec:intro}

Caching is a popular technique for facilitating large scale content delivery over the Internet. Traditionally, caching operates by storing popular content closer to the end users. Typically, the cache serves an end user's file request partially (or sometimes entirely) with the remainder of the content coming from the main server. Prior work in this area \cite{maddahN14} demonstrates that allowing coding in the cache and coded transmission from the server (referred to as {\it coded caching}) to the end users can allow for significant reductions in the number of bits transmitted from the server to the end users. This is an exciting development given the central role of caching in supporting a significant fraction of Internet traffic. In particular, reference \cite{maddahN14} considers a scenario where a single server contains $N$ files. %Each file is assumed to consist of $F$ subfiles (a subfile is a basic unit of storage).
The server connects to $K$ users over a shared link and each user has a cache that allows it to store $M/N$ fraction of all the files in the server. Coded caching consists of two distinct phases: a $\emph{placement phase}$ and a $\emph{delivery phase}$. In the placement phase, the caches of the users are populated. This phase does not depend on the user demands which are assumed to be arbitrary. In the delivery phase, the server sends a set of $\emph{coded}$ signals that are broadcast to each user such that each user's demand is satisfied.

The original work of \cite{maddahN14} considered the case of centralized coded caching, where the server decides the content that needs to be placed in the caches of the different users. Subsequent work considered the decentralized case where the users populate their caches by randomly choosing parts of each file while respecting the cache size constraint. Recently, there have been several papers that have examined various facets of coded caching. These include tightening known bounds on the coded caching rate \cite{ghasemiR17_accepted,sengupta2015improved}, considering
 issues with respect to decentralized caching \cite{maddahN14mr_tradeoff}, explicitly considering popularities of files \cite{maddahN14nonuniform_demand,hachemKD14a}, network topology issues \cite{TangR16,JJ15} and synchronization issues \cite{ghasemiR17,niesen2015coded}. %\aditya{some more CITES needed}

In this work, we examine another important aspect of the coded caching problem that is closely tied to its adoption in practice. It is important to note that the huge gains of coded caching require each file to be partitioned into $F_s \approx \binom{K}{\frac{KM}{N}}$ non-overlapping subfiles of equal size; $F_s$ is referred to as the \emph{subpacketization level}. It can be observed that for a fixed cache size $\frac{M}{N}$, $F_s$ grows exponentially with $K$. This can be problematic in practical implementations. For instance, suppose that $K=64$, with $\frac{M}{N}=0.25$ so that $F_s=\binom{64}{16}\approx 4.8 \times 10^{14}$ with a rate $R \approx 2.82$. In this case, it is evident that at the bare minimum, the size of each file has to be at least $480$ terabits for leveraging the gains in \cite{maddahN14}. It is even worse in practice. The atomic unit of storage on present day hard drives is a sector of size $512$ bytes and the trend in the disk drive industry is to move this to $4096$ bytes \cite{toshiba_wp}. As a result, the minimum size of each file needs to be much higher than $480$ terabits. Therefore, the scheme in \cite{maddahN14} is not practical even for moderate values of $K$. Furthermore, even for smaller values of $K$, schemes with low subpacketization levels are desirable. This is because any practical scheme will require each of the subfiles to have some header information that allows for decoding at the end users. When there are a large number of subfiles, the header overhead may be non-negligible. For these same parameters ($K=64, M/N = 0.25$) our proposed approach in this work allows us obtain, e.g., the following operating points: (i) $F_s \approx 1.07 \times 10^9$ and $R = 3$, (ii) $F_s \approx 1.6\times 10^4$ and $R=6$, (iii) $F_s=64$ and $R=12$. For the first point, it is evident that the subpacketization level drops by over five orders of magnitude with only a very small increase in the rate. Point (ii) and (iii) show proposed scheme allows us to operate at various points on the tradeoff between subpacketization level and rate. %\litang{Edit this part, but it seems we choose  $K$ and $k$ very specifically}
%\aditya{need to discuss, maybe it is better to pick a different value of K}

%For instance, suppose that $K=50$, with $\frac{M}{N}=0.4$ so that $F_s=\binom{50}{20}\approx 10^{14}$. In this case, it is evident that at the bare minimum, the size of each file has to be at least $100$ terabits for leveraging the gains in \cite{maddahN14}. It is even worse in practice. The atomic unit of storage on present day hard drives is a sector of size $512$ bytes and the trend in the disk drive industry is to move this to $4096$ bytes. As a result, the minimum size of each file needs to be much higher than $100$ terabits. Therefore, the scheme in \cite{maddahN14} is not practical even for moderate values of $K$. Furthermore, even for smaller values of $K$, schemes with low subpacketization levels are desirable. This is because any practical scheme will require each of the subfiles to have some header information that allows for decoding at the end users. When there are a large number of subfiles, the header overhead may be non-negligible.

The issue of subpacketization was first considered in the work of \cite{shanmugam_et_al14,shanmugam_et_al16} in the decentralized coded caching setting. In the centralized case it was considered in the work of \cite{yan_et_al17}. They proposed a low subpacketization scheme based on placement delivery arrays. Reference \cite{shangguan2016centralized} viewed the problem from a hypergraph perspective and presented several classes of coded caching schemes. The work of \cite{shanmugam2017coded} has recently shown that there exist coded caching schemes where the subpacketization level grows linearly with the number of users $K$; however, this result only applies when the number of users is very large. We elaborate on related work in Section \ref{sec:related_work}.

In this work, we propose low subpacketization level schemes for coded caching. Our proposed schemes leverage the properties of combinatorial structures known as resolvable designs and their natural relationship with linear block codes. Our schemes are applicable for a wide variety of parameter ranges and allow the system designer to tune the subpacketization level and the gain of the system with respect to an uncoded system. We note here that designs have also been used to obtain results in distributed data storage \cite{olmezR16} and network coding based function computation in recent work \cite{tripathyR15,tripathyR17}.


%We show that the construction proposed in \cite{yan_et_al16} (and our own prior work \cite{TangR16_Netcod}) is a special case of the present work.

This paper is organized as follows. Section \ref{sec:background} discusses the background and related work and summarizes the main contributions of our work. Section \ref{sec:design} outlines our proposed scheme. It includes all the constructions and the essential proofs. A central object of study in our work are matrices that satisfy a property that we call the consecutive column property (CCP). Section \ref{sec:LinearCode} overviews several constructions of matrices that satisfy this property. Several of the longer and more involved proofs of statements in Sections \ref{sec:design} and \ref{sec:LinearCode} appear in the Appendix. In Section \ref{sec:compare} we perform an in-depth comparison our work with existing constructions in the literature. We conclude the paper with a discussion of opportunities for future work in Section \ref{sec:conclusion}.
\section{Background, Related Work and Summary of Contributions}
\label{sec:background}
We consider a scenario where the server has $N$ files each of which consist of $F_s$ subfiles. There are $K$ users each equipped with a cache of size $MF_s$ subfiles. The coded caching scheme is specified by means of the placement scheme and an appropriate delivery scheme for each possible demand pattern. In this work, we use combinatorial designs \cite{Stinson} to specify the placement scheme in the coded caching system.	
\begin{definition}
\label{def:comb_design}
A design is a pair $(X, \calA)$ such that
\begin{enumerate}
\item  $X$ is a set of elements called points, and
\item $\calA$ is a collection of nonempty subsets of $X$ called blocks, where each block contains the same number of points.
\end{enumerate}
\end{definition}
A design is in one-to-one correspondence with an incidence matrix $\calN$ which is defined as follows.
\begin{definition}
	The incidence matrix $\calN$ of a design $(X, \calA)$ is a binary matrix of dimension $|X| \times |\calA|$, where the rows and columns correspond to the points and blocks respectively.
	Let $i \in X$ and $j \in \calA$. Then,
	\begin{align*}
		\calN (i,j) = \begin{cases}
			1 & \text{~if $i \in j$,}\\
			0 & \text{~otherwise}.
		\end{cases}
	\end{align*}
\end{definition}
It can be observed that the transpose of an incidence matrix also specifies a design. We will refer to this as the transposed design. In this work, we will utilize resolvable designs which are a special class of designs.
\begin{definition}
\label{def:resolv_design}
A parallel class $\calP$ in a design $(X,\calA)$ is a subset of disjoint blocks from $\calA$ whose union is $X$. A partition of $\calA$ into several parallel classes is called a resolution, and $(X,\calA)$ is said to be a resolvable design if $\calA$ has at least one resolution.
\end{definition}
For resolvable designs, it follows that each point also appears in the same number of blocks.

%We now provide an example of how a resolvable design can be used in the placement scheme, when the users and subfiles correspond to the blocks and points, respectively.
\begin{example}
\label{eg:resolv_6_2}
Consider a block design specified as follows.
\begin{align*}
X&=\{1,2,3,4\}, \text{~and}\\
\calA &=\{\{1,2\},\{1,3\},\{1,4\},\{2,3\},\{2,4\},\{3,4\}\}.
\end{align*}
Its incidence matrix is given below.
\begin{align*}
 \calN &= \begin{bmatrix}
 	1 & 1 & 1 & 0 & 0 & 0\\
 	1 & 0 & 0 & 1 & 1 & 0\\
 	0 & 1 & 0 & 1 & 0 & 1\\
 	0 & 0 & 1 & 0 & 1 & 1
\end{bmatrix}.
\end{align*}
It can be observed that this design is resolvable with the following parallel classes.
\begin{align*}
\calP_1 &= \{\{1,2\}, \{3,4\}\},\\
\calP_2 &= \{\{1,3\}, \{2,4\}\}, \text{~and}\\
\calP_3 &= \{\{1,4\}, \{2,3\}\}.
\end{align*}
\end{example}
In the sequel we let $[n]$ denote the set $\{1, \dots, n\}$.
We emphasize here that the original scheme of \cite{maddahN14} can be viewed as an instance of the trivial design. For example, consider the setting when $t = KM/N$ is an integer. Let  $X = [K]$ and $\calA = \{B: B \subset [K], |B| = t\}$. In the scheme of \cite{maddahN14}, the users are associated with $X$ and the subfiles with $\calA$. User $i \in [K]$ caches subfile $W_{n,B}, n \in [N]$ for $B \in \calA$ if $i \in B$. %In general, we can reverse the roles of the points and blocks and choose to associate the users with the blocks and subfiles with the points instead. Equivalently, the incidence matrix of the design (or its transpose) can be used to specify the placement scheme.
The main message of our work is that carefully constructed resolvable designs can be used to obtain coded caching schemes with low subpacketization levels, while retaining much of the rate gains of coded caching. The basic idea is to associate the users with the blocks and the subfiles with the points of the design. The roles of the users and subfiles can also be interchanged by simply working with the transposed design.

\begin{example}
\label{eg:placement_q_2_k_3}
Consider the resolvable design from Example \ref{eg:resolv_6_2}. The blocks in $\calA$ correspond to six users $U_{12}$, $U_{34}$, $U_{13}$, $U_{24}$, $U_{14}$, $U_{23}$. Each file is partitioned into $F_s=4$ subfiles $W_{n,1}, W_{n,2}, W_{n,3}, W_{n,4}$ which correspond to the four points in $X$. The cache in user $U_{B}$, denoted $Z_{B}$ is specified as $Z_{ij}=(W_{n,i},W_{n,j})_{n=1}^N$. For example, $Z_{12}=(W_{n,1}, W_{n,2})_{n=1}^{N}$.

We note here that the caching scheme is symmetric with respect to the files in the server. Furthermore, each user caches half of each file so that $M/N = 1/2$.
Suppose that in the delivery phase user $U_B$ requests file $W_{d_{B}}$ where $d_B \in [N]$. These demands can be satisfied as follows. We pick three blocks, one each from parallel classes $\calP_1$, $\calP_2$, $\calP_3$ and generate the signals transmitted in the delivery phase as follows.
\begin{align}
	&W_{d_{12},3}\oplus W_{d_{13},2}\oplus W_{d_{23},1}, \label{eq:eg_2_intro}\\
    &W_{d_{12},4}\oplus W_{d_{24},1}\oplus W_{d_{14},2}, \nonumber\\
    &W_{d_{34},1}\oplus W_{d_{13},4}\oplus W_{d_{14},3}, \text{~and} \nonumber\\
    &W_{d_{34},2}\oplus W_{d_{24},3}\oplus W_{d_{23},4}. \nonumber
\end{align}
The three terms in the in eq. (\ref{eq:eg_2_intro}) above correspond to blocks from different parallel classes $\{1,2\}\in \calP_1, \{1,3\}\in \calP_2 ,\{2,3\}\in \calP_3$. This equation has the {\it all-but-one} structure that was also exploited in \cite{maddahN14}, i.e., eq. (\ref{eq:eg_2_intro}) is such that each user caches all but one of the subfiles participating in the equation. Specifically, user $U_{12}$ contains $W_{n,1}$ and $W_{n,2}$ for all $n \in [N]$. Thus, it can decode subfile $W_{d_{12},3}$ that it needs. A similar argument applies to users $U_{13}$ and $U_{23}$. It can be verified that the other three equations also have this property. Thus, at the end of the delivery phase, each user obtains its missing subfiles.

%It can be observed that this equation benefits each of the three users participating in it. Furthermore, it is also apparent that at the end of the delivery phase, each user obtains its missing subfiles.

This scheme corresponds to a subpacketization level of $4$ and a rate of $1$. In contrast, the scheme of \cite{maddahN14} would require a subpacketization level of $\binom{6}{3} = 20$ with a rate of $0.75$. Thus, it is evident that we gain significantly in terms of the subpacketization while sacrificing some rate gains.
\end{example}
As shown in Example \ref{eg:placement_q_2_k_3}, we can obtain a scheme by associating the users with the blocks and the subfiles with the points. In this work, we demonstrate that this basic idea can be significantly generalized and several schemes with low subpacketization levels that continue to leverage much of the rate benefits of coded caching can be obtained. %conduct an in-depth analysis of the system parameters and compare it with existing work. %It turns out that a large class of resolvable block designs that are useful in the coded caching context can be constructed in an easy manner from linear block codes.

\subsection{Discussion of Related Work}
\label{sec:related_work}
Coded caching has been the subject of much investigation in recent work as discussed briefly earlier on. We now overview existing literature on the topic of low subpacketization schemes for coded caching.
In the original paper \cite{maddahN14}, for given problem parameters $K$ (number of users) and $M/N$ (cache fraction), the authors showed that when $N \geq K$, the rate equals
\begin{align*}
R &= \frac{K(1 - M/N)}{1 + KM/N}
\end{align*}
when $M$ is an integer multiple of $N/K$. Other points are obtained via memory sharing.
Thus, in the regime when $KM/N$ is large, the coded caching rate is approximately $N/M - 1$, which is independent of $K$. Crucially, though this requires the subpacketization level $F_s \approx \binom{K}{KM/N}$. It can be observed that for a fixed $M/N$, $F_s$ grows exponentially with $K$. This is one of main drawbacks of the original scheme and for reasons outlined in Section \ref{sec:intro}, deploying this solution in practice may be difficult.

The subpacketization issue was first discussed in the work of \cite{shanmugam_et_al14, shanmugam_et_al16} in the context of decentralized caching. Specifically, \cite{shanmugam_et_al16} showed that in the decentralized setting for any subpacketization level $F_s$ such that $F_s \leq \exp (KM/N)$ the rate would scale linearly in $K$, i.e., $R \geq cK$. Thus, much of the rate benefits of coded caching would be lost if $F_s$ did not scale exponentially in $K$. Following this work, the authors in \cite{yan_et_al17} introduced a technique for designing low subpacketization schemes in the centralized setting which they called placement delivery arrays. In \cite{yan_et_al17}, they considered the setting when $M/N = 1/q$ or $M/N = 1 - 1/q$ and demonstrated a scheme where the subpacketization level was exponentially smaller than the original scheme, while the rate was marginally higher. This scheme can be viewed as a special case of our work. We discuss these aspects in more detail in Section \ref{sec:compare}. In \cite{shangguan2016centralized}, the design of coded caching schemes was achieved through the design of hypergraphs with appropriate properties. In particular, for specific problem parameters, they were able to establish the existence of schemes where the subpacketization scaled as $\exp (c \sqrt{K})$. Reference\cite{yan2016placement} presented results in this setting by considering strong edge coloring of bipartite graphs.

Very recently, \cite{shanmugam2017coded} showed the existence of coded caching schemes where the subpacketization grows linearly with the number of users, but the coded caching rate grows as $O(K^\delta)$ where $0 < \delta < 1$. Thus, while the rate is not a constant, it does not grow linearly with $K$ either. Both \cite{shangguan2016centralized} and \cite{shanmugam2017coded} are interesting results that demonstrate the existence of regimes where the subpacketization scales in a manageable manner. Nevertheless, it is to be noted that these results come with several caveats. For example, the result of \cite{shanmugam2017coded} is only valid in the regime when $K$ is very large and is unlikely to be of use for practical values of $K$. The result of \cite{shangguan2016centralized} has significant restrictions on the number of users, e.g., in their paper, $K$ needs to be of the form $\binom{n}{a}$ and $q^t\binom{n}{a}$.%\aditya{Li, check this} \litang{Edit on 05/29: I delete $K$ is assumed to be large}% and again $K$ is assumed to be large.

\subsection{Summary of Contributions}
%\aditya{this subsection needs more content}
In this work, the subpacketization levels we obtain are typically exponentially smaller than the original scheme. However, they still continue to scale exponentially in $K$, albeit with much smaller exponents. However, our construction has the advantage of being applicable for a large range of problem parameters.
Our specific contributions include the following.
\begin{itemize}
\item We uncover a simple and natural relationship between a $(n,k)$ linear block code and a coded caching scheme. We first show that any linear block code over $GF(q)$ and in some cases $\mathbb{Z} \mod q$ (where $q$ is not a prime or a prime power) generates a resolvable design. This design in turn specifies a coded caching scheme with $K=nq$ users where the cache fraction $M/N = 1/q$. A complementary cache fraction point where $M/N = 1 - \alpha/nq$ where $\alpha$ is some integer between $1$ and $k+1$ can also be obtained. Intermediate points can be obtained by memory sharing between these points.
\item We consider a class of $(n,k)$ linear block codes whose generator matrices satisfy a specific rank property. In particular, we require collections of consecutive columns to have certain rank properties. For such codes, we are able to identify an efficient delivery phase and determine the precise coded caching rate. We demonstrate that the subpacketization level is at most $q^k (k+1)$ whereas the coded caching gain scales as $k+1$ with respect to an uncoded caching scheme. Thus, different choices of $k$ allow the system designer significant flexibility to choose the appropriate operating point.
\item We discuss several constructions of generator matrices that satisfy the required rank property. We characterize the ranges of alphabet sizes $(q)$ over which these matrices can be constructed. If one has a given subpacketization budget in a specific setting, we are able to find a set of schemes that fit the budget while leveraging the rate gains of coded caching.
\end{itemize}
\section{Proposed low subpacketization level scheme}
% \section{Low Subpacketization level scheme based on linear block code satisfies partially MDS property}
 \label{sec:design}
%	In this work we consider a caching system consisting of a single server and $K$ users, $U_1,\cdots, U_K$. The server is connected to all the users through an error-free shared link and contains a library of $N$ files where each file consists of $F$ subfiles. These files are represented by random variables $W_i$, $i=1,\cdots, N$, where $W_i$ is distributed uniformly over the set $[2^F]$ (we use $[n]$ to denote the set $\{1, 2, \dots, n\}$ throughout). Each user has a cache memory of $MF$ subfiles, where $M \leq N$.
	

%	The caching system has two distinct phases: a placement phase and a delivery phase. In the placement phase, the server populates the content of user's caches. This phase does not depend on the actual user requests that can be arbitrary. In the delivery phase, user $U_i$ requests a file $W_{d_i}$, where $d_i \in [N]$, from the server and the server responds by transmitting a certain number of bits which satisfies the demand of all the users.
%The work of \cite{maddahN14} shows that huge reductions in rate are possible when coded caching is used. %Specifically, they establish that the following rate is achievable.
%\begin{align}
%\label{eq:coded_rate}
%R_{C}(M) = K\bigg{(}1 -\frac{M}{N}\bigg{)} \cdot \min \bigg{\{}\frac{1}{1 + KM/N}, \frac{N}{K}\bigg{\}},
%\end{align}
%where $M \in \{0,N/K, 2N/K,\dots, N\}$ (i.e, for $M$ a multiple of $N/K$).
%
%%Compared with uncoded placement and uncoded delivery caching scheme, Maddah-Ali and Niesen's caching scheme enjoys a gain $\frac{1}{1+\frac{KM}{N}}$ at the transmission rate, which is referred to as coded gain in the literature.

All our constructions of low subpacketization schemes will stem from resolvable designs ({\it cf.} Definition \ref{def:resolv_design}). Our overall approach is to first show that any $(n,k)$ linear block code over $GF(q)$ can be used to obtain a resolvable block design. The placement scheme obtained from this resolvable design is such that $M/N = 1/q$. Under certain (mild) conditions on the generator matrix we show that a delivery phase scheme can be designed that allows for a significant rate gain over the uncoded scheme while having a subpacketization level that is significantly lower than \cite{maddahN14}. Furthermore, our scheme can be transformed into another scheme that operates at the point $M/N = 1 - \frac{k+1}{nq}$. Thus, intermediate values of $M/N$ can be obtained via memory sharing. We also discuss situations under which we can operate over modular arithmetic $\mathbb Z_q = \mathbb{Z} \mod q$ where $q$ is not necessarily a prime or a prime power; this allows us to obtain a larger range of parameters.



\subsection{Resolvable Design Construction}
\label{sec:construction}
 Consider a $(n,k)$ linear block code over $GF(q)$. To avoid trivialities we assume that its generator matrix does not have an all-zeros column. We collect its $q^k$ codewords %$\bfc_i$ of this $(n,k)$ code, which are obtained by computing $\bfc_i=\bfu_i\bfG$ for all possible message $\bfu_i$,
 and construct a matrix $\bfT$ of size $n\times q^{k}$ as follows.
 \begin{equation}
 \label{eq:T}
 \bfT=[\bfc_0^T,\bfc_1^T,\cdots,\bfc_{q^{k}-1}^T],
 \end{equation}
where the $1 \times n$ vector $\bfc_\ell$ represents the $\ell$-th codeword of the code. Let $X=\{0,1,\cdots,q^{k}-1\}$ be the point set and $\calA$ be the collection of all subsets $B_{i,l}$ for $0\le i\le n-1$ and $0\le l\le q-1$, where
 \begin{align*}
 B_{i,l}&=\{j:\bfT_{i,j}=l\}.
 \end{align*}
Using this construction, we can obtain the following result.
\begin{lemma}
 \label{lemma:Resolve_MDS}
The construction procedure above results in a design $(X, \calA)$ where $X = \{0,1,\cdots, q^k-1\}$ and $|B_{i,l}| = q^{k-1}$ for all $0 \leq i \leq n-1$ and $0 \leq l \leq q-1$. Furthermore, the design is resolvable with parallel classes given by $\calP_i = \{B_{i,l}: 0 \leq l \leq q-1\}$, for $0\leq i \leq n-1$.
\end{lemma}
\begin{proof}
%For a given $i$, we need to show that $|B_{i,l}|=q^{k-1}$ for all $0\le l\le q-1$ and that $\cup_{l=0}^{q-1} B_{i,l} = \{0,1,\cdots,q^{k}-1\}$.
Let $\bfG=[g_{ab}]$, for $0\le a\le k-1$, $0\le b\le n-1$, $g_{ab}\in GF(q)$. Note that for $\Delta = [\Delta_0 ~\Delta_1~ \dots~\Delta_{n-1}]= \bfu \bfG$, we have
\begin{align*}
\Delta_b &= \sum_{a=0}^{k-1} \bfu_ag_{ab},
\end{align*}
where $\bfu=[\bfu_0,\cdots, \bfu_{k-1}]$. Let $a^*$ be such that $g_{a^*b} \neq 0$. Consider the equation
\begin{align*}
\sum_{a \neq a^*} \bfu_ag_{ab}&=\Delta_b-\bfu_{a^*}g_{a^*b},
\end{align*}
where $\Delta_b$ is fixed. For arbitrary values of $\bfu_a$, $a \neq a^*$, this equation has a unique solution for $\bfu_{a^*}$, which implies that for any $\Delta_b$, $|B_{b,\Delta_b   }| = q^{k-1}$ and that $\calP_{b}$ forms a parallel class.
\end{proof}
\begin{remark} A $k \times n$ generator matrix over $GF(q)$ where $q$ is a prime power can also be considered as a matrix over an extension field $GF(q^m)$ where $m$ is an integer. Thus, one can obtain a resolvable design in this case as well; the corresponding parameters can be calculated in an easy manner.
\end{remark}

\begin{remark} We can also consider linear block codes over $\mathbb{Z} \mod q$ where $q$ is not necessarily a prime or a prime power. In this case the conditions under which a resolvable design can be obtained by forming the matrix $\bfT$ are a little more involved. We discuss this in Lemma \ref{lemma:resol_ring} in the Appendix.
\end{remark}
%\begin{remark}
%	\label{Rem:ringfield}
%	In Lemma \ref{lemma:Resolve_MDS}, the resolvable design $(X, \calA)$ is produced by a $(n,k)$ linear block code over $GF(q)$. It can be produced by a linear code over a ring, say $\mathbb{Z} \mod q$, with some constraints. We illustrate this in Appendix.  Consider a linear block code over the ring $\mathbb{Z} \mod 6$. It is easy to check that $2$ is a zero divisor in $\mathbb{Z} \mod 6$. Now assume $g_{a^*b}=2$ for some $a^*$ and $b$, and $\bfu_{a^*}g_{a^*b}=\Delta_b-\sum_{a \neq a^*} \bfu_ag_{ab}=0$. Then $\bfu_{a^*}=0$ or $3$, which implies that this equation has more than one solution for $\bfu_{a^*}$ and therefore $\calP_b$ cannot form a parallel class.
%	\litang{I think we should point out that $(n,k)$ code can generate resolvable design if all of non-zero element in $\bfG$ is non-zero divisor in this remark. And say that $GF(q)$ can guarantee that but ring cannot (take an example why it does not). But if we let all of non-zero entries in $\bfG$ over a ring be not zero-divisor we can still construct a resolvable design}
%\end{remark}
%	
%	However, there are situations when it is possible to operate over the ring $\mathbb{Z} \mod q$. For instance, consider the $(k+1,k)$ single parity check (SPC) code over $\mathbb{Z} \mod q$. In its generator matrix, $g_{ab}=0$ or $1$ for $0\le a\le k-1$, $0\le b\le n-1$. Since $1$ is not a zero divisor of the ring $\mathbb{Z} \mod q$, the resolvable design can be constructed. Therefore, $q$ can be any positive integer in this case. There are more such instances that we discuss in Section \ref{sec:more_cons_block}. \aditya{need to discuss carefully in light of recent findings}

\begin{example}
 	\label{eg:resolv_q_3_k_2}
 	Consider a $(4,2)$ linear block code over $GF(3)$ with generator matrix
 	$$
 	\bfG=\begin{bmatrix}
 	1&0&1&1\\
 	0&1&1&2
 	\end{bmatrix}.
 	$$
 	
 	Collecting the nine codewords, $\bfT$ is constructed as follows.
 	$$
 	\bfT=
 	\begin{bmatrix}
 	0&0&0&1&1&1&2&2&2\\
 	0&1&2&0&1&2&0&1&2\\
 	0&1&2&1&2&0&2&0&1\\
 	0&2&1&1&0&2&2&1&0
 	\end{bmatrix}.
 	$$
 	Using $\bfT$, we generate the resolvable block design $(X,\calA)$ where
 	the point set is $X=\{0,1,2,3,4,5,6,7,8\}$. For instance, block $B_{0,0}$ is obtained by identifying the column indexes of zeros in the first row of $\bfT$, i.e., $B_{0,0}=\{0,1,2\}$. Following this, we obtain
 	\begin{align*}
 	\calA=&\{\{0,1,2\},\{3,4,5\},\{6,7,8\},\{0,3,6\},\{1,4,7\},\{2,5,8\},\\
 	&\{0,5,7\}, \{1,3,8\},\{2,4,6\},\{0,4,8\},\{2,3,7\},\{1,5,6\}\}.
 	\end{align*}
 	It can be observed that $\calA$ has a resolution ({\it cf.} Definition \ref{def:resolv_design}) with the following parallel classes.
 	\begin{align*}
 	\calP_0 &=\{\{0,1,2\},\{3,4,5\},\{6,7,8\}\},\\
 	\calP_1 &=\{\{0,3,6\},\{1,4,7\},\{2,5,8\}\},\\
 	\calP_2 &=\{\{0,5,7\},\{1,3,8\},\{2,4,6\}\}, \text{~and}\\
 	\calP_3 &=\{\{0,4,8\},\{2,3,7\},\{1,5,6\}\}.
 	\end{align*}
 \end{example}
%The following lemma shows that the construction procedure above always results in a resolvable design.
%The proof of above lemma appears in the Appendix.
%
%that satisfy a $(k+1, k)$ consecutive column span condition that we define
%
%, which is called \emph{linear block code satisfies partially MDS property}. The resolvable design resulted from this class of code has more properties. It helps us to construct a coded caching scheme with low subpacketization level.

\subsection{A special class of linear block codes}

We now introduce a special class of linear block codes whose generator matrices satisfy specific rank properties. It turns out that resolvable designs obtained from these codes are especially suited for usage in coded caching.

%Consider an $(n,k)$ linear block code over $GF(q)$ and
Consider the generator matrix $\bfG$ of a $(n,k)$ linear block code over $GF(q)$. %Let $\bfG=[g_{ij}]$, where $0\le i\le k-1$, $0\le j\le n-1$.
 The $i$-th column of $\bfG$ is denoted by $\bfg_i$.
%Let $\bfg_i=[g_{i0}, g_{i1},\cdots,g_{i(k-1)}]^T$ be the $i$-th column of $\bfG$.
Let $z$ be the least positive integer such that $k+1$ divides $nz$ (denoted by $k+1~|~nz$). We let $(t)_n$ denote $t~\text{mod}~n$.

In our construction we will need to consider various collections of $k+1$ consecutive columns of $\bfG$ (wraparounds over the boundaries are allowed). For this purpose, let $\calT_a=\{a(k+1),\cdots, a(k+1)+k\}$  ($a$ is a non-negative integer) and $\calS_a= \{(t)_n~|~t\in \calT_a \}$. Let $\bfG_{\calS_a}$ be the $k \times (k+1)$ submatrix of $\bfG$ specified by the columns in $\calS_a$, i.e.,  $\bfg_{\ell}$ is a column in  $\bfG_{\calS_a}$ if $\ell \in \calS_a$.
%Let $\bfG_{\calS_a}=[\bfg_{i_0},\cdots,\bfg_{i_{k}}]$ be the $k \times (k+1)$ submatrix of $\bfG$ specified by the columns in $\calS_a$, i.e.,  $\bfg_{i_j}$ is a column in  $\bfG_{\calS_a}$ if $i_j\in \calS_a$. %\litang{$\bfG_{\calS_a}$ is not a set. $\bfg_{i_j} \in \bfG_{\calS_a}$ looks not good}
Next, we define the $(k,k+1)$-consecutive column property that is central to the rest of the discussion.
%In this work, we consider a $(n,k)$ linear block
%code $\bfG$ satisfies partially MDS property that is defined as below.

%\begin{definition}{\it Partially MDS property.}
\begin{definition}{\it $(k,k+1)$-consecutive column property.}
\label{def:MDSproperty}
Consider the submatrices of $\bfG$ specified by  $\bfG_{\calS_a}$ for $0\le a\le \frac{zn}{k+1}-1$. We say that $\bfG$ satisfies the $(k,k+1)$-consecutive column property if all $k \times k$ submatrices of each $\bfG_{\calS_a}$ are full rank.
% A $k\times (k+1)$ matrix is said to satisfy MDS property if its any $k$ columns are linearly independent.	An $(n,k)$ linear block code is said to satisfy partially MDS property if  every submatrix $\bfG_{\calS_a}$ of $\bfG$, where $0\le a\le \frac{zn}{k+1}-1$, satisfies MDS property.
\end{definition}
Henceforth, we abbreviate the $(k,k+1)$-consecutive column property as $(k,k+1)$-CCP.% or simply by CCP, if the value of $k$ is clear from the context.
\begin{example}
\label{eg:code_k=2_n=4}
In Example \ref{eg:resolv_q_3_k_2} we have $k=2, n=4$ and hence $z=3$. Thus, $\calS_0 = \{0,1,2\}, \calS_1 = \{3,0,1\}, \calS_2 = \{2, 3, 0\}$ and $\calS_3 = \{1,2,3\}$.
The corresponding generator matrix $\bfG$ satisfies the $(k,k+1)$ CCP as any two columns of the each of submatrices $\bfG_{\calS_i}, i = 0, \dots, 3$ are linearly independent over $GF(3)$.
%	\begin{align*}
%    &	
%    \bfG_{\calS_0}=\begin{bmatrix}
%	1&0&1\\
%	0&1&1
%	\end{bmatrix},
%	&
%	\bfG_{\calS_1}=\begin{bmatrix}
%	1&1&0\\
%	2&0&1
%	\end{bmatrix},\\
%	&
%	\bfG_{\calS_2}=\begin{bmatrix}
%	1&1&1\\
%	1&2&0
%	\end{bmatrix},
%	&
%	\bfG_{\calS_3}=\begin{bmatrix}
%	0&1&1\\
%	1&1&2
%	\end{bmatrix}.			
%	\end{align*}
%	any $2$ columns of them are linearly independent.
\end{example}

We note here that one can also define different levels of the consecutive column property. Let $\calT_a^\alpha=\{a\alpha,\cdots, a\alpha+\alpha-1\}$, $\calS_a^\alpha= \{(t)_n~|~t\in \calT_a^\alpha \}$ and $z$ is the least positive integer such that $\alpha| nz$.
\begin{definition}{\emph{$(k,\alpha)$-consecutive column property}}
\label{def:kalphacc}
Consider the submatrices of $\bfG$ specified by $\bfG_{\calS^\alpha_a}$ for $0\le a\le \frac{zn}{\alpha}-1$. We say that $\bfG$ satisfies the $(k,\alpha)$-consecutive column property, where $\alpha \leq k$ if each $\bfG_{\calS^\alpha_a}$ has full rank. In other words, the $\alpha$ columns in each $\bfG_{\calS^\alpha_a}$ are linearly independent.
\end{definition}
As pointed out in the sequel, codes that satisfy the $(k,\alpha)$-CCP, where $\alpha \leq k$ will result in caching systems that have a multiplicative rate gain of $\alpha$ over an uncoded system. %\litang{Until now we did not discuss anything that users $(k,k+1)$ or $(k,\alpha)$-CCP in caching system. Maybe it is not good to discuss coded gain here}
Likewise, codes that satisfy the $(k,k+1)$-CCP will have a gain of $k+1$ over an uncoded system. In the remainder of the paper, we will use the term CCP to refer to the $(k,k+1)$-CCP if the value of $k$ is clear from the context.

\subsection{Usage in a coded caching scenario}
A resolvable design generated from a linear block code that satisfies the CCP can be used in a coded caching scheme as follows. We associate the users with the blocks. Each subfile is associated with a point and an additional index. The placement scheme follows the natural incidence between the blocks and the points; a formal description is given in Algorithm \ref{Alg:Placement} and illustrated further in Example \ref{eg:placement_q_3_k_2}. %We explain the placement scheme by means of the example below. %The delivery scheme leverages the structure imposed by the CCP.

\begin{algorithm}[t]
	\caption{Placement Scheme}
	\label{Alg:Placement}
   \SetKwInOut{Input}{Input}
   \SetKwInOut{Output}{Output}
   \Input{Resolvable design $(X, \calA)$ constructed from a $(n,k)$ linear block code. Let $z$ be the least positive integer such that $k+1 ~|~ nz$.}
   Divide each file $W_n$, for $n \in [N]$ into $q^k z$ subfiles. Thus, $W_n = \{W_{n,t}^s : t \in \{0, \dots, q^k - 1\} \text{~and~} s \in \{0, \dots, z-1\}\}$ \;
   User $U_B$ for $B \in \calA$ caches $Z_B = \{W_{n,t}^s : n \in [N], t \in B \text{~and~} s \in \{0, \dots, z-1\} \}$ \;
   \Output{Cache content of user $U_B$ denoted $Z_B$ for $B \in \calA$.}
\end{algorithm}

%We first demonstrate our proposed placement scheme by using Example \ref{eg:placement_q_3_k_2} below. We associate the users with the blocks and subfiles with the points of the design.
\begin{example}
\label{eg:placement_q_3_k_2}
Consider the resolvable design from Example \ref{eg:resolv_q_3_k_2}, where we recall that $z=3$. The blocks in $\calA$ correspond to twelve users $U_{012}$, $U_{345}$, $U_{678}$, $U_{036}$, $U_{147}$, $U_{258}$, $U_{057}$, $U_{138}$, $U_{246}$, $U_{048}$, $U_{237}$, $U_{156}$. Each file is partitioned into $F_s=9\times z=27$ subfiles, each of which is denoted by $W_{n,t}^s$, $t=0,\cdots,8$, $s=0,1,2$. %One can observe that each subfile is indexed by a subscript $t$, which corresponds to one of nine points. Moreover, we further partition each subfile into $3$ parts, each of which is indexed by an additional superscript $s$, $s=0,1,2$.
The cache in user $U_{abc}$, denoted $Z_{abc}$ is specified as $Z_{abc}=\{W_{n,t}^s~|~t \in \{a,b,c\}, s \in \{0,1,2\} \text{~and~} n \in [N]\}$. %For instance,
%	\begin{align*}
%	Z_{012}=&\{W_{n,t}^s|t \in \{0,1,2\}, s \in \{0,1,2\} \text{~and~} n \in [N] \}
%	\end{align*}
This corresponds to a coded caching system where each user caches $1/3$-rd of each file so that $M/N = 1/3$.
\end{example}
%In general we start with a $(n,k)$ linear block code that satisfies the CCP and $z$ be the least positive integer such that $k+1 ~|~ nz$. We generate the corresponding resolvable design $(X, \calA)$ and associate the users with the blocks so that

In general, (see Algorithm \ref{Alg:Placement}) we have $K = |\calA| = nq$ users. Each file $W_n$, $n\in [N]$ is divided into $q^kz$ subfiles $W_n=\{W_{n,t}^s~|~0\le t\le q^k-1,0\le s\le z-1\}$. A subfile $W_{n,t}^s$ is cached in user $U_B$ where $B \in \calA$ if $t\in B$. Therefore, each user caches a total of $Nq^{k-1}z$ subfiles. As each file consists of $q^k z$ subfiles, we have that $M/N = 1/q$.

It remains to show that we can design a delivery phase
scheme that satisfies any possible demand pattern.
Suppose that in the delivery phase user $U_B$ requests file $W_{d_{B}}$ where $d_B \in [N]$. The server responds by transmitting several equations that satisfy each user. Each equation allows $k+1$ users from {\it different parallel classes}  to simultaneously obtain a missing subfile. Our delivery scheme is such that the set of transmitted equations can be classified into various {\it recovery sets} that correspond to appropriate collections of parallel classes. For example, in Fig. \ref{Fig:Recovery}, $\calP_{\calS_0} = \{\calP_0, \calP_1, \calP_2\}, \calP_{\calS_1} = \{\calP_0, \calP_1, \calP_3\}$ and so on. It turns out that these recovery sets correspond precisely to the sets $\calS_a, 0 \leq a \leq \frac{zn}{k+1} -1$ defined earlier. We illustrate this by means of the example below.



\begin{figure}[t]
		\centering
		\includegraphics[scale=0.8]{Figure2.pdf}
		\caption{Recovery set bipartite graph}
		\label{Fig:Recovery}
\end{figure}

%Define the set of parallel classes $\calP_\calS=\{\calP_i|i\in \calS, |\calS|=k+1\}$ as \emph{recovery set}. %These demands can be satisfied as follows.
\begin{example}
	\label{ex:delivery}	
Consider the placement scheme specified in Example \ref{eg:placement_q_3_k_2}. Let each user $U_B$ request file $W_{d_B}$. The recovery sets are specified by means of the recovery set bipartite graph shown in Fig. \ref{Fig:Recovery}, e.g., $\calP_{\calS_1}$ corresponds to $\calS_1 = \{0,1,3\}$. The outgoing edges from each parallel class are labeled arbitrarily with numbers $0, 1$ and $2$. Our delivery scheme is such that each user recovers missing subfiles with a specific superscript from each recovery set that its corresponding parallel class participates in. For instance, a user in parallel class $\calP_1$ recovers missing subfiles with superscript $0$ from $\calP_{\calS_0}$, superscript 1 from $\calP_{\calS_1}$ and superscript 2 from $\calP_{\calS_3}$; these superscripts are the labels of outgoing edges from $\calP_1$ in the bipartite graph.

%For the requests $W_{d_{012}}$, $W_{d_{345}}$, $W_{d_{678}}$, $W_{d_{036}}$, $W_{d_{147}}$, $W_{d_{258}}$, $W_{d_{057}}$, $W_{d_{138}}$, $W_{d_{246}}$, $W_{d_{048}}$, $W_{d_{237}}$ and $W_{d_{156}}$,
%	we generate several sets of signals transmitted in the delivery phase.
%	Each set of signals can recover missing subfiles of users  $U_B$ in a recovery set $\calP_{\calS_a}$, where $B\in \calP_{\calS_a}$. Firstly we construct recovery sets by recovery set graph in Figure \ref{Fig:Recovery}. Recovery set graph is a bipartite graph $G=(U\cup V,E)$. The vertices of $G$ is partitioned to two sets $U$ and $V$, where $U$ corresponds to $4$ parallel classes in Example \ref{eg:resolv_q_3_k_2}, $V$ corresponds to $\frac{nz}{t+1}=4$ recovery sets. The degree of vertex in $U$ (parallel class) is $z=3$ and the degree of vertex in $V$ (recovery set) is $k+1=3$. Let vertex $\calP_i$ adjacent to vertex $\calP_{\calS_a}$ be an element in recovery set $\calP_{\calS_a}$.  Then the recovery set represented in Figure \ref{Fig:Recovery} is
%	\begin{align*}
%	\calP_{\calS_0}=\{\calP_0,\calP_1,\calP_2\},&~~ \calP_{\calS_1}=\{\calP_3,\calP_0,\calP_1\},\\
%	\calP_{\calS_2}=\{\calP_2,\calP_3,\calP_0\},&~~ \calP_{\calS_3}=\{\calP_1,\calP_2,\calP_3\}.
%	\end{align*}
%	Next we label the $3$ edges adjacent to vertex $\calP_{\calS_a}$ in $U$ as $0$, $1$, $2$. Now for each recovery set, we can generate a set of signals to recover missing subfiles of users in each recovery set. For example, for $\calP_{\calS_1}$, we list the signals that can recover missing subfiles of $U_{012}$ as follows

It can be verified, e.g., that user $U_{012}$ which lies in $\calP_0$ recovers all missing subfiles with superscript $1$ from the equations below.
	\begin{align*}
		&W^1_{d_{012},3}\oplus W^1_{d_{036},2}\oplus W^0_{d_{237},0},&
		W^1_{d_{012},6}\oplus W^1_{d_{036},1}\oplus W^0_{d_{156},0},\\	
		&W^1_{d_{012},4}\oplus W^1_{d_{147},0}\oplus W^0_{d_{048},1},&
		W^1_{d_{012},7}\oplus W^1_{d_{147},2}\oplus W^0_{d_{237},1},\\
		&W^1_{d_{012},8}\oplus W^1_{d_{258},0}\oplus W^0_{d_{048},2},&
		W^1_{d_{012},5}\oplus W^1_{d_{258},1}\oplus W^0_{d_{156},2}.
	\end{align*}
Each of the equations above benefits three users. They are generated simply by choosing $U_{012}$ from $\calP_0$, {\it any} block from $\calP_1$ and the last block from $\calP_3$ so that the {\it intersection of all these blocks is empty}. The fact that these equations are useful for the problem at hand is a consequence of the CCP. The process of generating these equations can be applied to all possible recovery sets. It can be shown that this allows all users to be satisfied at the end of the procedure.
%	It is easy to check that $U_{012}$ recovers all of its missing subfiles with superscript $1$ since $U_{012}$ lies in $\calP_0\in \calP_{\calS_1}$, and the edge $\calP_0\calP_{\calS_1}$ is labeled by $1$. One can observe that in recovery set graph, each $\calP_i$ connects to $3$ distinct recovery sets $\calP_{\calS_j}$ with label $0,1,2$, and therefore the signals generated by recovery sets can recover all of missing subfiles of user with superscripts $0$, $1$, $2$.
	
\end{example}

%The general result can be shown as follows. Each recovery set consists of a subset of parallel classes. We first present a systematic procedure for generating equations corresponding to each recovery set; each equation benefits $k+1$ users. These equations allow each user in parallel class to recover all missing subfiles with a specific superscript. The process is repeated for all the recovery sets. At the end of the procedure, all users are satisfied.

In what follows, we first show that for the recovery set $\calP_{\calS_a}$ it is possible to generate equations that benefit $k+1$ users simultaneously.


%Upon inspection of Example \ref{ex:delivery}, each recovery set contains $k+1$ parallel classes, and it corresponds to a set of signals, which can recover missing subfiles of users in the recovery set with one superscript. In the set of signals, each signal recover $k+1$ missing subfiles of $k+1$ users from $k+1$ distinct parallel classes simultaneously. Moreover, each user can recover all its missing subfiles with $z$ superscripts from $z$ recovery sets. Next we generalize the idea conveyed by this example. Firstly we show that  by chooing $\calS_a$ in Section III.B as indices of recovery set, a set of signals can be generated to recover missing subfiles of users in this covery set with one superscript. Towards this end, the following lemma is required and the prove is referred in Appendix.
%Upon inspection of Example \ref{ex:delivery}, one set of signals recovers the missing subfiles of users from some $k+1$ parallel classes with one superscript. Moreover, each user can always recover its missing subfiles with $z$ superscripts from $z$ sets of signals and hence its request can be satisfied.

%\aditya{needs careful thought to reduce the number of subscripts}
\begin{claim}
\label{claim:MDSintersection}
	Consider the resolvable design $(X, \calA)$ constructed as described in Section III.A by a $(n,k)$ linear block code that satisfies the CCP. Let $\calP_{\calS_a}=\{\calP_i~|~i\in \calS_a\}$ for $0\le a\le \frac{zn}{k+1}-1$, i.e., it is the subset of parallel classes corresponding to $\calS_a$. We emphasize that $|\calP_{\calS_a}| = k+1$. Consider blocks $B_{i_1, l_{i_1}}, \dots, B_{i_{k}, l_{i_{k}}}$ (where $l_{i_j} \in \{0, \dots, q-1\}$) that are picked from any $k$ distinct parallel classes of $\calP_{\calS_a}$. Then, $|\cap_{j=1}^{k} B_{i_j, l_{i_j}}| = 1$.
\end{claim}
Before proving Claim \ref{claim:MDSintersection}, we discuss its application in the delivery phase. Note that the claim asserts that $k$ blocks chosen from $k$ distinct parallel classes intersect in precisely one point. Now, suppose that one picks $k+1$ users from $k+1$ distinct parallel classes, such that their intersection is empty. These blocks (equivalently, users) can participate in an equation that benefits $k+1$ users. In particular, each user will recover a missing subfile indexed by the intersection of the other $k$ blocks. We emphasize here that Claim \ref{claim:MDSintersection} is at the core of our delivery phase. Of course, we need to justify that enough equations can be found that allow all users to recover all their missing subfiles. This follows from a natural counting argument that is made more formally in the subsequent discussion. The superscripts $s \in \{0, \dots, z-1\}$ are needed for the counting argument to go through.
\begin{proof}
Following the construction in Section III.A, we note that a block $B_{i,l} \in \calP_i$ is specified by
$$
B_{i,l} = \{j : \bfT_{i,j} = l\}.
$$
%Let $\bfG=[g_{ab}]$, for $0\le a\le k-1$, $0\le b\le n-1$.

%We note that $\calS_a=\{(a(k+1))_n,\cdots, (a(k+1)+k)_n\}$.
Now consider $B_{i_1, l_{i_1}}, \dots, B_{i_{k}, l_{i_k}}$ (where $i_j \in \calS_a, l_{i_j} \in \{0, \dots, q-1\}$) that are picked from $k$ distinct parallel classes of  $\calP_{\calS_a}$. W.l.o.g. we assume that $i_1 < i_2 < \dots < i_{k}$. Let $\calI =  \{i_1, \dots, i_{k}\}$ and $\bfT_{\calI}$ denote the submatrix of $\bfT$ obtained by retaining the rows in $\calI$. We will show that the vector $[l_{i_1}~l_{i_2}~\dots~l_{i_k}]^T$ is a column in $\bfT_{\calI}$ and only appears once.

To see this  consider the system of equations in variables $\bfu_0, \dots, \bfu_{k-1}$.
\begin{align*}
\sum_{b=0}^{k-1}\bfu_{b}g_{bi_1} &= l_{i_1},\\
%\sum_{b=1}^{k}\bfu_{b}g_{bi_2} &= l_{i_2},\\
\mathrel{\makebox[\widthof{=}]{\vdots}}\\
\sum_{b=0}^{k-1}\bfu_{b}g_{bi_k} &= l_{i_k}.
\end{align*}
By the CCP, the vectors $\bfg_{i_1}, \bfg_{i_2}, \ldots, \bfg_{i_k}$ are linearly independent. Therefore this system of $k$ equations in $k$ variables has a unique solution over $GF(q)$. The result follows.
\end{proof}

%previous algorithm
%\begin{algorithm}[t]
%	\caption{Signal Generation Algorithm}
%	\label{Alg:Signal}
%   \SetKwInOut{Input}{Input}
%   \SetKwInOut{Output}{Output}
%   \Input{Indices of recovery set $
%   	\calS_a$, superscript function $E_a(B)$ for user $U_B \in \calP_j$ where $j \in \calS_a$, signal set $Sig=\emptyset$.}
%   \While{any user $U_B\in \calP_j, j\in \calS_a$ does not recover all its missing subfiles with superscript $E_a(B)$}
%   { Pick users $U_{B_{{i_1},l_{i_1}}}, \dots, U_{B_{{i_{k+1}},l_{i_{k+1}}}}$  where $l_{i_j} \in \{0, \dots, q-1\}, B_{j, l_{i_j}} \in \calP_j$ and $j\in \calS_a=\{i_1,\cdots,i_{k+1}\}$, such that $\cap_{j\in \calS_a} B_{j,l_{i_j}} = \phi$\;
%   	Let $\hat{l}_{s} = \cap_{j \in \calS_a \setminus \{s\}}B_{j,l_j}$ for $s\in \calS_a$\;
%   	Add signal $\oplus_{s \in S_a} W^{E_a(B_{s,l_s})}_{d_{B_{s,l_s}},\hat{l}_s}$ to $Sig$}
%   \Output{Signal set $Sig$.}
%\end{algorithm}


%Putting in revised algorithm to address changes 12/22/17
\begin{algorithm}[t]
\SetNoFillComment
	\caption{Signal Generation Algorithm for $\calP_{\calS_a}$}
	\label{Alg:Signal}
   \SetKwInOut{Input}{Input}
   \SetKwInOut{Output}{Output}
   \Input{For $\calP \in \calP_{\calS_a}$, $E(\calP) = \text{label}(\calP - \calP_{\calS_a})$. Signal set $Sig=\emptyset$.}
   \While{any user $U_B\in \calP_j, j\in \calS_a$ does not recover all its missing subfiles with superscript $E(\calP_j)$}
   {Pick blocks $B_{j,l_j} \in \calP_j$ for all $j \in \calS_a$ and $l_j \in \{0, \dots, q-1\}$ such that $\cap_{j \in \calS_a} B_{j,l_j} = \emptyset$\; \tcc{Pick blocks from distinct parallel classes in $\calP_{\calS_a}$ such that their intersection is empty}
   %{ Pick users $U_{B_{{i_1},l_{i_1}}}, \dots, U_{B_{{i_{k+1}},l_{i_{k+1}}}}$  where $l_{i_j} \in \{0, \dots, q-1\}, B_{j, l_{i_j}} \in \calP_j$ and $j\in \calS_a=\{i_1,\cdots,i_{k+1}\}$, such that $\cap_{j\in \calS_a} B_{j,l_{i_j}} = \phi$\;
   	Let $\hat{l}_{s} = \cap_{j \in \calS_a \setminus \{s\}}B_{j,l_j}$ for $s\in \calS_a$\;
   \tcc{Determine the missing subfile index that the user from $\calP_s$ will recover}
   	%Add signal $\oplus_{s \in S_a} W^{E_a(B_{s,l_s})}_{d_{B_{s,l_s}},\hat{l}_s}$ to $Sig$}
   Add signal $\oplus_{s \in S_a} W^{E(\calP_s)}_{\kappa_{s,l_s},\hat{l}_s}$ to $Sig$
   \tcc{User $U_{B_{s,l_s}}$ demands file $W_{\kappa_{s,l_s}}$. This equation allows it to recover the corresponding missing subfile index $\hat{l}_s$. The superscript is determined by the recovery set bipartite graph}
   }

   \Output{Signal set $Sig$.}
\end{algorithm}
%
%
%\aditya{Need to think carefully about what to do for Algorithm 2 and Claim 2}
%\aditya{Put in new algorithm 2 with reduced indexing and revised the proof of claim 2. Li please read}
%
We now provide an intuitive argument for the delivery phase. Recall that we form a recovery set bipartite graph (see Fig. \ref{Fig:Recovery} for an example) with parallel classes and recovery sets as the disjoint vertex subsets. The edges incident on each parallel class are labeled arbitrarily from $0, \dots, z-1$. For a parallel class $\calP \in \calP_{\calS_a}$ we denote this label by $\text{label}(\calP - \calP_{\calS_a})$. For a given recovery set $\calP_{\calS_a}$, the delivery phase proceeds by choosing blocks from distinct parallel classes in $\calP_{\calS_a}$ such that their intersection is empty; this provides an equation that benefits $k+1$ users.
It turns out that the equation allows a user in parallel class $\calP \in \calP_{\calS_a}$ to recover a missing subfile with the superscript $\text{label}(\calP - \calP_{\calS_a})$.

The formal argument is made in Algorithm \ref{Alg:Signal}. For ease of notation in Algorithm \ref{Alg:Signal}, we denote the demand of user $U_{B_{i,j}}$ for $0 \leq i \leq n-1,0 \leq j \leq q-1$ by $W_{\kappa_{i,j}}$.

%The formal argument is made in Algorithm \ref{Alg:Signal} which operates as follows. It takes as input a recovery set $\calP_{\calS_a}=\{\calP_i~|~i \in \calS_a\}$ and superscript function $E_a(B)$ for each user $U_B$ in $\calP_{\calS_a}$, which indicates the superscript of subfiles of $U_B$ that will be recovered. For any $k+1$ users $U_B$ from $k+1$ distinct parallel classes, if their corresponding blocks have no point in common, they can generate a signal, each of which can recover one missing subfile of $U_B$ with superscript $E_a(B)$. %Claim \ref{claim:signalgenerattion} (see Appendix for proof) demonstrates that the output signals $Sig$ can recover all missing subfiles of user $U_B$, $B\in \calP_{\calS_a}$, with superscript $E_a(B)$, if any $k\times k$ submatrices of $G_{\calS_a}$ are full rank.

%Previous proof of claim
%\begin{claim}
%	\label{claim:signalgeneration}
%	For each user $U_B$ belonging to a parallel class in $\calP_{\calS_a}$ with superscript function $E_a(B)$, the signals generated by Algorithm \ref{Alg:Signal} can recover all the missing subfiles needed by $U_B$ with superscript $E_a(B)$.%, if any $k\times k$ submatrices of corresponding $G_{\calS_a}$ are full rank.
%\end{claim}
%\begin{proof}
%    	In the arguments below, for the sake of convenience we argue that user $U_{B_{i_1,l_{i_1}}}$, $i_1\in \calS_a$ can recover all its missing subfiles with superscript $E_a(B_{i_1,l_{i_1}})$. Note that $|B_{i_1,l_{i_1}}|=q^{k-1}$. Thus, user $U_{B_{i_1,l_{i_1}}}$ needs to obtain $q^k-q^{k-1}$ missing subfiles with superscript $E_a(B_{i_1,l_{i_1}})$. The equation in Algorithm \ref{Alg:Signal} allows $U_{B_{i_1,l_{i_1}}}$ to recover $W^{E_a(B_{i_1,l_{i_1}})}_{d_{B_{i_1,l_{i_1}}},\hat{l}_{i_1}}$ where $\hat{l}_{i_1} = \cap_{j \in \calS_a \setminus \{i_1\}}B_{j,l_j}$. Note that $U_{B_{i_1,l_{i_1}}}$ does not have $W^{E_a(B_{i_1,l_{i_1}})}_{d_{B_{i_1,l_{i_1}}},\hat{l}_{i_1}}$ in its cache since $B_{i_1,l_{i_1}}\bigcap \cap_{j \in \calS_a \setminus \{i_1\}}B_{j,l_j}= \emptyset$.
%    	
%    	Next we count the number of equations that $U_{B_{i_1,l_{i_1}}}$ participates in. We can pick $k-1$ users from parallel classes $\calP_{i_2}, \calP_{i_3}, \cdots, \calP_{i_{k}}$. Claim \ref{claim:MDSintersection} ensures the blocks corresponding to users from $\calP_{i_1}, \cdots, \calP_{i_k}$ intersect in a single point. There are totally $q^{k-1}$ ways to pick them. Next we pick a block from $\calP_{i_{k+1}}$ such that the intersection of all blocks is empty. This can be done in $q-1$ ways. Thus there are a total of $q^{k-1}(q-1)$ equations in which user $U_{B_{i_1,l_{i_1}}}$ participates in.
%    	
%    	It remains to argue that each equation provides a distinct file part of user $U_{B_{i_1,l_{i_1}}}$ with superscript $E_a(B_{i_1,l_{i_1}})$. Towards this end suppose that there exist sets of blocks $\{B_{i_2,l_{i_2}},\dots, B_{i_{k+1},l_{i_{k+1}}}\}$ and $\{B_{i_2,l'_{i_2}}, \dots, B_{i_{k+1},l'_{i_{k+1}}}\}$ such that $\{B_{i_2,l_{i_2}}, \dots, B_{i_{k+1},l_{i_{k+1}}}\}\neq \{B_{i_2,l'_{i_2}}, \dots, B_{i_{k+1},l'_{i_{k+1}}}\}$, but $\cap_{j=2}^{k+1} B_{i_j,l_{i_j}}=\cap_{j=2}^{k+1} B_{i_j,l'_{i_j}}=\beta$. This is a contradiction since this in turn implies that $\beta \in \cap_{j=2}^{k+1} B_{i_j,l_{i_j}}\bigcap \cap_{j=2}^{k+1} B_{i_j,l'_{i_j}}$, which is impossible since two blocks from the same parallel class have an empty intersection.
%\end{proof}

%New proof based on revised algorithm.
\begin{claim}
\label{claim:signalgeneration}
Consider a user $U_B$ belonging to parallel class $\calP \in \calP_{\calS_a}$. The signals generated in  Algorithm \ref{Alg:Signal} can recover all the missing subfiles needed by $U_B$
with superscript $E(\calP)$.
	%For each user $U_B$ belonging to a parallel class in $\calP_{\calS_a}$ with superscript function $E_a(B)$, the signals generated by Algorithm \ref{Alg:Signal} can recover all the missing subfiles needed by $U_B$ with superscript $E_a(B)$.%, if any $k\times k$ submatrices of corresponding $G_{\calS_a}$ are full rank.
\end{claim}
\begin{proof}
    Let $\calP_\alpha \in \calP_{\calS_a}$. In the arguments below, we argue that user $U_{B_{\alpha,l_\alpha}}$ that demands file $W_{\kappa_{\alpha,l_\alpha}}$ can recover all its missing subfiles with superscript $E(\calP_\alpha)$.
    Note that $|B_{\alpha,l_\alpha}| = q^{k-1}$. Thus, user $U_{B_{\alpha,l_{\alpha}}}$ needs to obtain $q^k-q^{k-1}$ missing subfiles with superscript $E(\calP_\alpha)$.
    Consider an iteration of the while loop where block $B_{\alpha,l_\alpha}$ is picked in step 2.
    The equation in Algorithm \ref{Alg:Signal} allows it to recover $W^{E(\calP_\alpha)}_{\kappa_{\alpha,l_\alpha},\hat{l}_{\alpha}}$ where $\hat{l}_{\alpha} = \cap_{j \in \calS_a \setminus \{\alpha\}}B_{j,l_j}$.
    This is because $\cap_{j \in \calS_a} B_{j,l_j} = \emptyset$ and because of Claim \ref{claim:MDSintersection}.

    %Note that $U_{B_{i_1,l_{i_1}}}$ does not have $W^{E_a(B_{i_1,l_{i_1}})}_{d_{B_{i_1,l_{i_1}}},\hat{l}_{i_1}}$ in its cache since $B_{i_1,l_{i_1}}\bigcap \cap_{j \in \calS_a \setminus \{i_1\}}B_{j,l_j}= \emptyset$.
    	
    Next we count the number of equations that $U_{B_{\alpha,l_{\alpha}}}$ participates in. We can pick $k-1$ users from some $k-1$ distinct parallel classes in $\calP_{\calS_a}$. This can be done in $q^{k-1}$ ways. Claim \ref{claim:MDSintersection} ensures that the blocks so chosen intersect in a single point. Next we pick a block from the only remaining parallel class in $\calP_{\calS_a}$ such that the intersection of all blocks is empty. This can be done in $q-1$ ways. Thus, there are a total of $q^{k-1}(q-1) = q^k - q^{k-1}$ equations in which user $U_{B_{\alpha,l_\alpha}}$ participates in.
    	
    It remains to argue that each equation provides a distinct subfile. Towards this end, let $\{i_1, \dots, i_k\} \subset \calS_a$ be an index set such that $\alpha \notin \{i_1, \dots, i_k\}$. Suppose that there exist sets of blocks $\{B_{i_1,l_{i_1}},\dots, B_{i_{k},l_{i_{k}}}\}$ and $\{B_{i_1,l'_{i_1}}, \dots, B_{i_{k},l'_{i_{k}}}\}$ such that $\{B_{i_1,l_{i_1}}, \dots, B_{i_{k},l_{i_{k}}}\}\neq \{B_{i_1,l'_{i_1}}, \dots, B_{i_{k},l'_{i_{k}}}\}$, but $\cap_{j=1}^{k} B_{i_j,l_{i_j}}=\cap_{j=1}^{k} B_{i_j,l'_{i_j}}=\beta$. This is a contradiction since this in turn implies that $\beta \in \cap_{j=2}^{k+1} B_{i_j,l_{i_j}}\bigcap \cap_{j=2}^{k+1} B_{i_j,l'_{i_j}}$, which is impossible since two blocks from the same parallel class have an empty intersection.

    As the algorithm is symmetric with respect to all blocks in parallel classes belonging to $\calP_{\calS_a}$, we have the required result.
\end{proof}


%The proof of the above claim appears in the Appendix.
%For each recovery set $\calP_{\calS_a}$, the superscript function $E_a(B)$ of a user $U_B$ in parallel class $\calP \in \calP_{\calS_a}$ is obtained by the bipartite recovery set graph (see Fig. \ref{Fig:Recovery} for %an example).
The overall delivery scheme  repeatedly applies Algorithm \ref{Alg:Signal} to each of the recovery sets.
\begin{lemma}
	\label{lemma:delivery}
%	In the delivery phase, for $0\le a\le \frac{zn}{k+1}-1$, operating Algorithm $\ref{Alg:Signal}$ with input $\calP_{\calS_a}$ and	 $E_a(B_{(t)_n,j})={\lfloor\frac{t}{n}\rfloor}$, $t\in \calT_a$,%$
%	the output signals
	The proposed delivery scheme terminates and allows each user's demand to be satisfied. Furthermore the transmission rate of the server is $\frac{(q-1)n}{k+1}$ and the subpacketization level is $q^kz$.
\end{lemma}
\begin{proof}
See Appendix.
\end{proof}
%The proof of the above claim appears in the Appendix.
The main requirement for Lemma \ref{lemma:delivery} to hold is that the recovery set bipartite graph be biregular, where multiple edges between the same pair of nodes is disallowed and the degree of each parallel class is $z$. It is not too hard to see that this follows from the definition of the recovery sets (see the proof in the Appendix for details).

In an analogous manner, if one starts with the generator matrix of a code that satisfies the $(k,\alpha)$-CCP for $\alpha \leq k$, then we can obtain the following result which is stated below. The details are quite similar to the discussion for the $(k,k+1)$-CCP and can be found in the Appendix (Section \ref{sec:kalpha_ccp_matrices}).
\begin{corollary}
Consider a coded caching scheme obtained by forming the resolvable design obtained from a $(n,k)$ code that satisfies the $(k,\alpha)$-CCP where $\alpha \leq k$. Let $z$ be the least positive integer such that $\alpha ~|~nz$. Then, a delivery scheme can be constructed such that the transmission rate is $\frac{(q-1)n}{\alpha}$ and the subpacketization level is $q^kz$. %\aditya{Li, check this} \litang{I have check it}
\end{corollary}

\subsection{Obtaining a scheme for $M/N = 1 - \frac{k+1}{nq}$.}
The construction above works for a system where $M/N=1/q$. It turns out that this can be converted into a scheme for $\frac{M}{N} = 1 - \frac{k+1}{nq}$. Thus, any convex combination of these two points can be obtained by memory-sharing.
%\begin{claim}
%	\label{claim:symmcache}
%	Consider a caching system with $K$ users, cache fraction $\frac{M}{N}$ and subpacketization level $F_s$. Suppose that in the delivery phase, this system transmits $\Delta$ equations, each of which allows $g$ different users to simultaneously obtain a single missing subfile. Then there exists another coded caching system with $K'=K$ users, cache fraction $\frac{M'}{N'}=\frac{K-g}{K}$ and subpacketization level $F'_s=\Delta$. Furthermore, this system requires the transmission of $\Delta'$ equations, each of which allows $g'=K(1-\frac{M}{N})$ users to simultaneously recover missing subfiles. The overall transmission rate is thus ${F_s}/{\Delta}$.
%\end{claim}

Towards this end, we note that the class of coded caching schemes considered here can be specified by an \emph{equation-subfile} matrix. This is inspired by the hypergraph formulation and the placement delivery array (PDA) based schemes for coded caching in \cite{shangguan2016centralized} and \cite{yan_et_al17}. Each equation is assumed to be of the all-but-one type, i.e., it is of the form $W_{d_{t_1},\calA_{j_1}} \oplus W_{d_{t_2},\calA_{j_2}} \oplus \cdots \oplus W_{d_{t_{m}},\calA_{j_{m}}}$ where for each $\ell \in [m]$, we have the property that user $U_{t_\ell}$ does not cache subfile $W_{n,\calA_{j_\ell}}$ but caches all subfiles $W_{n,\calA_{j_s}}$ where $\{j_s : s \in [m], s \neq \ell\}$. %\aditya{usage of gsubi here is not good notation}

The coded caching system corresponds to a $\Delta\times F_s$ equation-subfile matrix $\bfS$ as follows. We associate each row of $\bfS$ with an equation and each column with a subfile. We denote the $i$-th row of $\bfS$ by $Eq_i$ and $j$-th column of $\bfS$ by $\calA_j$. The value $\bfS(i,j)=t$ if in the $i$-th equation, user $U_t$ recovers subfile $W_{d_t,\calA_j}$, otherwise, $\bfS(i,j)=0$. Suppose that these $\Delta$ equations allow each user to satisfy their demands, i.e., $\bfS$ corresponds to a valid coded caching scheme. It is not too hard to see that the placement scheme can be obtained by examining $\bfS$. Namely, user $U_t$ caches the subfile corresponding to the $j$-th column if integer $t$ does not appear in the $j$-th column.


%\aditya{need to redo example}

%Consider a caching system with parameters $K$, $F_s$, where each user caches $L_i$ subfiles, $1\le i\le K$. Firstly, we formulate this coded caching scheme. In the placement phase, each file $W_{n}$ is partitioned into $F_s$ subfiles and we denote the subfile as $W_{n,\calA_j}$ where $\calA_j$ is denoted by the set of users that cache this subfile, and $1\le j\le F_s$. \litang{change $\calA$ to $\calA_j$ } \aditya{question raised before. What if there are multiple such subfiles that are cached by the same set of users}. In the delivery phase,  $\Delta$ equations $Eq_{i}$ are transmitted from server and $Eq_{i}$ recovers $g_i$ missing subfiles simultaneously. Note that we assume each equation is of the all-but-one type if it is of the form $W_{d_{t_1},\calA_{j_1}} \oplus W_{d_{t_2},\calA_{j_2}} \oplus \cdots \oplus W_{d_{t_{g_i}},\calA_{j_{g_i}}}$ where for each $\ell \in [g_i]$, we have $t_\ell \notin \calA_{j_\ell}$ and $t_\ell \in \cap_{j_s : s \in [g_i], s \neq \ell} \calA_{j_s}$.
%For the above coded caching system, it corresponds to a $\Delta\times F_s$ equation-subfile matrix as follows.  We associate each row of $\bfS$ with an equation and each column with a subfile. The value $\bfS(i,j)=t$ if in $i$-th equation, user $U_t$ recovers subfile $W_{d_t,\calA_j}$, otherwise, $\bfS(i,j)=0$. We denote the $i$-th row of $\bfS$ be $Eq_i$ and $j$-th column of $\bfS$ be $\calA_j$.

\begin{example}
	\label{ex:lemmablock}
	Consider a coded caching system in \cite{maddahN14} with $K=4$, $\Delta=4$ and $F_s=6$. We denote the four users as $U_1, U_2, U_3, U_4$.
 Suppose that the equation-subfile matrix $\bfS$ for this scheme is as specified below.
	\begin{align*}
	\bordermatrix{~ & \calA_1 & \calA_2 & \calA_3 & \calA_4 & \calA_5 & \calA_6 \cr
		Eq_1 & 3 & 2 & 0 & 1 & 0 & 0\cr
		Eq_2 & 4 & 0 & 2 & 0 & 1 & 0\cr
		Eq_3 & 0 & 4 & 3 & 0 & 0 & 1\cr
		Eq_4 & 0 & 0 & 0 & 4 & 3 & 2\cr}.
	\end{align*}
Upon examining $\bfS$ it is evident for instance that user $U_1$ caches subfiles $\calA_1, \dots, \calA_3$ as the number $1$ does not appear in the corresponding columns. Similarly, the cache placement of the other users can be obtained. Interpreting this placement scheme in terms of the user-subfile assignment, it can be verified that the design so obtained corresponds to the transpose of the scheme considered in Example \ref{eq:eg_2_intro} (and also to the scheme of \cite{maddahN14} for $K=4$, $M/N = 1/2$).
 %
% In the placement phase, we partition each file $W_n$ into $6$ subfiles $\{W_{n,\calA_i}||\calA_i|=2, \calA_i\in [4]\}$ and cache content of users are specified as follows.
%	\begin{align*}
%	Z_1&=\{W_{n,12}, W_{n,13}, W_{n,14}\}_{n=1}^{N}\\
%	Z_2&=\{W_{n,12}, W_{n,23}, W_{n,24}\}_{n=1}^{N}\\
%	Z_3&=\{W_{n,13}, W_{n,23}, W_{n,34}\}_{n=1}^{N}\\
%	Z_4&=\{W_{n,14}, W_{n,24}, W_{n,34}\}_{n=1}^{N}
%	\end{align*}
%	In the delivery phase, the server transmits $4$ equations
%	\begin{align*}
%	W_{d_1, 23}+W_{d_2, 13}+W_{d_3, 12}&;\\
%	W_{d_1, 24}+W_{d_2, 14}+W_{d_4, 12}&;\\
%	W_{d_1, 34}+W_{d_3, 14}+W_{d_4, 13}&;\\
%	W_{d_2, 34}+W_{d_3, 24}+W_{d_4, 23}&.
%	\end{align*}
%	to recover all of missing subfiles. By above four equations, we construct equation-subfile matrix $\bfS$ as follows.
%	\begin{align*}
%	\bordermatrix{~ & \calA_1 & \calA_2 & \calA_3 & \calA_4 & \calA_5 & \calA_6 \cr
%		Eq_1 & 3 & 2 & 0 & 1 & 0 & 0\cr
%		Eq_2 & 4 & 0 & 2 & 0 & 1 & 0\cr
%		Eq_3 & 0 & 4 & 3 & 0 & 0 & 1\cr
%		Eq_4 & 0 & 0 & 0 & 4 & 3 & 2\cr}
%	\end{align*}
%	%to recover all of missing subfiles. By above four equations, we construct four pairs, $Eq_1, Eq_2, Eq_3, Eq_4$, where
%	%\begin{align*}
%	%E_{X_1}=\{1,2,3\},&E_{\calA_1}=\{\{23\},\{13\},\{12\}\};\\
%	%E_{X_2}=\{1,2,4\},&E_{\calA_2}=\{\{24\},\{14\},\{12\}\};\\
%	%E_{X_3}=\{1,3,4\},&E_{\calA_3}=\{\{34\},\{14\},\{13\}\};\\
%	%E_{X_4}=\{2,3,4\},&E_{\calA_4}=\{\{34\},\{24\},\{23\}\}.
%	%\end{align*}
\end{example}


%At this point we have established equation-subfile matrix and pointed out that a coded caching scheme corresponds to an equation-subfile matrix. Next we show that an equation-subfile corresponds to a coded caching scheme if the conditions in following lemma satisfy.
%We say that an equation is of the all-but-one type if it is of the form $W_{d_{i_1},\calA_{i_1}} \oplus W_{d_{i_2},\calA_{i_2}} \oplus \cdots \oplus W_{d_{i_g},\calA_{i_g}}$ where for each $\ell \in [g]$, we have $i_\ell \notin \calA_{i_\ell}$ and $i_\ell \in \cap_{i_j : j \in [g], j \neq \ell} \calA_{i_j}$. Furthermore, we say that such an equation benefits $g$ users.
\begin{lemma}
	\label{lemma:symmcache}
	Consider a $\Delta\times F_s$ equation-subfile matrix $\bfS$ whose entries belong to the set $\{0, 1, \dots, K\}$. It corresponds to a valid coded caching system if the following three conditions are satisfied.
	\begin{itemize}
		\item There is no non-zero integer appearing more than once in each column.
		\item There is no non-zero integer appearing more than once in each row.
		\item If $\bfS(i_1,j_1)=\bfS(i_2,j_2)\neq 0$, then $\bfS(i_1,j_2)=\bfS(i_2,j_1)=0$.
	\end{itemize}

	%with $K$ users, where $t$-th user caches $\frac{M_t}{N}$ fraction of all subfiles, $F_s$ subfiles, where $i$-th subfile is cached in $L_i$ users, $1\le i\le F_s$, and $\Delta$ equations, where $j$-th equation recovers $g_j$ subfiles, $1\le j\le \Delta$. The transpose of $\bfS$, $\bfS^T$., corresponds to a coded caching system with $K$ users, where $t$-th user caches $\frac{M'_t}{N}=1-\frac{F_s}{\Delta}(1-\frac{M_t}{N})$ fraction of all subfiles, $\Delta$ subfiles, where $i$-th subfile is cached in $L'_i=K-g_i$ users, $1\le i\le \Delta$, and $F_s$ equations, where each equation benefits $g'_j=K-L_j$ users, $1\le j\le F_s$. Furthermore, the users corresponds points set $[K]$ and  the subfiles corresponds to $\Delta$ blocks  $B'_i$, where $B'_i$ contains the points that does not appear in $i$-th row of $\bfS$, i.e., $B'_i=\{t: t\in X, t\neq \bfS(i,j), 1\le j\le F_s\}$. In the delivery phase, suppose the set of columns of non-zero entries in row $Eq'_j$ of $\bfS^T$ be $\calE'_j$. For each row $Eq'_j$ in $\bfS^T$, server transmits
	%\begin{align*}
	%\oplus_{i\in \calE'_j} W_{d_{\bfS^T(i,j)}, B'_i}
	%\end{align*}
\end{lemma}
\begin{proof}
The placement scheme is obtained as discussed earlier, i.e., user $U_t$ caches subfiles $W_{n,\calA_j}$ if integer $t$ does not appear in column $\calA_j$. Therefore, matrix $\bfS$ corresponds to a placement scheme.

Next we discuss the delivery scheme. Note that $Eq_i$ corresponds to an equation as follows.
$$W_{d_{t_1},\calA_{j_1}} \oplus W_{d_{t_2},\calA_{j_2}} \oplus \cdots \oplus W_{d_{t_{m}},\calA_{j_{m}}},$$
where $\bfS(i,j_1)=t_1,\cdots, \bfS(i,j_{m})=t_{m}$. The above equation can allow $m$ users to recover subfiles simultaneously if (a) $U_{t_\ell}$ does not cache $W_{n,\calA_{j_\ell}}$ and (b) $U_{t_\ell}$ caches all $W_{n,\calA_{j_s}}$ where $\{j_s : s \in [m], s \neq \ell \}$. It is evident that $U_{t_\ell}$ does not cache $W_{n,\calA_{j_\ell}}$ owing to the placement scheme. Next, to guarantee the condition (b), we need to show that integer $t_\ell=\bfS(i,j_\ell)$ will not appear in column $\calA_{j_s}$ in $\bfS$ where $\{j_s : s \in [m], s \neq \ell\}$. Towards this end, $t_\ell \neq \bfS(i,j_s)$ because of Condition 2. Next, consider the non-zero entries that lie in the column $\calA_{j_s}$ but not in the row $Eq_i$. Assume there exists an entry $\bfS(i',j_s)$ such that $\bfS(i',j_s)=\bfS(i,j_\ell)=t_\ell$ and $i'\neq i$, then $\bfS(i,j_s)=t_s\neq 0$, which is a contradiction to Condition 3. Finally, Condition 1 guarantees that each missing subfile is recovered only once.
\end{proof}
User $U_t$ caches a fraction $\frac{M_t}{N}=\frac{L_t}{F_s}$ where $L_t$ is the number of columns of $\bfS$ that do not have the entry $t$. Similarly, the transmission rate is given by $R=\frac{\Delta}{F_s}$.


%We point out that the equation-subfile matrix is different from the placement delivery array in \cite{yan_et_al17} although they have very similar properties. The placement delivery array can be viewed as a subfile-user matrix where the columns and rows are associated with subfiles and users respectively.
%The system specified by $\bfS$ has $K$ users and $F_s$ subfiles. %In the placement phase, user $U_t$ caches subfiles $W_{n,\calA}$ if integer $t$ does not appear in the column of $\bfS$ corresponding to subfile $W_{n,\calA}$.


%In the delivery phase, suppose the set of columns of non-zero entries in row $Eq_i$ of $\bfS$ be $\calE_i$. For each row $Eq_i$ in $\bfS$, server transmits
%\begin{align*}
%\oplus_{j\in \calE_i} W_{d_{\bfS(i,j)}, \calA_j}
%\end{align*}
%Suppose $Eq_i$ can recover $g_i$ subfiles simultaneously, $|\calE_i|=g_i$. By transmitting $\Delta$ equations corresponding to $\Delta$ rows of $\bfS$, all missing subfiles can be recovered. Then the transmission rate is $R=\frac{\Delta}{F_s}$.

The crucial point is that the transpose of $\bfS$, i.e., $\bfS^T$ also corresponds to a coded caching scheme. This follows directly from the fact that $\bfS^T$ also satisfies the conditions in Lemma \ref{lemma:symmcache}. In particular, $\bfS^T$ corresponds to a coded caching system with $K$ users and $\Delta$ subfiles. In the placement phase, the cache size of $U_t$ is $\frac{M'_t}{N}=\frac{\Delta-F_s+L_t}{\Delta}$. In the delivery phase, by transmitting $F_s$ equations corresponding to the rows of $\bfS^T$, all missing subfiles can be recovered. Then, the transmission rate is $R'=\frac{F_s}{\Delta}$.

Applying the above discussion in our context, consider the equation-subfile matrix $\bfS$ corresponding to the coded caching system with $K=nq$, $\frac{M_t}{N}=\frac{1}{q}$ for $1\le t\le nq$, $F_s=q^kz$ and $\Delta= q^k(q-1)\frac{nz}{k+1}$. Then $\bfS^T$ corresponds to a system with $K'=nq$, $\frac{M'}{N}=1-\frac{k+1}{nq}$, $F'_s=(q-1)q^k\frac{zn}{k+1}$, and transmission rate $R'=\frac{F_s}{\Delta}=\frac{k+1}{(q-1)n}$. The following theorem is the main result of this paper.
\begin{theorem}
	\label{them:main}
	Consider a $(n,k)$ linear block code over $GF(q)$ that satisfies the $(k,k+1)$ CCP. This corresponds to a coded caching scheme with $K=nq$ users, $N$ files in the server where each user has a cache of size $M \in \bigg{\{} \frac{1}{q}N,\bigg{(}1-\frac{k+1}{nq}\bigg{)}N \bigg{\}}$. Let $z$ be the least positive integer such that $k+1~|~nz$. When $\frac{M}{N}=\frac{1}{q}$, we have
	\begin{align*}
		R&=\frac{(q-1)n}{k+1}, \text{~and}\\
		F_s&=q^kz.
	\end{align*}
	When $\frac{M}{N}=(1-\frac{k+1}{nq})$, we have
	\begin{align*}
		R&=\frac{k+1}{(q-1)n}, \text{~and}\\
		F_s&=(q-1)q^k\frac{zn}{k+1}.
	\end{align*}
By memory sharing any convex combination of these points is achievable.
\end{theorem}


In a similar manner for the $(n,k)$ linear block code that satisfies the $(k,\alpha)$-CCP over $GF(q)$, the caching system where $M/N=1/q$ can be converted into a system where $K'=nq$, $\frac{M'}{N'}=1-\frac{\alpha}{nq}$, $F_s'=(q-1)q^k\frac{zn}{\alpha}$ and $R'=\frac{\alpha}{(q-1)n}$ using the equation-subfile technique. The arguments presented above apply with essentially no change.

%\aditya{At this point we should invoke prior lemmas and state that the proof of the main theorem is complete.}


%Recall that in the caching system with $K=nq$, $\frac{M}{N}=\frac{1}{q}$. In the placement phase, each file is partitioned into $F_s=q^kz$ subfiles. In the delivery phase, server transmits $E=(q-1)q^k\frac{zn}{k+1}$ equations, each of which recovers $g=k+1$ subfiles simultaneously, to recover missing subfiles of all users. By Claim \ref{claim:symmcache}, there exists another caching system with $K'=nq$, $\frac{M'}{N'}=\frac{nq-(k+1)}{nq}=1-\frac{k+1}{nq}$, $F'_s=(q-1)q^k\frac{zn}{k+1}$, $E'=q^kz$, $g'=nq(1-\frac{1}{q})=nq-n$. And thus the transmission rate $R'=\frac{E'}{F'_s}=\frac{F_s}{E}=\frac{k+1}{(q-1)n}$.

%The following theorem is the main result of this paper. \aditya{do we really need it as a separate one because of space issues?}
%  \begin{theorem}
%	\label{them:main}
%	Consider one $(n,k)$ linear block code over $GF(q)$ satisfies the $(k,k+1)$ CCP. It associates to a coded caching scheme with $K=nq$ users. Suppose that $N$ file in the server and each user has a cache of size $M=\{\frac{1}{q}N,(1-\frac{k+1}{nq})N\}$.
%	
%	For cache size $M=\frac{1}{q}N$,
%	\begin{align*}
%	R&=\frac{(q-1)n}{k+1};\\
%	F_s&=q^kz,
%	\end{align*}
%	where $z$ is the least integer such that $k+1|nz$.
%	
%	For cache size $M=(1-\frac{k+1}{nq})N$,
%	\begin{align*}
%	R&=\frac{k+1}{(q-1)n};\\
%	F_s&=(q-1)q^k\frac{zn}{k+1},
%	\end{align*}
%	Futhermore, by memory sharing technique in \cite{maddahN14}, the lower convex envelope of these points is achievable.
%\end{theorem}


\section{Some classes of linear codes that satisfy the CCP}
\label{sec:LinearCode}
At this point we have established that linear block codes that satisfy the CCP are attractive candidates for usage in coded caching. In this section, we demonstrate that there are a large class of generator matrices that satisfy the CCP. For most of the section we work with matrices over a finite field of order $q$. In the last subsection, we discuss some constructions for matrices over $\mathbb{Z} \mod q$ when $q$ is not a prime or prime power. We summarize the constructions presented in this section in Table \ref{Table:construction}.
%	\begin{table}[t]
%	\begin{center}	
%		\begin{tabular}{|c|c|c|c|}
%			\hline
%			\hline
%			 & Code construction & Constraint & CCP property \\
%			\hline
%			\hline
%			\multirow{5}{*}{Codes over field} & MDS codes  & MDS conjecture & $(k,k+1)$-CCP\\
%			\cline{2-4}
%			 & Cyclic codes  & Some generator matrix properties & $(k,k+1)$-CCP  \\
%			\cline{2-4}
%			  & Cyclic codes  & No constraint & $(k,k)$-CCP  \\
%			\cline{2-4}
%			  & Kronecker product of small codes  &Parameter constraint of small codes &  $(k,k)$-CCP and $(k,k+1)$-CCP\\
%			\cline{2-4}
%			 &Other constructions&& $(k,k)$-CCP and $(k,k+1)$-CCP\\
%			\hline
%			\hline
%			\multirow{3}{*}{Codes over ring}  & SPC code  &$n=k+1$& $(k,k+1)$-CCP \\
%			\cline{2-4}
%			   & Cyclic codes over ring  &No constraint&$(k,k)$-CCP  \\
%			\cline{2-4}
%			  & Other constructions  & &$(k,k+1)$-CCP \\
%			\hline
%			\hline
%		\end{tabular}
%	\end{center}
%	\caption{\label{Table:construction} List of constructions in Section \ref{sec:LinearCode}}
%\end{table}

{
	\renewcommand{\arraystretch}{1.5}
	\begin{table*}[t]
	\begin{center}
		\begin{tabular}{|p{3cm}|p{5cm}|p{7cm}|}
			\hline
			\hline
			 {\bf Code type} & {\bf Code construction} & {\bf Notes}  \\
			\hline
			\hline
			\multirow{5}{*}{Codes over field $GF(q)$} & $(n,k)$ MDS codes  & Satisfy $(k,k+1)$-CCP. Need $q+1 \geq n$. \\
			\cline{2-3}
			 & $(n,k)$ Cyclic codes  & Existence depends on certain properties of the generator polynomials. All cyclic codes satisfy the $(k,k)$-CCP. Need additional conditions for the $(k,k+1)$-CCP.  \\
			\cline{2-3}
			  & Kronecker product of $z \times \alpha$ matrix satisfying the $(z,z)$-CCP with the identity matrix $\bfI_{t \times t}$ & Satisfy the $(k,k)$-CCP where $k=tz$.\\
			\cline{2-3}
			 & Kronecker product of Vandermonde and Vandermonde-like matrices with structured base matrices & Satisfy the $(k,k+1)$-CCP for certain parameters.\\
            \cline{2-3}
            & CCP matrix extension & Extends a $k \times n$ CCP matrix to a $k \times (n + s(k+1))$ CCP matrix for integer s.\\
			\hline
			\hline
			\multirow{3}{*}{Codes over ring $\mathbb{Z} \mod q$}  & Single parity-check (SPC) code  & Satisfy the $(k,k+1)$-CCP with $n=k+1$. \\
			\cline{2-3}
			   & Cyclic codes over the ring  & Require that $q = q_1 \times q_2 \times \dots \times q_d$ where $q_i$'s are prime. Satisfy the $(k,k)$-CCP.  \\
			\cline{2-3}
			  & Kronecker product of $z \times \alpha$ matrix satisfying the $(z,z)$-CCP with the identity matrix $\bfI_{t \times t}$ & Satisfy the $(k,k)$-CCP property where $k=tz$.\\
			\cline{2-3}
            & CCP matrix extension & Extends a $k \times n$ CCP matrix to a $k \times (n + s(k+1))$ CCP matrix for integer s.\\
			\hline
			\hline
		\end{tabular}
	\end{center}
	\caption{\label{Table:construction} A summary of the different constructions of CCP matrices in Section \ref{sec:LinearCode}}
\end{table*}
}

\subsection{Maximum-distance-separable (MDS) codes}
\label{sec:MDS_cons}
$(n,k)$-MDS codes with minimum distance $n-k+1$ are clearly a class of codes that satisfy the CCP. In fact, for these codes any $k$ columns of the generator matrix can be shown to be full rank. Note however, that MDS codes typically need large field size, e.g., $q +1 \geq n$  (assuming that the MDS conjecture is true)\cite{RonRoth}. In our construction, the value of $M/N = 1/q$ and the number of users is $K = nq$. Thus, for large $n$, we will only obtain systems with small values of $M/N$, or equivalently large values of $M/N$ (by Theorem \ref{them:main} above). This may be restrictive in practice.

%\aditya{moving SPC stuff to new subsection}
%
%However, the $(k+1,k)$ SPC code which is a trivial instance of a MDS code can be defined over the additive group $\mathbb{Z} \mod q$ (where $q$ is not necessarily prime or a prime power). It is not too hard to see that the corresponding generator matrix $\bfG_{SPC} = [ I ~|~ \mathds{1}]$ satisfies the CCP. This results in a coded caching system with $K = (k+1)q, M/N = 1/q$ and $F = q^{k}$ with any integer value of $q$.

%More generally, we can find several classes of cyclic codes that satisfy the CCP.

%\subsection{MDS code}
%    Consider an $(n, k)$ linear block code $\mathbf C$. Code $\mathbf C$ is called a maximum distance separable (MDS) code, if its minimum Hamming distance $d$ meets the Singleton bound, i.e.,
%    \begin{align*}
%    d&=n-k+1.
%    \end{align*}
%    $(n,k)$ MDS code over $GF(q)$ always exists if $n\le q$.
%    One characterization of $(n,k)$ MDS codes, using generator matrix, namely,
%    \begin{theorem}
%    	\label{them:MDSproperty}
%    	Any $k$ columns of a generator matrix for MDS code are linearly independent.
%    \end{theorem}
%
%    By Theorem \ref{them:MDSproperty}, any $k\times (k+1)$ submatrix of generator matrix of MDS code satisfies MDS property and therefore MDS code is one class of code satisfies partially MDS property.
%
%    Consider an $(n,k)$ MDS code over $GF(q)$ where $q\ge n$. By Theorem \ref{them:main}, we can construct one coded caching scheme with $K=nq$, $\frac{M}{N}=\frac{1}{q}$ or $\frac{M}{N}=1-\frac{k+1}{nq}$, where $q\ge n$ is a prime power. $(k+1,k)$ single parity-check(SPC) code over $\mathbb Z_q$ is a special case of MDS code. As Remark 1 in Appendix, it corresponds to a coded caching scheme with $K=(k+1)q$, $\frac{M}{N}=\frac{1}{q}$ or $1-\frac{1}{q}$, where $q$ is a positive integer by Theorem \ref{them:main}.
%
%     One problem of MDS code is $q$ is increasing linearly with $n$(except SPC code case). It results that for large number of users $K$, the above caching scheme works for very small or large cache size.

\subsection{Cyclic Codes}
     A cyclic code is a linear block code, where the circular shift of each codeword is also a codeword \cite{lincostello}. A $(n,k)$ cyclic code over $GF(q)$ is specified by a monic polynomial $g(X) = \sum_{i=0}^{n-k} g_i X^i$ with coefficients from $GF(q)$ where $g_{n-k} = 1$ and $g_0 \neq 0$; $g(X)$ needs to divide the polynomial $X^n-1$. The generator matrix of the cyclic code is obtained as below.
     $$
     \bfG=\begin{bmatrix}
     g_0&g_1&\cdot&\cdot&\cdot&g_{n-k}&0&\cdot&\cdot&0\\
     0&g_0&g_1&\cdot&\cdot&\cdot&g_{n-k}&0&\cdot&0\\
     \vdots&&&&&&&&&\vdots\\
     0&0&\cdot&0&g_0&g_1&\cdot&\cdot&\cdot&g_{n-k}
     \end{bmatrix}.
     $$

    %We  use the following claim to determine if one cyclic code satisfies partially MDS property.

 %    \begin{claim}
 %    	\label{claim:cyclic_k}
 %    	In the generator matrix of cyclic code, any $k$ consecutive columns are linearly independent.
 %    \end{claim}
The following claim shows that for verifying the CCP for a cyclic code it suffices to pick {\it any} set of $k+1$ consecutive columns.
\begin{claim}
	\label{claim:cyclic_k1}
	Consider a $(n,k)$ cyclic code with generator matrix $\bfG$. Let $\bfG_\calS$ denote a set of $k+1$ consecutive columns of $\bfG$. If each $k \times k$ submatrix of $\bfG_S$ is full rank, then $\bfG$ satisfies the $(k,k+1)$-CCP.
\end{claim}
\begin{proof}

Let the generator polynomial of the cyclic code be $\bfg(X)$, where we note that $\bfg(X)$ has degree $n-k$. Let $\bfG_{\calS}=[\bfg_{(a)_n},\bfg_{(a+1)_n},\cdots,\bfg_{(a+k)_n}]$ where we assume that $\bfG_{\calS}$ satisfies the $(k,k+1)$-CCP. %We need to show that if $\bfG_{\calS}$ satisfies the $(k,k+1)$-CCP, then any $k \times k$ submatrix of $\bfG_{\calS'}=[\bfg_{(a+i)_n}\bfg_{(a+1+i)_n}\cdots\bfg_{(a+k+i)_n}]$, for $i<n$, is full rank.
Let
\begin{align*}
\bfG_{\calS\setminus j} =& [\bfg_{(a)_n},\dots,\bfg_{(a+j-1)_n},\bfg_{(a+j+1)_n},\dots,\bfg_{(a+k)_n}], \text{and}\\
\bfG_{\calS'\setminus j} =&[\bfg_{(a+i)_n},\dots,\bfg_{(a+j-1+i)_n},\\&~\bfg_{(a+j+1+i)_n},
\dots,\bfg_{(a+k+i)_n}].
\end{align*}
We need to show that if $\bfG_{\calS\setminus j}$ has full rank, then $\bfG_{\calS'\setminus j}$ has full rank, for any $0\le j\le k$. %\aditya{discuss}

As $\bfG_{\calS\setminus j}$ has full rank, there is no codeword $\bfc \neq \mathbf{0}$ such that $\bfc((a)_n)=\cdots=\bfc((a+j-1)_n)=\bfc((a+j+1)_n)=\cdots=\bfc((a+k)_n)=0.$
By the definition of a cyclic code, any circular shift of a codeword results in another codeword that belongs to the code. Therefore, there is no codeword $\bfc'$ such that $\bfc'((a+i)_n)=\cdots=\bfc'(a+j-1+i)_n)=\bfc'((a+j+1+i)_n)=\cdots=\bfc'((a+k+i)_n)=0.$ Thus, $\bfG_{\calS'\setminus j}$ has full rank.
\end{proof}

Claim \ref{claim:cyclic_k1} implies a low complexity search algorithm to determine if a cyclic code satisfies the CCP. Instead of checking all $\bfG_{\calS_a}$, $0\le a\le \frac{zn}{k+1}-1$, in Definition \ref{def:MDSproperty}, we only need to check an arbitrary $\bfG_{\calS}=[\bfg_{(i)_n},\bfg_{(i+1)_n},\cdots,\bfg_{(i+k)_n}]$, for $0\le i< n$. %If $\bfG_{\calS}$ satisfies MDS property, the cyclic code satisfies partially MDS property.
To further simplify the search, we choose $i=n-\lfloor \frac{k}{2}\rfloor-1$.% and check $\bfG_{\calS}$.% which is specified as follows. %\aditya{edited this section till here, Jan 14, 3:30pm}
%\begin{align*}
%\begin{bmatrix}
%g_0&g_1&\cdot&\cdot&g_{\lceil\frac{k}{2}\rceil-1}&0&\cdot&\cdot&0&0\\
%0&g_0&g_1&\cdot&g_{\lceil\frac{k}{2}\rceil-2}&0&\cdot&\cdot&0&0\\
%\vdots&&&&&&&&&\vdots\\
%0&\cdot&0&g_0&g_1&0&\cdot&\cdot&0&0\\
%0&\cdot&\cdot&0&g_0&g_{n-k}&0&\cdot&\cdot&0\\
%0&\cdot&\cdot&0&0&g_{n-k-1}&g_{n-k}&0&\cdot&0\\
%\vdots&&&&&&&&&\vdots\\
%0&\cdot&\cdot&0&0&g_{n-k-\lfloor \frac{k}{2}\rfloor}&\cdot&\cdot&\cdot&g_{n-k}
%\end{bmatrix}
%\end{align*}
%\begin{table*}[!tb]
%	\label{tb:compare}
%	\center
%	\caption{Comparison of rate and subpacketization level}
%	\begin{tabular}{ |c|c|c|c|c|c| }
%		\hline
%		& MN &\multicolumn{2}{c|}{YAN} & \multicolumn{2}{c|}{New Scheme}\\
%		\hline
%		 \multirow{2}{*}{$R$}&\multirow{2}{*}{$\frac{K(1-\frac{M}{N})}{1+\frac{KM}{N}}$}&$\frac{M}{N}=\frac{1}{q}$&$\frac{M}{N}=1-\frac{1}{q}$&$\frac{M}{N}=\frac{1}{q}$&$\frac{M}{N}=1-\frac{1}{q}$\\
%        \cline{3-6}
%        &&$q-1$&$\frac{1}{q-1}$&$\frac{(q-1)n}{k+1}$&$\frac{k+1}{(q-1)n}$\\
%		\hline
%		 \multirow{2}{*}{$F_s$}&\multirow{2}{*}{$\binom{K}{\frac{KM}{N}}$}&$\frac{M}{N}=\frac{1}{q}$&$\frac{M}{N}=1-\frac{1}{q}$&$\frac{M}{N}=\frac{1}{q}$&$\frac{M}{N}=1-\frac{k+1}{nq}$\\
%		\cline{3-6}
%		&&$q^n$&$q^kz$&$(q-1)q^n$&$(q-1)q^k\frac{zn}{k+1}$\\
%	    \hline
%	\end{tabular}
%\end{table*}

%Towards this end, we need to check whether all submatrices $\bfG_{\calS\setminus (i+j)_n}=[\bfg_{(i)_n},\bfg_{(i+1)_n},\cdots,\bfg_{(i+j-1)_n},\bfg_{(i+j+1)_n},\cdots,\bfg_{(i+k)_n}]$, where $i=n-\lfloor \frac{k}{2}\rfloor-1$ have full rank, i.e., $rank(\bfG_{\calS\setminus (i+j)_n})=k$.

For this choice of $i$, Claim \ref{claim:cyclic_MDS} shows that $\bfG_\calS$ is such that we only need to check the rank of a list of small-dimension matrices to determine if each $k\times k$ submatrix of $\bfG_\calS$ is full rank (the proof appears in the Appendix).

\begin{claim}
	\label{claim:cyclic_MDS}
	A cyclic code with generator matrix $\bfG$ satisfies the CCP if the following conditions hold.
\begin{itemize}
	\item
	For $0<j\le \lfloor \frac{k}{2}\rfloor$, the submatrices
	\begin{align*}
    \bfC_j =\begin{bmatrix}
	g_{n-k-1}&g_{n-k}&0&\cdot&\cdot&0\\
	g_{n-k-2}&g_{n-k-1}&g_{n-k}&0&\cdot&0\\
	\vdots&&&&&\vdots\\
	g_{n-k-j+1}&\cdot&\cdot&\cdot&\cdot&g_{n-k}\\
	g_{n-k-j}&\cdot&\cdot&\cdot&\cdot&g_{n-k-1}
	\end{bmatrix}
	\end{align*}
	have full rank. In the above expression, $g_i=0$ if $i<0$.
	\item
	For $\lfloor\frac{k}{2}\rfloor<j<k$, the submatrices
		\begin{align*}
		\bfC_j =\begin{bmatrix}
		g_{1}&g_{2}&\cdot&\cdot&\cdot&\cdot&g_{k-j}\\
		g_{0}&g_{1}&\cdot&\cdot&\cdot&\cdot&g_{k-j-1}\\
		\vdots&&&&&&\vdots\\
		0&\cdot&\cdot&0&g_0&g_1&g_2\\
		0&\cdot&&\cdot\cdot&0&g_0&g_1
		\end{bmatrix}
		\end{align*}
	have full rank.
\end{itemize}
\end{claim}

\begin{example}
	Consider the polynomial $\bfg(X)=X^4+X^3+X+2$ over $GF(3)$. Since it divides $X^8-1$, it is the generator polynomial of a $(8,4)$ cyclic code over $GF(3)$. The generator matrix of this code is given below.
	$$\bfG=
	\begin{bmatrix}
	2&1&0&1&1&0&0&0\\
	0&2&1&0&1&1&0&0\\
	0&0&2&1&0&1&1&0\\
	0&0&0&2&1&0&1&1
	\end{bmatrix}.
	$$
	It can be verified that the $4\times 5$ submatrix which consists of the two leftmost columns and three rightmost columns of $\bfG$ is such that all $4 \times 4$ submatrices of it are full rank. Thus, by Claim \ref{claim:cyclic_k1} the (4,5)-CCP is satisfied for $\bfG$.
%	$$\bfG_{\calS}=
%	\begin{bmatrix}
%	2&1&0&0&0\\
%	0&2&1&0&0\\
%	0&0&1&1&0\\
%	0&0&0&1&1
%	\end{bmatrix}.
%	$$
%	One can check that all $4\times 4$ submatrices of $\bfG_{\calS}$ have full rank. Thus, by Claim \ref{claim:cyclic_k1} the (4,5)-CCP is satisfied.% and therefore $\bfG_{\calS}$ satisfies MDS property. By Claim \ref{claim:cyclic_k1}, this cyclic code satisfies partially MDS property.
\end{example}
\begin{remark}
Cyclic codes form an important class of codes that satisfy the $(k,k)$-CCP ({\it cf.} Definition \ref{def:kalphacc}). This is because, it is well-known \cite{lincostello} that any $k$ consecutive columns of the generator matrix of a cyclic code are linearly independent. %\litang{We need to emphasis it somewhere}
\end{remark}
%Thus, we have the following result.
%\aditya{Based on the k, alpha- CCP we need to reword this.}
%
%
%Next we consider a special class of cyclic codes, i.e., cyclic code over $GF(2)$. As we will show in the claim below and prove in Appendix, for any cyclic code over $GF(2)$ (no matter it satisfies the CCP or not), it associates to a coded caching scheme.
    %\begin{claim}
    %	\label{claim:cyclic_code_result}
    %Suppose that there exists a $(n,k)$ cyclic code over $GF(q)$. This corresponds to a coded caching system with $K=nq$ users, cache fraction $M/N = 1/q$ with rate $R = \frac{n(q-1)}{k}$ and subpacketization level $F_s = q^k z'$ where $z'$ is the least integer such that $k|nz'$.
    %\end{claim}
    %
    %\litang{I don't think we need a claim here because throughout this section, we just discuss the code construction. If we discuss $\frac{M}{N}=\frac{1}{q}$ here, we have to discuss the flip of cache size, which may be redundant? And here I think we need to mention that by cyclic code we can see the constrain of $(k,\alpha)$ CCP is not as strict as $(k,k+1)$-CCP. Therefore, $(k,\alpha)$-CCP can give us large range of parameters.}

%\aditya{how do we include the special binary case.}
%Next we consider a special class of cyclic codes, i.e., cyclic code over $GF(2)$. As we will show in the claim below and prove in Appendix, for any cyclic code over $GF(2)$ (no matter it satisfies the CCP or not), it associates to a coded caching scheme.
%\begin{claim}
%	\label{claim:cyclicGF2}
%	Consider one $(n,k)$ cyclic code over $GF(2)$. It associates to a coded caching scheme with $K=nq$ users. Suppose that $N$ file in the server and each user has a cache of size $M=\frac{1}{2}N$. Then $R=\frac{n}{k}$ and $F_s=q^kz'$,
%	where $z'$ is the least integer such that $k|nz'$.
%\end{claim}
\subsection{Constructions leveraging properties of smaller base matrices}
\label{sec:more_cons_block}
It is well recognized that cyclic codes do not necessarily exist for any choice of parameters. This is because of the divisibility requirement on the generator polynomial. We now discuss a more general construction of generator matrices that satisfy the CCP. As we shall see, this construction provides a more or less satisfactory solution for a large range of system parameters.

%In this section, we construct more linear block codes that satisfy CCP. Firstly, we consider an $(n,k)$ linear block code over $GF(q)$ where



Our first simple observation is that the Kronecker product (denoted by $\otimes$ below) of a $z \times \alpha$ generator matrix that satisfies the $(z,z)$-CCP with a $t \times t$ identity matrix, $\bfI_{t\times t}$ immediately yields a generator matrix that satisfies the $(tz,tz)$-CCP.
%
%of cyclic code with an identity matrix immediately yields a matrix that satisfies the $(k,k)$-CCP.
\begin{claim}
	\label{claim:GconstructKKCCP}
%	Consider a $(n,k)$ linear block code over $GF(q)$ whose generator matrix is specified as $\bfG=\bfA\otimes \bfI_{t\times t}$, where $n=t\alpha$, $k=tz$, $\bfA$ is the generator matrix of $(\alpha,z)$ cyclic code over $GF(q)$. It satisfies $(k,k)$-CCP.

	Consider a $(n,k)$ linear block code over $GF(q)$ whose generator matrix is specified as $\bfG=\bfA\otimes \bfI_{t\times t}$ where $\bfA$ is a $z\times \alpha$ matrix that satisfies the $(z,z)$-CCP. Then, $\bfG$ satisfies the $(k,k)$-CCP  where $k=tz$ and $n=t\alpha$.
\end{claim}
\begin{proof}
	%Assume that $t'=GCD(n,k)$, then $z'=\frac{k}{t'}$ is the least integer such that $k|nz'$ and $z|z'$.
	The recovery set for $\bfA$ is specified as $\calS_a^z=\{(az)_\alpha,\cdots, (az+z-1)_\alpha\}$ and the recovery set for $\bfG$ is specified as $\calS_a^k=\{(ak)_n, \cdots, (ak+k-1)_n\}$. Since $\bfA$ satisfies the $(z,z)$-CCP, $\bfA_{\calS_a^z}$ has full rank.  Note that $\bfG_{\calS_a^k}=\bfA_{\calS_a^z}\otimes \bfI_{t\times t}$. Then $\det(\bfG_{\calS_a^k})=\det(\bfA_{\calS_a^z}\otimes \bfI_{t\times t})=\det(\bfA_{\calS_a^z})^t\neq 0$. Therefore, $\bfG$ satisfies the $(k,k)$-CCP. %\litang{Edit on 05/29: I edit the proof.}
\end{proof}
\begin{remark}
Let $\bfA$ be the generator matrix of a cyclic code over $GF(q)$, then $\bfG=\bfA \otimes \bfI_{t\times t}$ satisfies the $(k,k)$-CCP by Claim \ref{claim:GconstructKKCCP}.
\end{remark}
Our next construction addresses the $(k,k+1)$-CCP. In what follows, we use the following notation.
%In this section, we use the following notations.
\begin{itemize}
	%\item $\bfI_{a\times a}$: $a\times a$ identity matrix;
	\item $\bfoe_a$: $[\underbrace{1,\cdots,1}_a]^T$;
%	\item $\bfA_{a\times a}^b$: $a\times a$ diagonal matrix whose entries in diagonal line are all $b$. Clearly, $\bfA_{a\times a}^1=\bfI_{a\times a}$;
	\item $\bfC(c_1, c_2)_{a\times b}$: $a\times b$ matrix where each row is the cyclic
	shift (one place to the right) of the row above it and the first row is $[c_1~ c_2~ 0~ \cdots~ 0]$; and
	\item $\bfzr_{a\times b}$: $a\times b$ matrix with zero entries.
\end{itemize}

Consider parameters $n,k$. Let the greatest common divisor of $n$ and $k+1$, $\gcd(n,k+1)=t$. It is easy to verify that $z=\frac{k+1}{t}$ is the smallest integer such that $k+1~|~nz$. Let $n=t\alpha$ and $k+1=tz$. Claim \ref{claim:Gconstruct1} below constructs a $(n,k)$ linear code that satisfies the CCP over $GF(q)$ where $q > \alpha$. Since $\alpha=\frac{n}{t}$, the required field size in Claim \ref{claim:Gconstruct1} is lower than the MDS code considered in Section \ref{sec:MDS_cons}. %\aditya{where do we use that n is at most 2(k+1) in proof?} \litang{Edit on 05/30: I delete it and discuss how to use Claim 8 after Claim 8.}
\begin{claim}
	\label{claim:Gconstruct1}
	%Let $n<2(k+1)$.
	Consider a $(n,k)$ linear block code over $GF(q)$ whose generator matrix is specified as eq. (\ref{eq:Gconstruct1}),
	\begin{table*}[t]
			\begin{equation}
		\label{eq:Gconstruct1}
		\bfG=
		\begin{bmatrix}
		b_{00}\bfI_{t\times t}&b_{01}\bfI_{t\times t}&\cdots&b_{0(\alpha-1)}\bfI_{t\times t}\\
		b_{10}\bfI_{t\times t}&b_{11}\bfI_{t\times t}&\cdots&b_{1(\alpha-1)}\bfI_{t\times t}\\
		\vdots&&&\vdots\\
		b_{(z-2)0}\bfI_{t\times t}&b_{(z-2)1}\bfI_{t\times t}&\cdots&b_{(z-2)(\alpha-1)}\bfI_{t\times t}\\
		\bfC(b_{(z-1)0}, b_{(z-1)0})_{(t-1)\times t}&\bfC(b_{(z-1)1}, b_{(z-1)1})_{(t-1)\times t}&\cdots&\bfC(b_{(z-1)(\alpha-1)}, b_{(z-1)(\alpha-1)})_{(t-1)\times t}
		\end{bmatrix}
		\end{equation}
	\end{table*}
	where
	\begin{align*}
    \begin{bmatrix}
	    b_{00}&b_{01}&\cdots&b_{0(\alpha-1)}\\
    	b_{10}&b_{11}&\cdots&b_{1(\alpha-1)}\\
	    \vdots&&&\vdots\\
	    b_{(z-1)0}&b_{(z-1)1}&\cdots&b_{(z-1)(\alpha-1)}
	\end{bmatrix}
	\end{align*}
	is a Vandermonde matrix and $q> \alpha$. Then, $\bfG$ satisfies the $(k,k+1)$-CCP.
\end{claim}
\begin{proof}
The proof again leverages the idea that $\bfG$ can be expressed succinctly by using Kronecker products. The arguments can be found in the Appendix.
\end{proof}






%\litang{I think we should move Claim 11 to here since they are quite similar.}
%In certain specific cases, we are able to leverage this approach to construct generator matrices that operate over $\mathbb{Z} \mod q$ as well, i.e., $q$ does not need to be a prime power. \aditya{need to discuss carefully}
Consider the case when $\alpha=z+1$. We construct a $(n,k)$ linear code satisfy the CCP over $GF(q)$ where $q\ge z$. It can be noted that the constraint of field size is looser than the corresponding constraint in Claim \ref{claim:Gconstruct1}. %Furthermore, we are also able to construct a linear code that satisfies the CCP over  $\mathbb{Z} \mod q$ where $z=2$. \litang{Edit on 05/26: reword here} %$\phi(q)\ge z$. Here, $\phi(q)$ is Euler's totient function.
\begin{claim}
\label{claim:Gconstruct2}

Consider $nz=(z+1)\cdot (k+1)$ . Consider a $(n,k)$ linear block code whose generator matrix (over $GF(q)$) is specified as follows. %\aditya{Li: make the change we discussed in the statement of result} \litang{Edit on 05/30: made the change here}

\begin{equation}
\label{eq:Gconstruct2}
\bfG=
\begin{bmatrix}
\begin{smallmatrix}
\bfI_{t\times t}&\bfzr_{t\times t}&\cdots&\bfzr_{t\times t}&\bfzr_{t\times (t-1)}&\bfoe_t&{b_1}\bfI_{t\times t}\\
\bfzr_{t\times t}&\bfI_{t\times t}&\cdots&\bfzr_{t\times t}&\bfzr_{t\times (t-1)}&\bfoe_t&{b_2}\bfI_{t\times t}\\
\vdots&&&&&&\vdots\\
\bfzr_{t\times t}&\bfzr_{t\times t}&\cdots&\bfI_{t\times t}&\bfzr_{t\times (t-1)}&\bfoe_t&{b_{z-1}}\bfI_{t\times t}\\
\bfzr_{(t-1)\times t}&\bfzr_{(t-1)\times t}&\cdots&\bfzr_{(t-1)\times t}&\bfI_{(t-1)\times (t-1)}&\bfoe_{t-1}&\bfC(c_1, c_2)_{(t-1)\times t},
\end{smallmatrix}
\end{bmatrix}
\end{equation}
where $t=n-k-1$. If $q\ge z$, $b_1,b_2,\cdots,b_{z-1}$ are non-zero and distinct, and $c_1+c_2=0$, then $\bfG$ satisfies the CCP.
%The following conclusions can be drawn.
%\begin{itemize}
%	\item If $\bfG$ is considered as a matrix over $GF(q)$ where $q\ge z$, $b_1,b_2,\cdots,b_{z-1}$ are non-zero and distinct, and $c_1+c_2=0$, then $\bfG$ satisfies the CCP.
%	\item Let $z=2$, $b_1=1$ and $c_1=c_2=1$. If $\bfG$ is considered as a matrix over $\mathbb{Z} \mod q$, where $q$ is a positive integer, $\bfG$ satisfies the CCP.  \litang{Edit on 05/26:reword the second conclusion, will edit the proof}
	%If $\bfG$ is considered as a matrix over $\mathbb{Z} \mod q$ where $\phi(q)\ge z$, $b_1,b_2,\cdots,b_{z-1}$ are non-zero divisors in commutative ring $\mathbb{Z} \mod q$ and distinct, $c_1$ and $c_2$ are non-zero divisors and $c_1+c_2=0$, then $\bfG$ satisfies the CCP. \aditya{requires careful scrutiny. not correct as stated}
%\end{itemize}

\end{claim}
\begin{proof}
	See Appendix.
\end{proof}


Given a $(n,k)$ code that satisfies the CCP, we can use it obtain higher values of $n$ in a simple manner as discussed in the claim below.
%The following claim generalizes the construction in Claim \ref{claim:Gconstruct} to an $(n+s(k+1),k)$ linear block code over $GF(q)$.
\begin{claim}
	\label{claim:matrixextend}
	Consider a $(n,k)$ linear block code over $GF(q)$ with generator matrix $\bfG$ that satisfies the CCP. Let the first $k+1$ columns of $\bfG$ be denoted by the submatrix $\bfD$. Then the matrix $\bfG'$ of dimension $k \times (n + s(k+1))$ where $s\ge 0$
	\begin{align*}
	\bfG'=[\underbrace{\bfD| \cdots |\bfD}_s| \bfG]
	\end{align*}
also satisfies the CCP.
\end{claim}
\begin{proof}
	See Appendix.
\end{proof}

Claim \ref{claim:matrixextend} can provide more parameter choices and more possible code constructions. For example, given $n,k,q$, where $k+1+(n)_{k+1}\le q+1<n$, there may not exist a $(n, k)$-MDS code over $GF(q)$. However, there exists a $(k+1+(n)_{k+1}, k)$-MDS code over $GF(q)$. By Claim \ref{claim:matrixextend}, we can obtain a $(n,k)$ linear block code over $GF(q)$ that satisfies the CCP. Similarly, combining Claim \ref{claim:cyclic_MDS}, Claim \ref{claim:Gconstruct1}, Claim \ref{claim:Gconstruct2} with Claim \ref{claim:matrixextend}, we can obtain more linear block codes that satisfy the CCP. %\litang{Edit on 05/30: I edit how to use Claim 8 here}


A result very similar to Claim \ref{claim:matrixextend} can be obtained for the $(k,\alpha)$-CCP. Specifically, consider a $(n,k)$ linear block code with generator matrix $\bfG$ that satisfies the $(k,\alpha)$-CCP and let $\bfD$ be the first $\alpha$ columns of $\bfG$. Then, $\bfG'=[\underbrace{\bfD| \cdots |\bfD}_s| \bfG]$ of dimension $k\times (n+s\alpha)$ also satisfies the $(k,\alpha)$-CCP.%\litang{Edit on 05/27}

%\aditya{need to discuss}
%One special case in Claim \ref{claim:Gconstruct2} and \ref{claim:matrixextend} is $z=2$. In this case, we can always construct a binary generator matrix $\bfG$ by Claim \ref{claim:Gconstruct2} and \ref{claim:matrixextend}. Since $1$ is not zero divisor in any ring $\mathbb{Z} \mod q$(See Remark \ref{Rem:ringfield} for details), we can construct a $(n,k)$ linear block code over $\mathbb{Z} \mod q$, where $z=2$ and $q$ is an arbitrary positive integer, and it corresponds to a resolvable design $(X,\calA)$ by Lemma \ref{lemma:Resolve_MDS}. In the next claim, we show that $z\le 2$ is also a necessary condition of a binary $(n,k)$ linear block code that satisfies the CCP.


%\aditya{do we need the next claim? Do we use it anywhere?}
%\begin{claim}
%	\label{claim:ztwocase}
%	An binary $(n,k)$ linear block code satisfies the CCP if and only if $z\le 2$.
%\end{claim}
%\begin{proof}
%	See Appendix.
%\end{proof}


\subsection{Constructions where $q$ is not a prime or a prime power}
\label{sec:matrices_z_mod_q}
We now discuss constructions where $q$ is not a prime or a prime power. We attempt to construct matrices over the ring $\mathbb{Z} \mod q$ in this case. The issue is somewhat complicated by the fact that a square matrix over $\mathbb{Z} \mod q$ has linear independent rows if and only if its determinant is a unit in the ring \cite{dummit2003abstract}. In general, this fact makes it harder to obtain constructions such as those in Claim \ref{claim:Gconstruct1} that exploit the Vandermonde structure of the matrices. Specifically, the difference of units in a ring is not guaranteed to be a unit. However, we can still provide some constructions. It can be observed that Claim \ref{claim:GconstructKKCCP} and Claim \ref{claim:matrixextend} hold for linear block codes over $\mathbb{Z} \mod q$. We will use them without proof in this subsection. %\aditya{CHECK}
%\litang{Have checked it}

%\aditya{need to rephrase results as lemmas or theorems}

\begin{claim}
	\label{claim:SPC_CCPZmodq}
%The following matrices can be used as base matrices for Claim \ref{claim:GconstructKKCCP}.
%\begin{itemize}
Let $\bfG = [\bfI_{k \times k} | \bfoe_k]$, i.e., it is the generator matrix of a $(k+1, k)$ single parity check (SPC) code, where the entries are from $\mathbb{Z} \mod q$.
The $\bfG$ satisfies the $(k,k+1)$-CCP and the $(k,k)$-CCP. It can be used as base matrix for  Claim \ref{claim:GconstructKKCCP}.
%Then any $k \times k$ submatrix of $\bfG$ has a determinant which is $\pm 1$, i.e., it is a unit over $\mathbb{Z} \mod q$.
\end{claim}
\begin{proof}
It is not too hard to see that when $\bfG = [\bfI_{k \times k} | \bfoe_k]$, any $k \times k$ submatrix of $\bfG$ has a determinant which is $\pm 1$, i.e., it is a unit over $\mathbb{Z} \mod q$. Thus, the result holds in this case.
\end{proof}
%A construction analogous to Claim \ref{claim:Gconstruct2} is hard to come by for reasons outlined earlier. Nevertheless, we can provide a construction in a specific case.
\begin{claim}
\label{claim:z_2_Zmodq}
The following matrix with entries from $\mathbb{Z}\mod q$ satisfies the $(k,k+1)$-CCP. Here $k =2t-1$ and $n=3t$.
\begin{align*}
    \bfG = \begin{bmatrix}
	   \bfI_{t \times t}& \bfzr & \bfoe_t & \bfI_{t \times t}\\
    	 \bfzr &\bfI_{(t-1) \times (t-1)}& \bfoe_t & \bfC(1,-1)_{(t-1) \times t}
	\end{bmatrix}.
\end{align*}
\end{claim}
\begin{proof}
This can be proved by following the arguments in the proof of Claim \ref{claim:Gconstruct2} while treating elements to be from $\mathbb{Z} \mod q$ and setting $z=2$. We need to consider three different $k \times (k+1)$ submatrices for which we need to check the property. These correspond to simpler instances of the submatrices considered in Types I - III in the proof of Claim \ref{claim:Gconstruct2}. In particular, the corresponding determinants will always be $\pm 1$ which are units over $\mathbb{Z} \mod q$.
\end{proof}
\begin{remark}
We note that the general construction in Claim \ref{claim:Gconstruct2} can potentially fail in the case when the matrices are over $\mathbb{Z} \mod q$. This is because in one of the cases under consideration (specifically, Type III, Case 1), the determinant depends on the difference of the $b_i$ values. The difference of units in $\mathbb{Z} \mod q$ is not guaranteed to be a unit, thus there is no guarantee that the determinant is a unit.
\end{remark}
\begin{remark}
We can use Claim \ref{claim:matrixextend} to obtain higher values of $n$ based on the above two classes of linear block codes over $\mathbb{Z} \mod q$.
\end{remark}

%The first class of linear block code that satisfy the CCP and the $(k,k)$-CCP over $\mathbb{Z} \mod q$ is $(k+1,k)$-SPC code. This is because the determinant of any $k\times k$ submatrix of its generator matrix $\bfG$ is $1$, which is an unit over $\mathbb{Z} \mod q$ and thus it has full rank. Moreover, $\bfG \otimes \bfI_{t\times t}$ satisfy $(k,k)$-CCP by Claim \ref{claim:GconstructKKCCP}.
%
%In Claim \ref{claim:Gconstruct2}, let $z=2$, $b_1=c_1=c_2=1$, it results in a binary generator matrix $\bfG$ with size $2t\times (3t-1)$, which satisfies the  CCP over $\mathbb{Z}\mod q$. It is because all of determinant of $\bfG_{\calS_a}$ is $1$ or $-1$ in the proof of Claim \ref{claim:Gconstruct2}, which is an unit over $\mathbb{Z}\mod q$ and therefore $\bfG_{\calS_a}$ has full rank.
%
%We note that the  we can use Claim \ref{claim:matrixextend} to obtain higher $n$ based on above two classes of lienar block code over $\mathbb{Z} \mod q$.

While most constructions of cyclic codes are over $GF(q)$, there has been some work on constructing cyclic codes over $\mathbb{Z}\mod q$. Specifically, \cite{blake1972codes} provides a construction where $q=q_1\times q_2 \cdots \times q_d$ and $q_i, i = 1, \dots, d$ are prime. We begin by outlining this construction. By the Chinese remainder theorem any element $ \gamma \in \mathbb{Z}\mod q$ has a unique representation in terms of its residues modulo $q_i$, for $i=1, \dots, d$. Let $\psi: \mathbb{Z}\mod q \rightarrow GF(q_1) \times \dots \times GF(q_d)$ denote this map.
\begin{itemize}
\item Suppose that $(n,k_i)$ cyclic codes over $GF(q_i)$ exist for all $i = 1, \dots, d$. Each individual code is denoted $\calC^{i}$.
%\item Construct the corresponding codeword matrices $\bfT_i, i = 1, \dots d$.
\item Let $\calC$ denote the code over $\mathbb{Z} \mod q$. Let $\bfc^{(i)} \in \calC^{i}$ for $i = 1, \dots, d$. The codeword $\bfc \in \calC$ is obtained as follows. The $j$-th component of $\bfc$, $\bfc_j = \psi^{-1}(\bfc^{(1)}_j, \dots, \bfc^{(d)}_j)$
\end{itemize}
%\cite{blake1972codes} provides an interesting construction for the cyclic code over $\mathbb{Z}\mod q$ where $q=q_1\times q_2 \cdots q_d$ and $q_i$ is prime. \litang{I think this class of code is not a block code?} It is constructed by a set of $(n,k_i)$ cyclic code over $GF(q_i)$ (or equivalently $\mathbb{Z}\mod q_i$) and the codeword is obtained by the direct product of codeword from each $(n,k_i)$ cyclic code by Chinese remainder theorem.

%\aditya{till here. Will continue to edit.}
Therefore, there are $q_1^{k_1}q_2^{k_2}\cdots q_d^{k_d}$ codewords in $\calC$. It is also evident that $\calC$ is cyclic.
As discussed in Section \ref{sec:construction}, we form the matrix $\bfT$ for the codewords in $\calC$. It turns out that using $\bfT$ and the technique discussed in Section \ref{sec:construction}, we can obtain a resolvable design. Furthermore, the gain of the system in the delivery phase can be shown to be $k_{min}=\min\{k_1,k_2,\cdots,k_d\}$. We discuss these points in detail in the Appendix (Section \ref{sec:blake_codes}).

%Assume $k_{min}=\min\{k_1,k_2,\cdots,k_d\}$. We find that this class of linear code is suitable for our construction of $(k_{min},k_{min})$-CCP. We point out that the procedure to form matrix $\bfT$ by cyclic code in \cite{blake1972codes} is slightly different from  Section III.A since the codeword in \cite{blake1972codes} is not directly obtained by multiplying the message and generator matrix over $\mathbb{Z}\mod q$. We will dicuss it in Appendix.

\section{Discussion and Comparison with Existing Schemes}
\label{sec:compare}
\subsection{Discussion}

%As we have discussed in Section \ref{sec:intro}, for fixed $K$ and $\frac{M}{N}$, the scheme in \cite{maddahN14} can achieve a large coded gain $g=\frac{KM}{N}+1$ compared with uncoded caching at the expense of a subpacketization level $F_s=\binom{K}{\frac{KM}{N}}$ that grows exponentially with $K$ for a fixed $\frac{M}{N}$. This exponential growth can potentially restrict the applicability of their achievability scheme in practice. We now discuss the possible coded gain $(g)$ that can be achieved when one works with a given subpacketization budget $(F_s)$.

%In this paper, we attem
%\begin{center}
%	\emph{What is the highest coded gain we could achieve for the given budget of subpacketization level?}
%\end{center}

When the number of users is $K=nq$ and the cache fraction is $\frac{M}{N}=\frac{1}{q}$, we have shown in Theorem \ref{them:main} that the gain $g=k+1$ and $F_s=q^kz$. Therefore, both the gain and the subpacketization level increase with larger $k$. Thus, for our approach given a subpacketization budget $F'_s$, the highest coded gain that can be obtained is denoted by $g_{max}=k_{max}+1$ where $k_{max}$ is the largest integer such that $q^{k_{max}}z\le F'_s$ and there exists a $(n,k_{max})$ linear block code that satisfies the CCP.

For determining $k_{max}$, we have to characterize the collection of values of $k$ such that there exists a $(n,k)$ linear code satisfies the CCP over $GF(q)$ or $\mathbb{Z} \mod q$. We use our proposed constructions (MDS code, Claim \ref{claim:cyclic_MDS}, Claim \ref{claim:Gconstruct1}, Claim \ref{claim:Gconstruct2}, Claim \ref{claim:matrixextend}, Claim \ref{claim:SPC_CCPZmodq}, Claim \ref{claim:z_2_Zmodq}) for this purpose. We call this collection $\calC(n,q)$ and generate it in Algorithm \ref{Alg:CandidateK}. We note here that it is entirely possible that there are other linear block codes that fit the appropriate parameters and are outside the scope of our constructions. Thus, the list may not be exhaustive. In addition, we note that we only check for the $(k,k+1)$-CCP. Working with the $(k,\alpha)$-CCP where $\alpha \leq k$ can provide more operating points. %\aditya{check now} \litang{Edit on 05/30: I have checked it}

%\aditya{Does table contain entries where (k,k)-CCP was used?}\litang{Edit on 05/29: we did not include any $(k,k)$-CCP in the list.}

%, e.g., in our comparison we do not check whether cyclic codes with the required parameters exist. Furthermore, we only check for the $(k,k+1)$-CCP. Working with the $(k,\alpha)$-CCP where $\alpha \leq k$ can provide more operating points.

%
%
%Given $C(n,q)$ and $F'_s$, we  check the largest integer $k_{max}$ in $C(n,q)$ such that $F_s = q^{k_{max}}z\le F'_s$, then $g_{max}=k_{max}+1$ is the largest coded gain we could achieve.
{
	\renewcommand{\arraystretch}{1.5}
	\begin{table*}[t]
		\begin{center}	
		\begin{tabular}{|c|c|c|c|c|c|}
			\hline
			\hline
			$k$ & $n'$ & $z$ & $\alpha$ & \text{Construction} & \text{Notes}\\
			\hline
			\hline 
			11  & 12  & 1  & 1  & (12, 11)\text{~SPC code} & $k+1=n'$\\
			\hline
			10  & 12  & 11  & 12   & -&-\\
			\hline
			9  & 12  & 5  & 6    & \text{Claim \ref{claim:Gconstruct2}} & $\alpha = z+1$ and $q\ge z$\\
			\hline
			8  & 12  & 3  & 4     & \text{Claim \ref{claim:Gconstruct2}} &  $\alpha = z+1$ and $q\ge z$\\
		    \hline
			7  & 12  & 2  & 3    & \text{Claim \ref{claim:Gconstruct2}} & $\alpha = z+1$ and $q\ge z$\\
		    \hline
			6  & 12  & 7  & 12     & \text{Claim \ref{claim:cyclic_MDS}} &\text{Generator polynomial is} $X^6+X^5+3X^4+3X^3+X^2+4X+3$\\
		    \hline
			5  & 6  & 1  & 1     & \text{(6,5) SPC code and Claim \ref{claim:matrixextend}} &\text{Extend (6,5) SPC code to (12,5) code}\\
		    \hline
			4  & 7  & 5  & 7     & \text{Claim \ref{claim:cyclic_MDS}} &\text{Generator polynomial is} $X^8+X^7+4X^6+3X^5+2X^3+X^2+4X+4$\\
		    \hline
			3  & 4  & 1  & 1     & \text{(4,3) SPC code and Claim \ref{claim:matrixextend}} &\text{Extend (4,3) SPC code to (12,3) code} \\
		    \hline
			2  & 3  & 1  & 1     &  \text{(3,2) SPC code and Claim \ref{claim:matrixextend}} &\text{Extend (3,2) SPC code to (12,2) code}\\
			\hline
			1  & 2  & 1  & 1     &  \text{(2,1) SPC code and Claim \ref{claim:matrixextend}} &\text{Extend (2,1) SPC code to (12,1) code}\\
			\hline
			\hline
		\end{tabular}
    \end{center}
    \caption{\label{Table:Example} List of $k$ values for Example \ref{eg:discuss_comp_1}. The values of $n', \alpha$ and $z$ are obtained by following Algorithm \ref{Alg:CandidateK}.}
	\end{table*}
}
\begin{example}
\label{eg:discuss_comp_1}
	Consider a caching system with $K=nq=12\times 5=60$ users and cache fraction $\frac{M}{N}=\frac{1}{5}$. Suppose that the subpacketization budget is $1.5\times 10^6$. By checking all $k<n$ we can construct $\calC(n,q)$ (see Table \ref{Table:Example}). %\litang{Edit on 05/26: Edit the notes and Algorithm 3 by recent discussion.}
As a result, $\calC(n,q)=\{1,2,3,4,5,6,7,8,9,11\}$. Then $k_{max}=8$, $F_s\approx 1.17\times 10^6$ and the maximal coded gain we can achieve is $g_{max}=9$. By contrast, the scheme in \cite{maddahN14} can achieve coded gain $g=\frac{KM}{N}+1=13$ but requires subpacketization level $F_s=\binom{K}{\frac{KM}{N}}\approx 1.4\times 10^{12}$.

We can achieve almost the same rate by performing memory-sharing by using the scheme of \cite{maddahN14} in this example. In particular, we divide each file of size $\Omega$ into two smaller subfiles $W_n^1$ and $W_n^2$, where the size of $W_n^1$, $|W_n^1|=\frac{9}{10} \Omega$ and the size of $W_n^2$, $|W_n^2|=\frac{1}{10}\Omega$. The scheme of \cite{maddahN14} is then applied separately on $W_n^1$ and $W_n^2$ with $\frac{M_1}{N_1}=\frac{2}{15}$ (corresponding to $W_n^1$) and $\frac{M_2}{N_2}=\frac{13}{15}$ (corresponding to $W_n^2$). Thus, the overall cache fraction is $0.9 \times \frac{2}{15} + 0.1 \times \frac{13}{15} \approx \frac{1}{5}$. The overall coded gain of this scheme is $g \approx 9$. However, the subpacketization level is $F_s^{MN} = \binom{K}{KM_1/N_1} + \binom{K}{KM_2/N_2}\approx 5\times 10^9$, which is much greater than the subpacketization budget.
\end{example}

In Fig. \ref{fig:rate_comps}, we present another comparison for system parameters $K=64$ and different values of $M/N$. The scheme of \cite{maddahN14} works for all $M/N$ such that $KM/N$ is an integer. In Fig. \ref{fig:rate_comps}, our plots have markers corresponding to $M/N$ values that our scheme achieves. For ease of presentation, both the rate (left $y$-axis) and the logarithm of the subpacketization level (right $y$-axis) are shown on the same plot. We present results corresponding to two of our construction techniques: (i) the SPC code and (ii) a smaller SPC code coupled with Claim \ref{claim:matrixextend}. It can be seen that our subpacketization levels are several orders of magnitude smaller with only a small increase in the rate.

\begin{figure}[!t]
		\centering
		\includegraphics[scale=0.35]{Rate_comp_print.pdf}
		\caption{A comparison of rate and subpacketization level vs. $M/N$ for a system with $K=64$ users. The left $y$-axis shows the rate and the right $y$-axis shows the logarithm of the subpacketization level. The green and the blue curves correspond to two of our proposed constructions. Note that our schemes allow for multiple orders of magnitude reduction in subpacketization level and the expense of a small increase in coded caching rate.}
		\label{fig:rate_comps}
\end{figure}



An in-depth comparison for general parameters is discussed next. In the discussion below, we shall use the superscript $*$ to refer to the rates and subpacketization levels of our proposed scheme.

\begin{algorithm}[t]
	\caption{$\calC(n,q)$ Construction Algorithm}
	\label{Alg:CandidateK}
	\SetKwInOut{Input}{Input}
	\SetKwInOut{Output}{Output}
	\Input{$n$, $q$, $\calC(n,q)=\emptyset$}
	\If{$q$ is a prime power}
	{
		\For{$k=1:(n-1)$}
		{
			$n'\leftarrow (n)_{k+1}+k+1$\;
			$z\leftarrow \frac{k+1}{\gcd(n',k+1)}$\;
            $\alpha \leftarrow \frac{n'}{\gcd(n',k+1)}$\;
            \eIf{there exists a $(n' + i(k+1),k)$ cyclic code which satisfies the condition in Claim \ref{claim:cyclic_MDS} for some $i$ such that $n' + i(k+1) \leq n$ }{$\calC(n,q)\leftarrow k$. Corresponding codes are constructed by using Claim \ref{claim:matrixextend}.}{
			\eIf{$z\le 2$}{$\calC(n,q)\leftarrow k$. Corresponding codes are constructed by SPC code and Claim \ref{claim:matrixextend} when $z=1$ or Claim \ref{claim:Gconstruct2} and Claim \ref{claim:matrixextend} when $z=2$.}{
			\eIf{$q+1 \geq n'$}{$\calC(n,q)\leftarrow k$. Corresponding codes are constructed by MDS code and Claim \ref{claim:matrixextend}.}
		                   { \If{$\alpha=z+1$ and $q\ge z$} {$\calC(n,q)\leftarrow k$. Corresponding codes are constructed by Claim \ref{claim:Gconstruct2} and Claim \ref{claim:matrixextend}.}
		                     \If{$\alpha>z+1$ and $q > \alpha$} {$\calC(n,q)\leftarrow k$. Corresponding codes are constructed by Claim \ref{claim:Gconstruct1} and Claim \ref{claim:matrixextend}.}
                           }
           }
        }
        }
    }
    \If{$q$ is not a prime power}
    {
    	\For{$k=1:(n-1)$}
    	{
    	%	$n'\leftarrow (n)_{k+1}+k+1$\;
    	%	$z\leftarrow \frac{k+1}{GCD(n',k+1)}$\;
    	%	$\alpha\leftarrow \frac{n'}{GCD(n',k+1)}$\;
    		\If{$z\le 2$}
    		{$\calC(n,q)\leftarrow k$. Corresponding codes are constructed by Claim \ref{claim:SPC_CCPZmodq} when $z=1$ and Claim \ref{claim:matrixextend} or Claim \ref{claim:z_2_Zmodq} and Claim \ref{claim:matrixextend}  when $z=2$.
    		}
    	}
    }
	\Output{$\calC(n,q)$}
\end{algorithm}


\subsection{Comparison with memory-sharing within the scheme of \cite{maddahN14}}

%An alternate way of comparing the results is to keep the transmission rates of both schemes roughly the same and then determine the subpacketization levels.
%\aditya{Section needs more stuff including plots requested by reviewer 1 and careful checking to cite latest versions. Need to be explicit about the gain in the scaling exponent}
%This can be achieved by using memory-sharing in the scheme of \cite{maddahN14}.
Suppose that for given $K$, $M$ and $N$, a given rate $R$ can be achieved  by the memory sharing of the scheme in \cite{maddahN14} between the corner points $(M_1, R_1), (M_2,R_2),\cdots, (M_d,R_d)$ where $M_i=\frac{t_iN}{K}$ for some integer $t_i$. Then $R_i=\frac{K(1-\frac{M_i}{N})}{1+\frac{KM_i}{N}}$, $R=\sum_{i=1}^d \lambda_i R_i$, $M/N = \sum_{i=1}^d \lambda_i \frac{M_i}{N}$ and $\sum_{i=1}^d \lambda_i=1$. The subpacketization level is $F_s^{MS}=\sum_{i=1}^d\binom{K}{\frac{KM_i}{N}}$. In addition, we note that the function $h(x) = K(1 - x)/(1 + Kx)$ is convex in the parameter $0 \leq x \leq 1$. This can be verified by a simple second derivative calculation.

We first argue that $F_s^{MS}$ is lower bounded by $\binom{K}{\frac{KM'}{N}}$, where $M'$ is obtained as follows. For a given $M/N$, we first determine $\lambda$ and $\frac{M^*}{N}$ that satisfy the following equations.
\begin{align}
R &=\lambda\frac{K(1-\frac{M^*}{N})}{1+\frac{KM^*}{N}}+(1-\lambda)\frac{K\frac{M^*}{N}}{1+K(1-\frac{M^*}{N})}, \text{~and~} \label{eq:memoryR}\\
\frac{M}{N} &=\lambda \frac{M^*}{N}+(1-\lambda)\bigg{(} 1-\frac{M^*}{N} \bigg{)}. \label{eq:memoryM}
\end{align}
Here, $\frac{M^*}{N}\le \frac{1}{2}$, and $M'=\frac{t'N}{K}$, where $t'$ is the least integer such that $M'\ge M^*$.

To see this, consider the following argument. Suppose that the above statement is not true. Then, there exists a scheme that operates via memory sharing between points $(M_1,R_1), \cdots, (M_d,R_d)$ such that $F_s<\binom{K}{K\frac{M'}{N}}$. Note that $\binom{K}{\frac{K M_1}{N}}<\binom{K}{\frac{K M_2}{N}}$ if $\frac{M_1}{N}<\frac{M_2}{N}\le \frac{1}{2}$ or $\frac{M_1}{N}>\frac{M_2}{N}\ge \frac{1}{2}$. By the convexity of $h(\cdot)$, we can conclude that $(M, R)$ is not in the convex hull of the corner points $(M_1,R_1), \cdots, (M_d,R_d)$. This is a contradiction.


Next, we compare this lower bound on $F_s^{MS}$ to the subpacketization level of our proposed scheme. In principle, we can solve the system of equations (\ref{eq:memoryR}) and (\ref{eq:memoryM}) for $R = \frac{n(q-1)}{k+1}$ and $\frac{M}{N} = \frac{1}{q}$ and obtain the appropriate $\lambda$ and $M^*$ values\footnote{Similar results can be obtained for $\frac{M}{N}=1-\frac{k+1}{nq}$}. Unfortunately, doing this analytically becomes quite messy and does not yield much intuition. Instead, we illustrate the reduction in subpacketization level by numerical comparisons.



%For the cache size $\frac{M}{N}=\frac{1}{q}$, we have $F_s^* = q^k z$. To keep the transmission rates of memory sharing of \cite{maddahN14} be the same and determine the subpacketization levels, we let $R=zq^k$ and $\frac{M}{N}=\frac{1}{q}$ in (\ref{eq:memoryR}) and (\ref{eq:memoryM}), and solve the quadratic equations to get $M^*$, $M'$ and lower bound of $F_s^{MS}$. Unfortunately, the result is very complicated, but the numerical result shows that the lower bound of $F_s^{MS}$ is still much higher than $F^*_s$. A similar result can be shown in the case when $\frac{M}{N}=1-\frac{k+1}{nq}$. We show it by the following example.
%\begin{claim}
%	\label{claim:memorysharing}
%	For the given $K$, $M$, $N$, $R$, where $R>\frac{K(1-\frac{M}{N})}{1+\frac{KM}{N}}$, the optimal subpacketization level by memory-sharing in the scheme of \cite{maddahN14} is bounded by
%	\begin{align*}
%	F^{opt}_s \ge \binom{K}{K\frac{M'}{N}},
%	\end{align*}
%	where
%	\begin{align*}
%	R&=\lambda\frac{K(1-\frac{M^*}{N})}{1+\frac{KM^*}{N}}+(1-\lambda)\frac{K\frac{M^*}{N}}{1+K(1-\frac{M^*}{N})},\\
%	M&=\lambda \frac{M^*}{N}+(1-\lambda)(1-\frac{M^*}{N}),\\	\frac{M^*}{N}&\le \frac{1}{2},\\
%	M'&=\frac{tN}{K}, \text{~where~} t \text{~is~the~least~integer~such~that~} M'\ge M^*
%	\end{align*}
%\end{claim}
%\begin{proof}
%See Appendix.
%\end{proof}
%\subsection*{Proof of Claim \ref{claim:memorysharing}}
%	Suppose that for given $K$, $M$ and $N$, a given rate $R$ can be achieved  by the memory sharing of the scheme in \cite{maddahN14} between the corner points $(M_1, R_1), (M_2,R_2),\cdots, (M_d,R_d)$. Then $R_i=\frac{K(1-\frac{M_i}{N})}{1+\frac{KM_i}{N}}$, $R=\sum_{i=1}^d \lambda_i R_i$ and $\sum_{i=1}^d=1$. The subpacketization level is $F_s=\sum_{i=1}^d\binom{K}{K\frac{M'_i}{N}}$, where $M'_i=\frac{t_iN}{K}$ and $t_i$ is the least integer such that $M'_i\ge M_i$.
%
%	Assume there exist a memory sharing of the scheme in \cite{maddahN14} between some corner points such that $F_s<\binom{K}{K\frac{M'}{N}}$. Note that $\binom{K}{K\frac{M_1}{N}}<\binom{K}{K\frac{M_2}{N}}$ if $\frac{M_1}{N}<\frac{M_2}{N}\le \frac{1}{2}$ or $\frac{M_1}{N}>\frac{M_2}{N}\ge \frac{1}{2}$. Then for each corner points $(M_i,R_i)$, $t_i<t$ or $t_i>K-t$. Since $R^*(M)=\frac{K(1-\frac{M_i}{N})}{1+\frac{KM_i}{N}}$ is a convex function, point $(M,R)$ is not in the convex hull of $(M_1,R_1), \cdots, (M_d,R_d)$, where
%	\begin{align*}
%		R&=\lambda\frac{K(1-\frac{M^*}{N})}{1+\frac{KM^*}{N}}+(1-\lambda)\frac{K\frac{M^*}{N}}{1+K(1-\frac{M^*}{N})},\\
%		M&=\lambda \frac{M^*}{N}+(1-\lambda)(1-\frac{M^*}{N}),\\
%		M_i&=\frac{t_iN}{K}, \text{where~} t_i<t \text{~or~} t_i>K-t,\\
%		R_i&=\frac{K(1-\frac{M_i}{N})}{1+\frac{KM_i}{N}}.
%	\end{align*}
%	Moreover, $R<\sum_{i=1}^d \lambda_i R_i$ where $M=\sum_{i=1}^d \lambda_i M_i$ and $\sum_{i=1}^d \lambda_i=1$, which is a contradiction.
%\begin{figure}[bt]
%	\centering
%	\includegraphics[scale=0.7]{Figure5.pdf}
%	\caption{Memory sharing of scheme in \cite{maddahN14}}
%	\label{Fig:Recovery}
%\end{figure}


\begin{example}
	Consider a $(9,5)$ linear block code over $GF(2)$ with generator matrix specified below.
	\begin{align*}
	\bfG=
	\begin{bmatrix}
        1&0&0&0&0&1&1&0&0\\
        0&1&0&0&0&1&0&1&0\\
        0&0&1&0&0&1&0&0&1\\
        0&0&0&1&0&1&1&1&0\\
        0&0&0&0&1&1&0&1&1
    \end{bmatrix}.	
	\end{align*}
    It can be checked that $\bfG$ satisfies the $(5,6)$-CCP. Thus, it corresponds to a coded caching system with $K=9\times 2=18$ users. Our scheme achieves the point $\frac{M_1}{N}=\frac{1}{2}$, $R_1=\frac{3}{2}$, $F_{s,1}^*=64$ and $\frac{M_2}{N}=\frac{2}{3}$, $R_2=\frac{2}{3}$, $F_{s,2}^*=96$.

    On the other hand for $\frac{M_1}{N}=\frac{1}{2}$, $R_1=\frac{3}{2}$, by numerically solving  (\ref{eq:memoryR}) and (\ref{eq:memoryM}) we obtain $\frac{M_1^*}{N}\approx 0.227$ and therefore $\frac{M_1'}{N}=\frac{5}{18}$. Then $F_{s,1}^{MS}\ge\binom{18}{5}=8568$, which is much higher than $F_{s,1}^*=64$. A similar calculation shows that $\frac{M_2^*}{N}\approx \frac{1}{4}$ and therefore $\frac{M_2'}{N}=\frac{5}{18}$. Thus  $F_{s,2}^{MS}$ is also at least as large as $8568$, which is still much higher than $F_{s,2}^*=96$.
\end{example}

%\aditya{is this stuff needed?}
%\aditya{we say that q/n is not close to zero and then take limit of n. Does not make sense}
%Although a precise comparison between $F_s^{MS}$ and $F_s^*$ is complicated, some approximate conclusions can be drawn when $q$ is not very small and $\frac{M}{N}=\frac{1}{q}$. In (\ref{eq:memoryM}), we assume that $\lambda>>1-\lambda$ and we let $\lambda \approx 1$. In (\ref{eq:memoryR}), therefore
%\begin{align*}
%\frac{nq(1-\frac{1}{q})}{1+k} &= \frac{K(1-\frac{M^*}{N})}{1+\frac{KM^*}{N}}, \text{~so that}\\
%\frac{M^*}{N}&\ge \frac{k}{nq}.
%\end{align*}
%Thus, we can approximate $\frac{M'}{N} = \frac{k}{nq}$, so that $F_s^{MS} \geq \binom{nq}{k}$. We can numerically verify that this approximation is valid when $q \geq 3$ and $\frac{q}{n}$ is not closed to $0$.
%Using standard approximations for binomial coefficients, we can conclude that
%\begin{align*}
%\lim_{n \rightarrow \infty} \frac{1}{K}\log_2 \frac{F_s^{MS}}{F_s^*} = H_2(\frac{\eta}{q}) - \frac{\eta}{q}\log_2 q,
%\end{align*}
%%\litang{Fix it as Claim 11.}
%where $\eta=\frac{k}{n}$. % Since $\eta<1$ and $\frac{q-\eta}{q}<1$,
%$F_s^*$ is exponentially lower than $F_s^{MS}$. %\aditya{Li, above statement does not convey much. can we make it clear that there is an exponential gain}\litang{Edit on 05/29}
%%Next, we consider the case that $\frac{M}{N}=1-\frac{k+1}{nq}$.  In (\ref{eq:memoryM}), $\lambda<<1-\lambda$ and we approximate $\lambda=0$. In (\ref{eq:memoryR}), $\frac{K(1-\frac{M^*}{N})}{1+\frac{KM^*}{N}}<<\frac{K\frac{M^*}{N}}{1+K(1-\frac{M^*}{N})}$ then we approximate $R=\frac{K(1-\frac{M^*}{N})}{1+\frac{KM^*}{N}}$. Let $R=\frac{nq(1-\frac{1}{q})}{1+k}$ and $K=nq$, we get $\frac{M^*}{N}=\frac{k+\frac{1}{q}}{nq-n+k+1}\approx \frac{k}{nq-(n-k-1)}\ge \frac{k}{nq}$, and thus $\frac{M'}{N}\ge \frac{k}{nq}$.

The next set of comparisons are with other proposed schemes in the literature. We note here that several of these are restrictive in the parameters that they allow.
\subsection{Comparison with \cite{maddahN14}, \cite{yan_et_al17},\cite{yan2016placement}, \cite{shangguan2016centralized} and \cite{shanmugam2017coded}}

%\litang{We did not mention the comparsion with Mad-Ali's scheme in this section} \aditya{Include that comparison and also check all calculations carefully.}
For comparison with \cite{maddahN14}, denote  $R^{MN}$  and $F_s^{MN}$ be the rate and the subpacketization level of the scheme of \cite{maddahN14}, respectively. For the rate comparison, we note that
\begin{align*}
 \frac{R^*}{R^{MN}}=\frac{1+n}{1+k},&\text{~~for~} \frac{M}{N}=\frac{1}{q}\\
\frac{R^*}{R^{MN}}=\frac{nq-k}{nq-n},&\text{~~for~} \frac{M}{N}=1-\frac{1+k}{nq},
\end{align*}

For the comparison of  subpacketization level we have the following results.
\begin{claim} When $K = nq$, the following results hold.
	\label{claim:compare_MN}
	\begin{itemize}
		\item If  $\frac{M}{N}=\frac{1}{q}$, we have
		\begin{align}
		\lim_{n \rightarrow \infty} \frac{1}{K}\log_2\frac{F_s^{MN}}{F_s^*} = H_2\bigg{(}\frac{1}{q}\bigg{)} -\frac{\eta}{q} \log_2 q. \label{eq:scaling_gain}
		\end{align}
		\item If  $\frac{M}{N}=1-\frac{k+1}{nq}$, we have %\aditya{restate result in terms of limits} \litang{fix it}
		\begin{align}
		\lim_{n \rightarrow \infty}\frac{1}{K}\log_2\frac{F_s^{MN}}{F_s^*}= H_2\bigg{(}\frac{\eta}{q}\bigg{)}-\frac{\eta}{q} \log_2 q.
		\end{align}
	\end{itemize}
	%In the above expressions, $0 < \eta = k/n < 1$, $0 < \eta' =(k+1)/n \le 1$ and $H_2(\cdot)$ represents the binary entropy function.
	In the above expressions, $0 < \eta =k/n \le 1$ and $H_2(\cdot)$ represents the binary entropy function. % and $F_s^*$ and $F_s^{MN}$ denote the subpacketization level of our scheme and the scheme of \cite{maddahN14} respectively.
\end{claim}
\begin{proof}
	Both results are simple consequences of approximating $\binom{K}{Kp}\approx 2^{KH_2(p)}$ \cite{graham1994concrete}. The derivations can be found in the Appendix.
\end{proof}
It is not too hard to see that $F_s^*$ is exponentially lower than $F_s^{MN}$. Thus, our rate is higher, but the subpacketization level is exponentially lower.
Thus, the gain in the scaling exponent of with respect to the scheme of \cite{maddahN14} depends on the choice of $R$ and the value of $M/N$. In Fig. \ref{fig:scaling_exponent_gain} we plot this value of different values of $R$ and $q$. The plot assumes that codes satisfying the CCP can be found for these rates and corresponds to the gain in eq. (\ref{eq:scaling_gain}).
\begin{figure}[t]
		\centering
		\includegraphics[scale=0.5]{scaling_exponent_gain.pdf}
		\caption{The plot shows the gain in the scaling exponent obtained using our techniques for different value of $M/N = 1/q$. Each curve corresponds to a choice of $\eta = k/n$.}
		\label{fig:scaling_exponent_gain}

\end{figure}

%For the comparison of  subpacketization level,
%\begin{claim} When $K = nq$ and $n$ is large, the following results hold.
%	\begin{itemize}
%		\item If  $\frac{M}{N}=\frac{1}{q}$, we have
%		\begin{align*}
%		\frac{F_s^*}{F_s^{MN}}\approx q^{n(\eta -1)}z(\frac{q-1}{q})^{n(q-1)}.
%		\end{align*}
%		\item If  $\frac{M}{N}=1-\frac{k+1}{nq}$, we have
%		\begin{align*}
%		\frac{F_s^*}{F_s^{MN}}&\approx {\eta'}^{n\eta'-1}(\frac{q-\eta'}{q})^{n(q-\eta')}.
%		\end{align*}
%	\end{itemize}
%	In the above expressions, $0 < \eta = k/n < 1$, $0 < \eta' =(k+1)/n \le 1$. % and $F_s^*$ and $F_s^{MN}$ denote the subpacketization level of our scheme and the scheme of \cite{maddahN14} respectively.
%\end{claim}
%\begin{proof}
%	Both results are simple consequences of approximating $\binom{K}{Kp}\approx 2^{KH(p)}$  where $H(\cdot)$ represents the binary entropy function \cite{graham1994concrete}.
%\end{proof}
%It is not too hard to see that $F_s^*$ is exponentially lower than $F_s^{MN}$. Thus, our rate is higher, but the subpacketization level is exponentially lower.
%



In \cite{yan_et_al17} a scheme for the case when $M/N = 1/q$ or $M/N = 1 - 1/q$ with subpacketization level exponentially smaller with respect to \cite{maddahN14} was presented. This result can be recovered a special case of
our work (Theorem \ref{them:main}) when the linear block code is chosen as a single parity check code over $\mathbb{Z} \mod q$. In this specific case, $q$ does not need to be a prime power. Thus, our results subsume the results of \cite{yan_et_al17}.

In a more recent preprint, reference \cite{yan2016placement}, proposed a caching system with $K =\binom{m}{a}$, $F_s=\binom{m}{b}$ and $M/N = 1 -\binom{a}{\lambda}\binom{m-a}{b-\beta}/ \binom{m}{b}$. The corresponding rate is %$Z^{YAN}=\binom{m}{b}-\binom{a}{\lambda}\binom{m-a}{b-\lambda}$, and
$$R = \frac{\binom{m}{a+b-2\beta}}{\binom{m}{b}}\min \bigg{\{} \binom{m-(a+b-2\beta)}{\lambda},\binom{a+b-2\beta}{a-\beta} \bigg{\}},$$
where $m,a,b,\beta$ are positive integers and $0<a<m$, $0<b<m$, $0\le \beta \le \min\{a,b\}$. While a precise comparison is somewhat hard, we can compare the schemes for certain parameter choices, that were also considered in \cite{yan2016placement}.

Let $a=2$, $\beta=1$, $m=2b$. This corresponds to a coded caching system with $K=b(2b-1)\approx 2b^2$, $\frac{M}{N}=\frac{b-1}{2b-1}\approx \frac{1}{2}$, $F_s=\binom{2b}{b}\approx 2^{2b}$, $R=b$. For comparison with our scheme we keep the transmission rates of both schemes roughly the same and let $n=b^2$, $q=2$, $k=b-1$. We assume that the corresponding linear block code exists. Then $F^*_s\approx 2^b$, which is better than $F_s$.

On the other hand if we let $\beta=0$, $a=2$, $m=2qb$, we obtain a coded caching system with
$K=\frac{m(m-1)}{2}$, $\frac{M}{N}\approx \frac{1}{q}$, $F_s=\binom{m}{\frac{m}{2q}}\approx (2q)^{\frac{m}{2q}}$, $R^{YAN}=(2q-1)^2$.
For keeping the rates the same, we let $n=\frac{m(m-1)}{2q}$, $k= \frac{m(m-1)}{4q(2q-1)}-1$ so that  $F^*_s\approx q^{\frac{m(m-1)}{4q(2q-1)}}\approx q^{\frac{m^2}{8q^2}}$. In this regime, the subpacketization level of \cite{yan2016placement} will typically be lower.
%Compared with our scheme by keeping the transmission rates of both scheme roughly the same, we let $n=\frac{m(m-1)}{2q}$, $k= \frac{m(m-1)}{4q(2q-1)}-1$ and $F^*_s\approx q^{\frac{m(m-1)}{4q(2q-1)}}\approx q^{\frac{m^2}{8q^2}}$. $F_s^{YAN}$ is lower than $F^*_s$ when $\frac{q}{m}$ is small.

%For comparison with \cite{maddahN14}, we note that for $\frac{M}{N}=\frac{1}{q}$
%%Firstly, we compare our result with \cite{maddahN14}. For $\frac{M}{N}=\frac{1}{q}$,
%\begin{align*}
%\frac{R^*}{R^{MN}} &=\frac{1+n}{1+k}, \text{~and}\\
%\frac{F_s^*}{F_s^{MN}} &\approx q^{k-n}z \bigg{(}\frac{q-1}{q}\bigg{)}^{n(q-1)}.
%\end{align*}
%It is not too hard to see that $F_s^*$ is exponentially lower than $F_s^{MN}$. Thus, our rate is higher, but the subpacketization level is exponentially lower.
%A similar result can be shown in the case when $M/N = 1 - \frac{k+1}{nq}$ (see Appendix).

%
%\begin{example}
%	In Example \ref{ex:delivery}, the transmission rate of server is $\frac{8}{3}$ and subpacketization level is $27$.  In contrast, the scheme of \cite{maddahN14} would require a subpacketization level of $\binom{12}{4} = 495$ with a rate of $\frac{8}{5}$. It can be observed that the transmission rate in proposed scheme is higher than that in \cite{maddahN14} but the subpacketization level is exponentially lower than \cite{maddahN14}.
%\end{example}


%\subsection{Comparison with \cite{cheng2016optimal} and \cite{cheng2017optimal}}
%
%Let $\Delta$ be the number of equations transmitted in the delivery phase and $Z$ be the number of subfiles cached in each user. Clearly, $\frac{Z}{F_s}=\frac{M}{N}$ and $R=\frac{\Delta}{F_s}$. \cite{cheng2016optimal} and \cite{cheng2017optimal} proposed some lower bounds of $\Delta$ for given $K$, $F_s$, $Z$ based on placement delivery array (PDA) technique. In this section, we compare our result with these lower bounds and show that some of our results are optimal based on these lower bounds. To this end, recall that in our construction, for cache size $\frac{M}{N}=\frac{1}{q}$, $K=nq$, $F_s=q^kz$, $Z={F_s}\frac{M}{N}=q^{k-1}z$,  $\Delta=(q-1)q^k\frac{zn}{k+1}$ and for another cache size $\frac{M}{N}=1-\frac{k+1}{nq}$, we have $K=nq$, $F_s=(q-1)q^k\frac{zn}{k+1}$, $Z=(q-1)q^k\frac{zn}{k+1}(1-\frac{k+1}{nq})$, $\Delta = q^kz$.
%
% Firstly, we compare our result with \cite{cheng2016optimal}.
%\begin{theorem}
%	\cite{cheng2016optimal} Given positive $K$, $F_s$, $Z$ with $F\ge Z$,
%	\begin{equation}
%	\label{eq:lowerbound1}
%	\Delta^* \ge \bigg\lceil \frac{(F_s-Z)K}{F_s}\bigg\rceil+\bigg\lceil \frac{F_s-Z-1}{F_s-1} \bigg\lceil \frac{(F_s-Z)K}{F_s}\bigg\rceil\bigg\rceil + \dots+ \bigg\lceil \frac{1}{Z+1}\bigg\lceil \frac{2}{Z+2} \bigg\lceil\dots \bigg\lceil \frac{(F_s-Z)K}{F_s}\bigg\rceil \dots \bigg\rceil \bigg\rceil\bigg\rceil
%	\end{equation}
%\end{theorem}
%Table \ref{Table:Compare} shows a numerical multiplicative gap between our result and $\Delta^*_{low}$, the lower bound  in (\ref{eq:lowerbound1}), with $n=10, q=10$.
%\begin{table}[t]
%	\centering
%	\label{Table:Compare}
%	
%	\begin{tabular}{ccccccccc}
%		\hline
%		\hline
%		$k$ & 9 & 8 & 7 & 6 & 5 & 4 & 3 & 2\\
%		\hline
%		\hline
%		$\frac{\Delta}{\Delta^*_{low}}$  & $1.1$  & $1.2$  &$1.3$   & $1.5$   & $1.8$    & $2.2$  &$2.7$ & $3.3$\\
%		\hline
%		\hline
%	\end{tabular}
%	
%	\caption{Numerical multiplicative gap between our result and lower bound $\Delta^*_{low}$ in (\ref{eq:lowerbound1}) with $n=10, q=10$, and different values of $k$}.
%\end{table}
%
%\cite{cheng2016optimal} proposed two classes of optimal $(K,F_s,Z,\Delta)$ PDA for $Z=1$ and $Z=F-1$, that is,  for arbitrary $ K,F_s$, $\Delta$ can achieve the lower bound in (\ref{eq:lowerbound1}) for $Z=1$ and $Z=F_s-1$. \cite{cheng2016optimal} also proposed some classes of optimal  $(K,F_s,Z,\Delta)$ PDA for $Z=F_s-2$ and $Z=F_s-3$ for specific $K$ and $F_s$. We demonstrate that our construction can achieve optimal delivery rate for $Z=1$. Since our construction cannot achieve the cache size $Z=F_s-1$, $F_s-2$ and $F_s-3$, we ignore the comparison with these three cache sizes.
%
%\begin{theorem}
%	\label{thm:optimalZ1}
%	\cite{cheng2016optimal}  There exists an optimal $(K,F_s,1,m\binom{F_s}{2}-\frac{(F_s-\kappa)(F_s-\kappa-1)}{2})$ for any positive integers $K$ and $F_s$, where $K=(m-1)F_s+\kappa$ with $m\ge 1$ and $0\le \kappa<F_s$.
%\end{theorem}
%To achieve $Z=1$, we let $n=2, k=1$ in our construction. For cache size $\frac{M}{N}=\frac{1}{q}$, $K=2q$, $F_s=q$, $Z=1$, $\Delta=q(q-1)$. Then we have $m=3$ and $\kappa=0$. Applying Theorem \ref{thm:optimalZ1},
%\begin{align*}
%m\binom{F_s}{2}-\frac{(F_s-\kappa)(F_s-\kappa-1)}{2}=q(q-1),
%\end{align*}
%which means $\Delta=q(q-1)$ is optimal.
%
%Next, we compare with our result with \cite{cheng2017optimal}.
%\begin{theorem}
%\cite{cheng2017optimal}
%Given $K$, $F$, $n$, where $n=(F_s-Z)K$,
%\begin{equation}
%\label{eq:lowerbound2}
%\Delta^*\ge \frac{nF_s}{KF_s+F_s-n}=\frac{K(F_s-Z)F_s}{F_s+KZ}
%\end{equation}
%\end{theorem}
%
%For cache size $\frac{M}{N}=\frac{1}{q}$ in our construction, $\Delta^*_{low}$, the lower bound of $\Delta^*$, is denoted by $\Delta^*_{low}=\frac{n(q-1)q^kz}{n+1}$. Then
%\begin{align*}
%	\frac{\Delta}{\Delta^*_{low}}=\frac{1+n}{1+k}.
%\end{align*}
%It shows that our result is very closed to the optimal transmission rate when the code rate of linear code is very high. For example, if $n=k+1$,
%\begin{align*}
% \lim_{n\to \infty}\frac{\Delta}{\Delta^*_{low}} = \frac{1+n}{n}=1.
%\end{align*}
%
%For cache size $\frac{M}{N}=1-\frac{k+1}{nq}$ in our construction, $\Delta^*_{low}=\frac{(q-1)q^kzn}{nq-k}$. Then
%\begin{align*}
%\frac{\Delta}{\Delta^*_{low}}=\frac{nq-n}{nq-k}.
%\end{align*}
%Similar to the case of $\frac{M}{N}=\frac{1}{q}$, when $\frac{M}{N}=1-\frac{k+1}{nq}$, our result is very closed to the optimal transmission rate when the code rate of linear code is very high. For example, if $n=k+1$,
%\begin{align*}
%\lim_{n\to \infty}\frac{\Delta}{\Delta^*_{low}} = \frac{nq-n}{nq-n+1}=1.
%\end{align*}

%\subsection{Comparison with , \cite{shangguan2016centralized} and \cite{shanmugam2017coded}}
%
%\cite{yan2016placement}, \cite{shangguan2016centralized} and \cite{shanmugam2017coded} proposed a series of uncoded centralized caching scheme with specific $K$ and cache size.

The work of \cite{shangguan2016centralized} proposed caching schemes with parameters (i) $K=\binom{m}{a}$, $\frac{M}{N}=1-\frac{\binom{m-a}{b}}{\binom{m}{b}}$, $F_s=\binom{m}{b}$ and $R=\frac{\binom{m}{a+b}}{\binom{m}{b}}$, where $a,b,m$ are positive integers and $a+b\le m$ and (ii) $K=\binom{m}{t}q^t$, $\frac{M}{N}=1-\frac{1}{q^t}$, $F_s=q^m(q-1)^t$ and $R=\frac{1}{(q-1)^t}$, where $q,t,m$ are positive integers.

Their scheme (i), is the special case of scheme in \cite{yan2016placement} when $\beta=0$. For the second scheme, if we let $t=2$, \cite{shangguan2016centralized} shows that $R\approx R^*$, $F_s\approx q^{\sqrt{\frac{K}{2q}}}(\sqrt{q}-1)^2$ and $F_s^*\approx (q-1)q^{\frac{K}{q}-1}$, which means $F_s$ is again better than $F_s^*$. We emphasize here that these results require somewhat restrictive parameter settings.

Finally, we consider the work of \cite{shanmugam2017coded}. In their work, they leveraged the results of \cite{alon2012nearly} to arrive at coded caching schemes where the subpacketization is linear in $K$. Specifically, they show that for any constant $M/N$, there exists a scheme with rate $K^\delta$, where $\delta > 0$ can be chosen arbitrarily small by choosing $K$ large enough. From a theoretical perspective, this is a positive result that indicates that regimes where linear subpacketization scaling is possible. However, these results are only valid when the value of $K$ is very large. Specifically, $K = C^n$ and the result is asymptotic in the parameter $n$. For these parameter ranges, the result of \cite{shanmugam2017coded} will clearly be better as compared to our work.



\section{Conclusions and Future Work}
\label{sec:conclusion}
%In this work, we proposed a coded caching scheme which yields larger parameter ranges for cache size and transmission rate. In particular, the subpacketization level of proposed scheme is exponentially smaller than the scheme in \cite{maddahN14}.

In this work we have demonstrated a link between specific classes of linear block codes and the subpacketization problem in coded caching. Crucial to our approach is the consecutive column property which enforces that certain consecutive column sets of the corresponding generator matrices are full-rank. We present several constructions of such matrices that cover a large range of problem parameters. Leveraging this approach allows us to construct families of coded caching schemes where the subpacketization level is exponentially smaller compared to the approach of \cite{maddahN14}.

There are several opportunities for future work. Even though our subpacketization level is significantly lower than \cite{maddahN14}, it still scales exponentially with the number of users. Of course, the rate of growth with the number of users is much smaller. There have been some recent results on coded caching schemes that demonstrate the existence of schemes where the subpacketization scales sub-exponentially in the number of users. It would be interesting to investigate whether some of these ideas can be leveraged to obtain schemes that work for practical systems with tens or hundreds of users.%can be explored within the space of constructions (or variants thereof) proposed in our work.

%\bibliographystyle{IEEETran}
%\bibliography{refs}

% Generated by IEEEtran.bst, version: 1.14 (2015/08/26)
\begin{thebibliography}{10}
\providecommand{\url}[1]{#1}
\csname url@samestyle\endcsname
\providecommand{\newblock}{\relax}
\providecommand{\bibinfo}[2]{#2}
\providecommand{\BIBentrySTDinterwordspacing}{\spaceskip=0pt\relax}
\providecommand{\BIBentryALTinterwordstretchfactor}{4}
\providecommand{\BIBentryALTinterwordspacing}{\spaceskip=\fontdimen2\font plus
\BIBentryALTinterwordstretchfactor\fontdimen3\font minus
  \fontdimen4\font\relax}
\providecommand{\BIBforeignlanguage}[2]{{%
\expandafter\ifx\csname l@#1\endcsname\relax
\typeout{** WARNING: IEEEtran.bst: No hyphenation pattern has been}%
\typeout{** loaded for the language `#1'. Using the pattern for}%
\typeout{** the default language instead.}%
\else
\language=\csname l@#1\endcsname
\fi
#2}}
\providecommand{\BIBdecl}{\relax}
\BIBdecl

\bibitem{maddahN14}
M.~Maddah-Ali and U.~Niesen, ``Fundamental limits of caching,'' \emph{IEEE
  Trans. on Info. Th.}, vol.~60, no.~5, pp. 2856--2867, May 2014.

\bibitem{ghasemiR17_accepted}
H.~Ghasemi and A.~Ramamoorthy, ``{Improved lower bounds for coded caching},''
  \emph{IEEE Trans. on Info. Th.}, vol.~63, no.~7, pp. 4388--4413, 2017.

\bibitem{sengupta2015improved}
A.~Sengupta, R.~Tandon, and T.~C. Clancy, ``Improved approximation of
  storage-rate tradeoff for caching via new outer bounds,'' in \emph{IEEE Intl.
  Symposium on Info. Th.}, 2015, pp. 1691--1695.

\bibitem{maddahN14mr_tradeoff}
M.~Maddah-Ali and U.~Niesen, ``Decentralized coded caching attains
  order-optimal memory-rate tradeoff,'' \emph{IEEE/ACM Trans. Netw.}, vol.~23,
  no.~4, pp. 1029--1040, 2015.

\bibitem{maddahN14nonuniform_demand}
U.~Niesen and M.~A. Maddah-Ali, ``Coded caching with nonuniform demands,''
  \emph{IEEE Trans. on Info. Th.}, vol.~63, no.~2, pp. 1146--1158, Feb 2017.

\bibitem{hachemKD14a}
J.~Hachem, N.~Karamchandani, and S.~Diggavi, ``Multi-level coded caching,'' in
  \emph{IEEE Intl. Symposium on Info. Th.}, 2014, pp. 56--60.

\bibitem{TangR16}
L.~Tang and A.~Ramamoorthy, ``Coded caching for networks with the resolvability
  property,'' in \emph{IEEE Intl. Symposium on Info. Th.}, 2016.

\bibitem{JJ15}
M.~Ji, M.~F. Wong, A.~M. Tulino, J.~Llorca, G.~Caire, M.~Effros, and
  M.~Langberg, ``On the fundamental limits of caching in combination
  networks,'' in \emph{IEEE 16th International Workshop on Signal Processing
  Advances in Wireless Communications (SPAWC)}, June 2015, pp. 695--699.

\bibitem{ghasemiR17}
H.~Ghasemi and A.~Ramamoorthy, ``Asynchronous coded caching,'' in \emph{IEEE
  Intl. Symposium on Info. Th.}, 2017, pp. 2438--2442.

\bibitem{niesen2015coded}
U.~Niesen and M.~A. Maddah-Ali, ``Coded caching for delay-sensitive content,''
  in \emph{IEEE Intl. Conf. Comm.}, 2015, pp. 5559--5564.

\bibitem{toshiba_wp}
M.~E. Fitzpatrick, ``{4K Sector Disk Drives: Transitioning to the Future with
  Advanced Format Technologies},'' {Toshiba 4K White Paper}, 2011, [Online]
  \url{Available:
  http://cdaweb01.storage.toshiba.com/docs/services-support-documents/toshiba_4kwhitepaper.pdf}.

\bibitem{shanmugam_et_al14}
K.~Shanmugam, M.~Ji, A.~M. Tulino, J.~Llorca, and A.~G. Dimakis, ``Finite
  length analysis of caching-aided coded multicasting,'' in \emph{52nd Annual
  Allerton Conference on Communication, Control, and Computing}, Sept 2014, pp.
  914--920.

\bibitem{shanmugam_et_al16}
K.~Shanmugam, M.~Ji, A.~M. Tulino, J.~Llorca, and A.~G. Dimakis.,
  ``Finite-length analysis of caching-aided coded multicasting,'' \emph{IEEE
  Trans. on Info. Th.}, vol.~62, no.~10, pp. 5524--5537, 2016.

\bibitem{yan_et_al17}
Q.~Yan, M.~Cheng, X.~Tang, and Q.~Chen, ``On the placement delivery array
  design for centralized coded caching scheme,'' \emph{IEEE Trans. on Info.
  Th.}, vol.~63, no.~9, pp. 5821--5833, 2017.

\bibitem{shangguan2016centralized}
C.~Shangguan, Y.~Zhang, and G.~Ge, ``Centralized coded caching schemes: A
  hypergraph theoretical approach,'' preprint, 2016, [Online] Available:
  https://arxiv.org/abs/1608.03989.

\bibitem{shanmugam2017coded}
K.~Shanmugam, A.~M. Tulino, and A.~G. Dimakis, ``{Coded caching with linear
  subpacketization is possible using Ruzsa-Szem{\'{e}}redi graphs},'' in
  \emph{IEEE Intl. Symposium on Info. Th.}, June 2017, pp. 1237--1241.

\bibitem{olmezR16}
O.~Olmez and A.~Ramamoorthy, ``{Fractional repetition codes with flexible
  repair from combinatorial designs},'' \emph{IEEE Trans. on Info. Th.},
  vol.~62, no.~4, pp. 1565 --1591, 2016.

\bibitem{tripathyR15}
A.~S. Tripathy and A.~Ramamoorthy, ``Capacity of sum-networks for different
  message alphabets,'' in \emph{IEEE Intl. Symposium on Info. Th.}, 2015, pp.
  606--610.

\bibitem{tripathyR17}
------, ``{"Sum-networks from incidence structures: construction and capacity
  analysis},'' \emph{IEEE Trans. on Info. Th.}, 2017 (to appear).

\bibitem{Stinson}
D.~R. Stinson, \emph{Combinatorial Designs: Construction and Analysis}.\hskip
  1em plus 0.5em minus 0.4em\relax Springer, 2003.

\bibitem{yan2016placement}
Q.~Yan, X.~Tang, Q.~Chen, and M.~Cheng, ``Placement delivery array design
  through strong edge coloring of bipartite graphs,'' \emph{IEEE Communications
  Letters}, 2017 (to appear).

\bibitem{RonRoth}
R.~M. Roth, \emph{Introduction to Coding Theory}.\hskip 1em plus 0.5em minus
  0.4em\relax Cambridge University Press, 2006.

\bibitem{lincostello}
S.~Lin and D.~J. Costello, \emph{Error Control Coding, 2nd Ed.}\hskip 1em plus
  0.5em minus 0.4em\relax Prentice Hall, 2004.

\bibitem{dummit2003abstract}
D.~S. Dummit and R.~M. Foote, \emph{Abstract algebra}.\hskip 1em plus 0.5em
  minus 0.4em\relax Wiley, 3rd Ed., 2003.

\bibitem{blake1972codes}
I.~F. Blake, ``Codes over certain rings,'' \emph{Information and Control},
  vol.~20, no.~4, pp. 396--404, 1972.

\bibitem{graham1994concrete}
R.~L. Graham, D.~E. Knuth, and O.~Patashnik, \emph{Concrete mathematics: a
  foundation for computer science (2nd ed.)}.\hskip 1em plus 0.5em minus
  0.4em\relax Addison-Wesley Professional, 1994.

\bibitem{alon2012nearly}
N.~Alon, A.~Moitra, and B.~Sudakov, ``Nearly complete graphs decomposable into
  large induced matchings and their applications,'' in \emph{Proc. of the 44-th
  Annual ACM symposium on Theory of computing (STOC)}, 2012, pp. 1079--1090.

\bibitem{hornJ91}
R.~A. Horn and C.~R. Johnson, \emph{Topics in matrix analysis}.\hskip 1em plus
  0.5em minus 0.4em\relax Cambridge University Press, 1991.

\end{thebibliography}


\appendix
%\subsection*{Proof of Claim \ref{claim:signalgenerattion}}
%    	In the arguments below, for the sake of convenience we argue that user $U_{B_{i_1,l_{i_1}}}$, $i_1\in \calS_a$ can recover all its missing subfiles with superscript $E_a(B_{i_1,l_{i_1}})$. Note that $|B_{i_1,l_{i_1}}|=q^{k-1}$. Thus user $U_{B_{i_1,l_{i_1}}}$ needs to obtain $q^k-q^{k-1}$ missing subfiles with superscript $E_a(B_{i_1,l_{i_1}})$. The equation in Algorithm \ref{Alg:Signal} allows $U_{B_{i_1,l_{i_1}}}$ to recover $W^{E_a(B_{i_1,l_{i_1}})}_{d_{B_{i_1,l_{i_1}}},\hat{l}_{i_1}}$ where $\hat{l}_{i_1} = \cap_{j \in \calS_a \setminus \{i_1\}}B_{j,l_j}$. Note that $U_{B_{i_1,l_{i_1}}}$ does not have $W^{E_a(B_{i_1,l_{i_1}})}_{d_{B_{i_1,l_{i_1}}},\hat{l}_{i_1}}$ since $B_{i_1,l_{i_1}}\bigcap \cap_{j \in \calS_a \setminus \{i_1\}}B_{j,l_j}= \emptyset$.
%    	
%    	Next we count the number of equations that $U_{B_{i_1,l_{i_1}}}$ participates in. We can pick $k-1$ users from parallel classes $\calP_{i_2}, \calP_{i_3}, \cdots, \calP_{i_{k}}$. Claim \ref{claim:MDSintersection} ensures the blocks corresponding to users from $\calP_{i_1}, \cdots, \calP_{i_k}$ intersect in a single point. There are totally $q^{k-1}$ ways to pick them. Next we pick a block from $\calP_{i_{k+1}}$ such that the intersection of all blocks is empty. This can be done in $q-1$ ways. Thus there are a total of $q^{k-1}(q-1)$ equations in which user $U_{B_{i_1,l_{i_1}}}$ participates in.
%    	
%    	It remains to argue that each equation provides a distinct file part of user $U_{B_{i_1,l_{i_1}}}$ with superscript $E_a(B_{i_1,l_{i_1}})$. Towards this end suppose that there exist sets of blocks $\{B_{i_2,l_{i_2}},\cdots, B_{i_{k+1},l_{i_{k+1}}}\}$ and $\{B_{i_2,l'_{i_2}}, \cdots, B_{i_{k+1},l'_{i_{k+1}}}\}$ such that $\{B_{i_2,l_{i_2}}, \cdots, B_{i_{k+1},l_{i_{k+1}}}\}\neq \{B_{i_2,l'_{i_2}}, \cdots, B_{i_{k+1},l'_{i_{k+1}}}\}$, but $\cap_{j=2}^{k+1} B_{i_j,l_{i_j}}=\cap_{j=2}^{k+1} B_{i_j,l'_{i_j}}=\beta$. This is a contradiction since this in turn implies that $\beta \in \cap_{j=2}^{k+1} B_{i_j,l_{i_j}}\bigcap \cap_{j=2}^{k+1} B_{i_j,l'_{i_j}}$, which is impossible since two blocks from the same parallel class have an empty intersection.
%\endproof
\subsection{Resolvable design over $Z\text{~mod~}q$}
%\label{sec:resolv_z_mod_q}
\begin{lemma}
	\label{lemma:resol_ring}
	A $(n,k)$ linear block code over $\mathbb{Z} \text{~mod~}q$ with generator matrix $\bfG=[g_{ab}]$ can construct a resolvable block design by the procedure in Section \ref{sec:construction} if $\gcd(q,g_{0b},g_{1b},\cdots,g_{(k-1)b})=1$ for $0\le b<n$.%, where $\gcd(x,y)$ denotes the greatest common divisor of $x$ and $y$.
\end{lemma}
\begin{proof}
    Assume $q=q_1\times q_2\times \cdots \times q_d$ where $q_i$, $1\le i\le d$ is a prime or a prime power. If the $\gcd(q,g_{0b}, g_{1b}, \cdots, g_{(k-1)b})=1$, then it is evident that $\gcd(q_i,g_{0b}, g_{1b},\cdots, g_{(k-1)b})=1$ for $1\le i\le d$. As $q_i$ is either a prime or a prime power, it follows that there exists a $g_{a^*b}$ which is relatively prime to $q_i$, i.e., $g_{a^*b}$ is a unit in the ring $\mathbb{Z} \mod q_i$.

    Note that for $\Delta = [\Delta_0 ~\Delta_1~ \dots~\Delta_{n-1}]= \bfu \bfG$, we have
	\begin{equation}
	\label{eq:resolring}
	\Delta_b = \sum_{a=0}^{k-1} \bfu_ag_{ab},
	\end{equation}
	where $\bfu=[\bfu_0,\cdots, \bfu_{k-1}]$. We consider eq. (\ref{eq:resolring}) over the ring $\mathbb{Z} \mod q_i$ and rewrite eq. (\ref{eq:resolring}) as
	\begin{align*}
	\Delta_b-\bfu_{a^*}g_{a^*b}=\sum_{a\neq a^*}\bfu_ag_{ab},
	\end{align*}
	For arbitrary $\bfu_a$, $a\neq a^*$, this equation has a unique solution for $\bfu_{a^*}$ since $g_{a^*b}$ is a unit in $\mathbb{Z} \mod q_i$. This implies that there are $q_i^{k-1}$ distinct solutions for (\ref{eq:resolring}) over $\mathbb{Z} \mod q_i$. Using the Chinese remainder theorem, eq. (\ref{eq:resolring}) has $q_1^{k-1}\times q_2^{k-1}\times \cdots q_d^{k-1}=q^{k-1}$ solutions over $\mathbb{Z} \mod q$ and the result follows.
	 %then the rank of coefficient matrix of above equation is identical to that of the augmented matrix,
	%\begin{align*}
	%rank [g_{0b},g_{1b},\cdots,g_{(k-1)b}]&=rank [g_{0b}, g_{1b},\cdots, %g_{(k-1)b},\Delta_b]=1,
	%\end{align*}
	%and therefore $rank [g_{0b},g_{1b},\cdots,g_{(k-1)b}]=1$ over $Z\text{~mod~}q_i$
\end{proof}


%\begin{lemma}
%	\label{lemma:resol_ring}
%	A $(n,k)$ linear block code over $\mathbb{Z} \text{~mod~}q$ with generator matrix $\bfG=[g_{ab}]$ can construct a resolvable block design by the procedure in Section \ref{sec:construction} if $\gcd(q,g_{0b},g_{1b},\cdots,g_{(k-1)b})=1$ for $0\le b<n$.%, where $\gcd(x,y)$ denotes the greatest common divisor of $x$ and $y$.
%\end{lemma}
%\begin{proof}
%    Assume $q=q_1\times q_2\times \cdots \times q_d$ where $q_i$, $1\le i\le d$ is prime or a prime power. If the $\gcd(q,g_{0b}, g_{1b}, \cdots, g_{(k-1)b})=1$, then it is evident that $\gcd(q_i,g_{0b}, g_{1b},\cdots, g_{(k-1)b})=1$ for $1\le i\le d$. Therefore there exists a $g_{a^*b}$ such that $g_{a^*b}$ is a unit in the ring $\mathbb{Z} \mod q_i$.
%
%    Note that for $\Delta = [\Delta_0 ~\Delta_1~ \dots~\Delta_{n-1}]= \bfu \bfG$, we have
%	\begin{equation}
%	\label{eq:resolring}
%	\Delta_b = \sum_{a=0}^{k-1} \bfu_ag_{ab},
%	\end{equation}
%	where $\bfu=[\bfu_0,\cdots, \bfu_{k-1}]$. We consider eq. (\ref{eq:resolring}) over the ring $\mathbb{Z} \mod q_i$ and rewrite eq. (\ref{eq:resolring}) as
%	\begin{align*}
%	\Delta_b-\bfu_{a^*}g_{a^*b}=\sum_{a\neq a^*}\bfu_ag_{ab},
%	\end{align*}
%	For arbitrary $\bfu_a$, $a\neq a^*$, this equation has a unique solution for $\bfu_{a^*}$ since $g_{a^*b}$ is assumed to be an unit. This implies that there are $q_i^{k-1}$ distinct solutions for (\ref{eq:resolring}) over $\mathbb{Z} \mod q_i$. Using the Chinese remainder theorem, eq. (\ref{eq:resolring}) has $q_1^{k-1}\times q_2^{k-1}\times \cdots q_d^{k-1}=q^{k-1}$ solutions over $\mathbb{Z} \mod q$ and the result follows.
%	 %then the rank of coefficient matrix of above equation is identical to that of the augmented matrix,
%	%\begin{align*}
%	%rank [g_{0b},g_{1b},\cdots,g_{(k-1)b}]&=rank [g_{0b}, g_{1b},\cdots, %g_{(k-1)b},\Delta_b]=1,
%	%\end{align*}
%	%and therefore $rank [g_{0b},g_{1b},\cdots,g_{(k-1)b}]=1$ over $Z\text{~mod~}q_i$
%\end{proof}
\begin{remark}
	From Lemma \ref{lemma:resol_ring}, it can be easily verified that a linear block code over $\mathbb{Z}\text{~mod~}q$ can construct a resolvable block design if one of the following conditions for each column $\bfg_i$ of the generator matrix is satisfied.
	\begin{itemize}
		\item At least one non-zero entry of $\bfg_i$ is a unit in $\mathbb{Z} \mod q$, or
		\item all non-zero entries in $\bfg_i$ are zero divisors but their greatest common divisor is 1.
	\end{itemize}	
	For the SPC code over $\mathbb{Z}\text{~mod~}q$, all the non-zero entries in the generator matrix are $1$, which is an unit. Therefore, the construction always results in a resolvable design.
\end{remark}
\subsection*{Proof of Lemma \ref{lemma:delivery}}
First, we show that the proposed delivery scheme allows each user's demand to be satisfied. Note that Claim \ref{claim:signalgeneration} shows that each user in a parallel class that belongs to the recovery set $\calS_a$ recovers all missing subfiles with a specified superscript from it. Thus, we only need to show that if signals are generated (according to Claim \ref{claim:signalgeneration}) for each recovery set, we are done. This is equivalent to showing that the bipartite recovery set graph is such that each parallel class has degree $z$ and multiple edges between nodes are disallowed.

%It is sufficient to show that the degree of parallel class node in bipartite recovery set graph obtained by recovery set $\calS_a$ is $z$.

Towards this end, consider the parallel class and we claim that there exist exactly $z$ solutions $(a_\alpha, b_\alpha)$ for integer values of $\alpha=1, \dots, z$ to the equation
%\litang{Change the following to above: Towards this end, consider the parallel class $\calP_j$ where $(a_1(k+1)+b_1)_n=j < n$. Next, we claim that there exist exactly $z$ solutions $(a_\alpha, b_\alpha)$ for integer values of $\alpha=1, \dots, z$ to the equation}
\begin{align}
a_\alpha (k+1) + b_\alpha &= j + n(\alpha-1) \label{eq:congruence}
\end{align}
such that $a_{\alpha_1} \neq a_{\alpha_2}$ for $\alpha_1 \neq \alpha_2$ and $j < n$.
The existence of the solution for each equation above follows from the division algorithm. Note that $a_\alpha < nz/(k+1)$ as the $RHS < nz$. Furthermore, note that for $1 \leq \alpha_1 \leq z$ and $1 \leq \alpha_2 \leq z$, we cannot have solutions to eq. (\ref{eq:congruence}) such that $a_{\alpha_1} = a_{\alpha_2}$ as this would imply that $ |b_{\alpha_1} - b_{\alpha_2}| \geq n$ which is a contradiction.
This shows that each parallel class $P_j$ participates in at least $z$ different recovery sets.

The following facts follow easily from the construction of the recovery sets. The degree of each recovery set in the bipartite graph is $k+1$ and there are $\frac{nz}{k+1}$ of them; multiple edges between a recovery set and a parallel class are disallowed. Therefore, the total number of edges in the bipartite graph is $nz$. As each parallel class participates in at least $z$ recovery sets, by this argument, it participates in exactly $z$ recovery sets.
.

Finally, we calculate the rate of the delivery phase. In total, the server transmits $q^k(q-1)\frac{zn}{k+1}$ equations, where the symbol transmitted has the size of a subfile. Thus, the rate is
\begin{align*}
R&=q^k(q-1)\frac{zn}{k+1}\frac{1}{q^kz}\\
&=\frac{(q-1)n}{k+1}.
\end{align*}
\endproof


%\subsection*{Proof of Claim \ref{claim:cyclic_k1}}
%%\begin{proof}
%Let the generator polynomial of the cyclic code be $\bfg(X)$ with degree $n-k$. Let $\bfG_{\calS}=[\bfg_{(a)_n},\bfg_{(a+1)_n},\cdots,\bfg_{(a+k)_n}]$ where we assume that $\bfG_{\calS}$ satisfies the $(k,k+1)$-CCP. %We need to show that if $\bfG_{\calS}$ satisfies the $(k,k+1)$-CCP, then any $k \times k$ submatrix of $\bfG_{\calS'}=[\bfg_{(a+i)_n}\bfg_{(a+1+i)_n}\cdots\bfg_{(a+k+i)_n}]$, for $i<n$, is full rank.
%Let
%\begin{align*}
%\bfG_{\calS\setminus j} &= [\bfg_{(a)_n},\cdots,\bfg_{(a+j-1)_n},\bfg_{(a+j+1)_n},\cdots,\bfg_{(a+k)_n}], \text{and}\\
%\bfG_{\calS'\setminus j} &=[\bfg_{(a+i)_n},\cdots,\bfg_{(a+j-1+i)_n},\bfg_{(a+j+1+i)_n},\cdots,\bfg_{(a+k+i)_n}].
%\end{align*}
%We need to show that if $\bfG_{\calS\setminus j}$ has full rank, then $\bfG_{\calS'\setminus j}$ has full rank, for any $0\le j\le k$.
%
%As $\bfG_{\calS\setminus j}$ has full rank, there is no codeword $\bfc \neq \mathbf{0}$ such that $\bfc((a)_n)=\cdots=\bfc((a+j-1)_n)=\bfc((a+j+1)_n)=\cdots=\bfc((a+k)_n)=0.$
%By the definition of a cyclic code, any circular shift of a codeword results in another codeword that belongs to the code. Therefore, there is no codeword $\bfc'$ such that $\bfc'((a+i)_n)=\cdots=\bfc'(a+j-1+i)_n)=\bfc'((a+j+1+i)_n)=\cdots=\bfc'((a+k+i)_n)=0.$ Thus, $\bfG_{\calS'\setminus j}$ has full rank. \qed
%%\end{proof}

\subsection*{Proof of Claim \ref{claim:cyclic_MDS}}
The matrix  $\bfG_\calS$ is shown below.
\begin{align*}
\begin{bmatrix}
g_0&g_1&\cdot&\cdot&g_{\lceil\frac{k}{2}\rceil-1}&0&\cdot&\cdot&0&0\\
0&g_0&g_1&\cdot&g_{\lceil\frac{k}{2}\rceil-2}&0&\cdot&\cdot&0&0\\
\vdots&&&&&&&&&\vdots\\
0&\cdot&0&g_0&g_1&0&\cdot&\cdot&0&0\\
0&\cdot&\cdot&0&g_0&g_{n-k}&0&\cdot&\cdot&0\\
0&\cdot&\cdot&0&0&g_{n-k-1}&g_{n-k}&0&\cdot&0\\
\vdots&&&&&&&&&\vdots\\
0&\cdot&\cdot&0&0&g_{n-k-\lfloor \frac{k}{2}\rfloor}&\cdot&\cdot&\cdot&g_{n-k}
\end{bmatrix}
\end{align*}
In the above expression and the subsequent discussion if $i$ is such that $i < 0$, we set $g_i=0$.

By Claim \ref{claim:cyclic_k1}, a cyclic code with generator matrix $\bfG$ satisfies the CCP if all submatrices \begin{align*}
\bfG_{\calS\setminus (a+j)_n}=&[\bfg_{(a)_n},\bfg_{(a+1)_n},\cdots,\bfg_{(a+j-1)_n},\\
&~\bfg_{(a+j+1)_n},\cdots,\bfg_{(a+k)_n}],
\end{align*} where $a=n-\lfloor \frac{k}{2}\rfloor-1$, $0\le j\le k$, have full rank. %It is obtained by deleting the column $\bfg_{(a+j)_n}$.
In what follows, we argue that this is true.
%\aditya{I have questions about this proof... It is not clear}
Note that in the generator matrix of cyclic code, any $k$ consecutive columns are linearly independent \cite{lincostello}. Therefore for $j=0$ and $k$, $\bfG_{\calS\setminus (a+j)_n}$ has full rank, without needing the conditions of Claim \ref{claim:cyclic_MDS}.
For $0<j\le \lfloor \frac{k}{2}\rfloor$, $\bfG_{\calS\setminus (a+j)_n}$ is as eq. (\ref{eq:G_cylic_1}).
\begin{table*}
	\begin{align}
	\label{eq:G_cylic_1}
	\begin{bmatrix}
	g_0&g_1&\cdot&g_{\lceil\frac{k}{2}\rceil-1}&0&\cdot&\cdot&\cdot&\cdot&0\\
	0  &g_0&\cdot&g_{\lceil\frac{k}{2}\rceil-2}&0&\cdot&\cdot&\cdot&\cdot&0\\
	\vdots&&&&&&&&&\vdots\\
	0&\cdot&g_0&g_1&0&\cdot&\cdot&\cdot&\cdot&0\\
	0&\cdot&0&g_0&g_{n-k}&0&\cdot&\cdot&\cdot&0\\
	0&\cdot&\cdot&0&g_{n-k-1}&g_{n-k}&0&\cdot&\cdot&0\\
	\vdots&&&&&&&&&\vdots\\
	0&\cdot&\cdot&0&g_{n-k-j+1}&\cdot&g_{n-k}&0&\cdot&0\\
	0&\cdot&\cdot&0&g_{n-k-j}&\cdot&g_{n-k-1}&0&\cdot&0\\
	0&\cdot&\cdot&0&g_{n-k-j-1}&\cdot&g_{n-k-2}&g_{n-k}&\cdot&0\\
	\vdots&&&&&&&&&\vdots\\
	0&\cdot&\cdot&0&g_{n-k-\lfloor \frac{k}{2}\rfloor}&\cdot&g_{n-k-\lfloor \frac{k}{2}\rfloor+j-1}&g_{n-k-\lfloor \frac{k}{2}\rfloor+j+1}&\cdot&g_{n-k}
	\end{bmatrix}.
	\end{align}
\end{table*}

Rewriting $\bfG_{\calS\setminus (a+j)_n}$ in block form, we get
\begin{align*}
\bfG_{\calS\setminus (a+j)_n}=
\left[
\begin{array}{c|cc}
\mathbf A_j&\multicolumn{2}{c}{\mathbf B_j}\\  \hline
\multirow{2}*{\Huge$\mathbf 0$}&\mathbf C_j&\mathbf 0\\
&\mathbf D_j&\mathbf E_j
\end{array}
\right],
\end{align*}
where
$$\mathbf A_j=\begin{bmatrix}
g_0&g_1&\cdot&\cdot&g_{\lceil\frac{k}{2}\rceil-1}\\
0&g_0&g_1&\cdot&g_{\lceil\frac{k}{2}\rceil-2}\\
\vdots&&&&\vdots\\
0&\cdot&&0&g_0
\end{bmatrix},$$
$$\mathbf C_j=\begin{bmatrix}
g_{n-k-1}&g_{n-k}&0&\cdot&\cdot&0\\
g_{n-k-2}&g_{n-k-1}&g_{n-k}&0&\cdot&0\\
\vdots&&&&&\vdots\\
g_{n-k-j+1}&\cdot&\cdot&\cdot&\cdot&g_{n-k}\\
g_{n-k-j}&\cdot&\cdot&\cdot&\cdot&g_{n-k-1}
\end{bmatrix},$$
and
$$\mathbf E_j=\begin{bmatrix}
g_{n-k}&0&\cdot&\cdot&0\\
g_{n-k-1}&g_{n-k}&0&\cdot&0\\
\vdots&&&&\vdots\\
g_{n-k-\lfloor \frac{k}{2}\rfloor+j+1}&\cdot&\cdot&\cdot&g_{n-k}
\end{bmatrix}.$$
Matrices $\mathbf A_j$ and $\mathbf E_j$ have full rank as they are respectively upper triangular and lower triangular, with non-zero entries on the diagonal (as $g_0$ and $g_{n-k}$ are non-zero in a cyclic code). Therefore, $\bfG_{\calS\setminus (a+j)_n}$ has full rank if $\mathbf C_j$ has full rank.
For $\lfloor \frac{k}{2}\rfloor<j<k$, $\bfG_{\calS\setminus (a+j)_n}$ can be partitioned into a similar form and the result in Claim \ref{claim:cyclic_MDS} follows.
\endproof





\subsection*{Proof of Claim \ref{claim:Gconstruct1}}
We need to argue that all $k\times k$ submatrices of $\bfG_{\calS_{a}}$ where $0\le a< \alpha$ are full rank. In what follows we argue that all $k\times k$ submatrices of $\bfG_{\calS_0}$ are full rank. The proof for any $\bfG_{\calS_a}$ is similar. Note that $\bfG_{\calS_0}$ can be written compactly as follows by using Kronecker products.
\begin{align*}
	\bfG_{\calS_0}=
	\begin{bmatrix}
		\bfA\otimes \bfI_t \\
		\bfB\otimes \bfC_{(t-1)\times t}(1,1)
	\end{bmatrix},
\end{align*}
where 	
\begin{align*}
\bfA &=
\begin{bmatrix}
b_{00}&\cdots&b_{0(z-1)}\\
\vdots&&\vdots\\
b_{(z-2)0}&\cdots&b_{(z-2)(z-1)}
\end{bmatrix}
\end{align*}
and $\bfB =[b_{(z-1)0},\cdots,b_{(z-1)(z-1)}]$.

Next, we check the determinant of submatrices $\bfG_{\calS_0\setminus i}$ obtained by deleting $i$-th column of $\bfG_{\calS_0}$. W.l.o.g, we let $i=(z-1)t+j$ where $0 \leq j < t$. The block form of the resultant matrix $\bfG_{\calS_0\setminus i}$ can be expressed as
\begin{align*}	
	\bfG_{\calS_0\setminus i}&=
	\begin{bmatrix}
	\bfA'\otimes \bfI_t&\bfA''\otimes \Delta_1\\
	\bfB'\otimes \bfC_{(t-1)\times t}(1,1)&\bfB''\otimes \Delta_2
	\end{bmatrix},
\end{align*}
where $\bfA'$ and $\bfA''$ are the first $z-1$ columns and last column of $\bfA$ respectively. Likewise, $\bfB'$ and $\bfB''$ are the first $z-1$ components and last component of $\bfB$. The matrices $\Delta_1$ and $\Delta_2$ are obtained by deleting the $j$-th column of $\bfI_t$ and $\bfC_{(t-1)\times t}(1,1)$ respectively. Then, using the Schur determinant identity \cite{hornJ91}, we have
\begin{align*}
\det(\bfG_{\calS_0\setminus i})=&\det(\bfA'\otimes \bfI_t)\det(\bfB''\otimes \Delta_2-\\
&\bfB'\otimes \bfC_{(t-1)\times t}(1,1)\cdot (\bfA'\otimes \bfI_t)^{-1}\cdot \bfA''\otimes\Delta_1)\\
\overset{(1)}{=}&\det(\bfA'\otimes \bfI_t)\det(\bfB''\otimes \Delta_2-\\
&\bfB'\bfA'^{-1}\bfA''\otimes \bfC_{(t-1)\times t}(1,1)\Delta_1)\\
\overset{(2)}{=}&\det(\bfA'\otimes \bfI_t)\det((\bfB''-\bfB'\bfA'^{-1}\bfA'')\otimes \Delta_2),
%&\overset{(3)}{\neq}0,
\end{align*}
where $(1)$ holds by the properties of the Kronecker product \cite{hornJ91} and $(2)$ holds since $ \bfC_{(t-1)\times t}(1,1)\Delta_1=\Delta_2$. Next note that $\det(\Delta_2) \neq 0$. This is because $\Delta_2$ can be denoted as
	\begin{align*}
\Delta_2=
\left[
\begin{array}{c|c}
\mathbf A&\mathbf \bfzr\\  \hline
\bfzr&\mathbf B
\end{array}
\right],
\end{align*}
where $\bfA$ is a $j\times j$ upper-triangular matrix;
\begin{align*}
\bfA=\begin{bmatrix}
1&1&0&\cdots&0&0\\
0&1&1&\cdots&0&0\\
\vdots&&&&&\vdots\\
0&0&0&\cdots&1&1\\
0&0&0&\cdots&0&1
\end{bmatrix}
\end{align*}
and $\bfB$ is a $(t-1-j)\times (t-1-j)$ lower-triangular matrix;
\begin{align*}
\bfB=\begin{bmatrix}
1&0&\cdots&0&0&0\\
1&1&\cdots&0&0&0\\
\vdots&&&&&\vdots\\
0&0&\cdots&1&1&0\\
0&0&\cdots&0&1&1
\end{bmatrix}.
\end{align*}
Next, we define the matrix
\begin{align*}
\bfF= \begin{bmatrix}
b_{00}&b_{01}&\cdots&b_{0(z-1)}\\
b_{10}&b_{11}&\cdots&b_{1(z-1)}\\
\vdots&&&\vdots\\
b_{(z-1)0}&b_{(z-1)1}&\cdots&b_{(z-1)(z-1)}
\end{bmatrix}.
\end{align*}
Another application of the Schur determinant identity yields
%; $(3)$ holds since $\bfA'$ has full rank and
\begin{align*}
\det(\bfB''-\bfB'\bfA'^{-1}\bfA'')&=\frac{\det(\bfF)}{\det(\bfA')}\\
&\neq 0,
\end{align*}
since $\det(\bfF)$ and $\det(\bfA')$ are both non-zero as their columns have the Vandermonde form. In $\bfF$, the columns correspond to distinct and non-zero elements from $GF(q)$; therefore, $q>z$. Note however, that the above discussion focused only $\bfG_{\calS_0}$. As the argument needs to apply for all $\bfG_{\calS_a}$ where $0 \leq a < \alpha$, we need $q > \alpha$.

%\aditya{Li include the reason for the lower bound on q}
\subsection*{Proof of Claim \ref{claim:Gconstruct2}}

Note that the matrix in eq. (\ref{eq:Gconstruct2}) is the generator matrix of $(n,k)$ linear block code over $GF(q)$ where $nz=(z+1)(k+1)$. Since $z$ and $z+1$ are coprime, $z$ is the least positive integer such that $k+1~|~nz$. To show $\bfG$ satisfies the CCP, we need to argue that all $k\times k$ submatrices of $\bfG_{\calS_a}$ where $0\le a\le z$ are full rank. It is easy to check that $\calS_a=\{0,\cdots, n-1\}\setminus \{t(z-a),t(z-a)+1,\cdots,t(z-a)+t-1\}$. We verify three types of matrix $\bfG_{\calS_a}$ as follows: I. $a=0$ II. $a=1$ III. $a>1$.
\begin{itemize}
	\item Type I
	
	When $a=0$, it is easy to verify that any $k\times k$ submatrix of $\bfG_{\calS_0}$ has full rank since $\bfG_{\calS_0}$ has the form $[\bfI_{k\times k}|\bfoe_k]$, which is the generator matrix of the SPC code.
	
	\item Type II
	
	When $a=1$, $\bfG_{\calS_1}$ has the form in eq. (\ref{eq:claim_6_type_2}),
		\begin{table*}[t]
	\begin{align}
		\bfG_{\calS_1}&=
		\begin{bmatrix}
		\begin{array}{cc}
		\underbrace{\begin{array}{cccc}
			\bfI_{t\times t}&\bfzr_{t\times t}&\cdots&\bfzr_{t\times t}\\
			\bfzr_{t\times t}&\bfI_{t\times t}&\cdots&\bfzr_{t\times t}\\
			\vdots&&&\\
			\bfzr_{t\times t}&\bfzr_{t\times t}&\cdots&\bfI_{t\times t}\\
			\bfzr_{(t-1)\times t}&\bfzr_{(t-1)\times t}&\cdots&\bfzr_{(t-1)\times t}
			\end{array}
			}_{\text{Case 1}}&
		\underbrace{\begin{array}{c}
			{b_1}\bfI_{t\times t}\\
			{b_2}\bfI_{t\times t}\\
			\vdots\\
			{b_{z-1}}\bfI_{t\times t}\\
			\bfC(c_1, c_2)_{(t-1)\times t}\\
			\end{array}
		}_{\text{Case 2}}
		\end{array}
				\end{bmatrix}
        \label{eq:claim_6_type_2}
			%\bfI_{t\times t}&\bfzr_{t\times t}&\cdots&\bfzr_{t\times t}&{b_1}\bfI_{t\times t}\\
			%\bfzr_{t\times t}&\bfI_{t\times t}&\cdots&\bfzr_{t\times t}&{b_2}\bfI_{t\times t}\\
			%\vdots&&&&\vdots\\
			%\bfzr_{t\times t}&\bfzr_{t\times t}&\cdots&\bfI_{t\times t}&{b_{z-1}}\bfI_{t\times t}\\
			%\bfzr_{(t-1)\times t}&\bfzr_{(t-1)\times t}&\cdots&\bfzr_{(t-1)\times t}&\bfC(c_1, c_2)_{(t-1)\times t}\\
	%	\end{bmatrix}
	\end{align}
\end{table*}
	
	Case 1: Suppose that we delete any of first $(z-1)t$ columns in $\bfG_{\calS_1}$ (this set of columns is depicted by the underbrace in eq. (\ref{eq:claim_6_type_2})), say $i$-th column of $\bfG_{\calS_1}$, where $z_1t\le i< (z_1+1)t$ and $0\le z_1\le z-2$. Let $i_1=i-z_1t$, $i_2=(z_1+1)t-i-1$. The resultant matrix $\bfG_{\calS_1 \setminus i}$ can be expressed as follows.
	\begin{align*}
		\bfG_{\calS_1 \setminus i}=
		\left[
		\begin{array}{c|c}
			\mathbf A&\mathbf C\\  \hline
			\mathbf B&\mathbf D
		\end{array}
		\right],
	\end{align*}
	where
	\begin{align*}
		\mathbf A &= \bfI_{i\times i},\\
		\mathbf B &= \bfzr_{(k-i)\times i},\\
		\mathbf C &=
		\left[
		\begin{array}{ccc}
			\bfzr_{t\times (k-t-i)} &\multicolumn{2}{c}{{b_1}\bfI_{t\times t}} \\
			\bfzr_{t\times (k-t-i)} & \multicolumn{2}{c}{{b_2}\bfI_{t\times t}} \\
			\vdots &\multicolumn{2}{c}{\vdots}\\
			\bfzr_{t\times (k-t-i)} & \multicolumn{2}{c}{{b_{z_1}}\bfI_{t\times
					t}}\\
			\bfzr_{i_1\times (k-t-i)} &{b_{z_1+1}\bfI_{i_1\times
				i_1}}&\bfzr_{i_1\times (i_2+1)}
		\end{array}
		\right],
	\end{align*}
	and $\mathbf D$ has the form in eq. (\ref{eq:typeII_D}).
	\begin{table*}[t]
	\begin{align}
\mathbf D &=
\left[
\begin{array}{ccccccc}
\bfzr_{1\times i_2}  & \bfzr_{1\times t} & \cdots & \bfzr_{1\times t} & \bfzr_{1\times i_1} & b_{z_1+1} & \bfzr_{1\times i_2}\\
\bfI_{i_2\times i_2}  &\bfzr_{i_2\times t} &\cdots & \bfzr_{i_2\times t} &\multicolumn{2}{c}{\bfzr_{i_2\times (i_1+1)}} & {b_{z_1+1}}\bfI_{i_2\times
	i_2}\\
%\bfzr_{t\times i_2}  &\bfI_{t\times t} &\cdots & \bfzr_{t\times t} &\multicolumn{3}{c}{{b_{z_1+2}}\bfI_{t\times t}}\\
\vdots&&&&&\vdots&\\
\bfzr_{t\times i_2}  &\bfzr_{t\times t} &\cdots & \bfI_{t\times t} &\multicolumn{3}{c}{{b_{z-1}}\bfI_{t\times
		t}}\\
\bfzr_{(t-1)\times i_2}&\bfzr_{(t-1)\times t}&\cdots&\bfzr_{(t-1)\times t}&\multicolumn{3}{c}{\bfC(c_1, c_2)_{(t-1)\times t}}
\end{array}
\right]
\label{eq:typeII_D}
\end{align}
	\end{table*}


	Note that if $z_1=0$, $\bfC=[\bfzr_{i_1\times(k-t-i)}~b_1\bfI_{i_1\times i_1}~\bfzr_{i_1\times (i_2+1)}]$ and if $z_1=z-2$, %\litang{Have made the change $\bfD$.} \aditya{Check the matrix D below, based on our prior discussion}
	$$
	\mathbf D =
	\left[
	\begin{array}{cccc}
	\bfzr_{1\times i_2} & \bfzr_{1\times i_1} & b_{z-1} & \bfzr_{1\times i_2}\\
     \bfI_{i_2\times i_2} &\multicolumn{2}{c}{\bfzr_{i_2\times (i_1+1)}} & {b_{z-1}}\bfI_{i_2\times i_2}\\
	\bfzr_{(t-1)\times i_2}&\multicolumn{3}{c}{\bfC(c_1, c_2)_{(t-1)\times t}}
	\end{array}
	\right].
	$$
To verify $\bfG_{\calS_1 \setminus i}$ has full rank, we just need to check $\bfD$ has full rank (as $\mathbf A$ is full rank). Checking that $\bfD$ has full rank can be further simplified as follows. As $b_{z_1 + 1} \neq 0$, we can move the corresponding column that has $b_{z_1 + 1}$ as its first entry so that it is the first column of $\bfD$.

Following this, consider $\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i_1}$ which is obtained by deleting the $i_1$-th column of $\bfC(c_1, c_2)_{(t-1)\times t}$. %Towards this end, note that $\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i_1}$ can be denoted as follows
	\begin{align*}
		\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i_1} = \begin{bmatrix}
			\bfD_1 & \bfD_2\\
			\bfD_3 & \bfD_4
		\end{bmatrix},
	\end{align*}
	where $\bfD_1$ is a $i_1\times i_1$ matrix as follows
	\begin{align*}
		\bfD_1=\begin{bmatrix}
			c_1 & c_2 & 0 & 0 &\cdots&0 & 0\\
			0 & c_1 & c_2 & 0 &\cdots&0 & 0\\
			\vdots&&&&&&\vdots\\
			0 & 0 & 0 & \cdots & 0 &c_1 & c_2\\
			0 & 0 & 0 & \cdots & 0 &0 & c_1
		\end{bmatrix},
	\end{align*}
	$\bfD_4$ is a $i_2\times i_2$ matrix as follows
	\begin{align*}
		\bfD_4=\begin{bmatrix}
			c_2 & 0 & 0 & \cdots & 0 &0 & 0\\
			c_1 & c_2 & 0 & \cdots &0&0 & 0\\
			\vdots&&&&&&\vdots\\
			0 & 0 & \cdots & 0 & c_1 &c_2 & 0\\
			0 & 0 & \cdots & 0 & 0 &c_1 & c_2
		\end{bmatrix},
	\end{align*}
	and $\bfD_2$ and $\bfD_3$ are $i_1\times i_2$ and $i_2\times i_1$ all zero matrices respectively. Then $\det(\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i_1})=c_1^{i_1}c_2^{i_2}$ and $\det(\bfG_{\calS_1\setminus i}) = \pm b_{z_1+1}c_1^{i_1}c_2^{i_2} \neq 0$. %Since $b_{z_1+1},c_1,c_2$ are non-zero divisors (every non-zero element in a field is a non-zero divisor), $\det(\bfG_{\calS_1\setminus i})\neq 0$ and $\bfG_{\calS_1\setminus i}$ has full rank over $GF(q)$ or $\mathbb{Z} \mod q$.
	
	Case 2: By deleting any of last $t$ columns in $\bfG_{\calS_1}$, say $i$-th column of $\bfG_{\calS_1}$, where $(z-1)t\le i<zt$, the block form of resultant matrix $\bfG_{\calS_1 \setminus i}$ can be expressed as follows.
	\begin{align*}
		\bfG_{\calS_1 \setminus i}=
		\left[
		\begin{array}{c|c}
			\mathbf A&\mathbf C\\  \hline
			\mathbf B&\mathbf D
		\end{array}
		\right],
	\end{align*}
	where $\bfA = \bfI_{(z-1)t\times (z-1)t}$, $\mathbf B=\bfzr_{(t-1)\times (z-1)t}$, $\bfC$ is obtained by deleting the $(i-(z-1)t)$-th column of matrix $[{b_1}\bfI_{t\times t}~{b_2}\bfI_{t\times t}~\cdots~{b_{z-1}}\bfI_{t\times t}]^T$ and $\bfD$ is $\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i-(z-1)t}$. Since $\det(\bfD)=c_1^{i-(z-1)t}c_2^{zt-i-1}\neq 0$,  $\det(\bfG_{\calS_1 \setminus i})= \pm c_1^{i-(z-1)t}c_2^{zt-i-1}\neq 0$ and therefore $\bfG_{\calS_1 \setminus i}$ has full rank. %Thus, our argument that any $k\times k$ submatrix of $\bfG_{\calS_1}$ has full rank over $GF(q)$ or $\mathbb{Z} \mod q$ is complete.
	
	\item Type III
	when $a>1$, $\bfG_{\calS_a}$ has the form in eq. (\ref{eq:claim_6_type_3}). %\litang{Have made the change}\aditya{Here, need to depict Case 1-5 on the matrix itself}
	\begin{table*}
	\begin{align}
		\bfG_{\calS_a}=
		\begin{bmatrix}
		\underbrace{
		\begin{array}{ccc}
		\bfI_{t\times t}& \cdots& \bfzr_{t\times t}\\
		\vdots&&\vdots\\
		\bfzr_{t\times t}& \cdots& \bfI_{t\times t}\\
		\bfzr_{t\times t}& \cdots& \bfzr_{t\times t}\\
		\bfzr_{t\times t}& \cdots& \bfzr_{t\times t}\\
		\vdots&&\vdots\\
		\bfzr_{t\times t}& \cdots& \bfzr_{t\times t}\\
		\bfzr_{(t-1)\times t}& \cdots& \bfzr_{(t-1)\times t}	
		\end{array}
	    }_{\text{Case 1}}
	    &
	    \underbrace{
	    	\begin{array}{ccc}
	    	\bfzr_{t\times t} &\cdots&\bfzr_{t\times t}\\
	    	\vdots&&\vdots\\
	    	\bfzr_{t\times t} &\cdots&\bfzr_{t\times t}\\
	    	\bfzr_{t\times t} &\cdots&\bfzr_{t\times t}\\
	    	\bfI_{t\times t} &\cdots&\bfzr_{t\times t}\\
	    	\vdots&&\vdots\\
	    	\bfzr_{t\times t}& \cdots& \bfI_{t\times t}\\
	    	\bfzr_{(t-1)\times t} &\cdots&\bfzr_{(t-1)\times (t-1)}	
	    	\end{array}
	    }_{\text{Case 2}}
	    &
	    \underbrace{
	    	\begin{array}{c}
	    	\bfzr_{t\times (t-1)}\\
	    	\vdots\\
	    	\bfzr_{t\times (t-1)}\\
	    	\bfzr_{t\times (t-1)}\\
	    	\bfzr_{t\times (t-1)}\\
	    	\vdots\\
	    	\bfzr_{t\times (t-1)}\\
	    	\bfI_{(t-1)\times (t-1)}
	    	\end{array}
	    	}_{\text{Case 3}}
	    &
	    \underbrace{
	    	\begin{array}{c}
	    	\bfoe_{t}\\
	    	\vdots\\
	    	\bfoe_{t}\\
	    	\bfoe_{t}\\
	    	\bfoe_{t}\\
	    	\vdots\\
	    	\bfoe_{t}\\
	    	\bfoe_{t-1}
	    	\end{array}
	    }_{\text{Case 4}}
	    &
	    	\underbrace{
	    		\begin{array}{c}
	    		{b_1}\bfI_{t\times t}\\
	    		\vdots\\
	    		{b_{z-a}}\bfI_{t\times t}\\
	    		{b_{z-a+1}}\bfI_{t\times t}\\
	    		{b_{z-a+2}}\bfI_{t\times t}\\
	    		\vdots\\
	    		{b_{z-1}}\bfI_{t\times t}\\
	    		\bfC(c_1, c_2)_{(t-1)\times t}
	    		\end{array}
	    	}_{\text{Case 5}}
%			\bfI_{t\times t}& \cdots& \bfzr_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_1}\bfI_{t\times t}\\
%			\vdots&&&&&&&\vdots\\
%			\bfzr_{t\times t}& \cdots& \bfI_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_{z-a}}\bfI_{t\times t}\\
%			\bfzr_{t\times t}& \cdots& \bfzr_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_{z-a+1}}\bfI_{t\times t}\\
%						\vdots&&&&&&&\vdots\\
%			\bfzr_{t\times t}& \cdots& \bfzr_{t\times t} &\bfI_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_{z-1}}\bfI_{t\times t}\\
%			\bfzr_{(t-1)\times t}& \cdots& \bfzr_{(t-1)\times t} &\bfzr_{(t-1)\times t} &\cdots&\bfI_{(t-1)\times (t-1)}&\bfoe_{t-1}&\bfC(c_1, c_2)_{(t-1)\times t}
		\end{bmatrix}
    \label{eq:claim_6_type_3}
	\end{align}
	\end{table*}
As before we perform a case analysis. Each of the cases is specified by the corresponding underbrace in eq. (\ref{eq:claim_6_type_3}).

    Case 1:	By deleting the $i$-th column of $\bfG_{\calS_a}$, where $z_1t\le i< (z_1+1)t$, $z_1\le z-a-1$, $i_1=i-z_1t$, and $i_2=(z_1+1)t-i-1$, the block form of the resultant matrix $\bfG_{\calS_a \setminus i}$ can be expressed as follows,
	
	\begin{align*}
		\bfG_{\calS_a \setminus i}=
		\left[
		\begin{array}{c|c}
			\mathbf A&\mathbf C\\  \hline
			\mathbf B&\mathbf D
		\end{array}
		\right],
	\end{align*}
	where $\bfA= \bfI_{i\times i}, \mathbf B= \bfzr_{(k-i)\times i}
		$, $\mathbf C$ and $\mathbf D$ has the form in eq. (\ref{eq:typeIII_C}) and eq. (\ref{eq:typeIII_D}), respectively.
		\begin{table*}[t]
		\begin{align}
	\mathbf C &=
\left[
\begin{array}{ccccccc}
\bfzr_{t\times i_2} &\bfzr_{t\times t} &\cdots & \bfzr_{t\times (t-1)} & \bfoe_t &\multicolumn{2}{c}{{b_1}\bfI_{t\times t}}\\
\vdots&&&&&\multicolumn{2}{c}{\vdots}\\
\bfzr_{t\times i_2} &\bfzr_{t\times t}&\cdots & \bfzr_{t\times (t-1)} & \bfoe_t &\multicolumn{2}{c}{{b_{z_1}}\bfI_{t\times t}}\\
\bfzr_{i_1\times i_2}&\bfzr_{i_1\times t} &\cdots & \bfzr_{i_1\times (t-1)} & \bfoe_{i_1} &{b_{z_1+1}}\bfI_{i_1\times i_1}&\bfzr_{i_1\times(i_2+1)}
\label{eq:typeIII_C}
\end{array}
\right]
		\end{align}
		\end{table*}
			\begin{table*}[t]
	\begin{align}
	\bfD&=	\left[
\begin{array}{cccccccccc}
\bfzr_{1\times i_2} &\bfzr_{1\times t} &\cdots&\cdots &\cdots  &\bfzr_{1\times (t-1)} & 1 &\bfzr_{1\times i_1}  & b_{z_1+1} & \bfzr_{1\times i_2} \\
\bfI_{i_2\times i_2} &\bfzr_{i_2\times t} &\cdots&\cdots&\cdots  &\bfzr_{i_2\times (t-1)} &\bfoe_{i_2} &\multicolumn{2}{c}{\bfzr_{i_2\times (i_1+1)}} & {b_{z_1+1}}\bfI_{i_2\times i_2}\\
\bfzr_{t\times i_2} &\bfI_{t\times t} &\cdots&\cdots&\cdots  &\bfzr_{t\times (t-1)} &\bfoe_{t} &\multicolumn{3}{c}{{b_{z_1+2}}\bfI_{t\times t}}\\
\vdots &&&&&\vdots\\
\bfzr_{t\times i_2}& \bfzr_{t\times t}& \cdots &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&\multicolumn{3}{c}{{b_{z-a+1}}\bfI_{t\times t}}\\
\bfzr_{t\times i_2}& \bfzr_{t\times t}& \cdots &\bfI_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&\multicolumn{3}{c}{{b_{z-a+2}}\bfI_{t\times t}}\\
\vdots&&&&&&&&&\vdots\\
\bfzr_{(t-1)\times i_2}& \bfzr_{(t-1)\times t}& \cdots &\bfzr_{(t-1)\times t} &\cdots&\bfI_{(t-1)\times (t-1)}&\bfoe_{t-1}&\multicolumn{3}{c}{\bfC(c_1, c_2)_{(t-1)\times t}}
\label{eq:typeIII_D}
\end{array}
\right]
	\end{align}
\end{table*}
	Note that if $z_1=0$, $\bfC=[\bfzr_{i_1\times i_2}~\bfzr_{i_1\times t}~\cdots~ \bfzr_{i_1\times (t-1)}~\bfoe_{i_1}~{b_1}\bfI_{i_1\times i_1}~\bfzr_{i_1\times(i_2+1)}]$ and if $z_1=z-a-1$, $\mathbf D$ has the form in (\ref{eq:typeIII_D_2}).
	\begin{table*}[h]
	\begin{align}
	\mathbf D =
	\left[
	\begin{array}{cccccccccc}
	\bfzr_{1\times i_2} &\bfzr_{1\times t} &\cdots&\cdots &\cdots  &\bfzr_{1\times (t-1)} & 1 &\bfzr_{1\times i_1}  & b_{z-a} & \bfzr_{1\times i_2} \\
	\bfI_{i_2\times i_2} &\bfzr_{i_2\times t} &\cdots&\cdots&\cdots  &\bfzr_{i_2\times (t-1)} &\bfoe_{i_2} &\multicolumn{2}{c}{\bfzr_{i_2\times (i_1+1)}} & {b_{z-a}}\bfI_{i_2\times i_2}\\
	\bfzr_{t\times i_2}& \bfzr_{t\times t}& \cdots &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&\multicolumn{3}{c}{{b_{z-a+1}}\bfI_{t\times t}}\\
	\bfzr_{t\times i_2}& \bfzr_{t\times t}& \cdots &\bfI_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&\multicolumn{3}{c}{{b_{z-a+2}}\bfI_{t\times t}}\\
	\vdots&&&&&&&&&\vdots\\
	\bfzr_{(t-1)\times i_2}& \bfzr_{(t-1)\times t}& \cdots &\bfzr_{(t-1)\times t} &\cdots&\bfI_{(t-1)\times (t-1)}&\bfoe_{t-1}&\multicolumn{3}{c}{\bfC(c_1, c_2)_{(t-1)\times t}}
	\end{array}
	\right].
	\label{eq:typeIII_D_2}
	\end{align}
	\end{table*}

	To verify that $\bfG_{\calS_a \setminus i}$ has full rank, we just need to check $\bfD$ has full rank. Owing to the construction of $\bfD$, we have to check the determinant of the following $(t+1) \times (t+1)$ matrix.
	\begin{align*}
	\bfF=
		\begin{bmatrix}
			1&0 & 0 & \cdots & b_{z_1+1}& \cdots &0\\
			1&b_{z-a+1} &0 &\cdots & 0 & \cdots &0\\
			1&0 & b_{z-a+1}&\cdots & 0 & \cdots &0\\
			\vdots&&&&\vdots\\
			1&0&0&\cdots & 0 & \cdots&b_{z-a+1}
		\end{bmatrix};
	\end{align*}
	$\det(\bfF)=(b_{z-a+1}-b_{z_1+1})b_{z-a+1}^{t-1}$. Since $z_1\neq z-a$ and then $b_{z_1+1}\neq b_{z-a+1}$, the above matrix has full rank and $\det(\bfG_{\calS_a \setminus i})= \pm (b_{z-a+1}-b_{z_1+1})b_{z-a+1}^{t-1}\neq 0$, so that $\bfG_{\calS_a \setminus i}$ has full rank.
	
	Case 2: By deleting $i$-th column of $\bfG_{\calS_a}$, where $z_1t\le i< (z_1+1)t$, $z-a\le z_1\le z-3$, the proof that the resultant matrix has full rank is similar to the case that $z_1\le z-a-1$ and we omit it here. %\aditya{need to discuss}
	
	Case 3: By deleting $i$-th column of $\bfG_{\calS_a}$, where $(z-2)t\le i\le (z-1)t-2$, $i_1 = i-(z-2)t$ and $i_2=(z-1)t-2-i$, the resultant matrix is as follows,
	\begin{align*}
		\bfG_{\calS_a \setminus i}=
		\left[
		\begin{array}{c|c}
			\mathbf A&\mathbf C\\  \hline
			\mathbf B&\mathbf D
		\end{array}
		\right],
	\end{align*}
	where \begin{align*}
		\bfA&= \bfI_{(z-a)t\times (z-a)t}\\
		\mathbf B &= \bfzr_{(k-(z-a)t)\times (z-a)t}\\
		\mathbf C &= \begin{bmatrix}
			\bfzr_{t\times t}&\cdots&\bfzr_{t\times (t-2)}&\bfoe_t&{b_1}\bfI_{t\times t}\\
			\vdots&&&&\vdots\\
			\bfzr_{t\times t}&\cdots&\bfzr_{t\times (t-2)}&\bfoe_t&{b_{z-a}}\bfI_{t\times t}
		\end{bmatrix}\\	 	  	
		\bfD&=\begin{scriptsize}
	\left[
		\begin{array}{cccccc}
			\bfzr_{t\times t} & \cdots &\multicolumn{2}{c}{\bfzr_{t\times (t-2)}} & \bfoe_t & {b_{z-a+1}}\bfI_{t\times t}\\
			\bfI_{t\times t} & \cdots & \multicolumn{2}{c}{\bfzr_{t\times (t-2)}} & \bfoe_t & {b_{z-a+2}}\bfI_{t\times t}\\
			\vdots&&&&\vdots\\
			\multirow{3}*{$\bfzr_{(t-1)\times t}$}&\multirow{3}*{$\cdots$}&\bfI_{i_1\times i_1}&\bfzr_{i_1\times i_2}&\multirow{3}*{$\bfoe_{t-1}$}&\multirow{3}*{$\bfC(c_1, c_2)_{(t-1)\times t}$}\\
			&&\bfzr_{1\times i_1}&\bfzr_{1\times i_2}&&\\
			&&\bfzr_{i_2\times i_1}&\bfI_{i_2\times i_2}&&
		\end{array}
		\right]
				\end{scriptsize}
	\end{align*}
	To verify $\bfG_{\calS_a\setminus i}$ has full rank, we need to check the determinant of $\bfD$. Owing to the construction of $\bfD$, the following matrix is required to be full rank,
	\begin{align*}
		\bfD'=&\begin{bmatrix}
			\bfoe_t&{b_{z-a+1}}\bfI_{t\times t}\\
			1&\bfC(c_1, c_2)_{(t-1)\times t}(i_1)
		\end{bmatrix}\\=&
		\begin{bmatrix}
		\begin{smallmatrix}
			1&b_{z-a+1}&0&\cdots&0&0&0&\cdots&0\\
			1&0&b_{z-a+1}&\cdots&0&0&0&\cdots&0\\
			\vdots&&&&&&&&\vdots\\
			1&0&0&\cdots&0&0&0&\cdots&b_{z-a+1}\\
			1&0&\cdots&0&c_1&c_2&0&\cdots&0
			\end{smallmatrix}
		\end{bmatrix},
	\end{align*}
	where $\bfC(c_1, c_2)_{(t-1)\times t}(i_1)$ denotes the $i_1$-th row of $\bfC(c_1, c_2)_{(t-1)\times t}$, $0\le i\le t-2$.
	%\begin{align*}
	%	\bfD'=\begin{bmatrix}
	%		1&b_{z-a+1}&0\\
	%		1&0&b_{z-a+1}\\
	%		1&c_1&c_2
	%	\end{bmatrix}
	%\end{align*}
	%as follows.
%	\begin{align*}
%		\det \bfD'&= \det \begin{bmatrix}
%			b_{z-a+1}&0\\
%			0&b_{z-a+1}
%		\end{bmatrix}
%		\det(1-\begin{bmatrix}
%			c_1&c_2
%		\end{bmatrix}
%		\begin{bmatrix}
%			b_{z-a+1}^{-1}&0\\
%			0&b_{z-a+1}^{-1}
%		\end{bmatrix}
%		\begin{bmatrix}
%			1\\1
%		\end{bmatrix})\\
%		&=b_{z-a+1}^2(1-b_{z-a+1}^{-1}(c_1+c_2)).
%	\end{align*}
	\begin{align*}
	\det \bfD'=&\det (b_{z-a+1}\bfI_{t\times t})\cdot \det(1-\\
	&\bfC(c_1,c_2)_{(t-1)\times t}(i_1)\cdot(b^{-1}_{z-a+1}\bfI_{t\times t})\cdot\bfoe_t)\\
	=&b_{z-a+1}^t(1-b_{z-a+1}^{-1}(c_1+c_2))
	\end{align*}
	
	Since $b_{z-a+1}\neq 0$ and $c_1+c_2=0$, $\det \bfD'\neq 0$ and $\bfD'$ has full rank. Then $\det(\bfD)=b_{z-a+1}^t(1-b_{z-a+1}^{-1}(c_1+c_2))\neq 0$ and  thus $\bfG_{\calS_a\setminus i}$ is full rank.
	
	
	Case 4: By deleting $i$-th column of $\bfG_{\calS_a}$, where $i=(z-1)t-1$, the block form of the resultant matrix $\bfG_{\calS_a \setminus i}$ can be expressed as eq. (\ref{eq:case4_G1}).
	\begin{table*}[t]\begin{align}
		\bfG_{\calS_a\setminus i}&=
		\begin{bmatrix}
			\bfI_{t\times t}& \cdots& \bfzr_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&{b_1}\bfI_{t\times t}\\
			\vdots&&&&&&\vdots\\
			\bfzr_{t\times t}& \cdots& \bfI_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&{b_{z-a}}\bfI_{t\times t}\\
			\bfzr_{t\times t}& \cdots& \bfzr_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&{b_{z-a+1}}\bfI_{t\times t}\\
			\bfzr_{t\times t}& \cdots& \bfzr_{t\times t} &\bfI_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&{b_{z-a+2}}\bfI_{t\times t}\\
			\vdots&&&&&&\vdots\\
			\bfzr_{(t-1)\times t}& \cdots& \bfzr_{(t-1)\times t} &\bfzr_{(t-1)\times t} &\cdots&\bfI_{(t-1)\times (t-1)}&\bfC(c_1, c_2)_{(t-1)\times t}
		\end{bmatrix}
			\label{eq:case4_G1}
	\end{align}
	\end{table*}
   Evidently, $\det(\bfG_{\calS_a\setminus i})= \pm b_{z-a+1}^t$, so that $\bfG_{\calS_a\setminus i}$  has full rank.
	
	Case 5: By deleting $i$-th column of $\bfG_{\calS_a}$, where $(z-1)t\le i<zt$ and $i_1=i-(z-1)t$, the block form of the resultant matrix $\bfG_{\calS_a \setminus i}$ can be expressed as eq. (\ref{eq:case4_G2}).
	
	\begin{table*}[t]
	\begin{align}
		\bfG_{\calS_a\setminus i}&=
		\begin{bmatrix}
			\bfI_{t\times t}& \cdots& \bfzr_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_1}\bfI_{t\times t}\setminus \bfc_{i_1}\\
			\vdots&&&&&&&\vdots\\
			\bfzr_{t\times t}& \cdots& \bfI_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_{z-a}}\bfI_{t\times t}\setminus \bfc_{i_1}\\
			\bfzr_{t\times t}& \cdots& \bfzr_{t\times t} &\bfzr_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_{z-a+1}}\bfI_{t\times t}\setminus \bfc_{i_1}\\
			\bfzr_{t\times t}& \cdots& \bfzr_{t\times t} &\bfI_{t\times t} &\cdots&\bfzr_{t\times (t-1)}&\bfoe_t&{b_{z-a+2}}\bfI_{t\times t}\setminus \bfc_{i_1}\\
			\vdots&&&&&&&\vdots\\
			\bfzr_{(t-1)\times t}& \cdots& \bfzr_{(t-1)\times t} &\bfzr_{(t-1)\times t} &\cdots&\bfI_{(t-1)\times (t-1)}&\bfoe_{t-1}&\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i_1}
		\end{bmatrix}
				\label{eq:case4_G2}
	\end{align}
\end{table*}
	where ${b_s}\bfI_{t\times t}\setminus \bfc_{i_1}$ denotes the submatrix obtained by deleting $i_1$-th column of ${b_s}\bfI_{t\times t}$ and $\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i_1}$ denotes the submatrix obtained by deleting $i_1$-th column of $\bfC(c_1, c_2)_{(t-1)\times t}\setminus \bfc_{i_1}$. To verify $\bfG_{\calS_a\setminus i}$ has full rank, we just need to check $[\bfoe_t|{b_{z-a+1}}\bfI_{t\times t}\setminus \bfc_{i_1}]$ has full rank. Since $[\bfoe_{t}|{b_{z-a+1}}\bfI_{t\times t}]$ has the following form,
	\begin{align*}
		\begin{bmatrix}
			1&b_{z-a+1} &0 &\cdots &0\\
			1&0 & b_{z-a+1}&\cdots &0\\
			\vdots&&&&\vdots\\
			1&0&0&\cdots&b_{z-a+1}
		\end{bmatrix},
	\end{align*}
	by deleting any column of above matrix, it is obvious that $\det([\bfoe_t|{b_{z-a+1}}\bfI_{t\times t}\setminus \bfc_{i_1}])=\pm b_{z-a+1}^{t-1}$ and $\det(\bfG_{\calS_a\setminus i})\neq 0$.
	
\end{itemize}

\subsection*{Proof of Claim \ref{claim:matrixextend}}
%\aditya{This proof is quite hard to read}
Let $z$ be the least integer such that $k+1~|~nz$. First, we argue that $z$ is the least integer such that $k+1~|~(n+s(k+1))z$. Assume that this is not true, then there exists $z'<z$ such that $k+1~|~(n+s(k+1))z'$. As $n\ge k+1$ and $k+1~|~s(k+1)z'$ this implies that $k+1~|~nz'$ which is a contradiction.

Next we argue that $\bfG'$ satisfies the CCP, i.e., all $k \times k$ submatrices of each $\bfG'_{\calS'_a}$, where $\calT'_a=\{a(k+1),\cdots, a(k+1)+k\}$ and $\calS'_a=\{(t)_{n+s(k+1)}|t\in \calT'_a\}$ and $0\le a\le \frac{nz}{k+1}+sz$, are full rank. Let $n'= n+s(k+1)$. We argue it in three cases.

\begin{itemize}
\item {\it Case 1. The first column of $\bfG'_{\calS'_a}$ lies in the first $s(k+1)$ columns of $\bfG'$.}\\
Suppose $ln'\le a(k+1)< ln'+s(k+1)$ where $0\le l<  z-1$. By the construction of $\bfG'$, $\bfG'_{\calS_a}=\bfD$. Since $\bfD = \bfG_{\calS_0}$, all $k\times k$ submatrices of $\bfD$ have full rank and so does $\bfG'_{\calS_a}$.

\item {\it Case 2. The first and last column of $\bfG'_{\calS'_a}$ lie in the last $n$ columns of $\bfG'$.}\\
Suppose  $ln'+s(k+1)\le a(k+1)$ and $ a(k+1)+k< (l+1)n'$ where $0\le l< z-1$. As $n'>s(k+1)$, $a(k+1)-(l+1)s(k+1)>0$ and $k+1|a(k+1)-(l+1)s(k+1)$. Let $a'=a-(l+1)s$, then $\bfG'_{\calS_a}=\bfG_{\calS_{a'}}$ and hence  all $k\times k$ submatrices of $\bfG'_{\calS_a}$ have full rank.

\item {\it Case 3. The first column of $\bfG'_{\calS'_a}$ lies in the last $n$ columns of $\bfG'$ but the last column lies in the first $(k+1)$ columns of $\bfG'$.}\\
Suppose  $ln'+s(k+1)\le a(k+1)$ and $ a(k+1)+k> (l+1)n'$ where $0\le l<z-2$. Again, we can get $k+1|a(k+1)-(l+1)s(k+1)$ and let $a'=a-(l+1)s$. Let $\calS'^1=\{(a(k+1))_{n'},\cdots, (ln'+n'-1)_{n'}\}$ and $\calS^1=\{(a'(k+1))_n,\cdots,(ln+n-1)_n\}$. As $(ln'+n'-1)-a(k+1)=(ln+n-1)-a'(k+1)$, $\bfG'_{\calS'^1}=\bfG_{\calS^1}$. Let $\calS'^2=\{(ln'+n')_{n'},\cdots,(a(k+1)+k)_{n'}\}$ and $\calS^2=\{(ln+n)_n,\cdots, (a'(k+1)+k)_n\}$. By the construction of $\bfG'$, $\bfG_{\calS^2}=\bfG'_{\calS'^2}$. Then $\bfG'_{\calS_a}=[\bfG'_{\calS'^1} \bfG'_{\calS'^2}]=[\bfG_{\calS^1} \bfG_{\calS^2}]=\bfG_{\calS_{a'}}$ and hence all $k\times k$ submatrices of $\bfG'_{\calS_a}$ have full rank.
\end{itemize}
%\subsection*{Proof of Claim \ref{claim:CCPZmodq}}
%It is easy to check that $\calS_a=\{0,\cdots, 3t\}\setminus \{t(2-a), t(2-a)+1,\cdots, t(2-a)+t-1\}$. We verify three types of matrix $\bfG_{\calS_a}$ as follows: I. $a=1$ II. $a=2$. We do not verify $a=0$ since $\bfG_{\calS_0}$ is the generator matrix of SPC code and we have proof that it satisfies the CCP.
%
%Type I: When $a=1$, $\bfG_{\calS_1}$ has the following form,
%\begin{align}
%\bfG_{\calS_1}&=
%\begin{bmatrix}
%\begin{array}{cc}
%\underbrace{\begin{array}{c}
%	\bfI_{t \times t}\\
%	\bfzr_{(t-1)\times t}
%	\end{array}
%}_{\text{Case 1}}&
%\underbrace{\begin{array}{c}
%\bfI_{t\times t}\\
%\bfC (1,-1)_(t-1)\times t
%\end{array}
%}_{\text{Case 2}}
%\end{array}
%\end{bmatrix}
%\label{eq:claim_6_type_2}
%%\bfI_{t\times t}&\bfzr_{t\times t}&\cdots&\bfzr_{t\times t}&{b_1}\bfI_{t\times t}\\
%%\bfzr_{t\times t}&\bfI_{t\times t}&\cdots&\bfzr_{t\times t}&{b_2}\bfI_{t\times t}\\
%%\vdots&&&&\vdots\\
%%\bfzr_{t\times t}&\bfzr_{t\times t}&\cdots&\bfI_{t\times t}&{b_{z-1}}\bfI_{t\times t}\\
%%\bfzr_{(t-1)\times t}&\bfzr_{(t-1)\times t}&\cdots&\bfzr_{(t-1)\times t}&\bfC(c_1, c_2)_{(t-1)\times t}\\
%%	\end{bmatrix}
%\end{align}
%\subsection*{Proof of Claim \ref{claim:ztwocase}}
%In this proof, we only prove $z\le 2$ is the necessary condition such that a $(n,k)$ binary linear block code satisfies the CCP. Since we have the construction for a $(n,k)$ binary linear block code that satisfies the CCP when $z=1,2$, the proof is complete. Towards this end, we introduce the following two arguments.
%
%Firstly, let $\bfc_{i}, i\in \calS_a$, be the $k+1$ columns in $\bfG_{\calS_a}$. It is easy to verify that any $k\times k$ submatrix of binary $\bfG_{\calS_a}$ is full rank if $\sum_{i\in \calS_a} \bfc_i=0$ and $\sum_{i\in \calB} \bfc_i\neq 0$ where $\calB \subset \calS_a$ and $\calB \neq \calS_a$. Otherwise, $\bfc_i$, $i\in \calB$, are linear dependent. Secondly, let $z>2$, there exists $a_1$ such that $a_1(k+1)<n$, $a_1(k+1)+k>n$ and $a_1(k+1)+\frac{k+1}{2}\neq n$. Otherwise, $z=2$ or $z=1$. With the help of above two arguments, we argue that a $(n,k)$ linear block code satisfies the CCP cannot be binary if $z>2$ by contradiction.
%
%Assume a binary $(n,k)$ linear block code with $z>2$ satisfies the CCP. Suppose $a_1(k+1)+\frac{k+1}{2}<n$. Let $(a_1(k+1)+k-h)_n=0$ where $0\le h < \frac{k-1}{2}$. Since any $k\times k$ submatrices of $\bfG_{\calS_{j}}$ and $\bfG_{\calS_{a_1+1+j}}$ are full rank, where $0\le j<a_1$, we consider the following couples of equations.
%\begin{equation}
%\label{eq:z2eq1}
%\sum_{i=0}^k \bfc_{j(k+1)+i}=0
%\end{equation}
%\begin{equation}
%\label{eq:z2eq2}
%\sum_{i=0}^k \bfc_{((a_1+1+j)(k+1)+i)_n}=0
%\end{equation}
%where $0\le j<a_1$. Note that $(a_1(k+1)+k-h)_n=0$, we rewritten (\ref{eq:z2eq2}) as follows.
%\begin{equation}
%\label{eq:z2eq3}
%\sum_{i=0}^k \bfc_{j(k+1)+h+1+i}=0
%\end{equation}
%Combining (\ref{eq:z2eq1}) and (\ref{eq:z2eq3}), we have
%\begin{equation}
%\label{eq:z2eq4}
%\sum_{i=0}^h \bfc_{j(k+1)+i}=\sum_{i=0}^h \bfc_{j(k+1)+k+1+i}=\sum_{i=0}^h \bfc_{(j+1)(k+1)+i}
%\end{equation}
%Operating (\ref{eq:z2eq4}) from $j=0$ to $a_1-1$ iteratively, we have
%\begin{align*}
%\sum_{i=0}^h \bfc_i = \sum_{i=0}^h \bfc_{a_1(k+1)+i}
%\end{align*}
%
%Note that $\bfc_i=\bfc_{(a_1(k+1)+k-h+i)_n}$ and hence
%\begin{align*}
%\sum_{i=0}^h \bfc_{(a_1(k+1)+i)_n}+ \sum_{i=0}^h \bfc_{(a_1(k+1)+k-h+i)_n}=0,
%\end{align*}
%which is a contradiction that $\bfG$ satisfies the CCP if $\calB\subset \calS_{a_1}$ and $\calB\neq \calS_{a_1}$.
%
%Next, we suppose $a_1(k+1)+\frac{k+1}{2}>n$. Let $(a_1(k+1)+h+1)_n=0$ where $0\le h < \frac{k-1}{2}$. Since any $k\times k$ submatrices of $\bfG_{\calS_{j}}$ and $\bfG_{\calS_{a_1+j}}$ are full rank, where $0\le j<a_1$, we consider the following couples of equations.
%\begin{equation}
%\label{eq:z2eq5}
%\sum_{i=0}^k \bfc_{j(k+1)+i}=0
%\end{equation}
%\begin{equation}
%\label{eq:z2eq6}
%\sum_{i=0}^k \bfc_{((a_1+j)(k+1)+i)_n}=0.
%\end{equation}
%Note that $(a_1(k+1)+h+1)_n=0$, we rewritten (\ref{eq:z2eq6}) as
%\begin{equation}
%\label{eq:z2eq7}
%\begin{cases}
% \sum_{i=0}^{h} \bfc_{a_1(k+1)+i} + \sum_{i=0}^{k-h-1} \bfc_{i}=0, & \mbox{if } j=0 \\
%  \sum_{i=0}^k \bfc_{(j-1)(k+1)+k-h+i}=0, & \mbox{if } 0<j<a_1
%  \end{cases}
%\end{equation}
%Combining (\ref{eq:z2eq5}) and (\ref{eq:z2eq7}), we have
%\begin{equation}
%\label{eq:z2eq8}
%\begin{cases}
%\sum_{i=0}^{h} \bfc_{i+k-h} = \sum_{i=0}^{h} \bfc_{a_1(k+1)+i}, & \mbox{if } j=0\\
%\sum_{i=0}^h \bfc_{k-h+(k+1)(j-1)+i}=\sum_{i=0}^h \bfc_{j(k+1)+k-h+i}, & \mbox{if } 0<j<a_1
%\end{cases}
%\end{equation}
%
%Operating (\ref{eq:z2eq8}) from $j=0$ to $a_1-1$ iteratively, we have
%\begin{align*}
%\sum_{i=0}^h \bfc_{(a_1-1)(k+1)+k-h+i} = \sum_{i=0}^h \bfc_{a_1(k+1)+i}
%\end{align*}
%Note that $\bfc_{(a_1-1)(k+1)+k-h+i}=\bfc_{(2a_1(k+1)+i)_n}$ and $\bfc_{a_1(k+1)+i}=\bfc_{(2a_1(k+1)+h+i+1)_n}$ hence
%\begin{align*}
%\sum_{i=0}^h \bfc_{(2a_1(k+1)+i)_n}+ \sum_{i=0}^h \bfc_{(2a_1(k+1)+h+i+1)_n}=0,
%\end{align*}
%which is a contradiction that $\bfG$ satisfies the CCP if $\calB\subset \calS_{2a_1}$ and $\calB\neq \calS_{2a_1}$.
%
%\begin{figure}[t]
%	\centering
%	\includegraphics[scale=0.8]{Figure3.pdf}
%	\caption{Case 1: $a_1(k+1)+\frac{k+1}{2}<n$}
%	\label{Fig:Case1}
%\end{figure}
%\begin{figure}[t]
%	\centering
%	\includegraphics[scale=0.8]{Figure4.pdf}
%	\caption{Case 1: $a_1(k+1)+\frac{k+1}{2}>n$}
%	\label{Fig:Case2}
%\end{figure}
%
%
%
%%
%%\begin{lemma}
%%	\label{lemma:subpack_comp_1}
%%	Suppose $K=qn$ and $\frac{M}{N}=\frac{1}{q}$. Then,
%%	\begin{align*}
%%	\frac{F_s^*}{F_s^{MN}}\approx q^{k-n}z(\frac{q-1}{q})^{n(q-1)}.
%%	\end{align*}
%%\end{lemma}
%%
%%\begin{proof}
%%	It is well known \cite{graham1994concrete} that for large $K$ and $0\le p\le 1$
%%	\begin{equation}
%%	\label{eq:binomapprox}
%%	\binom{K}{Kp}\approx 2^{KH(p)},
%%	\end{equation}
%%	where $H(\cdot)$ represents the binary entropy function. Using this,
%%	\begin{align*}
%%	F_s^{MN}=\binom{qn}{n}&\approx 2^{nqH(\frac{1}{q})}\\
%%	&\approx 2^{nq[-\frac{1}{q}\log_2 \frac{1}{q}-(1-\frac{1}{q})\log_2 (1-\frac{1}{q})]}\\
%%	&=\frac{q^n}{(\frac{q-1}{q})^{n(q-1)}}
%%	\end{align*}
%%	Then
%%	\begin{align*}
%%	\frac{F_s^*}{F_s^{MN}}\approx q^{k-n}z(\frac{q-1}{q})^{n(q-1)}.
%%	\end{align*}
%%\end{proof}
%%
%%\begin{lemma}
%%	\label{lemma:subpack_comp_2}
%%	Suppose $K=qn$ and $\frac{M}{N}=1-\frac{k+1}{nq}$. Then,
%%	\begin{align*}
%%	\frac{F_s^*}{F_s^{MN}}&\approx R^{Rn-1}(\frac{q-R}{q})^{n(q-R)},
%%	\end{align*}
%%	where $R=\frac{k+1}{n}$.
%%\end{lemma}
%%\begin{proof}
%%	Using \ref{eq:binomapprox} again, we have
%%	\begin{align*}
%%	F_s^{MN}=\binom{qn}{k+1}&\approx 2^{nqH(\frac{k+1}{nq})}\\
%%	&\approx 2^{nqH(\frac{R}{q})}\\
%%	&= 2^{nq[-\frac{R}{q}\log_2 \frac{R}{q}-(1-\frac{R}{q})\log_2 (1-\frac{R}{q})]}\\
%%	&=\frac{(\frac{q}{R})^{nR}}{(\frac{q-R}{q})^{n(q-R)}} 	
%%	\end{align*}
%%	Then
%%	\begin{align*}
%%	\frac{F_s^*}{F_s^{MN}}&\approx \frac{(q-1)\frac{q^kz}{R}\cdot{(\frac{q-R}{q})^{n(q-R)}}}{(\frac{q}{R})^{Rn}}\\
%%	&\approx \frac{(q-1)q^k}{q^{nR}}\cdot \frac{R^{Rn}}{R}\cdot z(\frac{q-R}{q})^{n(q-R)}\\
%%	&\approx R^{Rn-1}(\frac{q-R}{q})^{n(q-R)}.
%%	\end{align*}
%%\end{proof}
%%
%%%\begin{lemma}
%%%	\label{lemma:subpack_comp_3}
%%%	Suppose $K=qn$ and $\frac{M}{N}=\frac{1}{q}$. Then,
%%%	\begin{align*}
%%%		\frac{F_s^*}{F_s^{MS}}&\approx (\frac{Rq}{q-R})^{Rn}(\frac{q-R}{q})^{qn},
%%%	\end{align*}
%%%	where $R=\frac{k}{n}$.
%%%\end{lemma}
%%%\begin{proof}
%%%	Using \ref{eq:binomapprox} again, we have
%%%	\begin{align*}
%%%		F_s^{MS}&=\binom{qn}{k}\\
%%%		&\approx 2^{nqH(\frac{k}{nq})}\\
%%%		%&\approx 2^{nqH(\frac{R}{q})}\\
%%%		&= 2^{nq[-\frac{R}{q}\log_2 \frac{R}{q}-(1-\frac{R}{q})\log_2 (1-\frac{R}{q})]}\\
%%%		&=\frac{(\frac{q}{R})^{nR}}{(\frac{q-R}{q})^{n(q-R)}} 	
%%%	\end{align*}
%%%	Then
%%%	\begin{align*}
%%%		\frac{F_s^*}{F_s^{MS}}&\approx \frac{zq^k\cdot{(\frac{q-R}{q})^{n(q-R)}}}{(\frac{q}{R})^{Rn}}\\
%%%		&\approx zR^{Rn}(\frac{q-R}{q})^{qn-Rn}\\
%%%		&\approx (\frac{Rq}{q-R})^{Rn}(\frac{q-R}{q})^{qn}.
%%%	\end{align*}
%%%\end{proof}
%
%
%\aditya{commenting out the cyclic code examples right now.}
%\subsection*{More examples of cyclic codes that satisfy the CCP}
%In this section, we show more examples of cyclic codes that satisfy the CCP.
%\begin{itemize}
%	\item Generator polynomial over $GF(2)$ with $n=6$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X^4+X^3+X^1+1.
%	\end{align*}
%	\item Generator polynomial over $GF(3)$ with $n=6$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X+2;\\
%		g(X)&=X^3+X^2+2X+2;\\
%		g(X)&=X^3+2X^2+2X+1;\\
%		g(X)&=X^4+2X^3+X+2;\\
%		g(X)&=X^4+X^3+2X+2.
%	\end{align*}
%	\item Generator polynomial over $GF(5)$ with $n=6$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X+4;\\
%		g(X)&=X^3+2X^2+2X+1;\\
%		g(X)&=X^3+2X^2+3X+4;\\
%		g(X)&=X^4+X^3+4X+4;\\
%		g(X)&=X^4+4X^3+X+4.
%	\end{align*}
%	\item Generator polynomial over $GF(2)$ with $n=7$.
%	\begin{align*}
%		g(X)&=X+1.
%	\end{align*}
%	\item Generator polynomial over $GF(3)$ with $n=7$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X+2.
%	\end{align*}
%	\item Generator polynomial over $GF(5)$ with $n=7$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X+4.
%	\end{align*}
%	\item Generator polynomial over $GF(2)$ with $n=8$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X^5+X^4+X+1.
%	\end{align*}
%	\item Generator polynomial over $GF(3)$ with $n=8$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X+2;\\
%		g(X)&=X^4+X^3+X+2;\\
%		g(X)&=X^4+2X^3+2X+2;\\
%		g(X)&=X^5+X^4+X+1;\\
%		g(X)&=X^5+2X^4+X+2;\\
%		g(X)&=X^6+X^5+2X^4+2X^2+2X+1;\\
%		g(X)&=X^6+2X^5+2X^4+2X^2+X+1.
%	\end{align*}
%	\item Generator polynomial over $GF(5)$ with $n=8$.
%	\begin{align*}
%		g(X)&=X+1;\\
%		g(X)&=X+2;\\
%		g(X)&=X+3;\\
%		g(X)&=X+4;\\
%		g(X)&=X^3+X^2+2X+2;\\
%		g(X)&=X^3+X^2+3X+3;\\
%		g(X)&=X^3+2X^2+2X+4;\\
%		g(X)&=X^3+2X^2+3X+1;\\
%		g(X)&=X^3+3X^2+2X+1;\\
%		g(X)&=X^3+3X^2+3X+4;\\
%		g(X)&=X^3+4X^2+2X+3;\\	
%		g(X)&=X^3+4X^2+3X+2;\\
%		g(X)&=X^4+3X^3+4X+1;\\						g(X)&=X^4+4X^3+3X+1;\\
%		g(X)&=X^4+4X^3+4X^2+3X+3;\\					g(X)&=X^4+2X^3+X+1;\\						g(X)&=X^5+4X^4+X+1;\\						g(X)&=X^5+2X^4+X+2;\\	
%		g(X)&=X^5+3X^4+X+3;\\	  	
%		g(X)&=X^5+4X^4+X+4;\\						g(X)&=X^5+X^4+3X^3+3X^2+2X+2;\\		
%		g(X)&=X^5+2X^4+X^3+2X^2+3X+1;\\
%		g(X)&=X^5+2X^4+2X^3+4X^2+2X+4;\\
%		g(X)&=X^5+3X^4+X^3+3X^2+3X+4;\\
%		g(X)&=X^5+3X^4+2X^3+X^2+2X+1;\\
%		g(X)&=X^5+4X^4+3X^3+2X^2+2X+3;\\
%		g(X)&=X^5+4X^4+4X^3+X^2+3X+2;\\
%		g(X)&=X^6+X^5+3X^4+X^2+X+3;\\
%		g(X)&=X^6+2X^5+2X^4+X^2+2X+2;\\	 	       	g(X)&=X^6+3X^5+2X^4+X^2+3X+2;\\										g(X)&=X^6+4X^5+3X^4+X^2+4X+3;\\	
%		g(X)&=X^6+X^5+X^4+X^3+X^2+X+1.\\			
%	\end{align*}
%\end{itemize}

\subsection*{Proof of Claim \ref{claim:compare_MN}}

\begin{itemize}
	\item $\frac{M}{N}=\frac{1}{q}$.
We have
\begin{align*}
\frac{1}{K} \log_2 \frac{F_s^{MN}}{F_s^*} &= \frac{1}{K} \log_2 \binom{K}{K/q} - \frac{1}{K} \log_2 z - \frac{k}{K} \log_2 q.
\end{align*}
Using the fact that $z \leq k+1$ and taking limits as $n \rightarrow \infty$, we get that
\begin{align*}
\lim_{n \rightarrow \infty} \frac{1}{K} \log_2 \frac{F_s^{MN}}{F_s^*} = H_2\bigg{(}\frac{1}{q}\bigg{)} - \frac{\eta}{q} \log_2 q.
\end{align*}

\item $\frac{M}{N}=1-\frac{k+1}{nq}$. We have %\aditya{rewrite proof like above}\litang{Fix it}
\begin{align*}
\frac{1}{K} \log_2 \frac{F_s^{MN}}{F_s^*} =& \frac{1}{K}\log_2 \binom{K}{k+1}-\frac{k+1}{K}\log_2 q\\
&-\frac{1}{K}\log_2\frac{zn}{k+1}.
    \end{align*}
 %   Again we use the approximation in eq. (\ref{eq:binomapprox}) to obtain
 Using the fact that $z \leq k+1$ and taking limits as $n \rightarrow \infty$, we get that
   	\begin{align*}
  \lim_{n \rightarrow \infty}  	\frac{1}{K} \log_2 \frac{F_s^{MN}}{F_s^*}&=H_2\bigg{(}\frac{\eta}{q}\bigg{)} - \frac{\eta}{q} \log_2 q.
   	\end{align*}
%   	And
%   	\begin{align*}
%   	F_s^{\ast}=(q-1)q^k\frac{zn}{k+1}\approx 2^{(k+1)\log_2 q+\log_2{\frac{zn}{k+1}}}
%   	\end{align*}
%   	Then let $K=nq$, $\eta'=\frac{k+1}{n}$,
%   	\begin{align*}
 %  		\log_2\frac{F_s^{MA}}{F_s^{\ast}}&= nqH_2(\frac{k+1}{nq})-(k+1)\log_2 q-\log_2{\frac{zn}{k+1}}\\
 %  		&\approx nqH_2(\frac{k+1}{nq})-(k+2)\log_2 q\\
%   		&\approx KH_2(\frac{\eta'}{q})-\frac{K\eta'}{q} \log_2 q
%    \end{align*}
\end{itemize}


%\begin{itemize}
%	\item $\frac{M}{N}=\frac{1}{q}$
%	
%	It is well known \cite{graham1994concrete} that for large $K$ and $0\le p\le 1$
%	\begin{equation}
%	\label{eq:binomapprox}
%	\binom{K}{Kp}\approx 2^{KH(p)},
%	\end{equation}
%	where $H(\cdot)$ represents the binary entropy function. Using this,
%	\begin{align*}
%	F_s^{MN}=\binom{qn}{n}&\approx 2^{nqH(\frac{1}{q})}
%	\end{align*}
%And
%    \begin{align*}
%		F_s^{\ast}=q^kz=2^{\log_2 z + k \log_2 q}.
%    \end{align*}
%    Then let $K=nq$, $\eta'=\frac{k+1}{n}$, we have
%    \begin{align*}
%    \log_2\frac{F_s^{MA}}{F_s^\ast}&=nqH_2(\frac{1}{q})-\log_2 z-k\log_2 q\\
%    &\approx nqH_2(\frac{1}{q})-(k+1)\log_2 q\\
%    &\approx KH_2(\frac{1}{q})-\frac{K\eta'}{q}\log_2 q
%    \end{align*}
%
% %   Let $K=nq$, $\eta=\frac{k}{n}$, we have
% %   \begin{align*}
% %   \log_2\frac{F_s^{MA}}{F_s^\ast}&=\frac{1}{q}[K-(\eta+\frac{1}{n})K]\log_2 q+(K-\frac{K}{q})\log_2 \frac{q}{q-1}\\
% %   &=-\frac{K}{q}(\eta+\frac{1}{n})\log_2 q +\frac{K}{q}\log_2 q - K(1-\frac{1}{q})\log_2(1-\frac{1}{q})\\
% %   &\approx KH_2(\frac{1}{q})-K\frac{\eta}{q}\log_2 q
% %   \end{align*}
%    and the result follows.
%
%    \item $\frac{M}{N}=1-\frac{k+1}{nq}$
%
%    Again we use the approximation in eq. (\ref{eq:binomapprox}) to obtain
%   	\begin{align*}
%   		F_s^{MS}&=\binom{qn}{k+1}\approx 2^{nqH(\frac{k+1}{nq})}	
%   	\end{align*}
%   	And
%   	\begin{align*}
%   	F_s^{\ast}=(q-1)q^k\frac{zn}{k+1}\approx 2^{(k+1)\log_2 q+\log_2{\frac{zn}{k+1}}}
%   	\end{align*}
%   	Then let $K=nq$, $\eta'=\frac{k+1}{n}$,
%   	\begin{align*}
%   		\log_2\frac{F_s^{MA}}{F_s^{\ast}}&= nqH_2(\frac{k+1}{nq})-(k+1)\log_2 q-\log_2{\frac{zn}{k+1}}\\
%   		&\approx nqH_2(\frac{k+1}{nq})-(k+2)\log_2 q\\
%   		&\approx KH_2(\frac{\eta'}{q})-\frac{K\eta'}{q} \log_2 q
%    \end{align*}
%\end{itemize}
\subsection{Discussion on coded caching systems constructed by generator matrices satisfying the $(k,\alpha)$-CCP where $\alpha \leq k$}
\label{sec:kalpha_ccp_matrices}
%\aditya{Need to revisit this part of the paper}
Consider the $(k,\alpha)$-CCP ({\it cf.} Definition \ref{def:kalphacc}) where $\alpha\le k$. Let $z$ be the least integer such that $\alpha~|~nz$, and let $\calT^\alpha_a=\{a\alpha,\cdots,a\alpha+\alpha-1)\}$ and $\calS^\alpha_a=\{(t)_n~|~t\in \calT^\alpha_a\}$. Let $\bfG_{\calS^\alpha_a}=[\bfg_{i_0},\cdots,\bfg_{i_{\alpha-1}}]$ be the submatrix of $\bfG$ specified by the columns in $\calS^\alpha_a$, i.e,  $\bfg_{i_j} \in \bfG_{\calS^\alpha_a}$ if $i_j\in \calS^\alpha_a$.
%Next, we define $(k,\alpha)$-consecutive column property as follows.
%\begin{definition}{\emph{$(k,\alpha)$-consecutive column property}}
%%\label{def:kalphacc}
%Consider the submatrices of $\bfG$ specified by $\bfG_{\calS^\alpha_a}$ for $0\le a\le \frac{zn}{\alpha}-1$. We say that $\bfG$ satisfies the $(k,\alpha)$-consecutive column property if each $\bfG_{\calS^\alpha_a}$ has full rank. In other words, $\alpha$ columns in each $\bfG_{\calS^\alpha_a}$ are linearly independent.
%\end{definition}
We demonstrate that the resolvable design generated from a linear block code that satisfies the $(k,\alpha)$-CCP can also be used in a coded caching scheme. First, we construct a $(X,\calA)$ resolvable design as described in Section \ref{sec:design}.A., which can be partitioned into $n$ parallel classes $\calP_i=\{B_{i,j}: 0\le j<q\}$, $0\le i<n$. By the constructed resolvable design, we partition each subfile $W_n$ into $q^kz$ subfiles $W_n=\{W_{n,t}^s~|~0\le t< q^k, 0\le s< z\}$ and operate the placement scheme in Algorithm \ref{Alg:Placement}. In the delivery phase, for each recovery set, several equations are generated, each of which benefit $\alpha$ users simultaneously. Furthermore, the equations generated by all the recovery sets can recover all the missing subfiles. In this section, we only show that for the recovery set $\calP_{\calS^\alpha_a}$, it is possible to generate equations which benefit $\alpha$ users and allow the recovery of all of missing subfiles with given superscript. The subsequent discussion exactly mirrors the discussion in the $(k,k+1)$-CCP case and is skipped.

Towards this end, we first show that picking $\alpha$ users from $\alpha$ distinct parallel classes can always form $q^{k-\alpha+1}-q^{k-\alpha}$ signals. More specifically, consider blocks $B_{i_1, l_{i_1}}, \dots, B_{i_{\alpha}, l_{i_{\alpha}}}$ (where $l_{i_j} \in \{0, \dots, q-1\}$) that are picked from $\alpha$ distinct parallel classes of $\calP_{\calS^\alpha_{a}}$. Then, $|\cap_{j=1}^{\alpha-1} B_{i_j, l_{i_j}}| = q^{k-\alpha+1}$ and $|\cap_{j=1}^\alpha B_{i_j, l_{i_j}}| = q^{k-\alpha}$.

\begin{claim}
	\label{claim:MDSintersectionKAlpha}
	Consider the resolvable design $(X, \calA)$ constructed by a $(n,k)$ linear block code that satisfies the $(k,\alpha)$ CCP. Let $\calP_{\calS^\alpha_a}=\{\calP_i~|~i\in \calS^\alpha_a\}$ for $0\le a< \frac{zn}{\alpha}$, i.e., it is the set of parallel classes corresponding to $\calS^\alpha_a$. We emphasize that $|\calP_{\calS^\alpha_a}| = \alpha\le k$. Consider blocks $B_{i_1, l_{i_1}}, \dots, B_{i_{\alpha'}, l_{i_{\alpha'}}}$ (where $l_{i_j} \in \{0, \dots, q-1\}$) that are picked from any $\alpha'$ distinct parallel classes of $\calP_{\calS^\alpha_a}$ where $\alpha'\le \alpha$. Then, $|\cap_{j=1}^{\alpha'} B_{i_j, l_{i_j}}| = q^{k-\alpha'}$.
\end{claim}
	The above argument implies that any $\alpha-1$ blocks from any $\alpha-1$ distinct parallel classes of $\calP_{\calS^\alpha_a}$ have $q^{k-\alpha+1}$ points in common and any $\alpha$ blocks $B_{i_1,l_{i_1}}$, $B_{i_\alpha,l_{i_\alpha}}$ from any $\alpha$ distinct parallel classes of $\calP_{\calS^{\alpha}_a}$ have $q^{k-\alpha}$ points in common. These blocks (or users) can participate in $q^{k-\alpha+1}-q^{k-\alpha}$ equations, each of which benefits $\alpha$ users. In particular, each user will recover a missing subfile indexed by an element belonging to the intersection of the other $\alpha-1$ blocks in each equation. A very similar argument to Lemma \ref{lemma:delivery} can be made to justify enough equations can be found that allow all users to recover all missing subfiles. %\litang{Please check it.}
%Let $\hat{L}_{s}$ be the set of points that are not in $B_{i_s,l_{i_s}}$ but in all of other blocks $B_{i_j,l_{i_j}}$ where $j\neq s$, i.e., $\hat{L}_{s} = \cap_{j \in \calS^\alpha_a \setminus \{s\}}B_{j,l_j}\setminus \cap_{j \in \calS^\alpha_a} B_{j,l_j}$ for $s\in \calS^\alpha_a$ so that $|\hat{L}_s|=q^{k-\alpha+1}-q^{k-\alpha}$.  We fix an arbitrary ordering on the elements of the set $\hat{L}_s$.  The above discussion implies that by randomly choosing $\alpha$ users from $\alpha$ parallel classes of $\calP_{\calS^{\alpha}_a}$, $q^{k-\alpha+1}-q^{k-\alpha}$ signals can be generated, each of which recover $\alpha$ distinct missing subfiles for these $\alpha$ users as follows, for $0\le i< q^{k-\alpha+1}-q^{k-\alpha}$,
%\begin{align*}
%	\oplus_{s \in S^\alpha_a} W^{E_a(B_{s,l_s})}_{d_{B_{s,l_s}},\hat{L}_s[i]}.
%\end{align*}
%It remains to show that these signals (generated by Algorithm \ref{Alg:SignalAlphaCCP}) can recover all of missing subfiles of $U_B$ with superscript $E_a(B)$.
\begin{proof}
	Recall that by the construction in Section III.A,  block $B_{i,l} \in \calP_i$ is specified as follows,
	$$
	B_{i,l} = \{j : \bfT_{i,j} = l\}.
	$$
	Let $\bfG=[g_{ab}]$, for $0\le a<k$, $0\le b<n$.
	
	Now consider $B_{i_1, l_{i_1}}, \dots, B_{i_{\alpha'}, l_{i_{\alpha'}}}$ (where $i_j \in \calS^\alpha_a, l_{i_j} \in \{0, \dots, q-1\}$) that are picked from $\alpha'$ distinct parallel classes of  $\calP_{\calS^\alpha_a}$. W.l.o.g. we assume that $i_1 < i_2 < \dots < i_{\alpha'}$. Let $\calI =  \{i_1, \dots, i_{\alpha'}\}$ and $\bfT_{\calI}$ denote the submatrix of $\bfT$ obtained by retaining the rows in $\calI$. We will show that the vector $[l_{i_1}~l_{i_2}~\dots~l_{i_{\alpha'}}]^T$ is a column in $\bfT_{\calI}$ and appears $q^{k-\alpha'}$ times in it.
	
	We note here that by the $(k,\alpha)$-CCP, the vectors $\bfg_{i_1}, \bfg_{i_2}, \ldots, \bfg_{i_\alpha}$ are linearly independent and thus the subset of these vectors, $\bfg_{i_1},\cdots,\bfg_{i_{\alpha'}}$ are linearly independent. W. l. o. g., we assume that the top $\alpha' \times \alpha'$ submatrix of the matrix $[\bfg_{i_1}~\bfg_{i_2}~ \dots ~\bfg_{i_{\alpha'}}]$ is full-rank.  Next, consider the system of equations in variables $\bfu_0, \dots, \bfu_{\alpha'-1}$.
	\begin{align*}
	\sum_{b=0}^{\alpha'-1}\bfu_{b}g_{bi_1} &= l_{i_1}-\sum_{b=\alpha'}^{k-1}\bfu_{b}g_{bi_1},\\
	\sum_{b=0}^{\alpha'-1}\bfu_{b}g_{bi_2} &= l_{i_2}-\sum_{b=\alpha'}^{k-1}\bfu_{b}g_{bi_2},\\
	\mathrel{\makebox[\widthof{=}]{\vdots}}\\
	\sum_{b=0}^{\alpha'-1}\bfu_{b}g_{bi_{\alpha'}} &= l_{i_{\alpha'}}-\sum_{b=\alpha'}^{k-1}\bfu_{b}g_{bi_{\alpha'}}.
	\end{align*}
	%By the $(k,\alpha)$-CCP, the vectors $\bfg_{i_1}, \bfg_{i_2}, \ldots, \bfg_{i_\alpha}$ are linearly independent and thus the subset of these vectors, $\bfg_{i_1},\cdots,\bfg_{i_{\alpha'}}$ are linearly independent.
By the assumed condition, it is evident that this system of $\alpha'$ equations in $\alpha'$ variables has a unique solution for a given vector $\bfv=[\bfu_{\alpha'},\cdots, \bfu_{k-1}]$ over $GF(q)$. Since there are $q^{k-\alpha'}$ possible $\bfv$ vectors, the result follows.
	\end{proof}
		
%		The above argument implies that any $\alpha-1$ blocks from any $\alpha-1$ distinct parallel classes of $\calP_{\calS^\alpha_a}$ have $q^{k-\alpha+1}$ points in common and any $\alpha$ blocks $B_{i_1,l_{i_1}}$, $B_{i_\alpha,l_{i_\alpha}}$ from any $\alpha$ distinct parallel classes of $\calP_{\calS^{\alpha}_a}$ have $q^{k-\alpha}$ points in common.
%		Let $\hat{L}_{s}$ be the set of points that are not in $B_{i_s,l_{i_s}}$ but in all of other blocks $B_{i_j,l_{i_j}}$ where $j\neq s$, i.e., $\hat{L}_{s} = \cap_{j \in \calS^\alpha_a \setminus \{s\}}B_{j,l_j}\setminus \cap_{j \in \calS^\alpha_a} B_{j,l_j}$ for $s\in \calS^\alpha_a$ so that $|\hat{L}_s|=q^{k-\alpha+1}-q^{k-\alpha}$.  We fix an arbitrary ordering on the elements of the set $\hat{L}_s$.  The above discussion implies that by randomly choosing $\alpha$ users from $\alpha$ parallel classes of $\calP_{\calS^{\alpha}_a}$, $q^{k-\alpha+1}-q^{k-\alpha}$ signals can be generated, each of which recover $\alpha$ distinct missing subfiles for these $\alpha$ users as follows, for $0\le i< q^{k-\alpha+1}-q^{k-\alpha}$,
%		\begin{align*}
%		\oplus_{s \in S^\alpha_a} W^{E_a(B_{s,l_s})}_{d_{B_{s,l_s}},\hat{L}_s[i]}.
%		\end{align*}
%We provide an intuitive argument for the delivery phase. Similar to caching system
As in the case of the $(k,k+1)$-CCP, we form a recovery set bipartite graph with parallel classes and recovery sets as the disjoint vertex subsets, and the edges incident on each parallel class are labeled arbitrarily from $0$ to $z-1$. For a parallel class $\calP\in \calP_{\calS^{\alpha}_a}$ we denote this label by label($\calP-\calP_{\calS^{\alpha}_a}$). For a given recovery set $\calP_{\calS^{\alpha}_a}$, the delivery phase proceeds by choosing blocks from $\alpha$ distinct parallel classes in $\calP_{\calS^{\alpha}_a}$ and it provides $q^{k-\alpha+1}-q^{k-\alpha}$ equations that benefit $\alpha$ users. Note that in the $(k,\alpha)$-CCP case, randomly picking $\alpha$ blocks from $\alpha$ parallel classes in $\calP_{\calS^{\alpha}_a}$ will always result in $q^{k-\alpha}$ intersections, which is different from $(k,k+1)$-CCP. It turns out that each equation allows a user in $\calP\in \calP_{\calS^{\alpha}_a}$ to recover a missing subfile with superscript label($\calP-\calP_{\calS_{a}^\alpha}$).

Let the demand of user $U_{B_{i,j}}$ for $i\in n-1, 0\le j\le q-1$ by $W_{\kappa_{i,j}}$. We formalize the argument in Algorithm \ref{Alg:SignalAlphaCCP} and prove that equations generated in each recovery set $\calP_{\calS^{\alpha}_a}$ can recover all missing subfile with superscript label$(\calP-\calP_{\calS^{\alpha}_a})$.


%	    It remains to show that these signals (generated by Algorithm \ref{Alg:SignalAlphaCCP}) can recover all of missing subfiles of $U_B$ with superscript $E_a(B)$.
	\begin{algorithm}[htb]
		\SetNoFillComment
		\caption{Signal Generation Algorithm for $\calP_{\calS_a^\alpha}$}
		\label{Alg:SignalAlphaCCP}
		\SetKwInOut{Input}{Input}
		\SetKwInOut{Output}{Output}
		\Input{For $\calP \in \calP_{\calS_a^\alpha}$, $E(\calP) = \text{label}(\calP - \calP_{\calS_a^\alpha})$. Signal set $Sig=\emptyset$.}
		\While{any user $U_B\in \calP_j, j \in \calS^\alpha_a$ does not recover all its missing subfiles with superscript $E(\calP)$}
		{ Pick blocks $B_{j,l_j} \in \calP_j$ for all $j \in \calS_a^{\alpha}$ and $l_j \in \{0, \dots, q-1\}$\;
			\tcc{Pick blocks from distinct parallel classes in $\calP_{\calS_a^\alpha}$. The cardinality of their intersection is always $q^{k-\alpha}$}
			Find set $\hat{L}_{s} = \cap_{j \in \calS^\alpha_a \setminus \{s\}}B_{j,l_j}\setminus \cap_{j \in \calS^\alpha_a} B_{j,l_j}$ for $s\in \calS^\alpha_a$\;% =\{i_1, \dots, i_\alpha\}$\;
			\tcc{Determine the missing subfile indices that the user from $\calP_s^\alpha$ will recover. Note that $|\hat{L}_{s}|=q^{k-\alpha+1}-q^{k-\alpha}$}
			Add signals $\oplus_{s \in S^\alpha_a} W^{E(\calP_s)}_{\kappa_{s,l_s},\hat{L}_s[t]}$, $0\le t< q^{k-\alpha+1}-q^{k-\alpha}$, to $Sig$\;
		\tcc{User $U_{B_{s,l_s}}$ demands file $W_{\kappa_{s,l_s}}$. This equation allows it to recover the corresponding missing subfile index $\hat{L}_s[t]$, which is the $t$-th element of $\hat{L}_s[t]$. The superscript is determined by the recovery set bipartite graph}
	}
		\Output{Signal set $Sig$.}
	\end{algorithm}
	
	For the sake of convenience we argue that user $U_{B_{\beta, l_\beta}}$ that demands $W_{\kappa_{\beta, l_\beta}}$ can recover all its missing subfiles with superscript $E(\calP_\beta)$. Note that $B_{\beta,l_{\beta}}=q^{k-1}$. Thus user $U_{B_{\beta,l_{\beta}}}$ needs to obtain $q^k-q^{k-1}$ missing subfiles with superscript $E(\calP_{\beta})$. The delivery phase scheme repeatedly picks $\alpha$ users from different parallel classes of $\calP_{\calS^\alpha_a}$. The equations in Algorithm \ref{Alg:SignalAlphaCCP} allow $U_{B_{\beta, l_\beta}}$ to recover all $W^{E(\calP_\beta)}_{\kappa_{\beta,l_\beta},\hat{L}_\beta[t]}$ where $\hat{L}_{\beta} = \cap_{j \in \calS^\alpha_a \setminus \{\beta\}}B_{j,l_j}\setminus \cap_{j \in \calS^\alpha_a} B_{j,l_j}$ and $t=1,\cdots, q^{k-\alpha+1}-q^{k-\alpha}$. This is because of Claim	\ref{claim:MDSintersectionKAlpha}.
	%For the sake of convenience we argue that user $U_{B_{i_1,l_{i_1}}}$, $i_1\in \calS^\alpha_a$ can recover all its missing subfiles with superscript $E_a(B_{i_1,l_{i_1}})$. Note that $B_{i_1,l_{i_1}}=q^{k-1}$. Thus user $U_{B_{i_1,l_{i_1}}}$ needs to obtain $q^k-q^{k-1}$ missing subfiles with superscript $E_a(B_{i_1, l_{i_1}})$. The delivery phase scheme repeatedly picks $\alpha$ users from different parallel classes of $\calP_{\calS^\alpha_a}$, $U_{B_{i_1,l_{i_1}}}, \cdots, U_{B_{i_{\alpha},l_{i_{\alpha}}}}$. The equations in Algorithm \ref{Alg:SignalAlphaCCP} allow $U_{B_{i_1,l_{i_1}}}$ to recover $W^{E_a(B_{i_1,l_{i_1}})}_{d_{B_{i_1,l_{i_1}}},\hat{L}_{i_1}[t]}$ where $0\le i\le q^{k-\alpha+1}-q^{k-\alpha}, \hat{L}_{i_1} = \cap_{j \in \calS^\alpha_a \setminus \{i_1\}}B_{j,l_j}\setminus \cap_{j \in \calS^\alpha_a} B_{j,l_j}$. Note that $U_{B_{i_1,l_{i_1}}}$ does not have $W^{E_a(B_{i_1,l_{i_1}})}_{d_{B_{i_1,l_{i_1}}},\hat{L}_{i_1}[t]}$ since $B_{i_1,l_{i_1}}\bigcap \cap_{j \in \calS^\alpha_a \setminus \{i_1\}}B_{j,l_j}= \cap_{j \in \calS^\alpha_a} B_{j,l_j}$.
	
	Next, we count the number of equations that  $U_{B_{\beta, l_\beta}}$  participates in. We can pick $\alpha-1$ users from $\alpha -1 $ parallel classes in $\calP_{\calS^{\alpha}_a}$. There are totally $q^{\alpha-1}$ ways to pick them, each of which generate $q^{k-\alpha+1}-q^{k-\alpha}$ equations. Thus there are a total of $q^k-q^{k-1}$ equations in which user  $U_{B_{\beta, l_\beta}}$ participates in.
	
	It remains to argue that each equation provides a distinct file part of user $U_{B_{\beta, l_\beta}}$. Towards this end, let $\{i_1,\cdots, i_{\alpha-1}\}\subset \calS_{a}^{\alpha}$ be an index set such that $\beta\notin \{i_1,\cdots, i_{\alpha-1}\}$ but $\beta\in \calS_{a}^{\alpha}$.  Note that when we pick the same set of blocks $\{B_{i_1,l_{i_1}},\cdots, B_{i_{\alpha-1},l_{i_{\alpha-1}}}\}$, it is impossible that the recovered subfiles $W^{E(\calP_{\beta})}_{\kappa_{\beta,l_{\beta}},\hat{L}_{\beta}[t_1]}$ and $W^{E(\calP_{\beta})}_{\kappa_{\beta,l_{\beta}},\hat{L}_{\beta}[t_2]}$ are the same since the points in $\hat{L}_\beta$ are distinct. Next, suppose that there exist sets of blocks $\{B_{i_1,l_{i_1}},\cdots, B_{i_{\alpha-1},l_{i_{\alpha-1}}}\}$ and $\{B_{i_1,l'_{i_1}}, \cdots, B_{i_{\alpha-1},l'_{i_{\alpha-1}}}\}$ such that $\{B_{i_1,l_{i_1}}, \cdots, B_{i_{\alpha-1},l_{i_{\alpha-1}}}\}\neq \{B_{i_1,l'_{i_1}}, \cdots, B_{i_{\alpha-1},l'_{i_{\alpha-1}}}\}$, but $\gamma\in \cap_{j=1}^{\alpha-1} B_{i_j,l_{i_j}}\setminus B_{\beta,l_{\beta}}$ and $\gamma\in \cap_{j=1}^{\alpha-1} B_{i_j,l'_{i_j}} \setminus B_{\beta,l'_{\beta}}$. This is a contradiction since this in turn implies that $\gamma \in \cap_{j=2}^{\alpha} B_{i_j,l_{i_j}}\bigcap \cap_{j=2}^{\alpha} B_{i_j,l'_{i_j}}$, which is impossible since two blocks from the same parallel class have an empty intersection.
	
	Finally we calculate the transmission rate. In Algorithm \ref{Alg:SignalAlphaCCP}, for each recovery set, we transmit $q^{k+1}-q^{k}$ equations and there are totally $\frac{zn}{\alpha}$ recovery sets. Since each equation has size equal to a subfile, the rate is given by
	\begin{align*}
	R&=(q^{k+1}-q^{k})\times \frac{zn}{\alpha}\times \frac{1}{zq^k}\\
	 &=\frac{n(q-1)}{\alpha}.
	\end{align*}

%\subsection*{Linear block codes satisfy $(k,k)$-CCP and cyclic code}
The $(n,k)$ linear block codes that satisfy the $(k,\alpha)$-CCP over $GF(q)$ correspond to a coded caching system with $K=nq$, $\frac{M}{N}=\frac{1}{q}$, $F_s=zq^k$ and have a rate $R=\frac{n(q-1)}{\alpha}$. Thus, the rate of this system is a little higher compared to the $(k,k+1)$-CCP system with almost the same subpacketization level.

However, by comparing Definitions \ref{def:MDSproperty} and \ref{def:kalphacc} it is evident that the rank constraints of the $(k,\alpha)$-CCP are weaker as compared to the $(k,k+1)$-CCP. Therefore, in general we can find more instances of generator matrices that satisfy the $(k,\alpha)$-CCP. For example, a large class of codes that satisfy the $(k,k)$-CCP are $(n,k)$ cyclic codes since any $k$ consecutive columns in their generator matrices are linearly independent \cite{lincostello}. Thus, $(n,k)$ cyclic codes always satisfy the $(k,k)$-CCP but satisfy $(k,k+1)$-CCP if they satisfy the additional constraints discussed in Claim \ref{claim:cyclic_k1}.

%In the next claim, we discuss a more general construction of generator matrices that satisfy $(k,k)$-CCP based on the cyclic code and Claim \ref{claim:Gconstruct1}.
%
%\begin{claim}
%	\label{claim:GconstructKKCCP}
%	Consider a $(n,k)$ linear block code over $GF(q)$ whose generator matrix is specified as $\bfG=\bfA\otimes \bfI_{t\times t}$, where $n=t\alpha$, $k=tz$, $\bfA$ is the generator matrix of $(\alpha,z)$ cyclic code over $GF(q)$. It satisfies $(k,k)$-CCP.
%\end{claim}
%\begin{proof}
%	%Assume that $t'=GCD(n,k)$, then $z'=\frac{k}{t'}$ is the least integer such that $k|nz'$ and $z|z'$.
%	The recovery set is specified as $\calS_a^k=\{(t)_n|t\in \calT_{a}^k\}$ and $\calT_{a}^k=\{ak,\cdots,ak+k-1\}$. For the sake of convenience we argue that $\bfG_{\calS_0^k}$ is full rank. Note that $\bfG_{\calS_0^k}=\bfA_{0}\otimes \bfI_{t\times t}$, where $\bfA_{0}$ is the first $z$ columns of $\bfA$. Then $\det(\bfG)=\det(\bfA_{0}\otimes \bfI_{t\times t})=\det(\bfA_{0})^z\neq 0$. Therefore, $\bfA$ satisfies the $(k,k)$-CCP.
%\end{proof}
%\begin{remark}	
%		In Claim \ref{claim:GconstructKKCCP}, we point out that although $\bfG$ has a cyclic form,  the corresponding $(n,k)$ code may not be cyclic code since the generator polynomial of this code may not divide $X^n-1$.
%\end{remark}

\subsection{Cyclic codes over $\mathbb{Z} \mod q$ \cite{blake1972codes}}
\label{sec:blake_codes}
%To show the cyclic code in \cite{blake1972codes} satisfies the $(k_{min},k_{min})$-CCP and is suitable in our coded caching scheme,
%
%
%We first show that the matrix $\bfT$ constructed by the approach outlined in Section \ref{sec:matrices_z_mod_q} still results in a resolvable design where each block contains $q_1^{k_1-1}q_2^{k_2-1}\cdots q_d^{k_d-1}$ points and any $\alpha'$ blocks from distinct parallel classes of $\calP_{\calS_{a}^{\alpha}}$  has $q_1^{k_1-\alpha'}q_2^{k_2-\alpha'}\cdots q_{d}^{k_d-\alpha'}$ intersections, where $\alpha'\le \alpha \le \min\{k_1,k_2\cdots,k_d\}$, and ${\calS^{\alpha}_a}=\{(ak_{min})_n, (ak_{min}+1)_n,\cdots,(ak_{min}+\alpha-1)_n\}$ (see Claim \ref{claim:MDSintersectionKAlpha}).
%
First, we show that matrix $\bfT$ constructed by constructed by the approach outlined in Section \ref{sec:matrices_z_mod_q} still results in a resolvable design. Let $\Delta=[\Delta_0 \Delta_1 \cdots \Delta_{n-1}]$ be a codeword of the cyclic code over $\mathbb{Z}\mod q$, denoted $\calC$ where $q=q_1q_2\cdots q_d$, and $q_i, i = 1, \dots, d$ are prime. By using the Chinese remaindering map $\psi$ (discussed in Section \ref{sec:matrices_z_mod_q}), $\Delta$ can be uniquely mapped into $d$ codewords $\bfc^{(i)}, i = 1, \dots, d$ where each $\bfc^{(i)}$ is a codeword of $\calC^i$ (the cyclic code over $GF(q_i)$). Thus, the $b$-th component $\Delta_b$ can be mapped to $(\bfc^{(1)}_{b}, \bfc^{(2)}_{b}, \dots, \bfc^{(d)}_{b})$

Let $\bfG^i=[g_{ab}^{(i)}]$ represent the generator matrix of the code $\calC^i$. Based on prior arguments, it is evident that there are $q_i^{k_i-1}$ distinct solutions over $GF(q_i)$ to the equation $\sum_{a=0}^{k_i-1}\bfu_a g_{ab}^{(i)}= \bfc^{(i)}_{b}$. In turn, this implies that $\Delta_b$ appears $q_1^{k_1-1}q_2^{k_2-1}\cdots q_d^{k_d-1}$ times in the $b$-th row of $\bfT$ and the result follows.
%
%
%$\Delta=(\Omega_1, \Omega_2, \cdots, \Omega_{d})$ where $\Omega_i=[\Omega_{i0}, \Omega_{i1}, \cdots, \Omega_{i(n-1)}]$ is over $\mathbb{Z}\mod q_i$ and $\Delta_{b} = (\Omega_{1b}, \Omega_{2b}, \cdots, \Omega_{db})$. Since $\Omega_i=\bfu \bfG$, where $\bfG$ is a $(n,k_i)$ generator matrix of cyclic code over $GF(q_i)$ and $\bfu=[\bfu_0,\cdots,\bfu_{k_i-1}]$, we have
%\begin{align*}
%\Omega_{ib} = \sum_{a=0}^{k_i-1} \bfu_a g_{ab}.
%\end{align*}
% We pick a non-zero element $g_{a^*b}$ in the $b$-th column of $\bfG$ and rewritten the above equation as
%\begin{align*}
%\Omega_{ib}-\bfu_{a^*}g_{a^*b}=\sum_{a \neq a^*} \bfu_{a} g_{ab}
%\end{align*}

%For any $\bfu_a$, $a\neq a^*$, this equation has a unique solution for $\bfu_{a^*}$. It implies there are $q_i^{k_i-1}$ distinct solutions over $\mathbb{Z}\mod q_i$. It means each $\Delta_b=(\Omega_{1b}, \Omega_{2b}, \cdots, \Omega_{db})$ appears $q_1^{k_1-1}q_2^{k_2-1}\cdots q_d^{k_d-1}$ times in the $b$-th row of $\bfT$ and the result follows.


Next we show any $\alpha$ blocks from distinct parallel classes of $\calP_{\calS_{a}^{k_{min}}}$  have $q_1^{k_1-\alpha}q_2^{k_2-\alpha}\cdots q_{d}^{k_d-\alpha}$ intersections, where $\alpha\le k_{min}$ and ${\calS^{k_{min}}_a}=\{(ak_{min})_n, (ak_{min}+1)_n,\cdots,(ak_{min}+k_{min}-1)_n\}$

Towards this end consider $B_{i_1, l_{i_1}}, \dots, B_{i_{\alpha}, l_{i_{\alpha}}}$ (where $i_j \in \calS^{k_{min}}_a, l_{i_j} \in \{0, \dots, q-1\}$) that are picked from $\alpha$ distinct parallel classes of  $\calP_{\calS^{k_{min}}_a}$. W.l.o.g. we assume that $i_1 < i_2 < \dots < i_{\alpha}$. Let $\calI =  \{i_1, \dots, i_{\alpha}\}$ and $\bfT_{\calI}$ denote the submatrix of $\bfT$ obtained by retaining the rows in $\calI$. We will show that the vector $[l_{i_1}~l_{i_2}~\dots~l_{i_{\alpha}}]^T$ is a column in $\bfT_{\calI}$ and appears $q_1^{k_1-\alpha}q_2^{k_2-\alpha}\cdots q_{d}^{k_d-\alpha}$ times.

Let $\psi_m(l_{i_j})$ for $m = 1, \dots, d$ represent the $m$-th component of the map $\psi$. Consider the $(n,k_1)$ cyclic code over $GF(q_1)$ and the system of equations in variables $\bfu_0, \dots, \bfu_{\alpha-1}$ that lie in $GF(q_1)$.
\begin{align*}
\sum_{b=0}^{\alpha-1}\bfu_{b}g_{bi_1}^{(1)}&= \psi_1(l_{i_1})-\sum_{b=\alpha}^{k_1-1}\bfu_{b}g_{bi_1}^{(1)},\\
\sum_{b=0}^{\alpha-1}\bfu_{b}g_{bi_2}^{(1)} &= \psi_1(l_{i_2})-\sum_{b=\alpha}^{k_1-1}\bfu_{b}g_{bi_2}^{(1)},\\
\mathrel{\makebox[\widthof{=}]{\vdots}}\\
\sum_{b=0}^{\alpha-1}\bfu_{b}g_{bi_{\alpha}}^{(1)} &= \psi_1(l_{i_{\alpha}})-\sum_{b=\alpha}^{k_1-1}\bfu_{b}g_{bi_{\alpha}}^{(1)}.
\end{align*}
By arguments identical to those made in Claim \ref{claim:MDSintersectionKAlpha} it can be seen that this system of equations has $q_1^{k_1-\alpha}$ solutions. Applying the same argument to the other cyclic codes we conclude that the vector $[l_{i_1},l_{i_2},\cdots, l_{i_{\alpha}}]$ appears $q_1^{k_1-\alpha}q_2^{k_2-\alpha}\cdots q_{d}^{k_d-\alpha}$ times in $\bfT_{\calI}$ and the result follows. %\litang{The symbol used in Proof is not the same as Section III.D}

%In the $(n,k_1)$ cyclic code over $\mathbb{Z}\mod q_1$, $\bfg_{i_1},\cdots,\bfg_{i_{\alpha'}}$ are linearly independent since $\alpha'\le k_{min}\le k_1$, therefore for a given $\bfv=[\bfu_{\alpha'},\cdots,\bfu_{k_1-1}]$, this system has a unique solution. Note that there are $q_1^{k_1-\alpha'}$ possible $\bfv$. A same argument can be made to other cyclic code. Then by Chinese remainder theorem, vector $[l_{i_1},l_{i_2},\cdots, l_{i_{\alpha'}}]$ appears $q_1^{k_1-\alpha'}q_2^{k_2-\alpha'}\cdots q_{d}^{k_d-\alpha'}$ times in $\bfT_{\calI}$ and the result follows.
\begin{IEEEbiographynophoto}{Li Tang} received his   B.E. degree in mechanical engineering from Beihang University, Beijing, China in 2011, and M.S. degree in electrical and information engineering from Beihang University, Beijing, China in 2014.  He is currently working towards the Ph.D degree in the Department of Electrical and Computer  Engineering at Iowa State University, Ames, IA, USA. His research interests include network coding and channel coding.
\end{IEEEbiographynophoto}

\begin{IEEEbiographynophoto}{Aditya Ramamoorthy}
(M'05) received the B.Tech. degree in electrical engineering from the Indian Institute of Technology, Delhi, in 1999, and the M.S. and Ph.D. degrees from the University of California, Los Angeles (UCLA), in 2002 and 2005, respectively. He was a systems engineer with Biomorphic VLSI Inc. until 2001. From 2005 to 2006, he was with the Data Storage Signal Processing Group of Marvell Semiconductor Inc. Since fall 2006, he has been with the Electrical and Computer Engineering Department at Iowa State University, Ames, IA 50011, USA. His research interests are in the areas of network information theory, channel coding and signal processing for bioinformatics and nanotechnology. Dr. Ramamoorthy served as an editor for the IEEE Transactions on Communications from 2011 -- 2015. He is currently serving as an associate editor for the IEEE Transactions on Information Theory. He is the recipient of the 2012 Early Career Engineering Faculty Research Award from Iowa State University, the 2012 NSF CAREER award, and the Harpole-Pentair professorship in 2009 and 2010.
\end{IEEEbiographynophoto}

 \end{document}
