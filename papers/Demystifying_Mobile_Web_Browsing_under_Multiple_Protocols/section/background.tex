\section{Background}
In this section, we demonstrate the shortcomings and inflexibility of HTTP/1.1, and describe the new features and improvement of HTTP/2 and SPDY.

\subsection{Shortcomings and inflexibility of HTTP(S)}

HTTP/1.1 is the defacto standard of HTTP, and has served the Web for more than fifteen years since the standardization. However, the Web has changed a lot to make it outdated. According to HTTP Archive~\cite{httparchive}, a Web page is becoming more and more complex. It may take more than 90 requests over 35 TCP connections to 16 different hosts to load a Web application, which may transfer about 1.9MB data on average. However, HTTP/1.1 practically only allows one outstanding request per TCP connection. Although HTTP/1.1 added the feature of reusing connections, only one request could occupy a TCP channel at a time. Other requests may initiate new TCP connections or wait until the occupied connections released. HTTP/1.1 is very latency sensitive, and has had enough of head of line blocking problem~\cite{headoflineblocking}. 

HTTPS piggybacks HTTP entirely on top of TLS/SSL, so it needs one more expensive TLS/SSL handshake for each new connection, which costs extra two Round-Trip Time (RTT).

Although Web developers have come up with many best practices like domain sharding, spriting, and inlining and concatenation of resources, these techniques have their own shortcommings~\cite{Stenberg:CCR14}. 

\subsection{HTTP/2 and SPDY}

HTTP/2 derives from SPDY, and addresses those shortcomings of HTTP(S). HTTP/2 inherits core features from SPDY~\cite{relationwithSDPY}, so we just present new features of HTTP/2 here.

HTTP/2 uses a single, multiplexed connection, replacing the multiple connections per domain that browsers opened up in HTTP/1.x. HTTP/2 compresses header data and sends it in a concise, binary format, rather than the plain text format used previously. By using a single connection, HTTP/2 reduces the need for several popular HTTP/1.x optimizations, making your Web applications simpler. 

Frame is the smallest unit of communication in HTTP/2, containing a frame header, which at minimum identifies the stream to which the frame belongs. All HTTP/2 communication is performed within a connection that can carry any number of bidirectional streams, each of which is a bidirectional flow of bytes. In turn, each stream communicates in messages, which consist of one or multiple frames, each of which may be interleaved and then reassembled via the embedded stream identifier in the header of each individual frame. There are four key features of HTTP/2:

\begin{itemize}
    \item{\textbf{One connection per origin.} One connection per origin significantly reduces the associated overhead: fewer sockets to manage along the connection path, smaller memory footprint, and better connection throughput. It also may lead to other benefits, such as better compression through use of a single compression context, less time in slow-start, faster congestion and loss recovery.}
    \item{\textbf{Request Prioritization.} HTTP message can be split into many individual frames, the exact order in which the frames are interleaved and delivered can be optimized to further improve the performance. The browser can immediately dispatch each request the moment the resource is discovered, specify the priority of each stream, and let the server determine the optimal response delivery. This eliminates unnecessary request queuing latency and allows us to make the most efficient use of each connection. }
    \item{\textbf{Header Compression.} Each HTTP transfer carries a set of headers that describe the transferred resource and its properties. In HTTP/1.x, this metadata is always sent as plain text and adds anywhere from 500 to 800 bytes of overhead per request, and kilobytes more if HTTP cookies are required. To reduce this overhead and improve performance, HTTP/2 compresses header metadata. Instead of retransmitting the same data on each request and response, HTTP/2 uses ``header table'' on both the client and server to track and store previously sent key-value pairs. Header tables persist for the entire HTTP/2 connection and are incrementally updated both by the client and server. We need to address that SPDY/2 just use a single GZIP context in each direction for header compression.}
    \item{\textbf{Server Push.} When browser loads a Web page in the era of HTTP/1.x, it first initiates a request to fetch the main HTML page. Then, it will initiate consequential requests to fetch other resources, including JavaScript files, CSS files, images when parsing HTML. However, browsers have to initiate a new request for each resource with HTTP/1.x. The key idea of server push is that we could infer further needed resources when loading a page. In additional to the response for the original request, the server can push additional resources to the client. In effect, server push obsoletes most of the cases where inlining is used with HTTP/1.x.}
\end{itemize}