
\documentclass[%
floatfix,
showkeys,
nofootinbib, %
superscriptaddress, %
]{revtex4-1}


\usepackage{cmap}
\usepackage{mathtext}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1,T2A]{fontenc}
\usepackage[english,german,russian]{babel}


\makeatletter
\@ifpackageloaded{ucs}{%
  \PrerenderUnicode{АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЬЫЪЭЮЯабвгдеёжзийклмнопрстуфхцчшщьыъэюя–}
}
\makeatother
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{mathtools}
\mathtoolsset{
showonlyrefs,
mathic = true
}

\allowdisplaybreaks

\usepackage{hyperref}
\hypersetup{backref,
 colorlinks=false}
\hypersetup{pdfborder=0 0 0}

\usepackage{breakurl}

\usepackage{microtype}
\UseMicrotypeSet[protrusion]{alltext}

\usepackage{listings}
\usepackage{listingsutf8}
\lstset{%
    showstringspaces=false,
    keepspaces=true,
    columns=flexible,
    basicstyle=\footnotesize\ttfamily,%
    breaklines=true,%
    breakatwhitespace=true,%
    postbreak=\space,%
    prebreak={\mbox{\quad$\hookleftarrow$}},%
}

\lstloadlanguages{C,make,bash,[x86masm]Assembler,[LaTeX]TeX}


\usepackage{fixltx2e}

\usepackage{nicefrac}

\makeatletter
\def\ps@pprintTitle{%
     \let\@oddhead\@empty
     \let\@evenhead\@empty
     \let\@oddfoot\@empty
     \let\@evenfoot\@oddfoot}
\makeatother

\usepackage{comment}
\usepackage{physics}
\usepackage{tensor}

\usepackage[section]{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{fancyvrb}

\usepackage{mathrsfs} 

\usepackage{amsthm} % Теоремы и т.п.
\usepackage{amsopn} % Пакет для объявления новых математических операторов \DeclareMathOperator


\newcommand{\const}{\mathrm{const}}

\input{listings-modelica.cfg}


\begin{document}
\graphicspath{{image/ru/}}

\floatname{algorithm}{Алгоритм}

\theoremstyle{definition}% Стиль для определений
\newtheorem*{thedefinition*}{Определение}
\newtheorem{thedefinition}{Определение}






\title{Генерация стохастических процессов в OpenModelica}


\author{М. Н. Геворкян}
\email{gevorkyan_mn@rudn.university}
\affiliation{Кафедра прикладной информатики и теории вероятностей,\\
  Российский университет дружбы народов,\\
  ул. Миклухо-Маклая, д. 6, Москва, Россия, 117198}


\author{А. В. Демидова}
\email{demidova_av@rudn.university}
\affiliation{Кафедра прикладной информатики и теории вероятностей,\\
  Российский университет дружбы народов,\\
  ул. Миклухо-Маклая, д. 6, Москва, Россия, 117198}




\author{А. В. Королькова}
\email{korolkova_av@rudn.university}
\affiliation{Кафедра прикладной информатики и теории вероятностей,\\
  Российский университет дружбы народов,\\
  ул. Миклухо-Маклая, д. 6, Москва, Россия, 117198}


\author{Д. С. Кулябов}
\email{kulyabov_ds@rudn.university}
\affiliation{Кафедра прикладной информатики и теории вероятностей,\\
  Российский университет дружбы народов,\\
  ул. Миклухо-Маклая, д. 6, Москва, Россия, 117198}
\affiliation{Лаборатория информационных технологий,\\
  Объединённый институт ядерных исследований,\\
  ул. Жолио-Кюри 6, Дубна, Московская область, Россия, 141980}





\author{Л. А. Севастьянов}
\email{sevastianov_la@rudn.university}
\affiliation{Кафедра прикладной информатики и теории вероятностей,\\
  Российский университет дружбы народов,\\
  ул. Миклухо-Маклая, д. 6, Москва, Россия, 117198}
\affiliation{Лаборатория теоретической физики,\\
  Объединённый институт ядерных исследований,\\
  ул. Жолио-Кюри 6, Дубна, Московская область, Россия, 141980}


\begin{abstract}

\begin{description}
\item[Предпосылки] Язык компонентно-ориентированного моделирования
  \texttt{Modelica} применяется для моделирования сложных процессов,
  задаваемых системой ОДУ. В стандартной библиотеке
  \texttt{OpenModelica} нет средств для генерации псевдослучайных
  чисел, что делает невозможным моделирование стохастических
  процессов.
\item[Цель] Целью данной статьи является краткий обзор некоторого
  числа алгоритмов генерации последовательности равномерно
  распределенных случайных чисел и оценка качества даваемых ими
  последовательностей, а также описание способов реализации некоторых
  из этих алгоритмов в системе OpenModelica.
\item[Методы] Все рассматриваемые алгоритмы реализованы на языке
  \texttt{С}, а результаты их работы протестированы с помощью свободно
  распространяемых тестов \texttt{DieHarder}. Описывается реализация
  алгоритмов на языке \texttt{Modelica} и подключение виде \texttt{C}
  функций.
\item[Результаты] Реализовано и протестировано около девяти
  алгоритмов. С помощью \texttt{DieHarder} выявлены наиболее
  качественные генераторы псевдослучайных чисел. Рассмотрены
  возможности библиотек для \texttt{OpenModelica}: \texttt{Noise} и
  \texttt{AdvancedNoise}.
\item[Выводы] В системе OpenModelica могут быть реализованы
  генераторы равномерно распределенных псевдослучайных чисел, что
  является первым шагом на пути использования OpenModelica для
  моделирования стохастических процессов.
\end{description}

\end{abstract}


  \keywords{Modelica, OpenModelica, генератор случайных величин, винеровский процесс,
    пуассоновский процесс, СДУ}


\maketitle




\section{Введение}

В данной статья рассматривается вопрос генерации равномерно
распределенных псевдослучайных чисел, а также винеровского и
пуассоновского стохастических процессов в среде
OpenModelica~\cite{L_OpenModelica}. OpenModelica является одной из
открытых реализацией языка Modelica~\cite{L_Modelica} (существуют
также другие реализации данного языка~\cite{L_SciLab, L_LMS, L_Dymola,
  L_JModelica, L_WolframSystemModeler, L_MapleSim}). Данный язык
предназначен для моделирования различных систем и процессов, которые
можно представить в виде системы алгебраических или дифференциальных
уравнений. Для численного решения уравнений используется ряд открытых
библиотек~\cite{L_lis:2016, L_LAPACK:2016, L_UMFPACK:2016,
  L_KINSOL:2015}. На данный момент, однако, в стандартной библиотеке
OpenModelica нет средств даже для генерации равномерно распределенных
случайных чисел.

\textbf{В первой части} статьи дается обзор некоторых алгоритмов
генерации псевдослучайных чисел, в том числе описывается
псевдоустройство \texttt{/dev/random} ОС Unix. Для большинства из них
приводится алгоритм в виде псевдокода. Все алгоритмы реализованы
авторами на языке \texttt{C} и частично на языке
\texttt{OpenModelica}, а также протестированы с помощью пакета тестов
\texttt{dieharder}. На основе результатов тестирования выбираются
лучшие алгоритмы для использования.

\textbf{Во второй части} статьи приводятся алгоритмы генерации
нормального и пуассоновско распределений на основе генераторов
равномерно распределенных псевдослучайных чисел. Даются краткие
сведения из теории случайных процессов, аксиоматические определения
пуассоновского и винеровского процессов, а также алгоритмы,
позволяющие генерировать эти процессы на компьютере.

\textbf{Третья часть} статьи носит практическую направленность и
посвящена описанию вызова функций на языке C непосредственно из кода
программы на языке Modelica

\section{Алгоритмы генерации равномерно распределенных псевдослучайных
  чисел}

В данном разделе мы опишем несколько наиболее распространенных
генераторов равномерно распределенных псевдослучайных чисел. Такие
генераторы служат основой для получения последовательностей
псевдослучайных чисел других распределений.

\subsection{Линейный конгруэнтный метод}

Линейный конгруэнтный метод был впервые предложен в 1949 году
Д. Г. Лехмером (D. H. Lehmer)~\cite{L_DKnuth:2004:ru}. Алгоритм~\ref{alg:lcg} задается одной формулой:
\[
x_{n+1} = (a x_{n} + c) \mod m,\;\; n \geqslant 0,
\]
где $m$ --- \emph{модуль} (mask) $m > 1$, $a$ --- \emph{множитель}
(multiplier) $(0 \leqslant a < m)$, $c$ --- \emph{приращение}
$(0 \leqslant c < m)$, $x_0$ --- начальное значение, \emph{зерно}
(seed). Результатом многократного применения данной рекуррентный
формулы является \emph{линейная конгруэнтная последовательность}
$x_{1},\ldots,x_{n}$. Особый случай $c=0$ называется
\emph{мультипликативным} конгруэнтным методом. Для краткого
обозначения данного метода будем использовать аббревиатуру
\texttt{LCG} (\textbf{l}inear \textbf{c}ongruential
\textbf{g}enerator).

\begin{algorithm}[H]
  \caption{\texttt{LCG} линейный конгруэнтный
    генератор}\label{alg:lcg}
  \begin{algorithmic}
    \Require $n$, $seed$ \State $\const\;\;m \leftarrow 2^{64}$ \State
    $\const\;\;a \leftarrow 6364136223846793005$ \State
    $\const\;\;c \leftarrow 1442695040888963407$ \State
    $x_{0} \leftarrow seed$ \For{$i=0$ to $n$} \State
    $x_{i} = (a \cdot x_{i-1} + c) \mod m$
    \EndFor
    \State \Return $\{x_{0}, x_{1}, \ldots, x_{n}\}$
  \end{algorithmic}
\end{algorithm}

Числа $m$, $a$, $c$ называют <<волшебными>> или <<магическими>> так
как их значения задаются в коде программы и выбираются исходя из опыта
применения генератора. Качество генерируемой последовательности
существенно зависит от правильного выбора данных
параметров. Последовательность $\{x\}^{n}_{1}$ периодична и ее период
зависит от числа $m$, которое поэтому должно быть большим. На практике
выбирают $m$ равным машинному слову (для 32-х битной архитектуры —
$2^{32}$ и для 64-х битной --- $2^{64}$). В~\cite{L_DKnuth:2004:ru} рекомендуется выбрать
\[
a=6364136223846793005,\; c=1442695040888963407,\; m=2^{64} =
18446744073709551616.
\]
В статье~\cite{L_Ecuyer:1999} можно найти объемные таблицы с
оптимальными значениями $a$, $b$ и $m$.

Квадратичный конгруэнтный метод
$x_{n} = ( a x_{n-1}^2 + b x_{n-1} + d ) \mod m$ кубический
конгруэнтный метод
$x_{n} = ( a x_{n-1}^3 + b x_{n-1}^2 + c x_{n-1} + d )\mod 2^e$.

В настоящее время линейный конгруэнтный метод представляет по большей
части лишь исторический интерес, так как он генерирует сравнительно
некачественную псевдослучайную последовательность по сравнению с
другими, не менее простыми генераторами.

Авторы реализовали линейный конгруэнтный метод~\ref{alg:lcg} на языке
\texttt{C} и сгенерировали с помощью него последовательность из
$10^{9}$ чисел. Данная последовательность была протестирована с
помощью открытого набора тестов
\texttt{DieHarder}~\cite{L_DieHarder:2013}. В результате генератор
\texttt{LCG} провалил около половины тестов.

\subsection{Метод Фибоначчи с запаздываниями}

Развитием \texttt{LCG} генератора можно считать идею использовать для
генерации $i$-го элемента псевдослучайной последовательности не один,
а несколько предыдущих элементов. Согласно~\cite{L_DKnuth:2004:ru} первый такой генератор был предложен в начале 50-х
годов и основывался на формуле:
\[
        x_{n+1} = (x_{n} + x_{n-1}) \mod m.
\]
Однако на практике он показал себя не лучшим образом. В 1958 году
Дж. Ж. Митчелом (G. J. Mitchell) и Д. Ф. Муром (D. Ph. Moore) был
изобретен намного лучший генератор~\ref{alg:lfg}
\[
        x_{n} = (x_{n-n_{a}} + x_{n - n_{b}}) \mod m,\; n \geqslant \max(n_a, n_b).
\]
Данный генератор получил название генератора Фибоначчи с запаздыванием
(\texttt{LFG}, \textbf{l}agged \textbf{F}ibonacci \textbf{G}enerator).

\begin{algorithm}[H]
  \caption{\texttt{LFG} генератор Фибоначчи с запаздываниями}\label{alg:lfg}
  \begin{algorithmic}
    \State $n_{a} \leftarrow 55$
    \State $n_{b} \leftarrow 24$
    \Require $s_0, s_1,\ldots,s_{n_{b}}$, $n\geqslant  0$
    
    \State $x_{0},x_{1},\ldots,x_{n_{b}}$ $\leftarrow$ $r_0, r_1,\ldots,r_{n_{b}}$
    
    \For{$i = (n_{a}+1)$ to $n$}
      \If{$x_{i-n_a} \geqslant x_{i-n_b}$}
        \State $x_{i} = x_{i-n_a} - x_{i-n_b}$
      \ElsIf{$x_{i-n_a} < x_{i-n_b}$}
        \State $x_i = x_{i-n_a} - x_{i-n_b} + 1$
      \EndIf
    \EndFor
    \State \Return $\{x_{0},x_{1},\ldots,x_{n}\}$
  \end{algorithmic}
\end{algorithm}

Как и в случае \texttt{LCG} генератора, выбор <<магических чисел>>
$n_a$ и $n_b$ сильно влияет на качество генерируемой
последовательности. Авторы предложили использовать следующие
магические числа $n_a$ и $n_b$:
\[
        n_a = 24, n_b = 55.
\]
Д. Кнут~\cite{L_DKnuth:2004:ru, L_DKnuth:1997:en} приводит ряд других
значений, начиная от $(37, 100)$ и заканчивая $(9739, 23209)$ Длина
периода данного генератора в точности равна $2^{e-1}(2^{55} - 1)$ при
выборе $m = 2^e$.

Как видно из алгоритма, для инициализации данного генератора
необходимо использовать не одно начальное значение, а
последовательность из $\max(n_a, n_b)$ случайных чисел.

В открытой библиотеке GNU Scientific Library (GSL)~\cite{L_GSL:2015}
используется \emph{составной мульти-рекурсивный} генератор,
предложенный в статье~\cite{L_Ecuyer:1996}. Данный генератор является
разновидностью \texttt{LFG} и может быть задан следующими формулами:
\[
        \begin{aligned}
                & x_{n} = (a_1 x_{n-1} + a_2 x_{n-2} + a_3 x_{n-3}) \mod m_{1},\\
                & y_{n} = (b_1 y_{n-1} + b_2 y_{n-2} + b_3 y_{n-3}) \mod m_{2},\\
                & z_{n} = (x_{n} - y_{n}) \mod m_{1}.
        \end{aligned}
\]
Составной характер данного алгоритма позволяет получить большой
период, равный $10^{56} \approx 2^{185}$. В GSL используются следующие
значения параметров $a_{i}, b_{i}, m_{1}, m_{2}$:
\[
        \begin{array}{lll}
                a_1 = 0, & b_1 = 86098, & m_1 = 2^{32} - 1 = 2147483647,\\
                a_2 = 63308, & b_2 = 0, & m_2 = 2145483479,\\
                a_3 = -183326, & b_3 = -539608. &
        \end{array}
\]

Еще одни метод, предложный в статье~\cite{L_Ecuyer:1993:1} также
является разновидностью метода Фибоначчи и определяется формулой:
\[
        x_{n} = (a_1 x_{n-1} + a_5 x_{n-5}) \mod 5,
\]
В GSL использованы следующие параметры: $a_1 = 107374182$, $a_2 = 0$,
$a_3 = 0$, $a_4 = 0$, $a_5 = 104480$, $m = 2^{31} - 1 =
2147483647$. Период этого генератора равен $10^{46}$.

Генератор \texttt{LFG}~\ref{alg:lfg} был реализован авторами на языке
\texttt{C} и подвергнут тестированию с помощью
\texttt{DieHarder}~\cite{L_DieHarder:2013}. Генератор показал высокое
качество сгенерированной последовательности ($10^9$ чисел), что дает
основание использовать его при моделировании стохастических процессов.

\subsection{Инверсный конгруэнтный генератор}

Инверсный конгруэнтный метод основан на использовании обратного по
модулю числа.
\[
        x_{i+1} = (a x^{-1}_{i} + b) \mod m
\]
где $a$ --- \emph{множитель} $(0\leqslant a < n)$, $b$ ---
\emph{приращение} $(0\leqslant b < n)$, $x_0$ --- начальное значение
(seed). Кроме того $\text{НОД}(x_0,m)=1$ и $\text{НОД}(a,m)=1$.

Данный генератор превосходит обычный линейный метод, однако сложнее
алгоритмически, так как необходимо искать обратные по модулю целые
числа, что приводит к медленной скорости генерации чисел. Для
вычисления обратного числа обычно применяется расширенный алгоритм
Евклида~\cite[\S 4.3.2]{L_DKnuth:2004:ru}.

\subsection{Генераторы c использованием побитовых операций}

Большинство генераторов, дающих наиболее качественные псевдослучайные
последовательности используют в своих алгоритмах побитовые операции
конъюнкции, дизъюнкции, отрицания, исключающей дизъюнкции
(\texttt{xor}) и побитовые вправо/влево.

\subsubsection{Вихрь Мерсенна}

Считается одним из лучших псевдослучайных генераторов. Разработан в
1997 году Мацумото и Нишимура~\cite{L_Matsumoto:1998:MTE}. Существуют
32-,64-,128-разрядные версии вихря Мерсенна. Свое название алгоритм
получил из-за использования простого числа Мерсенна $2^{19937}-1$. В
зависимости от реализации обеспечивается период вплоть до
$2^{216091}-1$.

Основным недостатком алгоритма является относительная громоздкость и,
как следствие, сравнительно медленная работа. В остальном же данный
генератор обеспечивает качественную псевдослучайную последовательность
и проходит все тесты \verb|DieHarder|. Важным перимуществом является
требование лишь одного инициирующего числа (seed). Вихрь Мерсенна
используется во многих стандартных библиотеках, например в модуле
\texttt{random} языка \texttt{Python 3}~\cite{L_Python3:3.5.1}.

Ввиду громоздкости алгоритма мы не приводим его псевдокод в данной
статье, однако стандартная имплементация алгоритма, созданная Мацумото
и Нишимура свободно доступна по ссылке
\url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html}.

\subsubsection{Генераторы \texttt{XorShift}}

Несколько простых генераторов (алгоритмы~\ref{alg:xorshift64star}
и~\ref{alg:xorshift128plus}, дающих качественную псевдослучайную
последовательность были разработаны в 2003 году Дж. Марсальей
(G. Marsaglia)~\cite{L_xorshift:2003, L_xorshift:2005}.

\begin{minipage}[t]{0.5\textwidth}
        \vspace{-10pt}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \begin{algorithm}[H]
                \begin{algorithmic}
                        \caption{Генератор \texttt{xorshift*}}\label{alg:xorshift64star}
                        \Require $n$, $seed$
                        \State $x \leftarrow seed$
                        \State $y_{0} \leftarrow x$
                        \For{$i=1$ to $n$}
                                \State $x$ $\leftarrow$ $x\; \oplus$ $x \gg 12$
                                \State $x$ $\leftarrow$ $x\; \oplus$ $x \ll 25$
                                \State $x$ $\leftarrow$ $x\; \oplus$ $x \gg 27$
                                \State $y_{i} \leftarrow  x \cdot 2685821657736338717$ 
                        \EndFor
                        \State \Return $\{y_{0}, y_{1}, \ldots, y_{n}\}$
                \end{algorithmic}
        \end{algorithm}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
        \vspace{-10pt}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \begin{algorithm}[H]
                \caption{Генератор \texttt{xorshift+}}\label{alg:xorshift128plus}
                \begin{algorithmic}
                        \Require $n$, $seed_{1}$, $seed_{2}$
                        \For{$i=1$ to $n$}
                                \State $x \leftarrow seed_{1}$
                                \State $y \leftarrow seed_{2}$
                                \State $seed_{1} \leftarrow y$
                                \State $x = x \oplus (x << 23)$
                                \State $seed_{2} = x \oplus y \oplus (x >> 17) \oplus (y >> 26)$
                                \State $z_{i} \leftarrow seed_{2} + y$
                        \EndFor
                        \State \Return $\{z_{1},\ldots,z_{n}\}$
                \end{algorithmic}
        \end{algorithm}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{minipage}

\subsubsection{Генераторы KISS (Keep It Simple Stupid)}

Еще одно семейство генераторов, дающих не менее качественную
последовательность псевдослучайных чисел~\cite{L_KISS:2011}. Генератор
\texttt{KISS} используется в процедуре \texttt{random\_number()} языка
\texttt{Frotran} (компилятор \texttt{gfortran}~\cite{L_gfortran:2015})

\begin{minipage}[t]{0.5\textwidth}
        \vspace{-10pt}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \begin{algorithm}[H]
                \begin{algorithmic}
                        \caption{Генератор \texttt{KISS}}\label{alg:kiss}
                        \Require $n$, $seed_{0},seed_{1},seed_{2},seed_{3}$
                        \State $t$
                        \For{$i=1$ to $n$}
                                \State $seed_{0} \leftarrow 69069 \cdot seed_{0} + 123456$
                                \State $seed_{1} \leftarrow seed_{1} \oplus (seed_{1} << 13)$
                                \State $seed_{1} \leftarrow seed_{1} \oplus (seed_{1} >> 17)$
                                \State $seed_{1} \leftarrow seed_{1} \oplus (seed_{1} << 5)$
                                \State $t \leftarrow 698769069 \cdot seed_{2} + seed_{3}$
                                \State $seed_{3} \leftarrow (t >> 32)$
                                \State $seed_{1} \leftarrow t$
                                \State $x_{i} \leftarrow seed_{0} + seed_{1} + seed_{2}$
                        \EndFor
                        \State \Return $\{x_{1},\ldots,x_{n}\}$
                \end{algorithmic}
        \end{algorithm}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
        \vspace{-10pt}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \begin{algorithm}[H]
                \begin{algorithmic}
                        \caption{Генератор \texttt{jKISS}}\label{alg:jkiss}
                        \Require $n$, $seed_{0},seed_{1},seed_{2},seed_{3}$
                        \State $t$
                        \For{$i=1$ to $n$}
                                \State $seed_{0} \leftarrow 314527869 \cdot seed_{0} + 1234567$
                                \State $seed_{1} \leftarrow seed_{1} \oplus (seed_{1} << 5)$
                                \State $seed_{1} \leftarrow seed_{1} \oplus (seed_{1} >> 7)$
                                \State $seed_{1} \leftarrow seed_{1} \oplus (seed_{1} << 22)$
                                \State $t \leftarrow 4294584393\cdot seed_{2} + seed_{3}$
                                \State $seed_{3} \leftarrow (t >> 32)$
                                \State $seed_{1} \leftarrow t$
                                \State $x_{i} \leftarrow seed_{0} + seed_{1} + seed_{2}$
                        \EndFor
                        \State \Return $\{x_{1},\ldots,x_{n}\}$
                \end{algorithmic}
        \end{algorithm}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{minipage}


\subsection{Устройства \texttt{/dev/random} и \texttt{/dev/urandom}}

Перевод комментариев к драйверу
random.c. \url{https://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/tree/drivers/char/random.c?id=refs/tags/v3.15.6#n52}.

Для создания истинно-случайной последовательности чисел с помощью
компьютера, в некоторых Unix системах (в частности GNU/Linux)
используется сбор <<фонового шума>> окружения операционной системы и
аппаратного обеспечения. Источником такого случайного шума являются
моменты времени между нажатия клавиш пользователем (inter-keyboard
timings), различные системные прерывания и другие события, которые
удовлетворяют двум требованиям: не детерминированности и сложной
доступности для измерения внешним наблюдателем.

Неопределённость из таких источников собирается драйвером ядра и
помещается в <<энтропийный пул>>, который дополнительно перемешивается
с помощью алгоритма, похожего на алгоритмы вычисления контрольных
сум. Когда случайные байты запрашиваются системным вызовом, они
извлекаются из энтропийного пула путем взятия SHA хеша от содержимого
пула. Взятие хеша позволяет не показывать внутреннее состояние пула,
так как восстановление содержимого по хешу считается вычислительно
невыполнимой задачей. Дополнительно извлекающая процедура занижает
размер содержимого пула для того, чтобы предотвратить выдачу хеша по
всему содержимому и минимизировать теоретическую возможость
определения его содержимого.

Во вне энтропийный пул доступен в виде символьного псевдоустройства
\texttt{/dev/random}. а также в виде системного вызова:
\begin{lstlisting}[language=C]
  void get_random_bytes(void *buf, int nbytes);
  % \end{minted}
\end{lstlisting}
Устройство \texttt{/dev/random} можно использовать для получения очень
качественной последовательности случайных чисел, однако оно возвращает
число байт, равное размеру накопленного энтропийного пула, поэтому
если требуется неограниченное количесто случайных чисел, то следует
использовать символьное псевдоустройство \texttt{/dev/urandom} у
которого нет данного ограничения, но оно уже генерирует
псевдослучайные числа, качество которых достаточно для большинства не
криптографических задач.

\subsection{Тестирование алгоритмов}
Обзор большого числа критериев оценки качества массива псевдослучайных
чисел можно найти в третей главе книги
Д. Кнута~\cite{L_DKnuth:2004:ru}, а также
статье~\cite{L_Ecuyer:2007} одного из ведущих специалистов по
генераторам псевдослучайных чисел. Все описанные в нашей статье
алгоритмы были реализованы на языке \texttt{C} и протестированы с
помощью набора тестов \texttt{dieharder}, доступного на официальном
сайте автора~\cite{L_DieHarder:2013}. Также этот пакет тестов в ходит
в состав официальных репозиториев многих дистрибутивов GNU/Linux.

\subsubsection{Описание \texttt{dieharder}}
Набор тестов \texttt{dieharder} реализован в виде утилиты командной
строки, которая позволяет тестировать последовательности равномерно
распределенных псевдослучайных чисел. Также \texttt{dieharder} может
использовать любой генератор из библиотеки GSL~\cite{L_GSL:2015} для
генерирования чисел или непосредственного тестирования.
\begin{itemize}
        \item \verb|dieharder -l| --- показать список доступных тестов,
        \item \verb|dieharder -g -1| --- показать список доступных генераторов псевдослучайных чисел, каждому генератору присвоено порядковое число, которое надо указать после флага \verb|-g| для включения нужного генератора.   
        \begin{itemize}
                \item \verb|200 stdin_input_raw| --- считывать стандартный входной бинарный поток,
                \item \verb|201 file_input_raw| --- считывать файл в бинарном формате,
                \item \verb|202 file_input| --- считывать файл в текстовом формате,
                \item \verb|500 /dev/random| --- использовать псевдо-устройство \texttt{/dev/random},
                \item \verb|501 /dev/urandom| --- использовать псевдо-устройство \texttt{/dev/urandom}.
        \end{itemize}
\end{itemize}
Каждое псевдослучайное число должно располагаться на новой строке, а в
первых строках файла необходимо указать: тип чисел (\verb|d| --- целые
числа двойной точности), количество чисел в файле и разрядность чисел
($32$ или $64$ бита). Пример такого файла:
\begin{verbatim}
                type: d
                count: 5
                numbit: 64
                1343742658553450546
                16329942027498366702
                3111285719358198731
                2966160837142136004
                17179712607770735227
\end{verbatim}
Когда такой файл создан можно передать его в \verb|dieharder|
\begin{verbatim}
dieharder -a -g 202 -f file.in > file.out
\end{verbatim}
где флаг \verb|-a| включает все встроенные тесты, а флаг \verb|-f| задает файл для анализа. Результаты тестирования будут сохранены в \verb|file.out|.

\subsubsection{Результаты тестов и выводы}

\begin{center}
    \begin{tabular}{ | l | c | c | c |}
    \hline
    \textbf{Генератор} & \textbf{Провалено} & \textbf{Слабо} & \textbf{Пройдено} \\ \hline\hline
                \texttt{LCG} (линейный конгруэнтный генератор) & 52 & 6 & 55 \\ \hline
                \texttt{LCG2} (составной линейный конгруэнтный генератор) & 51 & 8 & 54 \\ \hline
                \texttt{LFG} (линейный генератор Фибоначчи) & 0 & 2 & 111 \\ \hline
                \texttt{ICG} (инверсный конгруэнтный генератор) & 0 & 6 & 107 \\ \hline
                \texttt{KISS} & 0 & 3 & 110 \\ \hline
                \texttt{jKISS} & 0 & 4 & 109 \\ \hline
                \texttt{XorShift} & 0 & 4 & 109 \\ \hline
                \texttt{XorShift+} & 0 & 2 & 111  \\ \hline
                \texttt{XorShift*} & 0 & 2 & 111 \\ \hline
                \texttt{MT} (вихрь Мерсенна) & 0 & 2 & 111 \\ \hline
                \texttt{dev/urandom} & 0 & 2 & 111              \\ \hline
    \hline
    \end{tabular}
\end{center}

Из генераторов, использующих побитовые операции выделяются генераторы
\texttt{xorshift*}, \texttt{xorshift+} и вихрь Мерсенна. Все они дают
одинаково качественную последовательность. Алгоритм вихря Мерсенна,
однако, намного более громоздок, чем \texttt{xorshift*} или
\texttt{xorshift+}, поэтому для генерирования больших
последовательностей предпочтительней использовать \texttt{xorshift*}
или \texttt{xorshift+}.

Среди генераторов не использующих побитовые операции выделяется
линейный генератор Фибоначчи, который при тестировании дает результаты
на уровне \texttt{XorShift+} и вихря Мерсенна. Однако необходимость
задать минимум 55 начальных значений для инициализации данного
генератора сводит его полезность к минимуму. Инверсный конгруэнтный
генератор показывает немногим худшие результаты, но требует всего одно
число для инициации алгоритма.


\section{Алгоритмы генерации винеровскго и пуассоновского процессов}

Рассмотрим вопрос генерации нормального и пуассоновского
распределений. Выбор именно этих двух распределений мотивирован их
ключевой ролью в теории стохастических дифференциальных
уравнений. Наиболее общий вид таких уравнений использует два случайных
процесса: винеровский и
пуассоновский~\cite{L_Platen_Bruti}. Винеровский процесс позволяет
учесть имплицитную стохастичность моделируемой системы, а
пуассоновский процесс --- внешнее воздействие. Кратко опишем структуру
статьи.

\subsection{Генерирование равномерно распределенных псевдослучайных чисел из единичного промежутка}

Генераторы псевдослучайных равномерно распределенных чисел являются
основой для получения других псевдослучайных
последовательностей. Однако, большинство алгоритмов требуют задания
случайного числа из интервала $[0,1]$, в то время как подавляющее
большинство генераторов равномерно распределенных псевдослучайных
чисел дают последовательность из интервала $[0, m]$, где число $m$
зависит от алгоритма, разрядности операционной системы и процессора.
Чаще всего используют $m \approx 2^{32}$ для 32х битных и
$m \approx 2^{64}$ для 64 битных систем.

Для получения чисел из интервала $[0, 1]$ можно поступить двумя
способами. Во первых можно нормировать пученную последовательность
случайных числе, поделив каждый ее элемент на максимальный элемент
последовательности. Такой подход гарантированно даст $1$ в качестве
одного из случайных чисел. Однако такой способ плох, когда
последовательность псевдослучайных чисел слишком велика и не умещается
в оперативную память. В этом случае лучше использовать второй способ,
а именно поделить каждое сгенерированное число на $m$.

\subsection{Генерирование нормального распределения}

Метод генерации нормально распределенных псевдослучайных величин
предложен в 1958 году Дж. Э. Р. Боксоми
П. Мюллером~\cite{L_BoxMuller:1958} и назван в их честь
\emph{преобразованием Бокса-Мюллера}. Метод основан на простом
порообразовании, задаваемом двумя формулами. Данное преобразование
обычно записывается в двух форматах:
\begin{itemize}
  \item стандартная форма (она как раз и предложена авторами статьи~\cite{L_BoxMuller:1958}),
  \item полярная форма (предложена Дж. Беллом~\cite{L_Bell:1968} и Р. Кнопом~\cite{L_Knop:1969}).
\end{itemize}

\textbf{Стандартная форма.} Пусть $x$ и $y$ --- два независимых, равномерно распределенных псевдослучайных числа из интервала $(0, 1)$, тогда числа $z_1$ и $z_2$ вычисляются по формуле
\[
  z_{1} = \cos(2\pi y)\sqrt{-2\ln{x}},\; z_{2} = \sin(2\pi y)\sqrt{-2\ln{x}}
\]
и являются независимыми псевдослучайными числами, распределенными по
стандартному нормальному закону $\mathcal{N}(0,1)$ с математическим
ожиданием $\mu = 0$ и стандартным среднеквадратичным отклонением
$\sigma = 1$.

\textbf{Полярная форма.} Пусть $x$ и $y$ --- два независимых,
равномерно распределенных псевдослучайных числа из интервала
$[-1, 1]$. Вычислим вспомогательную величину $s = x^2 + y^2$, если
$s>1$ и $s=0$, то значения $x$ и $y$ следует отбросить и проверить
следующую пару. Если же $0 < s \geqslant 1$ тогда числа $z_1$ и $z_2$
вычисляются по формуле
\[
  z_1 = x\sqrt{\dfrac{-2\ln{s}}{s}},\; z_2 = y \sqrt{\dfrac{-2\ln{s}}{s}}
\]
и являются независимыми псевдослучайными числами, распределенными по
стандартному нормальному закону $\mathcal{N}(0,1)$.

При компьютерной реализации данного алгоритма предпочтительней
использовать полярную форму, так как в этом случае приходится
вычислять только одну трансцендентную функцию $\ln$, а не три ($\ln$,
$\sin$ $\cos$), как в стандартном варианте. Это компенсирует даже тот
факт, что часть исходных равномерно распределенных числе отбрасывается
--- полярная версия метода все равно работает быстрее. Пример работы
алгоритма изображен на рисунке~\ref{fig:normal}

Для получения нормального распределения общего вида из стандартного нормального распределения используют формулу $Z = \sigma \cdot z + \mu$, где $z \sim \mathcal{N}(0,1)$, а $Z \sim \mathcal{N}(\mu,\sigma)$.

  % y = - \dfrac{1}{\lambda}\ln(1-x),

\subsection{Генерирование распределения Пуассона}

Для генерирования распределения Пуассона существует большое число
различных алгоритмов~\cite{L_Devroye, L_Ahrens:1974,
  L_Ahrens:1982}. Наиболее простой был предложен
Кнутом~\cite{L_DKnuth:2004:ru}. Для работы
алгоритма~\ref{alg:poisson} необходимо уметь генерировать равномерные
псевдослучайные числа из промежутка $[0,1]$. Пример работы алгоритма
изображе на рисунке~\ref{fig:poisson}
\begin{algorithm}[H]
  \caption{Генератор распределения Пуассона}\label{alg:poisson}
  \begin{algorithmic}
                \Require $seed$, $\lambda$
    
                \State $\Lambda \leftarrow \exp(-\lambda)$, $k \leftarrow 0$, $p \leftarrow 1$, $u \leftarrow seed$
    \Repeat
      \State $k \leftarrow k + 1$
                        \State $u \leftarrow rand(u)$ \Comment{генерируем равномерно распределенное случайное число}
                        \State $p = p \cdot u$
    \Until{$p > \Lambda$}
    \State \Return $k - 1$
  \end{algorithmic}
\end{algorithm}

\begin{figure}
  \centering
  \begin{minipage}[b]{0.48\linewidth}
    \includegraphics[width=1.0\linewidth]{normal.pdf}
    \caption{Нормальное распределение}
    \label{fig:normal}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.48\linewidth}
    \includegraphics[width=1.0\linewidth]{poisson.pdf}
    \caption{Распределение Пуассона}
    \label{fig:poisson}
  \end{minipage}
\end{figure}

\subsection{Генерирование пуассоновского и винеровского процессов}

Вышеописанные генераторы нормального и пуассоновского распределений мы
используем для генерации винеровского и пуассоновского стохастических
процессов. Дадим вначале определения данных процессов, а затем
перейдем к описанию алгоритмов.

\subsubsection{Определение винеровского и пуассоновского случайных процессов}

Пусть $(\Omega, \mathscr{A}, P)$ --- вероятностное пространство, где
$\Omega$ --- пространство элементарных событий, $\mathscr{A}$ ---
$\sigma$--алгебра подмножеств $\Omega$ (случайные события), $P$ ---
вероятность или, иначе, вероятностная мера такая что $P(\Omega) = 1$.

\begin{thedefinition*}[см.~\cite{L_Kloeden_Platen, L_Oksendal_en}]
        Семейство случайных величин $X = \{X_{t}, 0 \leqslant t \leqslant T\}$, где $X_{t} \in \mathbb{R}^{d}$ будет называться $d$--мерным стохастическим процессом, где совокупность их конечномерных функций распределения 
        \[
                F_{X_{t_{1}},X_{t_{2}},\ldots,X_{t_{k}}}(x_{i_1},x_{i_2},\ldots,x_{i_k}) = P(X_{t_{1}}\leqslant x_{i_1}, X_{t_{2}} \leqslant x_{i_2}, \ldots, X_{t_{k}} \leqslant x_{i_k})
        \]
        для всех $i_{k} = 1,2,3,\ldots$, $k = 1,2,3,\ldots$, $x_{i} \in \mathbb{R}^{d}$ и $t_{k} \in \mathrm{T}$
\end{thedefinition*}

Пространство состояний $X$ --- $d$--мерное евклидово пространство
$\mathbb{R}^{d}$, $d=1,2,3,\ldots$. Временной интервал $[0, T]$, где
$T>0$. В численных методах рассматривают последовательность моментов
времени $\{t_0,t_1,t_2,\ldots \}$.


\begin{thedefinition*}[см.~\cite{L_Kloeden_Platen, L_Oksendal_en}]
        Случайный кусочно-постоянный процесс $N = \{N_{t}, 0 \leqslant t \leqslant T\}$ с интенсивностью $\lambda > 0$ называется \emph{процессом Пуассона} (пуассоновским) если выполняются следующие свойства.
        \begin{enumerate}
                \item $P\{N_0 = 0\} = 1$, иначе говоря $N_0 = 0$ почти наверное.
                \item $N_t$ --- процесс с независимыми приращениями, то есть $\{\Delta N_{0}, \Delta N_{1}, \ldots\}$ независимые случайные величины; $\Delta N_{t_i} = N_{t_{i+1}} - N_{t_{i}}$ и $0 \leqslant t_{0} < t_{1} < t_{2} < \ldots  < t_{n} \leqslant T$; $\Delta N_{t_i} = N_{t_{i+1}} - N_{t_{i}}$ и $0 \leqslant t_{0} < t_{1} < t_{2} < \ldots  < t_{n} \leqslant T$.
                \item Существует число $\lambda > 0$ такое, что для любого приращения $\Delta N_{i},\; i = 0, \ldots, n-1$, $ E[\Delta N_{i}]= \lambda \Delta t_{i}$.
                \item Если $P(s) = P\{N_{t+s} - N_{t} > 2\}$, то $\lim\limits_{s\to 0} \dfrac{P(s)}{s} = 0$.
        \end{enumerate}
\end{thedefinition*}


\begin{thedefinition*}[см.~\cite{L_Kloeden_Platen, L_Oksendal_en}]
        Случайный процесс $W = \{W_t, 0 \leqslant t \leqslant T\}$ называется скалярным \emph{процессом Винера} (винеровским) если выполняются следующие условия.
        \begin{enumerate}
                \item $P\{W_0 = 0\} = 1$, иначе говоря $W_0 = 0$ почти наверное.
                \item $W_t$ --- процесс с независимыми приращениями, то есть $\{\Delta W_{0}, \Delta W_{1}, \ldots\}$ независимые случайные величины; $\Delta W_{t_i} = W_{t_{i+1}} - W_{t_{i}}$ и $0 \leqslant t_{0} < t_{1} < t_{2} < \ldots  < t_{n} \leqslant T$.
                \item $\Delta W_{i} = W_{t_{i+1}} - W_{t_{i}} \sim \mathcal{N}(0,t_{i+1}-t_{i})$ где $0\leqslant t_{i+1} < t_{i} < T$, $i=0,1,\ldots,n-1$.
        \end{enumerate}
\end{thedefinition*}
Из определения следует, что $\Delta W_{i}$ --- нормально
распределённая случайная величина с математическим ожиданием
$\mathbb{E}[\Delta W_{i}] = \mu = 0$ и дисперсией
$\mathbb{D}[\Delta W_{i}] = \sigma^{2} = \Delta t_{i}$.

Винеровский процесс является моделью \emph{броуновского движения}
(хаотического блуждания). Если рассмотреть процесс $W_t$ в те моменты
времени $0 = t_{0} < t_{1} < t_{2} < \ldots < t_{N-1} < t_{N}$ когда
он испытывает случайные аддитивные изменения, то непосредственно из
определения следует:
$ W_{t_{1}} = W_{t_{0}} + \Delta W_0,\; W_{t_{2}} = W_{t_{1}} + \Delta
W_1,\; \ldots,\; W(t_{N}) = W(t_{N-1}) + \Delta W_{n-1}, $ где
$\Delta W_{i} \sim \mathcal{N}(0,\Delta t_{i})$,
$\forall i = 0,\ldots,n-1$.

Запишем $W_{t_{n}}$ в виде накопленной суммы:
$ W_{t_{n}} = W_{t_{0}} + \sum\limits_{i=0}^{n-1}\Delta W_{i} $ и
учтем, что $\mathbb{E}[\Delta W_{i}] = 0$ и
$\mathbb{D}[\Delta W_{i}] = \Delta t_{i}$ можно показать, что сумма
нормально распределенных случайных чисел $\Delta W_{i}$ также является
нормально распределенным случайным числом:
\[
        \mathbb{E}\sum\limits_{i=0}^{n-1}\Delta W_{i} = 0, \;\; \mathbb{D}\sum\limits_{i=0}^{n-1}\Delta W_{i} = \sum\limits_{i=0}^{n-1} \Delta t_{i} = T,\;\; \sum\limits_{i=0}^{n-1}\Delta W_{i} \sim \mathcal{N}(0,T).
\]

Многомерный винеровский процесс
$\mathbf{W}_{t}\colon \Omega\times[t_{0},T]\to \mathbb{R}^{m}$
определяют как случайный процесс составленный из совместно независимых
одномерных винеровских процессов $W^{1}_t,\ldots,W^{m}_t$. Приращения
$\Delta W^{\alpha}_{i},\;\forall \alpha = 1,\ldots,m$ являются
совместно независимыми нормально распределенными случайными
величинами. С другой стороны вектор $\Delta W^{\alpha}_{i}$ можно
представить как многомерную нормально распределенную случайную
величину с вектором математических ожиданий $\mu = 1$ и диагональной
матрицей ковариаций.

\subsubsection{Генерирование винеровского процесса}

Для симулирования одномерного винеровского процесса необходимо
сгенерировать $N$ нормально распределенных случайных чисел
$\varepsilon_{1}, \ldots, \varepsilon_{N}$ и построить их накопленные
суммы $\varepsilon_{1}$, $\varepsilon_{1} + \varepsilon_{2}$,
$\varepsilon_{1} + \varepsilon_{2} + \varepsilon_{3}$ ... В результате
мы получим \emph{выборочную траекторию} винеровского процесса
$W(t)$~см.~рис.~\ref{fig:wienerprocess}.

В случае многомерного случайного процесса следует сгенерировать уже
$m$ последовательностей из $N$ нормально распределенных случайных
величин.

\subsubsection{Генерирование пуассоновского процесса}

Симулирование пуассоновского процесса во многом аналогично
винеровскому, но теперь необходимо сгенерировать последовательность из
чисел распределенных по пуассоновскому закону и затем вычислить их
накопленную сумму. График процесса изображен на
рис.~\ref{fig:poissonprocess}. Из графика видно, что пуассоновский
процесс представляет собой скачкообразное изменение числа произошедших
с течением времени событий. От интенсивности $\lambda$ зависит среднее
количество событий за отрезок времени.

Из за такого характерного поведения пуассоновский процесс также
называется скачкообразным, а стохастические дифференциальные уравнения
где он участвует в качестве второго ведущего процесса получили
названия уравнений со скачками~\cite{L_Platen_Bruti}

\begin{figure}
  \centering
  \begin{minipage}[b]{0.48\linewidth}
    \includegraphics[width=1.0\linewidth]{wiener_process.pdf}
    \caption{Винеровский процесс}
    \label{fig:wienerprocess}
  \end{minipage}
  \hfill
  \begin{minipage}[b]{0.48\linewidth}
    \includegraphics[width=1.0\linewidth]{poisson_process.pdf}
    \caption{Пуассоновский процесс}
    \label{fig:poissonprocess}
  \end{minipage}
\end{figure}


\section{Моделирование стохастических процессов в OpenModelica}

Как уже отмечалось во введении, в OpenModelica отсутствуют
псевдослучайные генераторы, что делает эту систему непригодной для
моделирования стохастических процессов. Стоит, однако, отметить
библиотеку \texttt{Noise}
\url{build.openmodelica.org/Documentation/Noise.html}, разрабатываемую
Клёкнером (Klöckner)~\cite{L_Klockner:2014} и другими. В основе данной
библиотеки лежит семейство генераторов \texttt{xorshift}
(алгоритмы~\ref{alg:xorshift64star} и~\ref{alg:xorshift128plus} из
первого раздела), написанных на языке C. Однако неподготовленный
пользователь может столкнуться с проблемой при использовании
библиотеки Noise, так как для ее работы необходимо сперва
скомпилировать исходные файлы библиотек на языке C.

В данной части статьи мы опишем процедуру подключения внешних C
функций к OpenModelica, что позволит пользователю использовать как
библиотеку Noise, так и подключить свои генераторы случайных
чисел. Также мы приведем минимальный рабочий пример генерации
стохастического винеровского процесса в среде OpenModelica и решения
обыкновенного дифференциального уравнения с аддитивно добавленным
стохастическим членом.

\subsection{Подключение внешних C функций к OpenModelica}

Перейдем к рассмотрению процесса подключения внешних функций к
программе на OpenModelica. Соответствующий раздел в официальной
документации при описании данной процедуры упускает несколько
существенных деталей и следование его указаниям приводит к ошибке. Все
описанные нами действия проводились на компьютере под управлением
операционной системы Ubunyu Linux версии 16.04 LTS и OpenModelica
версии 1.11.0-dev-15.

При компиляции кода OpenModelica программа транслируется в C-код,
который затем обрабатывается уже C-компилятором. Поэтому поддержка
C-функций реализована в OpenModelica на уровне архитектуры. Кроме
языка C OpenModelica поддерживает также вызов Fortran (только F77) и
Python функций. Однако оба этих языка поддерживаются косвенным путем,
а именно с помощью обертывания их в соответствующие C-функции.

Использование внешних C-функций может понадобится по разным причинам:
повышение быстродействия ресурсоёмких компонент программы,
необходимость использования полноценного императивного языка
программирования, использование уже существующего C-кода т.д.

Приведем простейший пример вызова C функций из программы написанной на
языке Modelica. Создадим два исходных файла \verb|ExternalFunc1.c| и
\verb|ExternalFunc2.c|. В этих файлах будут содержаться простейшие
функции, которые мы хотим использовать в нашей программе на языке
Modelica.

\begin{verbatim}
// Файл ExternalFunc1.c
double ExternalFunc1_ext(double x)
{
  return x+2.0*x*x;
}
\end{verbatim}
\begin{verbatim}
// Файл ExternalFunc2.c
double ExternalFunc2(double x)
{
  return (x-1.0)*(x+2.0);;
}
\end{verbatim}
В директории, где находится исходный код программы на языке Modelica
необходимо создать каталог \verb|Resources| а в нем каталог
\verb|Library|, в котором будут находится оба наших файла
\verb|ExternalFunc1.c| и \verb|ExternalFunc2.c|. После этого следует
создать объектные файлы и поместить их в архив, который будет служить
подключаемой библиотекой. Для этого следует выполнить ряд команд.
\begin{verbatim}
gcc -c -o ExternalFunc1.o ExternalFunc1.c
gcc -c -o ExternalFunc2.o ExternalFunc2.c
ar rcs libExternalFunc1.a ExternalFunc1.o
ar rcs libExternalFunc2.a ExternalFunc2.o
\end{verbatim}

Для создания объектных файлов мы использовали утилиту компиляции gcc с
опцией -c и архиватор ar для помещения созданных объектных файлов в
архив. В результате мы получим два файла \verb|libExternalFunc1.a| и
\verb|libExternalFunc2.a|. Есть также возможность поместить все
необходимые нам объектные файлы в один архив.

Для вызова внешних функций следует использовать ключевое слово
\verb|external|. Название функции-обертки на языке Modelica может как
совпадать, так и отличаться от названия внешней функции. Во втором
случае необходимо явно указать какую внешнюю функции следует обернуть.
\begin{verbatim}
model ExternalLibraries
        // Название функции не совпадает с названием функции
        // на языке C
  function ExternalFunc1
    input Real x;
    output Real y;
                // Явно указываем название С-функции
                external y=ExternalFunc1_ext(x) annotation(Library="ExternalFunc1");
  end ExternalFunc1;

  function ExternalFunc2
    input Real x;
    output Real y;
                // Названия функций совпадают, поэтому явное указание
                // не требуется
                external "C" annotation(Library="ExternalFunc2");
  end ExternalFunc2;
  
  Real x(start=1.0, fixed=true), y(start=2.0, fixed=true);
equation
  der(x)=-ExternalFunc1(x);
  der(y)=-ExternalFunc2(y);
end ExternalLibraries;
\end{verbatim}

Заметьте, что в аннотации название подключаемой библиотеки указанно
как \verb|ExternalFunc1|, в то время как сам файл называется
\verb|libExternalFunc1.a|. Это не является опечаткой и приставку lib
необходимо добавлять ко всем библиотечным файлам.

Из примера видно, что тип \verb|Real| языка Modelica соответствует
типу \verb|double| языка C. Кроме того тип \verb|Integer| и
\verb|Boolean| соответствуют типу \verb|int|. Массивы типа \verb|Real|
и \verb|Integer| также переводятся в массивы типа \verb|double| и
\verb|int|.

Стабильно работает вызов функций с аргументами типа \verb|int| и
\verb|double|, а также массивами этих типов. Попытка же уточнить
используемый тип, например \verb|long long int| или использовать
беззнаковый тип, например \verb|unsigned int| приводит к ошибке.

\subsection{Моделирование стохастического винеровского процесса}

Опишем реализацию генератора нормального распределения и винеровского
процесса. Будем предполагать, что генератор равномерно-распределенных
случайных величин уже реализован в виде функции \verb|urand|. Для
генерирования нормального воспользуемся вышеописанным преобразованием
Бокса-Мюллера, а элементы последовательности, задающей винеровский
процесс вычислим как кумулятивную сумму нормально-распределенных
чисел.

Минимальный рабочий вариант кода приведен ниже.Ключевым моментом
является использование оператора \verb|sample(t_0, h)|, который
генерирует события через \verb|h| секунд, начиная с момента времени
\verb|t_0|. При каждом срабатывании оператора \verb|sample| вызывается
функция \verb|urand|, которая возвращает новое случайное число.

\begin{verbatim}
  model generator
    Integer x1, x2;
    Port lg; "Порт для линейного генератора"
    Port normal; "Порт для нормально распределенных чисел"
    Port wiener; "Порт для винеровского процесса"
    Integer m = 429496729; "Значение модуля (маски), применяемого в генераторе"
    Real u1, u2;
  initial equation
    x1 = 114561;
    x2 = 148166;
  algorithm
    when sample(0, 0.1) then
      x1 := urand(x1);
      x2 := urand(x2);
    end when;
    // если необходимо, то нормируем псевдослучайные числа
    lg.data[1] := x1 / m;
    lg.data[2] := x2 / m;
    u1 := lcg.data[1];
    u2 := lcg.data[2];
    // нормальный генератор
    normal.data[1] := sqrt(-2 * log(u1)) * sin(6.28 * u2);
    normal.data[2] := sqrt(-2 * log(u1)) * cos(6.28 * u2);
    // Винеровский процесс
    wiener.data[1] := wiener.data[1] + normal.data[1];
    wiener.data[2] := wiener.data[2] + normal.data[2];
  end generator;
\end{verbatim}

Отметим также применение специальной переменной типа Port, которая
служит для соединения различных моделей между собой. В нашем примере
мы создали три таких переменных: \verb|lg|, \verb|normal|,
\verb|wiener|. Благодаря этому, другие модели могут получить доступ к
результату работы нашего генератора.

\begin{lstlisting}[language=modelica]
  connector Port
    Real data[2];
  end Port;
  % \end{minted}
\end{lstlisting}

Ниже представлен минимальный код примера иллюстрирующего соединение
моделей между собой. В качестве примера выбрана система из двух
обыкновенных дифференциальных уравнений, описывающая осциллятор
Ван-дер-Поля–Дуффинга и к ней добавлен стохастический вклад в виде
процесса Винера (см.~\ref{fig:vanderpolduff}).
\[
  \left\{
  \begin{aligned}
    & \dot{x} = y,\\
    & \dot{y} = x(1.0 - x^{2}) - y + x\cdot W_{t}.
  \end{aligned}
  \right.
\]
Отметим особо, что это уравнение не является
стохастическим. Встроенные в OpenModelica численные методы не
позволяют решать стохастические дифференциальные уравнения.

\begin{verbatim}
// модель задает систему ОДУ
  model ODE
    Real x, y;
    Port IN;
  initial equation
    x = 2.0;
    y = 0.0;
  equation
    der(x) = y ;
    der(y) = x*(1-x*x) - y + x*IN.data[1];
  end ODE;
// Эту модель надо запускать на симуляцию
// в ней числа из случайного генератора поступают
// в систему ОДУ
  model sim
    generator gen;
    ODE eq;
  equation
    connect(gen.wiener, eq.IN);
  end sim;
\end{verbatim}

\begin{figure}
  \centering
  \includegraphics[width=0.8\linewidth]{oscill.png}
  \caption{Результаты моделирования осциллятора Ван-дер-Поля–Дуффинга с добавленным стохастическим вкладом. Графики созданы с помощью функционала OMEditor'a}
  \label{fig:vanderpolduff}
\end{figure}




\section{Заключение}

Был дан обзор основным алгоритмам генерации равномерно распределенных
псевдослучайных чисел. Все алгоритмы были реализованы авторами на
языке С и протестированы с помощью утилиты DieHarder. Результаты
тестов выявили, что наиболее эффективными алгоритмами являются
алгоритмы \texttt{xorshift} и вихрь Мерсенна.

В связи с тем, что в OpenModelica не реализованы побитовые логические
операции и операции сдвига, генераторы равномерно распределенных
псевдослучайных чисел следует реализовать на языке C и подключить в
виде внешних функций. Мы дали достаточно подробное описание процесса
подключения внешних C-функций, восполняющее пробелы официальной
документации.
        
Был приведён минимальный рабочий пример моделирования винеровского
стохастического процесса, который был использован для моделирования
осциллятор Ван-дер-Поля–Дуффинга с аддитивным стохастическим членом.
Важно отметить, что такое уравнение не является стохастическим. Для
построения моделей на основе стохастических уравнений среду
OpenModelica необходимо дополнить стохастическими численными методами,
для чего по видимому необходимо внести изменения в исходный код
OpenModelica.

\def\acknowledgmentsname{Благодарности}

\begin{acknowledgments}



Работа частично поддержана грантами РФФИ \textnumero~15-07-08795, 16-07-00556.
Также публикация выполнена при финансовой поддержке Минобрнауки России
(Соглашение \textnumero~02.A03.21.0008). 
Расчёты проведены на вычислительном кластере «Felix» РУДН и на
Гетерогенном вычислительном кластере «HybriLIT» Многофункционального
центра хранения, обработки и анализа данных ОИЯИ.

\end{acknowledgments}


  \ifthenelse{\boolean{xetex}}
  {\bibliographystyle{ugost2008l}}
  {\bibliographystyle{gost2008l}}

\bibliography{bib/cite}







\end{document}
