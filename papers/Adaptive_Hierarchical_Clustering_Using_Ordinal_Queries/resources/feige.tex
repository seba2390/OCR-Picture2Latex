%% Proof of Lemma~\ref{lem:feige}

\section{Proof of Lemma~\ref{lem:feige}}
\label{sec:feige}

In this section, we provide the proof of Lemma~\ref{lem:feige}.
We restate the lemma here for convenience.

\begin{rtheorem}{Lemma}{\ref{lem:feige}}
Assume that each query response is correct
independently with probability $p > \Half$,
and adversarially incorrect with probability $1 - p$.
There exists an adaptive algorithm with the following property:
Given a tree \Tree of diameter \Diameter, and error parameter $\Err > 0$,
the algorithm finds the target with probability at least $1 - \Err$,
using at most $O(\Diameter + \log(1/\Err))$ vertex queries.
\end{rtheorem}

Our algorithm is a very minor modification of an algorithm 
of Feige et al.~\cite{feige-raghavan-peleg-upfal:1994:noisy}.
The algorithm performs a walk on the tree \Tree:
in each iteration, a vertex \Vertex is queried,
and if the response points to a neighbor \VertexP,
the algorithm next ``moves to'' \VertexP.
However, with every response confirming \Vertex as the target,
the algorithm moves ``deeper'' into \Vertex
(by incrementing a counter):
subsequently, responses pointing to neighbors of \Vertex will only
move the walk one step ``shallower'' in \Vertex,
and the walk will only leave \Vertex once the counter has been reduced
down to 0.

%Let \Query[i] be the \Ordinal{i} vertex that our algorithm queries.
%Our algorithm starts with querying an arbitrary node,
%i.e., \Query[1] is arbitrary.

More formally, each vertex \Vertex in \Tree has a counter
\Counter{\Vertex}.
All the counters are initially $0$,
and at any point of the algorithm, at most one counter will have a
non-zero (positive) value.

In the \Ordinal{i} iteration, the algorithm queries a vertex \Query[i].
The response to the query is either the node \Query[i] itself
or one of its neighbors in \Tree.
If the query response is \Query[i], i.e.,
the noisy response proposes \Query[i] as the target,
then the algorithm increments \Counter{\Query[i]}
and will next query the same node $\Query[i+1] = \Query[i]$.
If the query response is a node other than \Query[i],
the algorithm's action depends on \Counter{q_i}.
If $\Counter{\Query[i]} > 0$,
the algorithm decrements \Counter{\Query[i]}
and will next query the same node $\Query[i+1] = \Query[i]$.
Finally, if $\Counter{q_i} = 0$, then $\Query[i + 1]$ is simply the
vertex given in response to the query.
The algorithm is given formally as Algorithm~\ref{alg:feige}.

\InsertAlgorithmInOneColumn{\TreeWalk $(\Tree, \Err)$}%
{alg:feige}{
\STATE{$\Counter{\Vertex} \AlgAssign 0$ for every vertex \Vertex in \Tree.} 
\STATE{Let \Query be an arbitrary vertex in \Tree.}
\FOR{$i = 1, \ldots
\max(\frac{2 (D+1)}{2p - 1}, \frac{8 \ln(1/\Err)}{(2p - 1)^2})$}
\STATE{Query the node \Query, and let \Response be the noisy response.}
\IF{$\Response = \Query$}
\STATE{$\Counter{\Query} = \Counter{\Query} + 1$.}
\ELSIF{$\Counter{\Query} > 0$}
\STATE{$\Counter{\Query} = \Counter{\Query} - 1$.}
\ELSE
\STATE{$\Query \AlgAssign \Response$.}
\ENDIF
\ENDFOR
\RETURN{\Query}
}

We use \Counter[i]{\Vertex} to denote 
the value of the counter \Counter{\Vertex} after the \Ordinal{i} iteration.
Let \Dis{\Vertex}{\VertexP} denote the distance between \Vertex and \VertexP
in \Tree, and define the \emph{potential value} of \Vertex in iteration $i$
as
\begin{align*}
\Potential[\Vertex]{i}
& = \Dis{\Vertex}{\Query[i]} - \Counter[i]{\Vertex}
+ \sum_{\VertexP \neq \Vertex} \Counter[i]{\VertexP}.
\end{align*}

The following lemma states that the
potential of the (unknown) target node must decrease
with each correct response to a query
(and may increase with incorrect responses).

\begin{lemma} \label{lem:potential}
Let \Target be the (unknown) target.
For every $i$, if the response to the \Ordinal{i} query is correct,
then $\Potential[\Target]{i + 1} = \Potential[\Target]{i} - 1$;
if the response is incorrect, then
$\Potential[\Target]{i + 1} \leq \Potential[\Target]{i} + 1$.
\end{lemma}

\begin{emptyproof}
We distinguish two cases, based on the node queried in the \Ordinal{i} iteration.
\begin{itemize}
\item If $\Query[i] = \Target$, then a correct response increments 
\Target's counter, and thus decreases \Target's potential by 1.
An incorrect response either decrements \Target's counter
or --- if the counter was 0 --- moves the query node to one of
\Target's neighbors.
In either case, \Target's potential is only increased by 1.
\item If $\Query[i] \neq \Target$, then a correct response points
towards \Target. 
If $\Counter[i]{\Query[i]} > 0$, then \Counter{\Query[i]} is decremented;
if $\Counter[i]{\Query[i]} = 0$,
then the new query $\Query[i+1] = \Response[i]$ is made to a node one
step closer to \Target.
Therefore, \Target's potential is decreased by 1.

An incorrect response could increment the counter of \Query[i]
(if it points to \Query[i]),
decrement the counter of \Query[i]
(if it points to an incorrect neighbor of \Query[i] and
$\Counter[i]{\Query[i]} > 0$),
or move the next query $\Query[i+1] = \Response[i]$ to an incorrect
neighbor of \Query[i] that is one step further away from \Target.
In all three cases, the potential of \Target increases or decreases by 1;
in particular, it at most increases by 1.\QED
\end{itemize}
\end{emptyproof}

\begin{extraproof}{Lemma~\ref{lem:feige}}
Algorithm~\ref{alg:feige} runs for \NumQuery iterations.
In expectation, a $p$ fraction of the query responses are correct.
Let $\epsilon = \frac{2p - 1}{4} < p$.
Using Hoeffding's inequality \cite{hoeffding:1963:probability},
with probability at least $1 - e^{- 2 \NumQuery \epsilon^2}$,
at least $(p - \epsilon) \NumQuery$ query responses are correct.
In that case, by Lemma~\ref{lem:potential},
\begin{align}
\Potential[\Target]{\NumQuery}
& \leq \Potential[\Target]{0} - (p - \epsilon) \NumQuery +
(1- p + \epsilon) \NumQuery \nonumber
\\ & = \Dis{\Target}{\Query[0]} - (2p - 1 - 2\epsilon) \NumQuery
\leq D - \frac{2p-1}{2} \NumQuery. \label{equ:potential}
\end{align}

Because $\NumQuery \geq \frac{\ln(1/\Err)}{2 \epsilon^2}$,
the success probability is at least
$1 - e^{- 2 \epsilon^2 \NumQuery} \geq 1 - \Err$.
And because $\NumQuery \geq \frac{2 (D+1)}{2p - 1}$,
Inequality~\ref{equ:potential} implies that
$\Potential[\Target]{\NumQuery} \leq D - (D+1) < 0$.
Therefore, by definition of the potential value,
$\Counter[\NumQuery]{\Target} > 0$.
The only node that could have a positive counter
in any iteration $i$ is \Query[i];
therefore, the returned node must be \Target in the high-probability case.
\end{extraproof}

