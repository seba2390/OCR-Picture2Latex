\subsection{Algorithm}\label{additive:algorithm}
In this section, we present a polynomial time algorithm to find a $(3/4-\epsilon)$-$\MMS$ allocation in the additive setting. More precisely, we show that our method for proving the existence of a $3/4$-$\MMS$ allocation can be used to find such an allocation in polynomial time. 
Recall that our algorithm consists of two main phases: The clustering phase and the $\bagfilling$ phase. In Sections \ref{algcluster} and \ref{sphase} we separately explain how to implement each phase of the algorithm in polynomial time. Given this, there are still a few computational issues that need to be resolved. First, in the existential proof, we assume $\MMS_i = 1$ for every agent $\agent_i \in \agents$.  Second, we assume that the problem is $3/4$-irreducible. Both of these assumptions are without loss of generality for the existential proof due to Observation \ref{reducibility} and the fact that one can scale the valuation functions to ensure $\MMS_i =1$ for every agent $\agent_i$. However, the computational aspect of the problem will be affected by these assumptions.  
The first issue can be alleviated by incurring an additional $1+\epsilon$ factor to the approximation guarantee. \epsteinefficient ~\cite{epstein2014efficient} show that for a given additive function $f$, $\MMS_f^n$ can be approximated within a factor $1+\epsilon$ for constant $\epsilon$ in time $\poly(n)$. Thus, we can scale the valuation functions to ensure $\MMS_i = 1$ while losing a factor of at most $1+\epsilon$. Therefore, finding a $(3/4-\epsilon)$-$\MMS$ allocation can be done in polynomial time if the problem is $3/4$-irreducible. Finally, in Section \ref{irre} we show how to reduce the $3/4$-reducible instances and extend the algorithm to all instances of the problem. The algorithm along with the reduction yields Theorem \ref{addpoly}

\begin{theorem}
	\label{addpoly}
	For any $\epsilon > 0$, there exists an algorithm that finds a $(3/4 - \epsilon)$-$\MMS$ allocation in polynomial time. 
\end{theorem}

\begin{comment}
\subsubsection{Computing the value of $\MMS_i$ in polynomial time}\label{mmsi}
As described in the beginning of Section \ref{additive}, finding the exact value of $\MMS_i$ for an agent is $NP-hard$ and there is no polynomial time algorithm for this problem, unless $P=NP$. In \cite{epstein2014efficient}, this problem is studied in the context of job scheduling. In addition to the hardness proof, they proposed a PTAS for finding a $(1+\epsilon)$ approximation of $\MMS_i$ which yields to a ploynomial time algorithm for finding $\MMS_i$, for constant $\epsilon$.  

Thus, in the beginning of the algorithm, we can compute $\MMS_i$ for every agent $\agent_i$. Considering the fact the the problem of finding $\MMS_i$ is a maximization problem, we know that the value obtained for $\MMS_i$ by method in \cite{epstein2014efficient}, is at least $\MMS_i (1 - \epsilon)$. Considering this value as $\MMS_i$ has no effect on the correctness of the algorithm except that the final result would be a $(3/4-\epsilon)$-$\MMS$ allocation. Thus, assuming that the rest of the algorithm can be implemented in polynomial time, we have a polynomial time $(3/4-\epsilon)$-$\MMS$ allocation algorithm for contant $\epsilon$. 
\end{comment}
\subsubsection{The Clustering Phase}\label{algcluster}
Recall that in the clustering phase we cluster the agents into three sets $\cone$,$\ctwo$, and $\cthree$. In order to build Cluster $\cone$, we find an $\MCMWM$ of the $1/2$-filtering of the value graph. This can be trivially done in polynomial time since finding an $\MCMWM$ is polynomially tractable~\cite{west2001introduction}. However, the refinement phase of Cluster $\cone$ requires finding $F_G(\itemsv,M)$ for a giving graph $G$ and a matching $M$. In what follows, we show this problem can also be solved in polynomial time.

\begin{comment}
First, note that an $\MCMWM$ of $G$ can be found in polynomial time using standard methods for finding minimum cost maxmimum flow in networks. For this, create a networks as follows: Orient every edge $(\itemv_j,\agentv_i)$ from $\agentv_i$ to $\itemv_j$, with cost $-w(\itemv_j,\agentv_i)$ and capacity $1$. Also, add a source node $s$ and connect it to all the vertices in $\parttwo$ with cost $0$ and capacity $1$ and add a sink node $t$ and connect every vertex in $\partone$ to $t$, with cost $0$ and capacity $1$. It is easy to observe that the edges between $\partone$ and $\parttwo$ with non-zero flow in a Min Cost Maximum Flow from $s$ to $t$ in this network form a maximum cardinality matching $M$. In addition to this, since the maximum flow was minimum cost, 
$$\sum_{(\itemv_j,\agentv_i) \in M} -w(\itemv_j,\agentv_i)$$
is minimized, which means 
$$\sum_{(\itemv_j,\agentv_i) \in M} w(\itemv_j,\agentv_i)$$
is maximized in $M$. So, $M$ is a $\MCMWM$ of $H$. 
\end{comment}

Notice that finding an $\MCMWM$ of $G$ can be done in polynomial time~\cite{west2001introduction}. Therefore, in order to determine $F_H(M,\partone)$, it only suffices to find the vertices of $\partone$ that are reachable from the unmatched vertices of $\parttwo$ by an alternating path. Let $\hat{X}$ be the set of these vertices. We can find $\hat{X}$ using a depth-first-search from the unmatched vertices of $\parttwo$. By definition, $F_H(M,\partone) = \parttwo \setminus \hat{X}$. Therefore, $F_H(M,\partone)$ can be found in polynomial time.

In addition to $F_G(\itemsv,M)$, we also need to find a matching of the graph which satisfies the conditions of Lemma \ref{nicematch}. We show in the following that this problem also can be solved in polynomial time. First, note that in Lemma \ref{v1size} we prove that $G_1$ has a matching that saturates all the vertices of $W_1$. Now, let $p_{\agent_k}$ be the position of $\agent_k$ in the topological ordering of $\cone$, as described in the proof of Lemma \ref{nicematch}. Furthermore, Let $M_1$ be a matching that minimizes the following expression.
$$ \sum_{(x_j,y_i) \in M_1} p_i.$$ Recall that in the proof Lemma \ref{nicematch}, we show that $M_1$ satisfies the condition described in Lemma \ref{nicematch}. Here, we show that $M_1$ can be found in polynomial time. To this end, we model this with a network design problem. 

Orient every edge $(x_j,y_i) \in G_1$ from $y_i$ to $x_j$ and set the cost of this edge to $p_{a_i}$. Also, add a source node $s$ and add a directed edge from $s$  to every vertex of $V_{\cone}$ with cost $0$. Furthermore, add a sink node $t$ and add directed edges from the vertices of $W_1$ to $t$ with cost $0$. Finally, set the capacity of all edges to $1$. 

One can observe that in a minimum cost maximum flow from $s$ to $t$ in this network, the edges with non-zero flow between $V_{\cone}$ and $W_1$ form a maximum matching $M_1$. In addition to this, since the cost of the flow is minimal, $\sum_{(x_j,y_i) \in M_1} cost(x_j,y_i)$ is minimized. Therefore, in this matching, 
$\sum_{(x_j,y_i) \in M_1} p_i$
is minimized. Thus, the matching with desired properties of Lemma \ref{nicematch} can be found in polynomial time.

The same algorithms can be used to compute Cluster $\ctwo$. Finally, we put the rest of the agents in Cluster $\cthree$.


\subsubsection{The $\bagfilling$ Phase}\label{sphase}
In each round of the second phase, we iteratively find a minimal feasible subset of $\fitems$ and allocate its items to the agent with the lowest priority in $\Phi(S)$.  Note that for a feasible set $S$, one can trivially find the agent with lowest priority in $\Phi(S)$ in polynomial time. Thus, it only remains to show that we can find a minimal feasible subset of $\fitems$ in polynomial time. 

Consider the following algorithm, namely \emph{reverse $\bagfilling$ algorithm}: Start with a bag containing all the items of $\fitems$ and so long as there exists an item $\ite_j$ in the bag such that after removing $\ite_j$, the set of items in the bag is still feasible, remove $\ite_j$ from the bag. After this process, the remaining items in the bag  form  a minimally feasible subset of $\fitems$. Therefore, this phase can be run in polynomial time.

\subsubsection{Reducibility}\label{irre}
The most challenging part of our algorithm is dealing with the $3/4$-irreducibility assumption. The catch is that, in order to run the algorithm, we don't necessarily need the $3/4$-irreducibility assumption. Recall that we leverage the following three consequences of irreducibility to prove the existential theorem.
\begin{itemize}
	\item The value of every item in $\items$ is less that $3/4$ to every agent.
	\item Every pair of items in $\itemsv'' \setminus \itemsv''_{1/2}$ is in total worth less than $3/4$ to any agent.
	\item The condition of Lemma \ref{v1size} holds.
\end{itemize}
 Therefore, the algorithm works so long as the mentioned conditions hold. Note that, although it is not clear whether determining if an instance of the problem is $3/4$-reducible is polynomially tractable, all of the above conditions can be validated in polynomial time. This is trivial for the first two conditions; we iterate over all items or pairs of items and check if the condition holds for these items. The last condition, however, is harder to validate.
 %Therefore, it only suffices to show that we can operate in a way that our problem preserves these three conditions.

%For the first condition, consider the following process: While there exists an agent $\agent_i$ and an item $\ite_j$ with $\valu_i(\{\ite_j\})\geq 3/4$, assign $\ite_j$ to $\agent_i$ and solve the problem recursively for the rest of the agents and items. Trivially, this process can be implemented in polynomial time. Furthermore, after this process, all the items are worth less than $3/4$ to any agent and the first condition holds. 

The condition of Lemma \ref{v1size} holds if for all $S \subseteq W_1$, $|N(S)| > |S|$. Recall that in the proof of Lemma \ref{v1size} we showed that if this condition does not hold, then $F_{G_1}(M,\itemsv)$ is non-empty. Next, we showed that if $F_{G_1}(M,\itemsv)$ is non-empty, then we can reduce the problem via satisfying every agents of $F_{G_1}(M,\itemsv)$ by his matched item in $M$. Therefore, on the computational side, we only need to find whether $F_{G_1}(M,\itemsv)$ is empty which indeed can be determined in polynomial time. 
%In this case, we operate as follows: %
%If the condition in Lemma \ref{v1size} does not hold, we reduce the problem by satisfying the agents in $F_{G_1}(M,\itemsv))$. After this, regarding Lemma \ref{iff}, the condition in Lemma \ref{v1size} holds. As described in section \ref{cphase}, $F_{G_1}(M,\itemsv))$ can be found in polynomial time.

%For the third condition, we can operate in the same way as the first condition: While there exists an agent $\agent_i$ and a pair of items $\ite_j,\ite_k$ such that   $\valu_i(\{\ite_j,\ite_k\})\geq 3/4$, reduce the problem by assigning $\ite_j,\ite_k$ to $\agent_i$ and removing them from $\items$ and $\agents$, respectively. 

Note that every time we reduce the problem, $|\agents|$ is decreased by at least $1$, which implies the number of times we reduce the problem is no more than $n$. Moreover, our reduction takes a polynomial time. Thus, the running time of the algorithm is polynomial. %Thus, in polynomial time, you can either satisfty all the agents, or obtain the problem instance that preserves all three conditions.