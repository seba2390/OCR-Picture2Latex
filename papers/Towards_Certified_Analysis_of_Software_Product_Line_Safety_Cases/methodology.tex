\newcommand{\lift}[1] {#1$'$}
\newcommand{\liftt}[1] {#1'}
\newcommand{\find}{\texttt{Find}}
\newcommand{\ff}{\texttt{False}}
\newcommand{\instance}{P}
\newcommand{\result}{R}
\newcommand{\analysis}{f}

\newcommand{\Rn}{R'}
\newcommand{\TR}{\lift{TraceRel}}
\newcommand{\Cza}{C0a}
\newcommand{\Czd}{C0d}
\newcommand{\Czm}{C0m}
\newcommand{\Codm}{C1dm}
\newcommand{\Coam}{C1am}

\newcommand{\tPC}{\code{PC}}
\newcommand{\Var}{\code{Var}}
\newcommand{\lset}{\code{set$'$}}

\vspace{-0.15in}
\section{Methodology and Infrastructure}
\label{sec:methodology}
\vspace{-0.1in}
In this section, we present a set of generic infrastructure building blocks that can be used in designing and certifying the correctness of variability-aware algorithms applied to safety cases.
We then present the correctness criteria of variability-aware algorithms with respect to their single-product counterparts. 
Finally, we put the infrastructure together with the correctness criteria into a correct-by-construction methodology for systematic lifting of safety case algorithms.  
%We then present the 
%, and lifted change impact assessment in particular (Listing~\ref{lst:gsnia}), followed by the lifted algorithm itself. Finally we outline the formal correctness proof (full proof available online).

We formalize algorithms, theorems, and proofs using the Lean~\cite{deMoura:2015} interactive theorem prover. 
%Correctness of the lifted algorithm in Sec.~\ref{sec:lifting} is then defined and proven with respect to this formalization. 
We had two requirements for the proof assistant to be used in this project: (1) to be based on constructive rather than classical logic, to allow for explicit tracing of which sub-goals (and their proof evidence) contribute to the overall proof; and (2) to allow for sound user-defined proof automation procedures, which can reduce the human effort involved in the proof development process. Lean meets those two requirements. It is based on the Calculus of Inductive Constructions~\cite{Bertot:2010}, so it supports constructive logic by default. It also supports tactic-based meta-programming of theorems and proof objects. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%% Variability-aware data structures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstinputlisting[style=lean,basicstyle=\small,firstline=9,lastline=16,caption=Variability-aware building blocks.,label=lst:var]{variability.lean}

\vspace{0.1in}
\noindent
{\bf Lifted Data Structures.}
%\subsection{Lifted Data Structures}
\label{sec:lifted_data}
The types of all input, output, and intermediate data structures of an algorithm need to be lifted, i.e., elements of each of those data structures need to be paired with presence conditions, indicating the set of products this element belongs to. Listing~\ref{lst:var} has definitions of some of the data types used for lifted data structures. \tPC~(line 1) is the type for presence conditions, which is defined as native Lean propositions. \Var~(line 2) is a higher-order lifted type, taking a type $\alpha$ as a parameter, and pairing values of type $\alpha$ with presence conditions. 

The lifted set data type \lset~(line 3) is a higher-order type parameterized by type $\alpha$, and implemented as a function $\alpha \to \tPC$. This implementation happens to be the same as the implementation of Lean sets. However, the semantics of Lean sets assume that a value of type $\alpha$ is either present or absent in a set over $\alpha$. Lifted sets on the other hand map an element of type $\alpha$ to an arbitrary propositional formula which might evaluate to \TT~(i.e., the element exists in the set in all configurations), \FF~(i.e., the element does not exist in any configuration of the set), or a contingent formula indicating the set of configurations in which the element exists in the set.

The primary operation on lifted data types in general is indexing. Given a lifted set \code{s}~and a presence condition \code{pc}, \code{index s pc}~evaluates to a Lean set (not lifted) of elements existing in the configurations satisfied by \code{pc}~in \code{s}. This is exactly how the \code{index} operator is defined on \lset, conjoining \code{pc} with the presence condition of each element in \code{s} (line 4).

Standard set operations also need to be overloaded for lifted sets. Lifted set membership semantically checks if a lifted value \code{(v,pc)} exists in all configurations of a lifted set \code{s}. It is defined (line 5) as a propositional implication between \code{pc} (the set of configurations where the lifted value exists), and the set of configurations where \code{v} exists in \code{s}.

Lifted subset is defined exactly the same as standard subset, using the lifted definition of set membership (line 6). Similarly, lifted set union is implemented as a disjunction of the propositional definitions of its two arguments (line 7). The last lifted set operation is \code{image} (line 8), taking a function $f : \alpha \to \beta$ and a lifted set $s$ of $\alpha$, and applies $f$ to each element $s$, returning a lifted set of $\beta$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Correctness criteria
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
	\begin{subfigure}[c]{0.45\textwidth}
		\centering
		\begin{tikzcd}
		\SPL \arrow{r}{\liftt{\analysis}} \arrow{d}{\indexProd{}{\config}} & \liftt{\result} \arrow{d}{\indexProd{}{\config}} \\
		\instance \arrow{r}{\analysis} & \result
		\end{tikzcd}
		\caption{Correctness of a lifted function~\cite{Shahin:2020}.}
		\label{fig:correctness1}
	\end{subfigure}
	\hfill
	\begin{subfigure}[c]{0.55\textwidth}
		\centering
		\begin{tikzcd}
		\SPL \arrow{d}{\indexProd{}{\config}} \arrow{r}{\liftt{\analysis}} & \liftt{\result} \arrow{r}{\liftt{g}} & \liftt{S} \arrow{d}{\indexProd{}{\config}} \\
		\instance \arrow{r}{\analysis} & \result \arrow{r}{g} & S
		\end{tikzcd}
		\caption{Correctness of lifted function composition.}
		\label{fig:correctness2}
	\end{subfigure}
	\vspace{-0.1in}
	\caption{Lifting correctness criteria.}
	\label{fig:correctness}
	\vspace{-0.2in}
\end{figure}

\lstinputlisting[style=lean,basicstyle=\small,firstline=42,lastline=46,caption=Lifted function composition theorem.,label=lst:funComp]{variability.lean}

\vspace{0.1in}
\noindent
{\bf Correctness Criteria.}
%The correctness criteria of a lifted GSN Impact Assessment algorithm (\lift{GSN\_IA}) are outlined in Fig.~\ref{fig:correctness1}. 
Given a product line $\SPL$, an analysis algorithm $\analysis$, and a product configuration $\config$, we construct a lifted version of $\analysis$ (referred to as \lift{$\analysis$}), such that instantiating a product $\instance$ from $\SPL$ using configuration $\config$, and then applying $\analysis$ to $\instance$ has the same result as applying \lift{$\analysis$} to $\SPL$ and then instantiating a product-specific result using $\config$. This is summarized by the commuting diagram in Fig.~\ref{fig:correctness1}~\cite{Shahin:2020}.

\vspace{0.1in}
\noindent
{\bf Lifting Methodology.}
We follow a divide-and-conquer methodology to design lifted analyses from their single-product counterparts. If an analysis algorithm is broken-down into smaller functions, and each of those functions is individually lifted, composing the lifted functions together has to preserve the correctness criteria. This is summarized in Fig.~\ref{fig:correctness2}. 

We formulate the correctness criteria of lifted function composition as a theorem (Listing~\ref{lst:funComp}). Assume we have two functions \code{(f:set $\alpha$ $\to$ set $\beta$)} and \code{(g:set $\beta$ $\to$ set $\gamma$)}, and two lifted functions \code{(\lift{f}:\lift{set} $\alpha$ $\to$ \lift{set} $\beta$)} and \code{(\lift{g}:\lift{set} $\beta$ $\to$ \lift{set} $\gamma$)} (Line 2). The theorem states that if \code{\lift{f}} is a correct lifting of \code{f}, and \code{\lift{g}} is a correct lifting of \code{g}, then \code{\lift{g} $\circ$ \lift{f}} is a correct lifting of \code{g $\circ$ f} (Lines 3-5). The theorem is proven by term rewriting. Definitions of all theorems, lemmas, and their full Lean proofs are available online\footnote
{\url{https://github.com/ramyshahin/variability}}.

Correctness of the lifted function composition theorem is the foundation of compositional lifting correctness proofs. Small helper functions can be manually lifted and proven correct relatively easily, and their correctness proofs can be composed together with composing the functions themselves using the theorem. This way, lifted analyses can be compositionally implemented following the same structure of their single-product counterparts, composing correctness proofs together with function composition. We demonstrate this methodology on lifting a Change Impact Assessment (CIA) algorithm in Sec.~\ref{sec:cia}.

%Taking the lifted helper functions and their corresponding lifting correctness proofs, we compose the functions and the proofs back following the structure of the original single-product algorithm. Composition of lifted functions preserves correctness~\cite{Shahin:2020} (Fig.~\ref{fig:correctness2}), and a correctness proof of lifted function composition is included as a part of our Lean infrastructure library. This methodology is demonstrated on the CIA algorithm in Sec.~\ref{sec:lifting}.
 
%The single-product GSN\_IA algorithm (Listing~\ref{lst:gsnia}) is a sequence of helper function calls with no side effects. If we replace each of those helper functions with a lifted version that satisfies the criteria of Fig.~\ref{fig:correctness1} and prove correctness of lifted function composition (Fig.~\ref{fig:correctness2}), we get a correct-by-construction \lift{GSN\_IA}. 
%The proof is straight-forward, because 
%Assuming that \lift{$\analysis$} is correct w.r.t. to $\analysis$, then $\forall \config: \indexProd{\liftt{\result}}{\config} = \result$. Assuming \lift{$g$} is also correct w.r.t. $g$, then $\forall \config: \indexProd{\liftt{g}(\liftt{\result})}{\config} = g(\indexProd{\liftt{\result}}{\config})$.

%\lstinputlisting[style=lean,firstline=14,lastline=18,caption=Lifted sets used in \lift{GSN\_IA}.,label=lst:liftedSets]{liftedCIA.lean} 

%\[ \liftt{\sys} = \{(e,pc) | e \in \sys, pc \in PC\} \\
%\liftt{\ac} = \{(e,pc)  | e \in \ac,  pc \in PC\} \\
%\liftt{\tr} = \{((x, y), pc) | x \in \sys, y \in \ac, pc \in PC \} \]

%Set membership in each of those three lifted set types has slightly different semantics now. The \find~operator checks if element $e$ belongs to lifted set $A$. \find~returns a presence condition denoting the set of configurations in which $e$ belongs to $A$. If $e$ does not exist in $A$ at all, \find~returns \ff, which is the presence condition denoting the set of empty configurations.

%\todo{discuss well-formedness constraints on presence conditions, and explain that they are not required to hold in order to establish algorithm correctness.}