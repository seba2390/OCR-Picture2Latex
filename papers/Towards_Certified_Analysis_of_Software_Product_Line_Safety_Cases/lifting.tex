\vspace{-0.1in}
\subsection{Lifted Algorithm}
\label{sec:lifting}
\vspace{-0.1in}

%To construct \lift{GSN\_IA}, we start with an overview of the lifted data structures used for algorithm inputs, outputs and intermediate values, then outline \lift{GSN\_IA}, and finally give two examples of lifted helper algorithms.

%\subsection{Lifted Algorithm}
%\label{sec:lifted_algo}

%\IncMargin{1em}
%\LinesNumbered
%\begin{algorithm}[t]
%	\SetKwData{S}{S}
%	\SetKwData{Sm}{S'}
%	\SetKwData{Sys}{\hlight{\lift{Sys}}}
%	\SetKwData{A}{A}
%	\SetKwData{GSN}{\hlight{\lift{GSN}}}
%	\SetKwData{R}{R}
%	\SetKwData{TR}{\hlight{\lift{TraceRel}}}
%	\SetKwData{Rm}{R'}
%	\SetKwData{D}{D}
%	\SetKwData{K}{K}
%	\SetKwData{Caz}{C0a}
%	\SetKwData{Cdz}{C0d}
%	\SetKwData{Cmz}{C0m}
%	\SetKwData{Cdmo}{C1dm}
%	\SetKwData{Camo}{C1am}
%	\SetKwData{Ct}{C2}
%	\SetKwData{Cr}{C3}
%	\SetKwData{Ctrecheck}{C2recheck}
%	\SetKwData{Ctrevise}{C2revise}
%	\SetKwData{Crrechecko}{C3recheck1}
%	\SetKwData{Crrecheckt}{C3recheck2}
%	
%	\SetKwFunction{Restrict}{\hlight{\lift{Restrict}}}
%	\SetKwFunction{Union}{Union}
%	\SetKwFunction{Trace}{\hlight{\lift{Trace}}}
%	\SetKwFunction{Slicesys}{\hlight{\lift{Slice\_Sys}}}
%	\SetKwFunction{Slicegsnv}{\hlight{\lift{Slice\_GSN\_V}}}
%	\SetKwFunction{Slicegsnr}{\hlight{\lift{Slice\_GSN\_R}}}
%	\SetKwFunction{CreateAnnotation}{\hlight{\lift{CreateAnnotation}}}
%	
%	\SetKwInOut{Input}{Inputs}\SetKwInOut{Output}{Output}
%	
%	\SetAlgoLined
%	\Input{\typerel{\S}{\Sys}    \tcp*[f]{Initial SPL megamodel} \newline
%		   \typerel{\Sm}{\Sys}   \tcp*[f]{Modified SPL megamodel} \newline
%	   	   \typerel{\A}{\GSN}   \tcp*[f]{GSN model}                \newline
%		   \typerel{\R}{\TR}  \tcp*[f]{Traceability map}         \newline
%		   \D =$\langle \Caz, \Cdz, \Cmz \rangle$                  \tcp*[f]{Delta}}
%	\Output{\K \tcp*[f]{GSN model Annotation}}
%	\BlankLine
%	
%	\assign{\Rm}{\Restrict{\R,\D}} \;
%	\assign{\Cdmo}{\Slicesys{\S, \Union{\Cdz, \Cmz}}} \;
%	\assign{\Camo}{\Slicesys{\Sm,\Union{\Caz, \Cmz}}} \;
%	\assign{\Ctrecheck}{\Union{\Trace{\R,\Cdmo}, \Trace{\Rm, \Camo}}} \;
%	\assign{\Ctrevise}{\Trace{\R,\Cdz}} \;
%	\assign{\Crrechecko}{\Slicegsnv{\A,\Ctrevise}} \;
%	\assign{\Crrecheckt}{\Slicegsnr{\A,\Union{\Ctrecheck, \Crrechecko}}} \;
%	\assign{\K}{\CreateAnnotation{\A, \Crrecheckt, \Ctrevise}} \;
%	\Return \K;
%	\BlankLine
%	
%	\caption{\lift{GSN\_IA}}
%	\label{alg:CIA_lifted}
%\end{algorithm}
%\DecMargin{1em}
%
%\begin{algorithm}[t]
%%\vspace{-0.3in}
%	\SetKwInOut{Input}{Inputs}\SetKwInOut{Output}{Output}
%	
%	\SetKwData{R}{R}
%	\SetKwData{Rn}{R'}
%	\SetKwData{TR}{\lift{TraceRel}}
%	\SetKwData{D}{D}
%	\SetKwData{Caz}{C0a}
%	\SetKwData{Cdz}{C0d}
%	\SetKwData{Cmz}{C0m}
%	\SetKwData{E}{e}
%	\SetKwData{PC}{pc}
%	\SetKwData{PCn}{pc'}
%	\SetKwData{EPC}{(e,pce)}
%	\SetKwData{EPCn}{(e,pc')}
%	\SetKwData{XYPC}{((x,y),pc)}
%	\SetKwData{XY}{(x,y)}
%	\SetKwData{X}{x}
%	
%	\SetKwFunction{Add}{add}
%	\SetKwFunction{Remove}{remove}
%	
%	\SetKwFunction{Find}{Find}
%	\SetKwFunction{Fn}{Function}
%	\SetKwProg{Fn}{Function}{ is}{end}
%	
%	\SetAlgoLined
%	\Input{\typerel{\R}{\TR}  \tcp*[f]{Traceability map}         \newline
%		\D =$\langle \Caz, \Cdz, \Cmz \rangle$                  \tcp*[f]{Delta}}
%	\Output{\Rn \tcp*[f]{restricted traceability relation}}
%	\BlankLine
%	%
%	%\Fn{\Add(\typerel{\R}{\TR}, \EPC)}{
%	%	\assign{\tPCn}{\Find{\R,\E}} \;
%	%	\If(\tcp*[f]{was e found in R?}){(\tPCn)}{
%	%		\lIf{\tPC == \tPCn}
%	%		{\Return \R}
%	%		\lElse{\Return \R $-$ \{\EPCn\} $\union$ \{(\E, \tPC $\vee$ \tPCn)\}} 
%	%	} 
%	%	\Else{
%	%		\Return \R $\union$ \{\EPCn\} \;
%	%	}
%	%}
%	%
%	\BlankLine
%	
%	\Fn{\Remove(\typerel{\R}{\TR}, \XYPC)}{
%		\assign{\tPCn}{\Find{\R,\XY}} \;
%		\If(\tcp*[f]{was (x,y) found in R?}){(\tPCn)}{
%			\lIf{\tPC == \tPCn}
%			{\Return \R $-$ \{\XYPC\}}
%			\lElse{\Return \R $-$ \{\XYPC\} $\union$ \{(\XY, $\neg$\tPC $\wedge$ \tPCn)\}} 
%		} 
%		\Else{
%			\Return \R \;
%		}
%	}
%	
%	\BlankLine
%	
%	\assign{\Rn}{\R} \;
%	%\For{$\EPC \in \Caz$}{
%	%	\assign{\Rn}{\Add{\Rn,\EPC}}
%	%}
%	\For{$\EPC \in \Cdz$}{
%		\For{$\XYPC \in \Rn$} {
%			\If{\E == \X} {
%				\assign{\Rn}{\Remove{\Rn, \XYPC}}
%			}
%		}
%	}
%	\Return \Rn \;
%	\caption{\lift{Restrict}}
%	\label{alg:restrict_lifted}
%	%\vspace{-0.15in}
%\end{algorithm}
%\vspace{-3in}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Lifted algorithm
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstinputlisting[style=lean,basicstyle=\small,firstline=102,lastline=116,caption=Lifted Change Impact Assessment algorithm.,label=lst:liftedCIA]{liftedCIA.lean}

Listing~\ref{lst:liftedCIA} is the variability-aware version of the algorithm in Listing~\ref{lst:gsnia}. Both algorithms are compositions of function/operator calls, so each of those functions/operators is replaced with its lifted counterpart. We assume that lifted versions of the three slicers are provided, and that they meet the correctness criteria of Fig.~\ref{fig:correctness1}. 
%The structure of the lifted algorithm follows that of the original one.

All the set types used in GSN\_IA need to be lifted. Definitions in lines 1-4 are lifted sets of system model elements, GSN model elements, and traceability mappings. A lifted delta (line 4) is composed of three lifted sets (additions, deletions and modifications).

The proof of the correctness theorem used auxiliary correctness lemmas for each of the helper algorithms. Each of the proofs expands definitions and repeatedly applies the correctness of lifted function composition (Fig.~\ref{fig:correctness2}). 
%{\url{https://www.github.com/ramyshahin/variability/}}.
%%%%%%%%%%%%%%%%%%%%%%%%
% Lifted helpers
%%%%%%%%%%%%%%%%%%%%%%%%

\vspace{0.1in}
\noindent
{\bf Lifted Helper Algorithms.}
%\subsection{Lifted Helper Algorithms}
\label{sec:lifted_helpers}
Since the lifted CIA algorithm operates on lifted data structures, all helper algorithms need to be modified to correctly operate on lifted data structures as well. In particular, we outline lifted versions of \restrict~and \trace~(Listing~\ref{lst:liftedHelpers}).

The original implementation of \restrict~takes a traceability map and a delta as inputs, and returns the minimal subset of the traceability map that covers all the elements in the delta. We now have presence conditions associated to system model elements, assurance case elements, and also the traceability links in between. The lifted version of \restrict~(referred to as \lift{\restrict}) needs to correctly process all those presence conditions.

The lifted algorithm starts by calculating the set of relevant elements in the system model, which is the union of added, deleted and modified elements in the delta (line 2). The algorithm returns a lifted traceability mapping as a function taking \code{((s,g),pc)}, where \code{(s,g)} is a system model element-GSN model element pair, and \code{pc} is a presence condition. This function evaluates to the conjunction of applying the input traceability map \code{t} to \code{((s,g),pc)}, and applying \code{relevant} to \code{(s,g)}. Recall that variability-aware sets (as well as Lean sets) are functions mapping values of a given type to propositions.

%Removing a traceability link from $\Rn$ needs to take presence conditions into consideration. When removing $((x,y),\tPC{})$ from $\Rn$, there are three possible cases:
%(1) if $(x,y)$ exists in $\Rn$ with the same presence condition $\tPC{}$, we just remove it (line 4).
%(2) if $(x,y)$ exists in $\Rn$ with a different presence condition $\tPC{}'$, then we only need to remove $(x,y)$ for the intersection of the set of products denoted by $\tPC{}$ and $\tPC{}'$ (line 5).
%(3) if $(x,y)$ does not exist in $\Rn$ at all, we do not remove anything (line 8).

Similarly, \lift{\trace} is the lifted version of \trace. The returned lifted set is a function mapping a GSN model element \code{g}~to the set of configurations from which there exists a system model element \code{s}~in the input lifted set of system elements, where \code{(s,g)} belongs to the input traceability map.

The lifted version of \createAnnotation~(named \lift{\createAnnotation}) is of exactly the same structure as the original because it strictly uses set operations (union, set difference and image), which have been all lifted as a part of the underlying variability-aware set implementation (Listing~\ref{lst:var}).
%The algorithm starts with an empty set of GSN elements (line 1), then iterates through all the elements of the traceability relation (lines 2-7). For each traceability link $(x,y)$ with presence condition $\tPC{}$, if $x$ exists in the system model parameter $\S$ with presence condition $\tPC{}'$ that isn't \ff, and if the conjunction of $\tPC{}$ and $\tPC{}'$ is satisfiable, we add $(y, \tPC{} \land \tPC{}')$ to $A$. Here the conjunction of the two presence conditions denotes the intersection of the sets of products denoted by the traceability link presence condition, and the GSN element presence condition.

\lstinputlisting[style=lean,basicstyle=\small,firstline=46,lastline=51,caption=Lifted implementation of \code{restrict} and \code{trace}.,label=lst:liftedHelpers]{liftedCIA.lean}
%\vspace{0.3in}

%\vspace{-0.4in}
%\begin{algorithm}[t]
%	\SetKwInOut{Input}{Inputs}\SetKwInOut{Output}{Output}
%	\SetKwData{S}{S}
%	\SetKwData{Sys}{\lift{Sys}}
%	\SetKwData{R}{R}
%	\SetKwData{TR}{\lift{TraceRel}}
%	\SetKwData{A}{A}
%	\SetKwData{GSN}{\lift{GSN}}
%	\SetKwData{X}{x}
%	\SetKwData{XPC}{xpc}
%	\SetKwData{Y}{y}
%	\SetKwData{YPC}{ypc}
%	\SetKwData{XP}{(\X,\XPC)}
%	\SetKwData{YP}{(\Y,\YPC)}
%	\SetKwData{PC}{pc}
%	\SetKwData{PCn}{pc'}
%	\SetKwData{E}{e}
%	
%	\SetKwFunction{Find}{Find}
%	
%	\SetAlgoLined
%	\Input{\typerel{\R}{\TR}  \tcp*[f]{Traceability map}         \newline
%		\typerel{\S}{\Sys}   \tcp*[f]{set of model elements with presence conditions}}
%	\Output{\typerel{\A}{\GSN}   \tcp*[f]{set of GSN elements with presence conditions}}
%	
%	\assign{\A}{\{\}}
%	
%	\For{$(\X,\Y,\tPC) \in \R$}{
%		\assign{\tPCn}{\Find{\S,\X}} \;
%		\If{(\tPCn)}{
%			\lIf{$\tPC \wedge \tPCn$}
%			{\assign{\A}{\A \cup \{(\Y, \tPC \wedge \tPCn)\}}}
%		}
%	}
%	
%	\Return{\A}
%	\caption{\lift{Trace}}
%	\label{alg:trace_lifted}
%	%\vspace{-0.15in}
%\end{algorithm}

\lstinputlisting[style=lean,basicstyle=\small,firstline=147,lastline=149,caption=Correctness theorem of \lift{GSN\_IA}.,label=lst:correctness]{liftedCIA.lean}

The correctness theorem of \lift{GSN\_IA} with respect to GSN\_IA is in Listing~\ref{lst:correctness}. It is a direct instantiation of the general correctness criteria in Fig.~\ref{fig:correctness1}, applied to inputs of the GSN\_IA algorithm.
