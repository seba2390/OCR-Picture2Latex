\newcommand{\pf}{\pfun}
\newcommand{\sys}{Sys}		% system
\newcommand{\sinit}{S}
\newcommand{\snext}{S'}
\newcommand{\ac}{GSN}		% assurance case
\newcommand{\tr}{TraceRel}	% traceability relation
\newcommand{\Ea}{C_a}		% added elements
\newcommand{\Em}{C_m}		% modified elements
\newcommand{\Ed}{C_d}		% deleted elements
\newcommand{\annot}{K}		% annotation relation
\newcommand{\revi}{revise}
\newcommand{\rec}{recheck}
\newcommand{\reu}{reuse}

%\newcommand{\restrict}{\texttt{Restrict}}
%\newcommand{\trace}{\texttt{Trace}}

\section{Background}
\label{sec:background}
\vspace{-0.1in}

%\todo{...}
%\vspace{0.1in}
%\noindent
%{\bf GSN-IA:  GSN Impact Assessment Algorithm.}
%\vspace{-0.1in}


%For example, the goal ``The power sliding door opens when the function
%\mbox{\name{DriverSwitch.}\name{RequestDoorOpen()}} is invoked and the vehicle speed is not greater than 15km/h.'' (see
%the class diagram in Fig.~\ref{f:psdcdsd}) must be revised if the
%function name is changed to \name{CommandDoorOpen()} since the goal now refers to an element that does not exist.
%However, if some aspect of
%the system that affects door opening functionality changes, then the
%goal must be rechecked because it may no longer hold. We assume
%that after a revision, a recheck must take place; thus, at most one of
%these impacts can apply to an element. If an element is not
%impacted by a system change we say that it can be reused and mark it
%as \name{reuse}.


%\begin{figure}[t]
%	\vspace{-0.2in}
%	\centering
%	\begin{minipage}{.5\textwidth}
%		\centering
%		\includegraphics[width=1.0\textwidth]{images/GSNmeta.pdf}
%		\vspace{-0.1in}
%		\caption{Fragment of GSN Metamodel extended with validity states \todo{fix image}.}
%		\vspace{-0.15in}
%		\label{f:gsnmeta}
%	\end{minipage}
%	\hspace{0.2in}
%	\begin{minipage}{.4\textwidth}
%		\centering
%		\begin{subfigure}[b]{0.9\textwidth}  
%			\centering
%			\includegraphics[width=0.8\textwidth]{images/PSDmega.pdf}
%			\caption{PSD System Megamodel}
%			\label{f:psdmega}
%		\end{subfigure}
%		\begin{subfigure}[b]{0.9\textwidth}
%			\vspace{0.1in}
%			\centering
%			\includegraphics[width=0.5\textwidth]{images/annotation.pdf}
%			\caption{Annotation Metamodel}
%			\label{f:annotation} 
%		\end{subfigure}
%		\caption{PSD System Megamodel and Annotation Metamodel.}
%	\end{minipage}
%	\vspace{-0.25in}
%\end{figure}

%\begin{figure}[t]
%  \vspace{-0.2in}
%\begin{minipage}{0.4\textwidth}
%\scriptsize
%\begin{tabbing}
%b \= bll \= bl \= bl \= bl \= bl \= bl \= bl \= bl \= (Distinctttt) \= \kill
%\\
%\textbf{Algorithm: GSN-IA}\\
%\textbf{Params}: $\tuple{\mathtt{Slice}_{Sys}}$ \\
%\textbf{Input}: initial system model $S:Sys$, safety case $A:GSN$, \\
%\> \> \> traceability map $R$, changed system megamodel $S':Sys$,\\ 
%\> \> \>  delta $D= \tuple{C0a, C0d, C0m}$   \\
%\textbf{Output}: Annotation $K$\\
%\> 1: \> $R'_A \leftarrow \mathtt{Restrict}(R,D)$ \\ 
%\> 2: \> $C1dm \leftarrow \mathtt{Slice}_{Sys}(S, \mathtt{Union}(C0d,C0m))$  \\
%\> 3: \> $C1am \leftarrow \mathtt{Slice}_{Sys}(S', \mathtt{Union}(C0a,C0m))$  \\
%\> 4: \> $C2_{\mbox{recheck}} \leftarrow \mathtt{Union}(\mathtt{Trace}(R, C1dm), \mathtt{Trace}(R'_A, C1am))$ \\
%\> 5: \> $C2_{\mbox{revise}} \leftarrow \mathtt{Trace}(R, C0d)$ \\
%\> 6: \> $C3_{\mbox{recheck1}} \leftarrow  \mathtt{Slice}_{GSN_V}(A,C2_{\mbox{revise}})$ \\
%\> 7: \> $C3_{\mbox{recheck2}} \leftarrow  \mathtt{Slice}_{GSN_R}(A,\mathtt{Union}(C2_{\mbox{recheck}},C3_{\mbox{recheck1}}))$ \\
%\> 8: \> $K\leftarrow \mathtt{CreateAnnotation}(A, C3_{\mbox{recheck2}},C2_{\mbox{revise}})$\\
%\> 9: \> {\bf return} $K$
%\end{tabbing}
%\vspace{-0.2in}
%\end{minipage}%
%\begin{minipage}{0.4\textwidth}
%\centering{
%\includegraphics[width=0.9\textwidth]{images/mmdev_cropped.pdf}}
%\end{minipage}
%\caption{Algorithm for assessing impact of system changes on a GSN safety case.}
%\label{f:algorithm}
%\vspace{-0.18in}
%\end{figure}

%\begin{figure}[htb]
%	\vspace{-0.2in}
%	\begin{center}
%		%\begin{minipage}{1.0\textwidth}
%		%\scriptsize
%		\begin{tabbing}
%			b \= bll \= bl \= bl \= bl \= bl \= bl \= bl \= bl \= (Distinctttt) \= \kill
%			\\
%			\textbf{Algorithm: GSN-IA}\\
%			\textbf{Params}: $\tuple{\mathtt{Slice}_{Sys}}$ \\
%			\textbf{Input}: initial system model $S:Sys$, safety case $A:GSN$, \\
%			\> \> \> traceability map $R$, changed system megamodel $S':Sys$,\\ 
%			\> \> \>  delta $D= \tuple{C0a, C0d, C0m}$   \\
%			\textbf{Output}: Annotation $K$\\
%			\> 1: \> $R'_A \leftarrow \mathtt{Restrict}(R,D)$ \\ 
%			\> 2: \> $C1dm \leftarrow \mathtt{Slice}_{Sys}(S, \mathtt{Union}(C0d,C0m))$  \\
%			\> 3: \> $C1am \leftarrow \mathtt{Slice}_{Sys}(S', \mathtt{Union}(C0a,C0m))$  \\
%			\> 4: \> $C2_{\mbox{recheck}} \leftarrow \mathtt{Union}(\mathtt{Trace}(R, C1dm), \mathtt{Trace}(R'_A, C1am))$ \\
%			\> 5: \> $C2_{\mbox{revise}} \leftarrow \mathtt{Trace}(R, C0d)$ \\
%			\> 6: \> $C3_{\mbox{recheck1}} \leftarrow  \mathtt{Slice}_{GSN_V}(A,C2_{\mbox{revise}})$ \\
%			\> 7: \> $C3_{\mbox{recheck2}} \leftarrow  \mathtt{Slice}_{GSN_R}(A,\mathtt{Union}(C2_{\mbox{recheck}},C3_{\mbox{recheck1}}))$ \\
%			\> 8: \> $K\leftarrow \mathtt{CreateAnnotation}(A, C3_{\mbox{recheck2}},C2_{\mbox{revise}})$\\
%			\> 9: \> {\bf return} $K$
%		\end{tabbing}
%	\end{center}
%	\vspace{-0.25in}
%	%\end{minipage}
%	\caption{Algorithm for assessing impact of system changes on a GSN safety case.}
%	\label{f:algorithm}
%	%\vspace{-0.18in}
%\end{figure}

\subsection{Safety Cases, GSN, and Change Impact Assessment}
\vspace{-0.1in}
A safety case is a structured argument, decomposing safety goals into sub-goals, and linking pieces of safety evidence to the goals. Safety goals are usually identified using hazard assessment techniques. Each of the hazards needs to be mitigated by fulfilling one or more safety goal(s).

Goal Structured Notation (GSN)~\cite{Kelly:2004} is a graphical notation for defining safety cases. The safety case portion of Fig.~\ref{fig:ex} is an example of a GSN safety case model. A GSN model has elements of four different types. %\term{Goal}, \term{Solution}, \term{Strategy}, and \term{Context}. 
A \term{goal} is either satisfied or not based on the states of its sub-goals, connected solution nodes, and the semantics of decomposition strategy nodes involved. A \term{solution} is a piece of evidence that needs to be validated for its connected goal(s) to be satisfied. A \term{strategy} is a decomposition of a goal into sub-goals. A \term{context} connected to a goal node adds contextual assumptions that are assumed to hold when evaluating whether a goal is satisfied or not.

%\subsection{Change Impact Assessment with GSN-IA}

%\vspace{-0.2in}
%\IncMargin{1em}
%\LinesNumbered
%\begin{algorithm}[t]
%	\SetKwData{S}{S}
%	\SetKwData{Sm}{S'}
%	\SetKwData{Sys}{Sys}
%	\SetKwData{A}{A}
%	\SetKwData{GSN}{GSN}
%	\SetKwData{TR}{TraceRel}
%	\SetKwData{R}{R}
%	\SetKwData{Rm}{R'}
%	\SetKwData{D}{D}
%	\SetKwData{K}{K}
%	\SetKwData{Caz}{C0a}
%	\SetKwData{Cdz}{C0d}
%	\SetKwData{Cmz}{C0m}
%	\SetKwData{Cdmo}{C1dm}
%	\SetKwData{Camo}{C1am}
%	\SetKwData{Ct}{C2}
%	\SetKwData{Cr}{C3}
%	\SetKwData{Ctrecheck}{C2recheck}
%	\SetKwData{Ctrevise}{C2revise}
%	\SetKwData{Crrechecko}{C3recheck1}
%	\SetKwData{Crrecheckt}{C3recheck2}
%	
%	\SetKwFunction{Restrict}{Restrict}
%	\SetKwFunction{Union}{Union}
%	\SetKwFunction{Trace}{Trace}
%	\SetKwFunction{Slicesys}{Slice\_Sys}
%	\SetKwFunction{Slicegsnv}{Slice\_GSN\_V}
%	\SetKwFunction{Slicegsnr}{Slice\_GSN\_R}
%       \SetKwFunction{CreateAnnotation}{CreateAnnotation}
%
%\SetKwInOut{Input}{Inputs}\SetKwInOut{Output}{Output}
%
%\SetAlgoLined
%\Input{\typerel{\S}{\Sys} \tcp*[f]{Initial system megamodel} \newline
%	\typerel{\Sm}{\Sys}   \tcp*[f]{Modified system megamodel} \newline
%	\typerel{\A}{\GSN}    \tcp*[f]{GSN model}                \newline
%	\typerel{\R}{\TR}  \tcp*[f]{Traceability map}         \newline
%	\D =$\langle \Caz, \Cdz, \Cmz \rangle$                  \tcp*[f]{Delta}}
%\Output{\K \tcp*[f]{GSN model Annotation}}
%\BlankLine
%
%\assign{\Rm}{\Restrict{\R,\D}} \;
%\assign{\Cdmo}{\Slicesys{\S, \Union{\Cdz, \Cmz}}} \;
%\assign{\Camo}{\Slicesys{\Sm,\Union{\Caz, \Cmz}}} \;
%\assign{\Ctrecheck}{\Union{\Trace{\R,\Cdmo}, \Trace{\Rm, \Camo}}} \;
%\assign{\Ctrevise}{\Trace{\R,\Cdz}} \;
%\assign{\Crrechecko}{\Slicegsnv{\A,\Ctrevise}} \;
%\assign{\Crrecheckt}{\Slicegsnr{\A,\Union{\Ctrecheck, \Crrechecko}}} \;
%\assign{\K}{\CreateAnnotation{\A, \Crrecheckt, \Ctrevise}} \;
%\Return \K;
%\BlankLine
%
%\caption{GSN-IA~\cite{Kokaly:2017}.}
%\label{alg:CIA}
%\end{algorithm}
%\DecMargin{1em}

GSN-IA~\cite{Kokaly:2017} is an algorithm for reflecting changes made in system models onto the relevant GSN safety cases. %~\cite{Kokaly:2017}.  In this section, we describe this algorithm, following the notation introduced in \cite{Kokaly:2017}.
%Algorithm~\ref{alg:CIA} shows the GSN-IA algorithm in pseudocode, with a visual illustration on Fig.~\ref{f:algorithm_v} (transitions are annotated by algorithm line numbers). 
The inputs to GSN-IA are the initial system model $S$
and a safety case $A$ connected by a traceability mapping $R$, the
changed system $S'$ and the delta $D$ recording the changes between
$S$ and $S'$. Specifically, $D$ is the triple $\tuple{C0a, C0d, C0m}$ where $C0a$, $C0d$, and $C0m$ are the 
set of elements added, deleted, and modified respectively.
% in $S'$, $C0d$ is the set of elements deleted from $S$, and $C0m$ is the set of modified elements that appear in both $S$ and $S'$. 
The output of GSN-IA is the annotated model $K$ of the safety case $A$, indicating which elements are marked for \name{revise},
\name{recheck}, or \name{reuse}.

%These are shown in the top part of the diagram.  
GSN-IA is parameterized by three slicers~\cite{Salay:2016}: a system model slicer $\mathtt{Slice}_{Sys}$, and two safety case slicers $\mathtt{Slice}_{GSN_V}$ and $\mathtt{Slice}_{GSN_R}$. $\mathtt{Slice}_{Sys}$ is used to
determine how the impact of modifications propagates within the system model. Similarly, the safety case slicers trace through dependencies within the safety case, with $\mathtt{Slice}_{GSN_V}$ only tracing direct dependencies, while $\mathtt{Slice}_{GSN_R}$ recursively generates the transitive closure of dependencies.

% -- that is, we consider this slicer to be given as an input to GSN-IA.
%Note that our approach readily applies not only to singleton models but also to more
%realistic cases where the system is described by a heterogeneous
%collection of related models as a megamodel.  A sound
%slicing approach for this case has been defined~\cite{Salay:2016}.  

%\begin{figure}[t]
%	%\vspace{-1.3in}
%	\begin{center}
%		\includegraphics[width=0.5\textwidth]{images/mmdev_cropped.pdf}
%		\vspace{-0.1in}
%		\caption{Visualization of GSN-IA algorithm~\cite{Kokaly:2017}.}
%		\label{f:algorithm_v}
%	\end{center}
%	\vspace{-0.2in}
%\end{figure}

%GSN-IA uses several \emph{model transformations} described
%below.  In line 1, the \name{Restrict} transformation extracts the
%subset $R'_A$ of traceability links from $R$ that are also valid for
%$S'$. Lines 2 and 3 use the model slicer $\mathtt{Slice}_{Sys}$ to
%expand the combined (using \name{Union}) set of changed elements in
%$S$ and $S'$, respectively, to all elements \emph{potentially
%	impacted} by the change.  Then, in line 4, these potentially
%impacted elements are traced to $A$ across the traceability
%relationships using the \name{Trace} transformation and combined to
%identify the subset of elements in $A$ that must be rechecked.  The
%subset of safety case elements for revision is identified in line 5 by
%tracing the deleted and modified elements of $S$ to $A$. Note that the
%elements of $A$ marked \name{revise} 
%is a subset of those marked \name{recheck}.
%Only those that are directly traceable
%to changed elements of $S$ may require revision; others
%only need to be rechecked.   In lines 6 and 7, the appropriate GSN slicer $\mathtt{Slice}_{GSN_V}$ ($\mathtt{Slice}_{GSN_R}$) is invoked to propagate each of
%the revise (recheck) subsets to dependent elements in $A$ which are added to the recheck subset. Finally, line 8 invokes
%\name{CreateAnnotation} to construct the annotation model $K$
%from the identified subsets of $A$. The elements of the subset
%$C2_{\mbox{revise}}$ are marked \name{revise}; the remaining elements
%in the subset $C3_{\mbox{recheck2}}$ are marked \name{recheck}, and all
%other elements are marked \name{reuse}.

%\begin{table}[t]
%%	\vspace{-0.1in}
%	\begin{center}
%		\begin{tabular}{ | c | p{2cm}| p{9cm}|}
%			\hline
%			{\bf Rule} & {\bf Element} & {\bf Dependent Element(s)}\\ \hline
%			\texttt{$GSN_1$} &  \name{Goal} $G$ & 1.~All goals/strategies linked to $G$ on either end of the \name{IsSupportedBy} relation.\\
%			&  & 2.~All solutions linked to $G$ via the \name{IsSolvedBy} relation.\\ \hline
%			\texttt{$GSN_2$} & \name{Strategy} $S$ &  All goals linked to $S$ on either end of the \name{IsSupportedBy} relation.\\  \hline
%			\texttt{$GSN_3$} & \name{Context} $C$ & 1.~All goals, strategies and solutions $A$ that introduce $C$ as the context via the \name{InContextOf} relation.\\
%			&  & 2.~All goals, strategies and solutions that inherit $C$ as the context (i.e., all children of $A$).\\  \hline
%			\texttt{$GSN_4$} & \name{Solution} $S$ & All goals related to $S$ via the \name{IsSolvedBy} relation.\\  \hline
%		\end{tabular}
%	\end{center}
%	%\vspace{-0.1in}
%	\caption{Dependency rules used for GSN model slicing ($\mathtt{Slice}_{GSN_V}$)~\cite{Kokaly:2017}.}
%	\label{t:dependencies}
%	%\vspace{-0.2in}
%\end{table}



%Our $\mathtt{Slice}_{GSN_V}$ slicer uses the dependency rules in
%Table~\ref{t:dependencies} adapted from the set of propagation rules
%described in \cite{Kelly:2001} to identify elements to be marked for rechecking. For example, \name{GSN_{1}}
%says that all goals and strategies linked to a goal $G$ on either end of the \name{IsSupportedBy} relation are dependent on $G$ (and are therefore marked ``recheck''), if $G$ is marked
%for revision. On the other hand, $\mathtt{Slice}_{GSN_R}$ only
%uses two dependency rules to identify elements to be marked for rechecking: (1) Conclusion goals depend on premise goals they
%are indirectly linked to by the same strategy, and (2) Goals depend on
%solutions they are linked to by the \name{IsSolvedBy} relation.
%
%While  $\mathtt{Slice}_{GSN_V}$ only performs a one-step slice to find the revised elements' direct dependencies, $\mathtt{Slice}_{GSN_R}$ works by continuously expanding a subset of elements in a
%GSN model to include its dependent elements until no further expansion
%is possible.

\vspace{-0.15in}
\subsection{Software Product Lines}
\vspace{-0.1in}
We introduce Software Product Line (SPL) concepts following definitions from~\cite{Salay:2014}.
An SPL $\SPL$ is a tuple $(\featset, \featmodel, \domainmodel, \pcmap)$ where:
(1) $\featset$ is the set of features s.t.  an individual product can be derived from $\SPL$ via a \term{feature configuration} $\config \subseteq \featset$.
(2) $\featmodel \in \Prop(\featset)$ is a propositional formula over $\featset$ defining the valid set of feature configurations. $\featmodel$ is called a \term{Feature Model (FM)}. The set of valid configurations defined by $\featmodel$ is called $\Conf(\SPL)$.
(3) $\domainmodel$ is a set of program elements, called the \term{domain model}. The whole set of program elements is usually referred to as the \term{150\% representation}. 
(4) $\pcmap:\domainmodel \to \Prop(\featset)$ is a total function mapping each program element to a proposition (\term{feature expression}) defined over the set of features $F$. $\pcmap(e)$ is called the \term{Presence Condition (PC)} of element $e$, i.e. the set of product configurations in which $e$ is present.
%\ED

Given a product line $\SPL$ and a feature configuration $\config$, we define $\indexProd{\SPL}{\config}$ to be the subset of elements of $\SPL$ that belong to at least one of the features in $\config$. We loosely use the same indexing operator when referring to subsets of values in a data structure subject to a feature configuration. For example, given a feature configuration \{\name{LDWS, Visual}\}, a product with all the elements, except for the ones annotated in green, is instantiated from the product line (Fig.~\ref{fig:ex}).
