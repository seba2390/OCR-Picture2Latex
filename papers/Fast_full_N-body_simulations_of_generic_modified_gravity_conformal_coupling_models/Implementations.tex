
\section{Numerical Implementations}
\label{sect:numerics}

This section is the core part of this paper, where will describe in detail how the different theoretical models of \S\ref{sec:theories} can be incorporated in a numerical simulation code, so that the scalar degree of freedom can be solved at any given time with any given matter density field. This way, the various effects of the scalar field on cosmic structure formation can be accurately predicted and implemented. 

\subsection{The {\sc glam} code}
\label{subsect:glam}

The \textsc{glam} code is presented in \cite{Klypin:2017iwu}, and is a promising tool to quickly generate $N$-body simulations with reasonable speed and acceptable resolution, which are suitable for the massive production of galaxy survey mocks. 


As a PM code, \textsc{glam} solves the Poisson equation for the gravitational potential in a periodic cube using fast Fourier Transformation (FFT). The code uses a 3D mesh for density and potential estimates, and only one mesh is needed for the calculation: the density mesh is replaced with the potential. The gravity solver uses FFT to solve the discrete analogue of the Poisson equation, by applying it first in $x$- and then to $y$-direction, and finally transposing the matrix to improve data locality before applying FFT in the third ($z$-)direction. After multiplying this data matrix by the Green's function, an inverse FFT is applied, performing one matrix transposition and three FFTs, to compute the Newtonian potential field on the mesh. The potential is then differentiated using a standard three-point finite difference scheme to obtain the $x,y$ and $z$ force components at the centres of the mesh cells. These force components are next interpolated to the locations of simulation particles, which are displaced using a leapfrog scheme. A standard Cloud-in-Cell (CIC) interpolation scheme is used for both the assignment of particles to calculate the density values in the mesh cells and the interpolation of the forces.  

A combination of parameters that define the resolution and speed of the \textsc{glam} code are carefully selected. For example, it uses the \textsc{FFT}5 code (the Fortran 90 version of \textsc{FFTpack}5.1) because it has an option of real-to-real FFT that uses only half of the memory as compared to \textsc{FFTW}. It typically uses $1/2$--$1/3$ of  the number of particles (in 1D) as compared with the mesh size---given that the code is limited by available RAM, this is a better combination than using the same number of particles and mesh points.

\textsc{glam} uses \textsc{openmp} directives to parallelise the solver. %The parallelisation of the particle displacements is trivial, while density assignment is more complicated because it is not really parallel, since different particles can contribute to the same cell. {Atomic} \textsc{openmp} statement is used to remove racing conditions---this slows the code a bit, but other alternatives are not much faster and typically require extra memory. 
Overall, the code scales nearly perfectly, as has been demonstrated by tests run with different mesh sizes and on different processors (later in the paper we will present some actual scaling test of \textsc{mg-glam} as well, which again is nearly perfect). \textsc{mpi} parallelisation is used only to run many realisations on different supercomputer nodes with very little inter-node communications. Load balance is excellent since theoretically every realisation requires the same number of CPUs. 

Initial conditions are generated on spot by \textsc{glam}, using the standard Zel'dovich approximation \cite{Zeldovich:1970A&A.....5...84Z,Efstathiou:1985ApJS...57..241E} from a user-provided linear matter power spectrum $P(k)$ at $z=0$. The code backscales this $P(k)$ to the initial redshift $z_{\rm ini}$ using the \textcolor{black}{scale-independent} linear growth factor for $\Lambda$CDM with the specified cosmological parameters. As the Zel'dovich approximation is less accurate at low redshifts \cite{Crocce:2006ve}, the simulation is started at an initial redshift $z_{\rm ini}\geq100$. \textcolor{black}{Starting at a higher redshift such as $z_{\rm ini}=100$ also has the additional advantage that, for the MG models of interest here, the effect of the scalar field is smaller at earlier times, which means that it is an increasingly better approximation to use the same initial conditions in the MG models as in the $\Lambda$CDM model with the same cosmological parameters, as we practice throughout this work. If, as in the general scenarios, there is non-negligible MG effect prior to $z_{\rm ini}$, such effect should be taken into account in the generation of initial conditions, e.g., \citep{Li:2011PhRvD..83b4007L}. We note that using $\Lambda$CDM initial conditions in the MG simulations means that we do not need to backscale the linear $P(k)$ (e.g., at $z=0$) of the corresponding MG models, which are usually scale-dependent --- this latter approach has been checked for clustering dark energy models in \citep{Hassani:2019JCAP...12..011H}, where it is found to be unable to give the correct matter and gravitational potential power spectra at late times simultaneously (see \citep{Hassani:2019wed} for a way to overcome this issue).}

% \revision{In general, the modified gravity affects the generation of the ICs \cite{Li:2011PhRvD..83b4007L}.
% But we start the simulation at $z = 100$, a time in which the MG fields have little effect on the growth of structure.
% Also, it was checked that the $\Lambda$CDM and MG simulations can use the same initial conditions for the symmetron model \cite{Davis:2011pj}. 
% However, this is not case for all modified gravity or dark energy models. 
% For example, Ref.~\cite{Hassani:2019JCAP...12..011H} shows that the backscaling initial conditions cannot compute simultaneously the power spectrum of matter and of the gravitational potential for clustered dark energy. }


\textsc{glam} uses a fixed number of time steps, but this number is user-specified. The standard choice is about $150$--$200$. Here, we have compared the model difference of the matter power spectra between modified gravity \textsc{mg-glam} and $\Lambda$CDM \textsc{glam} simulations and found that the result is converged with $160$ time steps. Doubling the number of steps from $160$ to $320$ makes negligible difference. 

The code generates the density field, including peculiar velocities, for a particular cosmological model. Nonlinear matter power spectra and halo catalogues at user-specified output redshifts (snapshots) are measured on the fly. For the latter, \textsc{glam} employs the Bound Density Maximum (BDM; \cite{Klypin:1997sk,Riebe:2011arXiv1109.0003R}) algorithm to get around the usual limitations placed on the completeness of low-mass haloes by the lack of force resolution in PM simulations. Here we briefly describe the idea behind the BDM halo finder, and further details can be found in \cite{Riebe:2011arXiv1109.0003R,Knebe:2011MNRAS.415.2293K}. The code starts by calculating a local density at the positions of individual particles, using a spherical tophat filter containing a constant number $N_{\rm filter}$ (typically 20) of particles. It then gathers all the density maxima and, for each maximum, finds a sphere that contains a mass $M_\Delta = \frac{4}{3}\pi\Delta\rho_{\rm crit}(z)R_\Delta^3$, where $\rho_{\rm crit}(z)$ is the critical density at the halo redshift $z$, and $\Delta$ is the overdensity within the halo radius $R_\Delta$. Throughout this work we will use the virial density definition for $\Delta$ given by \cite{Bryan:1997dn}
\begin{equation}
    \Delta_{\rm vir}(z) = 18\pi^2 + 82\left[\Omega_{\rm m}(z)-1\right] - 39\left[\Omega_{\rm m}(z)-1\right]^2,
\end{equation}
where $\Omega_{\rm m}(z)$ is the matter density parameter at $z$. To find distinct haloes, the BDM halo finder still needs to deal with overlapping spheres. To this end, it treats the density maxima as halo centres and finds the one sphere, amongst a group of overlapping ones, with the deepest Newtonian potential. This is treated as a distinct, central, halo. The radii and masses of the haloes which correspond to the other (overlapping) spheres are then found by a procedure that guarantees a smooth transition of the properties of small haloes when they fall into the larger halo to become subhaloes of the latter. The latter is done by defining the radius of the infalling halo as $\max(R_1, R_2)$, where $R_1$ is its distance to the surface of the larger, soon-to-be host, central halo, and $R_2$ is its distance to the nearest density maximum in the spherical shell  $[\min(R_\Delta,R_1),\max(R_\Delta,R_1)]$ centred around it (if no density maximum exists in this shell, $R_2=R_\Delta$). The BDM halo finder was compared against a range of other halo finders in \cite{Knebe:2011MNRAS.415.2293K}, where good agreement was found. 

% \textcolor{red}{[The above paragraph needs to be checked, and we may need Anatoly to write something about how the halo mass is calculated.]}

\textsc{mg-glam} extends \textsc{glam} to a general class of modified gravity theories by adding extra modules for solving MG scalar field equations, which will be introduced in the following subsection.


%------------------------------------------------------
\subsubsection{The \textsc{glam} code units}
\label{sec:glam_units}
%------------------------------------------------------

Like most other $N$-body codes, \textsc{glam} uses its own internal unit system. The code units are designed such that the physical equations can be cast in dimensionless form, which is more convenient for numerical solutions.

Let the box size of simulations be $L$ and the number of grid points in one dimension be $N_{\rm g}$. We can introduce dimensionless coordinates $\tilde{\boldsymbol{x}}$, momenta $\tilde{\boldsymbol{p}}$ and potentials $\tilde{\Phi}$ using the following relations \citep{Klypin:2017iwu} 
\begin{equation}\label{eq:code_units}
\tilde{\boldsymbol{x}} = \left( \frac{N_{\rm g}}{L}\right) {\boldsymbol{x}} \,, \qquad
\tilde{\boldsymbol{p}} = \left( \frac{N_{\rm g}}{H_0 L}\right) {\boldsymbol{p}}\,, \qquad
\tilde\Phi = \left( \frac{N_{\rm g}}{H_0 L}\right)^2\Phi\,.
\end{equation}
Having the dimensionless momenta, we can find the peculiar velocity,
\begin{equation}
{\boldsymbol{v}}_{\rm pec} = 100 \left(\frac{L}{N_{\rm g}}\right)\left(\frac{\tilde{\boldsymbol{p}}}{a}\right)\,{\rm km}~{\rm s}^{-1}\,,
\end{equation}
where we assumed that box size $L$ is given in units of $\Mpch$.
Using these notations, we write the particle equations of motion and the Poisson equation as
\begin{align}
\frac{{\rm d}\tilde{\boldsymbol{p}}}{{\rm d} a} &= -\left(\frac{H_0}{\dot{a}}\right)\tilde{\boldsymbol{\nabla}}\tilde{\Phi}\,,\\
\frac{{\rm d}\tilde{\boldsymbol{x}}}{{\rm d} a} &= -\left(\frac{H_0}{\dot{a}}\right)\frac{\tilde{\boldsymbol{p}}}{a^2}\,,\\
\label{eq:GR_poisson_codeunit}\tilde{\nabla}^2\tilde{\Phi} &= \frac{3}{2}\Omega_{\rm m} a^{-1} \tilde{\delta},
\end{align}
where $\tilde{\delta}$ is the code unit expression of the density contrast $\delta$.

From Eqs.~\eqref{eq:code_units} we can derive the following units,
\begin{equation}\label{eq:code_units2}
\tilde{\boldsymbol{\nabla}} = \left(\frac{L}{N_{\rm g}}\right) \boldsymbol{\nabla}\,, \quad {\rm d} \tilde t = H_0 {\rm d} {t}\,, \quad \tilde{\rho}_{\rm m} = \left( \frac{a^3}{\rho_{\rm crit, 0}\Omega_{\rm m}}\right) \rho_{\rm m}\,, \quad \tilde{\delta} = \delta\,.
\end{equation}
In what follows, we will also use the following definition
\begin{equation}
    \tilde{c} = \left(\frac{N_{\rm g}}{H_0 L}\right) c
\end{equation}
for the code-unit expression of the speed of light, $c$.

{\sc glam} uses a regularly spaced three-dimensional mesh of size $N_{\rm g}^3$ that covers the cubic domain $L^3$ of a simulation box. The size of a cell, $\Delta x =L/N_{\rm g}$, and the mass of each particle, $m_{\rm p}$, define the force and mass resolution respectively:
\begin{eqnarray}
m_{\rm p} &=& \Omega_{\rm m} \, \rho_{\rm crit,0}\left[\frac{L}{N_{\rm p}}\right]^3 = 8.517\times 10^{10}\left[\frac{\Omega_{\rm m}}{0.30}\right]
\left[\frac{L/\Gpch}{N_{\rm p}/1000}\right]^3h^{-1}M_\odot, \label{eqn:mass_resolution_def}\\
\Delta x &=& \left[\frac{L/\Gpch}{N_{\rm g}/1000}\right]\Mpch, \label{eqn:force_resolution_def}
\end{eqnarray}
where $N_{\rm p}^3$ is the number of particles and $\rho_{\rm crit,0}$ is the critical density of the universe at present.

\subsection{Solvers for the extra degrees of freedom}
\label{subsect:extradof}

We have seen in \S\ref{sec:theories} that in modified gravity models we usually need to solve a new, dynamical, degree of freedom, which is governed by some nonlinear, elliptical type, partial differential equation (PDE). Being a nonlinear PDE, unlike the linear Poisson equation solved in default {\sc glam}, the equation can not be solved by a one-step fast Fourier transform\footnote{This does not mean that FFT cannot be used under any circumstances. For example, Ref.~\cite{Chan:2009ew} used a FFT-relaxation method to solve nonlinear PDEs iteratively. In each iteration, the equation is treated as if it were linear (by treating the nonlinear terms as a `source') and solved using FFT, but the solution in the previous step is used to update the `source', for the PDE to be solved again to get a more accurate solution, until some convergence is reached.} but requires a \textit{multigrid relaxation} scheme to obtain a solution.

For completeness, we will first give a concise summary of the relaxation method and its multigrid implementation (\S\ref{subsubsect:relaxation}). Next, we will specify the practical side, discussing how to efficiently arrange the memory in the computer, to allow the same memory space to be used for different quantities at different stages of the calculation, therefore minimising the overall memory requirement (\S\ref{subsubsect:code_struc}), and also saving the time for frequently allocating and deallocating operations. 
After that, in \S\ref{subsubsect:csf_imp}--\S\ref{subsubsect:fR_imp}, we will respectively discuss how the nonlinear PDEs in general coupled quintessence, symmetron and $f(R)$ models can be solved most efficiently. Much effort will be devoted to replacing the common Newton-Gauss-Seidel relaxation method by a nonlinear Gauss-Seidel, which has been found to lead to substantial speedup of simulations \cite{Bose:2016wms} (but we will generalise this to more models than focused on in Ref.~\cite{Bose:2016wms}). For the coupled quintessence model, we will also briefly describe how the background evolution of the scalar field is numerically solved as an integral part of {\sc mg}-{\sc glam}, to further increase its flexibility. 

\subsubsection{Multigrid Gauss-Seidel relaxation}
\label{subsubsect:relaxation}
% \ca{}{[I am not sure this section is necessary as a part of this paper as this is textbook material though it would certainly be useful as a thesis chapter.]}

Let the partial differential equation (PDE) to be solved take the following form:
\begin{equation}
    \mathcal{L}(u) = 0,
\end{equation}
where $u$ is the scalar field and $\mathcal{L}$ is the PDE operator. To solve this equation numerically, we use finite difference to get a discrete version of it on a mesh\footnote{In this paper we consider the simplest case of cubic cells.}. Since {\sc mg}-{\sc glam} is a particle-mesh (PM) code, it has a uniform mesh resolution and does not use adaptive mesh refinement (AMR). When discretised on a uniform mesh with cell size $h$, the above equation can be denoted as
\begin{equation}\label{eq:general_pde}
    \mathcal{L}^h({u}^h) = {f}^h,
\end{equation}
where we have added a nonzero right-hand side, $f^h$, for generality (while $f^h=0$ on the mesh with cell size $h$, later when we discrete it on coarser meshes needed for the multigrid implementation, $f$ is no longer necessarily zero). Both $u^h$ and $f^h$ are evaluated at the cell centres of the given mesh.

The solution we obtain numerically, $\hat{u}$, is unlikely to be the true solution $u^h$ to the discrete equation, and applying the PDE operator on the former gives the following, slightly different, equation:
\begin{equation}\label{eq:general_pde_numerical}
    \mathcal{L}^h(\hat{u}^h) = \hat{f}^h.
\end{equation}
Taking the difference between the above two equations, we get
\begin{equation}\label{eq:numerical_error}
    \mathcal{L}^h({u}^h) - \mathcal{L}^h(\hat{u}^h) = f^h-\hat{f}^h = -d^h,
\end{equation}
where 
\begin{equation}\label{eq:residual_d}
    d^h \equiv \hat{f}^h-f^h,
\end{equation}
is the {\it local residual}, which characterises the inaccuracy of the solution $\hat{u}^h$ (this is because if $\hat{u}^h=u^h$, we would expect $\hat{f}^h=f^h$ and hence there is zero `inaccuracy'). $d^h$ is also evaluated at cell centres. Later, to check if a given set of numerical solution $\hat{u}^h$ is acceptable, we will use a \textit{global residual}, $\epsilon^h$, which is a single number for the given mesh of cell size $h$. In this work we choose to define $\epsilon^h$ as the root-mean-squared of $d^h$ in all mesh cells (although this is by no means the only possible definition). We will call both $d^h$ and $\epsilon^h$ `residual' as the context will make it clear which one is referred to.

Relaxation solves Eq.~\eqref{eq:general_pde} by starting from some approximate trial solution to $u^h$, $\hat{u}^h_{\rm old}$, and check if it satisfies the PDE. If not, this trial solution can be updated using a method that is similar to the Newton-Ralphson iterative method to solve nonlinear algebraic equations
\begin{equation}\label{eq:relaxation_iteration}
    \hat{u}^h_{\rm new} = \hat{u}^h_{\rm old} - \frac{\mathcal{L}^h\left(\hat{u}^h_{\rm old}\right)-\hat{f}^h}{\partial\mathcal{L}^h\left(\hat{u}^h_{\rm old}\right)/\partial\hat{u}^h}.
\end{equation}
This process can be repeated iteratively, until the updated solution satisfies the PDE to an acceptable level, i.e., $\epsilon^h$ becomes small enough. In practice, because we are solving the PDE on a mesh, Eq.~\eqref{eq:relaxation_iteration} should be performed for all mesh cells, which raises the question of how to order this operation for the many cells. We will adopt the Gauss-Seidel `black-red chessboard' approach, where the cells are split into two classes, `black' and `red', such that all the six direct neighbours\footnote{The direct neighbours of a given cell are the six neighbouring cells which share a common face with that cell.} of a `red' cell are black and vice versa. The relaxation operation, Eq.~\eqref{eq:relaxation_iteration}, is performed in two sweeps, the first for `black' cells (i.e., only updating $\hat{u}^h$ in `black' cells while keeping their values in `red' cells untouched), while the second for all the `red' cells. This is a standard method to solve nonlinear elliptical PDEs by using relaxation, known as the \textit{Newton-Gauss-Seidel method}. However, although this method is generic, it is not always efficient, and later we will describe a less generic alternative which is nevertheless more efficient. 

Relaxation iterations are useful at reducing the Fourier modes of the error in the trial solution $\hat{u}^h$, whose wavelengths are comparable to that of the size of the mesh cell $h$. If we do relaxation on a fine mesh, this means that the short-wave modes of the error are quickly reduced, but the long-wave modes are generally much slower to decrease, which can lead to a slow convergence of the relaxation iterations. A useful approach to solve this problem is by using {\it multigrid}: after a few iterations on the fine level, we `move' the equation to a coarser level where the cell size is larger and the longer-wave modes of the error in $\hat{u}^h$ can be more quickly decreased. The discretised PDE on the coarser level is given by
\begin{equation}\label{eq:general_pde_numerical_coarse}
    \mathcal{L}^H(u^H) = \mathcal{L}\left(\mathcal{R}\hat{u}^h\right) - \mathcal{R}d^h \equiv S^H,
\end{equation}
where the superscript $^H$ denotes the coarse level where the cell size is $H$ (in our case $H=2h$), and $\mathcal{R}$ denotes the \textit{restriction} operator which interpolates quantities from the fine level to the coarse level. In our numerical implementation, a coarse (cubic) cell contains 8 fine (cubic) cells of equal volume, and the restriction operation can be conveniently taken as the arithmetic average of the values of the quantity to be interpolated in the 8 fine cells. 

Eq.~\eqref{eq:general_pde_numerical_coarse} can be solved using relaxation similarly to Eq.~\eqref{eq:general_pde_numerical}, for which the numerical solution is denoted as $\hat{u}^H$. This can be used to `correct' and `improve' the approximate solution $\hat{u}^h$ on the fine level, as
\begin{equation}\label{eq:solution_correction}
    \hat{u}^{h,{\rm new}} = \hat{u}^{h,{\rm old}} + \mathcal{P}\left(\hat{u}^H - \mathcal{R}\hat{u}^h\right),
\end{equation}
where $\mathcal{P}$ is the \textit{prolongation} operation which does the interpolation from the coarse to the fine levels. In this work we shall use the following definition of the prolongation operation: for a given fine cell,
\begin{enumerate}
    \item find its parent cell, i.e., the coarser cell that contains the fine cell;
    \item find the seven neighbours of the parent cell, i.e., the coarser cells which share a face (there are 3 of these), an edge (there are 3 of these) or a vertex (just 1) with the above parent coarser cell;
    \item calculate the fine-cell value of the quantity to be interpolated from the coarse to the fine levels, as a weighted average of the corresponding values in the 8 coarse cells mentioned above: $27/64$ for the parent coarse cell, and $9/64$, $3/64$ and $1/64$ respectively for the coarse cells sharing a face, an edge and a vertex with the parent cell. 
\end{enumerate}

The above is a simple illustration of how multigrid works for two levels of mesh resolution, $h$ and $H$. In principle, multigrid can be and is usually implemented using more than two levels. In this paper we will use a hierarchy of increasingly coarser meshes with the coarsest one having $4^3$ cells. 

There are flexibilities in how to arrange the relaxations at different levels. The most-commonly used arrangement is the so-called V-cycle, where one starts from the finest level, moves to the coarsest one performing relaxation iterations on each of the intermediate levels (cf.~Eq.~\eqref{eq:general_pde_numerical_coarse}), and then moves straight back to the finest performing corrections using Eq.~\eqref{eq:solution_correction} on each of the intermediate levels. Other arrangements, such as F-cycle and W-cycle (cf.~Fig.~\ref{fig:multigrid_cycles}), are sometimes more efficient in improving the convergence rate of $\hat{u}^h$ to $u^u$, and we have implemented them in {\sc mg}-{\sc glam} as well. 

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{./fig/multigrid_cycles.pdf}
\caption{An illustration of the three different arrangements of multigrid relaxation method used in this paper: from left to right, V-cycle, F-cycle and W-cycle. The horizontal dotted lines depict 4 multigrid levels of mesh, with the finest mesh (denoted by its cell size $h$) on top, and the coarsest mesh (with cell size $8h$) at the bottom. The relaxation always starts on the finest level, and the solid lines show how the multigrid solver walks through the different levels, performing Gauss-Seidel relaxation iterations at each level (denoted by the circles), called smoothing. Only one single full cycle is shown for each case. The solver walks over the multigrid levels more times in W-cycle than in F-cycle and V-cycle, and thus it requires fewer cycles in the former case to arrive at a converged solution. However, it is also computationally more expensive. We will compare the performances of the three different arrangements in real cosmological simulations in Sect.~\ref{subsect:convergence_tests}.}
    \label{fig:multigrid_cycles}
\end{figure}

\subsubsection{Memory usage}
\label{subsubsect:code_struc}

{\sc glam} uses a single array to store mesh quantities, such as the matter density field and the Newtonian potential, because at any given time only one of these is needed. The Newtonian force at cell centres is calculated by finite-differencing the potential and then interpolated to the particle positions. To be memory efficient, \textsc{glam} also opts not to create a separate array to store the forces at the cell centres, but instead directly calculates them at the particle positions immediately before updating the particle velocities.

With the new scalar field to be solved in modified gravity models, we need two additional arrays of size $N_{\rm g}^3$, where $N_{\rm g}^3$ is the number of cells of the PM grid (i.e., there are $N_{\rm g}$ cells in each direction of the cubic simulation box). This leads to three arrays. \texttt{Array 1} is the default array in {\sc glam}, which is used to store the density field $\rho$ and the Newtonian potential $\Phi$ (at different stages of the simulation). Note that the density field is also needed when solving the scalar field equation of motion during the relaxation iterations, and so we cannot use this array to also store the scalar field. On the other hand, we will solve the Newtonian potential after the scalar field, by when it is safe to overwrite this array with $\Phi$. \texttt{Array2} is exclusively used to store the scalar field solution $\hat{u}^h$ on the PM grid, which will be used to calculate the fifth force. \texttt{Array3} is used to store the various intermediate quantities which are created for the implementation of the multigrid relaxation, such as $d^h$, $\hat{u}^H$, $\mathcal{R}\hat{u}^h$, $\mathcal{R}d^h$, $S^H$ and $\rho^H$, the last of which is the density field on the coarser level $^H$, which appears in the coarse-level discrete PDE operator $\mathcal{L}^H$.

To be concrete, we imagine the 3D array (\texttt{Array3}) as a cubic box with $N_{\rm g}^3$ cubic cells of equal size. An array element, denoted by $(i,j,k)$, represents the $i$th cell in the $x$ direction, $j$th cell in the $y$ direction and $k$th cell in the $z$ direction, with $i,j,k=1,\cdots,N_{\rm g}$. We divide this array into 8 sections, each of which can be considered to correspond to one of the 8 octants that equally divide the volume of the cubic box. The range of $(i,j,k)$ of each section and the quantity stored in that section of \texttt{Array3} are summarised in the table below: 
% \ca{}{[Is this necessary for any explanations later? I'm not sure it makes sense to go into that much detail in the main part of the paper - possibly move to the appendix?]}
\begin{center}
    \begin{tabular}{|c|p{3cm}|p{3cm}|p{3cm}|p{3cm}|}
    \hline
    Section & $i$ range & $j$ range & $k$ range & Quantity\\ 
    \hline
    \hline
    1 & $1,\cdots,N_{\rm g}/2$ & $1,\cdots,N_{\rm g}/2$ & $1,\cdots,N_{\rm g}/2$ & $d^\ell$, $\mathcal{R}d^\ell$ \\ 
    \hline
    2 & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $1,\cdots,N_{\rm g}/2$ & $1,\cdots,N_{\rm g}/2$ & $d^\ell$, $\rho^{\ell-1} = \mathcal{R}\rho^\ell$ \\ 
    \hline
    3 & $1,\cdots,N_{\rm g}/2$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $1,\cdots,N_{\rm g}/2$ & $d^\ell$, $\mathcal{R}\hat{u}^\ell$ \\ 
    \hline
    4 & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $1,\cdots,N_{\rm g}/2$ & $d^\ell$, $\hat{u}^{\ell-1}$ \\ \hline
    5 & $1,\cdots,N_{\rm g}/2$ & $1,\cdots,N_{\rm g}/2$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $d^\ell$, recursion \\ 
    \hline
    6 & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $1,\cdots,N_{\rm g}/2$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $d^\ell$, $d^{\ell-1}$ \\ \hline
    7 & $1,\cdots,N_{\rm g}/2$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $d^\ell$, $S^{\ell-1}$ \\ \hline
    8 & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $N_{\rm g}/2+1,\cdots,N_{\rm g}$ & $d^\ell$ \\
    \hline
    \end{tabular}
\end{center}


Let us explain this more explicitly. First of all, the whole \texttt{Array3}, of size $N_{\rm g}^3$, will be used to store the residual value $d^h$ on the PM grid (which has $N_{\rm g}^3$ cells). From now on, we label this grid by `level-$\ell$', and use `level-($\ell-m$)' to denote the grid that are $m$ times coarser, i.e., if the cell size of the PM grid is $h$, then the cells in this coarse grid have a size of $2^mh$. 
In the table above we have used $d^\ell$ to denote the $d^h$ on level-$\ell$, and so on. 
Note that we always use $N_{\rm g}=2^\ell$.


The local residual $d^h$ on a fine grid is only needed for two purposes: (1) to calculate the global residual on that grid, $\epsilon^h$, which is needed to decide convergence of the relaxation, and (2) to calculate the coarse-level PDE operator $\mathcal{L}^H$ that is needed for the multigrid acceleration, as per Eq.~\eqref{eq:general_pde_numerical_coarse}. This suggests that $d^h$ does not have to occupy \texttt{Array3} all the time, and so this array can be reused to store other intermediate quantities (see the last column of the above table) \textit{after} we have obtained $\epsilon^h$. 

In our arrangement, Section 1 stores the residual $\mathcal{R}d^\ell$, Section 2 stores the restricted density field $\rho^{\ell-1}=\mathcal{R}\rho^\ell$, Sections 3 and 4 store, respectively, the restricted scalar field solution $\mathcal{R}\hat{u}^\ell$ and the coarse-grid scalar field solution $\hat{u}^{\ell-1}$ --- the former is needed to calculate $S^{\ell-1}$ in Eq.~\eqref{eq:general_pde_numerical_coarse} and to correct the fine-grid solution using Eq.~\eqref{eq:solution_correction}, which is fixed after calculation, while the latter is updated during the coarse-grid relaxation sweeps\footnote{We use $\mathcal{R}\hat{u}^\ell$ as the initial guess for $\hat{u}^{\ell-1}$ for the Gauss-Seidel relaxations on the coarse level.}. Section 7 stores the coarse-grid source $S^{\ell-1}$ for the PDE operator $\mathcal{L}^{\ell-1}$ as defined in Eq.~\eqref{eq:general_pde_numerical_coarse}, and finally Section 6 stores the residual on the coarse level, $d^{\ell-1}$. Note that all these quantities are for level-$(\ell-1)$, so that they can be stored in section of \texttt{Array3} of size $\left(N_{\rm g}/2\right)^3$. Section 8 is not used to store anything other than $d^\ell$. 

We have not touched Section 5 so far --- this section is reserved to store the same quantities as above, but for level-$(\ell-2)$, which are needed if we want to use more than two levels of multigrid. It is further divided into 8 section, each of which will play the same roles as detailed in the table above\footnote{The exception is that, as $d^{\ell-1}$ is already stored in Section 6, it does not have to be stored in Section 5 again.}. In particular, the (sub)Section 5 of Section 5 is reserved for quantities on level-$(\ell-3)$, and so on. In this way, there is no need to create separate arrays of various sizes to store the intermediate quantities on different multigrid levels which therefore saves memory. 

There is a small tricky issue here: as we mentioned above, the local residual $d^\ell$ on the PM grid is needed to calculate the coarse-grid source $S^{\ell-1}$ using Eq.~\eqref{eq:general_pde_numerical_coarse}, thus we will be using the quantity $d^\ell$ stored in \texttt{Array3} to calculate $\mathcal{R}d^{\ell}$ and then write it to (part of) the same array, running the risk of overwriting some of the data while it is still needed. To avoid this problem, we refrain from using the $d^\ell$ data already stored in \texttt{Array3}, but instead recalculate it in the subroutine to calculate $\mathcal{R}d^\ell$ (this only needs to be done for level-$\ell$). With a bit of extra computation, this enables use to avoid creating another array of similar size to \texttt{Array3}.

Since \texttt{Array3} stores different quantities in different parts, care must be excised when assessing these data. There is a simple rule for this: suppose that we need to read or write the quantities on the coarse grid of level-$(\ell-m)$ with $m\geq1$. These are 3-dimensional quantities with the three directions labelled by $I,J,K$, which run over $1,\cdots,2^{\ell-m}$, and we have
\begin{align}
    \mathcal{R}(d^{\ell-m+1}) \left[I,J,K\right] &\leftrightarrow \texttt{Array3}[i=I,&j=J\phantom{\ +2^{\ell-m}},k=K + \left(2^{m}-2\right)\cdot2^{\ell-m}],\nonumber\\
    \mathcal{R}(\rho^{\ell-m+1})\left[I,J,K\right] &\leftrightarrow \texttt{Array3}[i=I+2^{\ell-m},&j=J\phantom{\ +2^{\ell-m}},k=K + \left(2^{m}-2\right)\cdot2^{\ell-m}],\nonumber\\
    \mathcal{R}(u^{\ell-m+1})\left[I,J,K\right] &\leftrightarrow\texttt{Array3}[i=I,&j=J+2^{\ell-m},k=K + \left(2^{m}-2\right)\cdot2^{\ell-m}],\nonumber\\
    \hat{u}^{\ell-m}\left[I,J,K\right] &\leftrightarrow \texttt{Array3}[i=I+2^{\ell-m},&j=J+2^{\ell-m},k=K + \left(2^{m}-2\right)\cdot2^{\ell-m}],\nonumber\\
    d^{\ell-m}\left[I,J,K\right] &\leftrightarrow \texttt{Array3}[i=I+2^{\ell-m},&j=J\phantom{\ +2^{\ell-m}},k=K + \left(2^{m}-1\right)\cdot2^{\ell-m}],\nonumber\\
    S^{\ell-m}[I,J,K] &\leftrightarrow \texttt{Array3}[i=I,&j=J+2^{\ell-m},k=K + \left(2^{m}-1\right)\cdot2^{\ell-m}],
\end{align}
% \begin{eqnarray}
% \mathcal{R}(d^{\ell-m+1}) \left[I,J,K\right] &\leftrightarrow&  \textcolor{black}{\textrm{Array}~3[i=I,j=J,k=\left(2^{m}-2\right)\cdot2^{\ell-m}+K]},\nonumber\\
% \mathcal{R}(\rho^{\ell-m+1})\left[I,J,K\right] &\leftrightarrow& \textcolor{black}{\textrm{Array}~3[i=2^{\ell-m}+I,j=J,k=\left(2^{m}-2\right)\cdot2^{\ell-m}+K]},\nonumber\\
% \mathcal{R}(u^{\ell-m+1})\left[I,J,K\right] &\leftrightarrow& \textcolor{black}{\textrm{Array}~3[i=I,j=2^{\ell-m}+J,k=\left(2^{m}-2\right)\cdot2^{\ell-m}+K]},\nonumber\\
% \hat{u}^{\ell-m}\left[I,J,K\right] &\leftrightarrow& \textcolor{black}{\textrm{Array}~3[i=2^{\ell-m}+I,j=2^{\ell-m}+J,k=\left(2^{m}-2\right)\cdot2^{\ell-m}+K]},\nonumber\\
% d^{\ell-m}\left[I,J,K\right] &\leftrightarrow& \textcolor{black}{\textrm{Array}~3[i=2^{\ell-m}+I,j=J,k=\left(2^{m}-1\right)\cdot2^{\ell-m}+K]},\nonumber\\
% S^{\ell-m}[I,J,K] &\leftrightarrow& \textcolor{black}{\textrm{Array}~3[i=I,j=2^{\ell-m}+J,k=\left(2^{m}-1\right)\cdot2^{\ell-m}+K]},
% \end{eqnarray}
where $i,j,k=1,\cdots,N_{\rm g}$ run over the entire \texttt{Array3}. 


We can estimate the required memory for \textsc{mg-glam} simulations as follows. As mentioned above, the code uses a 3D array of single precision to store both the density field and the Newtonian potential, and one set of arrays for particle positions and velocities. In addition, two arrays are added %of double precision 
to store the scalar field solution (\texttt{Array2}) and various intermediate quantities in the multigrid relaxation solver (\texttt{Array3}). In the cosmological simulations described in this paper, we have used double precision for the two new arrays, and we have checked that using single precision slightly speeds up the simulation, while agreeing with the double-precision results within $0.001\%$ and $0.5\%$ respectively for the matter power spectrum and halo mass function. Given its fast speed and its shared-memory nature, memory is expected to be the main limiting factor for large \textsc{mg-glam} jobs. For this reason, we assume that all arrays are set to be single precision for future runs, and this leads to the following estimate of the total required memory:
\begin{align}
M_{\rm tot} &= 12N^3_{\rm g} + 24N^3_{\rm p} \, {\rm bytes}\,,\nonumber\\
&= 89.41 \qty(\frac{N_{\rm g}}{2000})^3 + 22.35\qty(\frac{N_{\rm p}}{1000})^3 \, {\rm GB}\,,\nonumber\\
&\approx 112 \, \qty(\frac{N_{\rm p}}{1000})^3 \, {\rm GB}\,,\quad {\rm for} \  N_{\rm g}=2N_{\rm p}\,,
\end{align}
where we have used $1~\mathrm{GB} = 1024^3~\mathrm{bytes}$. This is slightly more than twice the memory requirement of the default \textsc{glam} code, which is $52\left(N_{\rm p}/1000\right)^3$ GB \citep{Klypin:2017iwu}.



















%\subsubsection{Code units}
%\label{subsubsect:code_unit}

%For numerical evaluations during the simulation, it can be beneficial to first express the equations to be solved in a unit system that employs only dimensionless quantities, instead of using physical units. \textsc{glam}'s internal unit uses the scale factor $a$ as the `time' coordinate for time integration.  The particle equation of motion and the Poisson equation are given by 
%\begin{align}
%    \frac{\dd{\bm{x}}}{\dd{a}} &= \frac{1}{a^2 \dot{a}} \bm{p} \ , \label{eqn:basic_eqn1_phyunit} \\
%    \frac{\dd{\bm{p}}}{\dd{a}} &= -\frac{1}{\dot{a}} \nabla \Phi_{\rm N} \ , \label{eqn:basic_eqn2_phyunit} \\
%    \nabla^2 \Phi_{\rm N} &= 4 \pi G \bar{\rho}_{\rm m} a^2 \delta = \frac{3}{2} \Omega_{\rm m} a^{-1} \delta \ , \label{eqn:poisson_eqn_phyunit}
%\end{align}
%where $\bm{p} \equiv a^2 \dot{\bm{x}}$.
%
%
%The code unit used in the \textsc{mg-glam} code are given by the following expressions (where tilded quantitles are in code unit):
%\begin{align}
%    \tilde{\bm{x}} &\equiv \frac{N_{\rm g}}{L} \bm{x} \ , & \quad \tilde{\nabla} &\equiv \frac{L}{N_{\rm g}} \nabla \ , \notag \\
%    \quad \tilde{\bm{p}} &\equiv \frac{N_{\rm g}}{H_0 L} \bm{p} \ , & \quad \tilde{\Phi}_N &\equiv \qty(\frac{N_{\rm g}}{H_0 L})^2 \Phi_N \ .
%\end{align}
%where $L$ is the simulation box size. The basic Eqs.~\eqref{eqn:basic_eqn1_phyunit}-\eqref{eqn:poisson_eqn_phyunit} become 
%\begin{align}
%    \frac{\dd{\tilde{\bm{x}}}}{\dd{a}} &= \frac{H_0}{a^2 \dot{a}} \tilde{\bm{p}} \ , \\
%    \frac{\dd{\tilde{\bm{p}}}}{\dd{a}} &= -\frac{H_0}{\dot{a}} \tilde{\nabla} \tilde{\Phi}_{\rm N} \ , \\
%    \tilde{\nabla}^2 \tilde{\Phi}_{\rm N} &= \frac{3}{2} \Omega_{\rm m} a^{-1} \delta \ . \label{eq:GR_poisson_codeunit}
%\end{align}
%For later use for the scalar field, we define the following code unit for the speed of light, $c$:
%\begin{equation}
%    \tilde{c} \equiv \frac{N_{\rm g}}{H_0 L} c \ .
%\end{equation}
%The code unit for the scalar field depends on the model considered, and these will be described in the next few subsubsections. 

% For $\Lambda$CDM, the geodesic equation \eqref{eq:csf_particle_geodesic_qsa} can be expressed in code unit as
% \begin{eqnarray}
%     \frac{{\rm d}\tilde{\boldsymbol{x}}}{{\rm d}a} &=& \frac{H_0}{a^2\dot{a}}\tilde{\boldsymbol{p}},\\
%     \frac{{\rm d}\tilde{\boldsymbol{p}}}{{\rm d}a} &=& -\frac{H_0}{\dot{a}}\tilde{\boldsymbol{\nabla}}\tilde{\Phi}_{\rm N},
% \end{eqnarray}
% where $\boldsymbol{p}\equiv a^2\dot{\boldsymbol{x}}$, and the Poisson equation \eqref{eq:GR_Poisson_qsa} becomes
% \begin{equation}\label{eq:GR_poisson_codeunit}
%     \tilde{\boldsymbol{\nabla}}^2\tilde{\Phi}_{\rm N} = \frac{3}{2}\Omega_{\rm m}a^{-1}\tilde{\delta},
% \end{equation}
% in which we have defined the following code unit expressions:
% \begin{eqnarray}
%     \tilde{\boldsymbol{x}} &=& \frac{N_{\rm g}}{L}\boldsymbol{x},\nonumber\\
%     \tilde{\boldsymbol{\nabla}} &=& \frac{L}{H_g}\boldsymbol{\nabla},\nonumber\\
%     \tilde{\boldsymbol{p}} &=& \frac{N_{\rm g}}{H_0L}\boldsymbol{p},\nonumber\\
%     \tilde{\Phi}_{\rm N} &=& \frac{N_{\rm g}^2}{H_0^2L^2}\Phi_{\rm N},\nonumber\\
%     \tilde{\rho} &=& \frac{\rho_m}{\bar{\rho}_{\rm m}} = \tilde{\delta}+1,
% \end{eqnarray}
% where $L$ is the simulation box size in units of $h^{-1}{\rm Mpc}$. 
% For later use for the scalar field, we define the following code unit for the speed of light, $c$:
% \begin{equation}
%     \tilde{c} = \frac{N_{\rm g}}{H_0L}c.
% \end{equation}
% The code unit for the scalar field depends on the model considered, and these will be described in the next few subsubsections. 














\subsubsection{Implementation of coupled quintessence}
\label{subsubsect:csf_imp}

Defining the code unit of the dimensionless scalar field perturbation, $\delta\varphi=\varphi-\bar{\varphi}$, as\footnote{Note that, for brevity, we have slightly abused the notations, by using the same symbol $\varphi$ with a tilde for the code-unit expression of $\delta\varphi$. Given that the code-unit quantity always comes with a tilde, this should not cause any confusion with, e.g., the background scalar field $\bar{\varphi}$, or the total dimensionless scalar field $\varphi$ in physical units.}
\begin{equation}
    \tilde{\varphi} \equiv \frac{c^2N_{\rm g}}{H_0^2L^2}\delta\varphi = \tilde{c}^2\delta\varphi,
\end{equation}
with $\delta\varphi$ being the perturbation to $\varphi$, we can rewrite its equation of motion as
\begin{equation}\label{eq:csf_eom_code}
    \tilde{\boldsymbol{\nabla}}^2\tilde{\varphi} = 3\beta{\Omega_{\rm m}}{a^{-1}}e^{\beta\bar{\varphi}}\left[\exp\left(\beta\frac{\tilde{\varphi}}{\tilde{c}^2}\right)(1+\tilde{\delta})-1\right] -\alpha\lambda^2a^2\left[\frac{1}{\left(\bar{\varphi}+\tilde{c}^{-2}\tilde{\varphi}\right)^{1+\alpha}}-\frac{1}{\bar{\varphi}^{1+\alpha}}\right],
\end{equation}
where $\bar{\varphi}$ is the background value of $\varphi$, and $\lambda$ is defined in Eq.~\eqref{eq:csf_param_lambda}. The Poisson equation becomes
\begin{equation}\label{eq:csf_poisson_code}
    \Tilde{\boldsymbol{\nabla}}^2\tilde{\Phi}_{\rm N} = \frac{3}{2}\Omega_{\rm m}a^{-1}e^{\beta\bar{\varphi}}\left[\exp\left(\beta\frac{\tilde{\varphi}}{\tilde{c}^2}\right)(1+\tilde{\delta})-1\right] + \lambda^2a^2\left[\frac{1}{\left(\bar{\varphi}+\tilde{c}^{-2}\tilde{\varphi}\right)^{\alpha}}-\frac{1}{\bar{\varphi}^{\alpha}}\right].
\end{equation}
In practice, as we know that the scalar field density perturbation is small in the models of interest, the second term on the right-hand side of the Poisson equation can be dropped approximately. We have also chosen to neglect the term $\exp\left(\beta\tilde{c}^{-2}\tilde{\varphi}\right)$ in front of $(1+\tilde{\delta})$, to simplify the simulation --- this is again justified because $|\delta\varphi|\ll|\bar{\varphi}|\simeq\mathcal{O}(1)$ at late times, although including this in the simulation is trivial.

The modified particle coordinate and velocity updates can be rewritten as
\begin{eqnarray}
    \label{eq:csf_particle_geodesic_code1}\frac{{\rm d}\tilde{\boldsymbol{x}}}{{\rm d}a} &=& \frac{H_0}{a^2\dot{a}}\tilde{\boldsymbol{p}},\\
    \label{eq:csf_particle_geodesic_code2}\frac{{\rm d}\tilde{\boldsymbol{p}}}{{\rm d}a} &=& -\frac{H_0}{\dot{a}}\left[\tilde{\boldsymbol{\nabla}}\tilde{\Phi}_{\rm N}+\beta\tilde{\boldsymbol{\nabla}}\tilde{\varphi}\right] - \beta\frac{{\rm d}\bar{\varphi}}{{\rm d}a}\tilde{\boldsymbol{p}}.
\end{eqnarray}
Here we can observe more explicitly the effect of a modified background expansion history in coupled quintessence models, encoded in the $H_0\dot{a}^{-1}$ terms.

In \textsc{mg}-\textsc{glam}, Eq.~\eqref{eq:csf_eom_code} is solved using the Newton-Gauss-Seidel method described in \S\ref{subsubsect:relaxation}. Eq.~\eqref{eq:csf_poisson_code} is not directly solved, but instead we solve the (standard) Poisson equation not having $e^{\beta\bar{\varphi}}$: since this is a background quantity, we instead multiply it when calculating the Newtonian force from $\tilde{\Phi}_{\rm N}$. Eqs.~(\ref{eq:csf_particle_geodesic_code1}, \ref{eq:csf_particle_geodesic_code2}) are then solved --- the fifth force $\beta\tilde{\boldsymbol{\nabla}}\tilde{\varphi}$ is incorporated by first summing up the two potentials, $\tilde{\Phi}_{\rm N}+\beta\tilde{\varphi}$, and then doing the finite difference.

\subsubsection*{\textsc{mg-glam} background cosmology solver}

As Eqs.~(\ref{eq:csf_particle_geodesic_code1}, \ref{eq:csf_particle_geodesic_code2}) contain background quantities $\dot{a}$ and ${\rm d}\tilde{\varphi}/{\rm d}a$, for every given coupled quintessence model we need to solve its background evolution. This is governed by the following system of equations --- the equation of motion for the background scalar field $\bar{\varphi}$:  
\begin{equation}\label{eq:csf_background_eom}
    \ddot{\bar{\varphi}} + 3\frac{\dot{a}}{a}\dot{\bar{\varphi}} + \frac{{\rm d}V(\bar{\varphi})}{{\rm d}\varphi} + \frac{{\rm d}A\left(\bar{\varphi}\right)}{{\rm d}\varphi}8\pi G\bar{\rho}_{\rm m} = 0,
\end{equation}
the Friedmann equation (with a flat Universe, $k=0$, being assumed)
\begin{equation}\label{eq:csf_background_Friedmann}
    H^2 = \left(\frac{\dot{a}}{a}\right)^2 = \frac{8\pi{G}}{3}\left[\bar{\rho}_{\rm r}(a) + A(\bar{\varphi})\bar{\rho}_{\rm m}(a)\right] + \frac{1}{6}\dot{\bar{\varphi}}^2+H_0^2\frac{\lambda^2}{\bar{\varphi}^\alpha},
\end{equation}
and the Raychaudhuri equation 
\begin{equation}\label{eq:csf_background_Raychaudhuri}
    3\left(\dot{H}+H^2\right) = -4\pi{G}\left[2\bar{\rho}_{\rm r}(a) + A(\bar{\varphi})\bar{\rho}_{\rm m}(a)\right] - \dot{\bar{\varphi}}^2+H_0^2\frac{\lambda^2}{\bar{\varphi}^\alpha},
\end{equation}
where $\bar{\rho}_{\rm r}$ denotes the background density of radiations (we assume that all three species of neutrinos are massless and thus counted as radiation). Note that in Eqs.~(\ref{eq:csf_background_Friedmann}, \ref{eq:csf_background_Raychaudhuri}), to see the dimensions of the different terms clearly, we have already explicitly substituted the inverse-powerlaw potential and used the definition of $\lambda$ in Eq.~\eqref{eq:csf_param_lambda}. In \textsc{mg-glam} the scalar field equation is solved by a fifth-sixth order continuous Runge-Kutta method\footnote{For this numerical integrator we have used \texttt{subroutine dverk} from the \href{https://camb.info/}{\textsc{camb} code}, originally developed in Fortran 66 by K.~R.~Jackson.}. 

For numerical solutions in background cosmology, instead of directly working with Eqs.~(\ref{eq:csf_background_eom}, \ref{eq:csf_background_Friedmann}, \ref{eq:csf_background_Raychaudhuri}), it is convenient to use $N\equiv\ln(a)$ as the time variable, for which we have
\begin{equation}
    \bar{\varphi}' = \mathcal{H}\frac{{\rm d}\bar{\varphi}}{{\rm d}N}, \quad \bar{\varphi}'' = \mathcal{H}^2\frac{{\rm d}^2\bar{\varphi}}{{\rm d}N^2} + \mathcal{H}'\frac{{\rm d}\bar{\varphi}}{{\rm d}N},
\end{equation}
where, as mentioned in the Introduction, $'$ is the derivative with respect to the conformal time $\tau$ and $\mathcal{H}\equiv a'/a$. In this convention, the background quintessence field equation of motion, Eq.~\eqref{eq:csf_background_eom}, can be written as
\begin{equation}\label{eq:csf_background_eom_codeunit}
    \frac{\mathcal{H}^2}{H_0^2}\frac{{\rm d}^2\bar{\varphi}}{{\rm d}N^2} + \left[2\frac{\mathcal{H}^2}{H^2_0}+\frac{\mathcal{H}'}{H_0^2}\right]\frac{{\rm d}\bar{\varphi}}{{\rm d}N} - 3\alpha\lambda{\rm e}^{2N}{\bar{\varphi}^{-(1+\alpha)}} + 3\beta{\rm e}^{-N}\Omega_{\rm m}\exp(\beta\bar{\varphi}) = 0,
\end{equation}
where the quantities $\mathcal{H}^2/H_0^2$ and $\mathcal{H}'/H_0^2$ can be obtained from Eqs.~(\ref{eq:csf_background_Friedmann}, \ref{eq:csf_background_Raychaudhuri}) as
\begin{eqnarray}
    \frac{\mathcal{H}^2}{H^2_0} &=& \left[1-\frac{1}{6}\left(\frac{{\rm d}\bar{\varphi}}{{\rm d}N}\right)^2\right]^{-1}\left[\Omega_{\rm r}{\rm e}^{-2N}+\exp(\beta\bar{\varphi})\Omega_{\rm m}{\rm e}^{-N}+\lambda{\rm e}^{2N}\bar{\varphi}^{-\alpha}\right],\\
    \frac{\mathcal{H}'}{H^2_0} &=& -\frac{1}{3}\left(\frac{{\rm d}\bar{\varphi}}{{\rm d}N}\right)^2\frac{\mathcal{H}^2}{H_0^2} + \lambda{\rm e}^{2N}\bar{\varphi}^{-\alpha} - \Omega_{\rm r}{\rm e}^{-2N} - \frac{1}{2}\Omega_{\rm m}{\rm e}^{-N}\exp(\beta\bar{\varphi}).
\end{eqnarray}
Here $\Omega_{\rm r}$ denotes the present-day radiation density parameter, with `radiation' including CMB photons with a present-day temperature of $2.7255$ K and $3.046$ flavours of massless neutrinos; we defer the implementation of massive neutrinos, both as a non-interacting particle species and in the context of coupling to scalar fields, to future works.

We note that $\lambda$ is \textit{not} a free parameter of the model. Rather, once the density parameters $\Omega_{\rm m}$, $\Omega_{\rm r}$ and $H_0$ are specified (or equally once the present-day densities of matter and radiation are specified), $\lambda$, which quantifies the size of the potential energy of the scalar field, must take some certain value in order to ensure consistency. If $\lambda$ is too large, the predicted $H(a=1)$ will be larger than the desired (input) value of $H_0$, and vice versa. In practice, \textsc{mg}-\textsc{glam} starts from a trial value of $\lambda=1$, evolves Eqs.~(\ref{eq:csf_background_eom}, \ref{eq:csf_background_Friedmann}, \ref{eq:csf_background_Raychaudhuri}) from some initial redshift ($z_{\rm i}=10^5$) to $z=0$, and checks if the calculated value of $H(a=1)$ is equal to the desired value $H_0$ (within a small relative error of order $\mathcal{O}\left(10^{-6}\right)$); if the predicted $H(a=1)$ is larger than the desired $H_0$, $\lambda$ is decreased, and vice versa. This process is repeated iteratively to obtain a good approximation to $\lambda$ with a relative error smaller than $10^{-6}$. The initial conditions of $\bar{\varphi}$ and $\dot{\bar{\varphi}}$ at $z_{\rm i}=10^5$ are not important, as long as their values are small enough. Once the value of $\lambda$ has been determined in this way, it is stored to be used in other parts of the code; also stored are a large array of the various background quantities such as $H, \dot{H}, \bar{\varphi}$ and $\dot{\bar{\varphi}}$ --- if needed at any time by the scalar field solver of \textsc{mg}-\textsc{glam}, these quantities can be linearly interpolated in the scale factor $a$.  

\subsubsection{Implementation of symmetrons}
\label{subsubsect:sym_imp}

The scalar field equation of motion in the symmetron model, Eq.~\eqref{eq:sym_eom}, can be written in code unit as
\begin{equation}\label{eq:sym_eom_code_unit}
    \tilde{c}^2\tilde{\nabla}^2u = \frac{a^2}{2\xi^2}\left[\tilde{\rho}\frac{a_\ast^3}{a^3}-1\right]u + \frac{a^2}{2\xi^2}u^3.
\end{equation}
While this equation can be solved similarly to the case of coupled quintessence by using the standard Newton-Gauss-Seidel relaxation method we described in \S\ref{subsubsect:csf_imp}, the `Newton' approximation of this method, Eq.~\eqref{eq:relaxation_iteration}, is indeed unnecessary, as can be seen from the following derivation. Defining
\begin{equation}\label{eq:Lijk}
    L_{i,j,k}(u) \equiv u_{i+1,j,k}+u_{i-1,j,k}+u_{i,j+1,k}+u_{i,j-1,k}+u_{i,j,k+1}+u_{i,j,k-1},
\end{equation}
where a subscript $_{i,j,k}$ denotes the value of a quantity in a cell that is the $i$th ($j$th, $k$th) in the $x$ ($y$, $z$) direction, the discretised version of Eq.~\eqref{eq:sym_eom_code_unit}, after some rearrangement, can be written as
\begin{equation}
    u^3_{i,j,k}+\left[\tilde{\rho}_{i,j,k}\frac{a^3_\ast}{a^3}-1\right]u_{i,j,k} + \frac{12}{h^2}\frac{\tilde{c}^2\xi^2}{a^2}u_{i,j,k} - \frac{2}{h^2}\frac{\tilde{c}^2\xi^2}{a^2}L_{i,j,k} = 0.
\end{equation}
We can define
\begin{eqnarray}
    p &\equiv& \tilde{\rho}_{i,j,k}\frac{a^3_\ast}{a^3}-1 + \frac{12}{h^2}\frac{\tilde{c}^2\xi^2}{a^2},\\
    q &\equiv& - \frac{2}{h^2}\frac{\tilde{c}^2\xi^2}{a^2}L_{i,j,k},
\end{eqnarray}
so that the above equation can be simplified as
\begin{equation}\label{eq:sym_cubic_eqn}
    u^3_{i,j,k} + pu_{i,j,k} + q = 0.
\end{equation}
This is similar to the discrete equation of motion in the Hu-Sawicki $f(R)$ gravity model with $n=1$, as discussed in Ref.~\cite{Bose:2016wms}, which can be treated as a cubic equation of $u_{i,j,k}$ that can be solved exactly (analytically). Therefore, given the (approximate) values of the field $u$ in the six direct neighbouring cells of $(i,j,k)$, we can calculate $u_{i,j,k}$ analytically, and there is no need to solve it using the Newton approximation as in Eq.~\eqref{eq:relaxation_iteration}. The relaxation iterations are still needed, since the values of $u$ in the six direct neighbours are \textit{approximate} and therefore need to be updated iteratively, but the replacement of the Newton solver with an exact solution of $u_{i,j,k}$ (therefore the name \textit{nonlinear Gauss-Seidel} as opposed to \textit{Newton Gauss-Seidel}) has been found to significantly improve the convergence speed of the relaxation \cite{Bose:2016wms}. This method for the symmetron model was briefly mentioned in an Appendix of Ref.~\cite{Bose:2016wms} but no numerical implementation was shown there.

The solution to Eq.~\eqref{eq:sym_cubic_eqn} can be found as
\begin{align}\label{eq:sym_cubic_solns}
    u_{i,j,k} = \begin{cases}
        \displaystyle -\frac{1}{3} \left( C + \frac{\Delta_0}{C} \right) \ , & \Delta > 0  \ , \\
        \displaystyle \sqrt[3]{-q} \ , & \Delta = 0 \ , \\
        \displaystyle -\frac{2}{3} \sqrt{\Delta_0} \cos \left( \frac{\Theta}{3} + \frac{2\pi}{3} \right) \ , & \Delta < 0 \ ,
    \end{cases} 
\end{align}
where we have defined $\Delta_0 \equiv -3p$, $\Delta_1 \equiv 27 q$, $\Delta \equiv \Delta_1^2 - 4 \Delta_0^3$ and 
\begin{eqnarray}
    C &\equiv& \sqrt[3]{\frac{1}{2} \left[ \Delta_1 + \sqrt{\Delta_1^2 - 4 \Delta_0^3} \right]},\\ 
    \Theta &\equiv& \arccos \left( \frac{\Delta_1}{2\sqrt{\Delta_0^3}}\right).
\end{eqnarray}
It can be shown that all the 3 branches of solutions in Eq.~\eqref{eq:sym_cubic_solns} can be the physical solution in certain regimes, depending on model parameters, density values, mesh size, and so on. In our implementation in \textsc{mg}-\textsc{glam}, we have used Eq.~\eqref{eq:sym_cubic_solns} instead of Eq.~\eqref{eq:relaxation_iteration} for the symmetron model. 

The acceleration on particles, Eq.~\eqref{eq:csf_particle_geodesic_qsa}, can be written as following in the symmetron model:
\begin{eqnarray}
    \frac{{\rm d}\tilde{\boldsymbol{x}}}{{\rm d}a} &=& \frac{H_0}{a^2\dot{a}}{\tilde{\boldsymbol{p}}},\\
    \frac{{\rm d}\tilde{\boldsymbol{p}}}{{\rm d}a} &=& \tilde{\boldsymbol{F}}_{\rm N}+\tilde{\boldsymbol{F}}_5+\tilde{\boldsymbol{F}}_\times,
\end{eqnarray}
where $\tilde{\boldsymbol{F}}_{\rm N}$, $\tilde{\boldsymbol{F}}_5$ and $\tilde{\boldsymbol{F}}_\times$ denote, respectively, the standard Newtonian acceleration, the fifth force acceleration and the frictional force acceleration, in code units, given by
\begin{eqnarray}
    \label{eq:F_N_codeunit}\tilde{\boldsymbol{F}}_{\rm N} &=& -\frac{H_0}{\dot{a}}\tilde{\boldsymbol{\nabla}}\tilde{\Phi}_{\rm N},\\
    \label{eq:F_5_codeunit}\tilde{\boldsymbol{F}}_5 &=& -6\frac{H_0}{\dot{a}}\xi^2\Omega_{\rm m}\beta_\ast^2\tilde{c}^2a_{\ast}^{-3}u\tilde{\boldsymbol{\nabla}}u = -3\frac{H_0}{\dot{a}}\xi^2\Omega_{\rm m}\beta_\ast^2\tilde{c}^2a_{\ast}^{-3}\tilde{\boldsymbol{\nabla}}\left(u^2\right),\\
    \label{eq:F_x_codeunit}\tilde{\boldsymbol{F}}_\times &=& -9\Omega_{\rm m}\beta_\ast^2\xi^2\sqrt{1-\left(\frac{a_\ast}{a}\right)^3}\frac{1}{a^4}u\tilde{\boldsymbol{p}}.
\end{eqnarray}
In practice, as mentioned earlier, the frictional force is much weaker than the other two force components because of the very slow time evolution of the symmetron field. Likewise, any time variation of the matter particle mass due to the coupling with the symmetron field must be tiny and negligible. Therefore, for the Poisson equation, which governs $\Phi_{\rm N}$ and thus $\boldsymbol{F}_{\rm N}$, we simply approximate it to be the same as in $\Lambda$CDM.

\subsubsection{Implementation of $f(R)$ gravity}
\label{subsubsect:fR_imp}

In \S\ref{subsect:fR} we have introduced a class of $f(R)$ models with an (inverse) power-law function $f_R$, Eq.~\eqref{eq:fR_HS}, and mentioned that we will focus on the cases of $n=0$, $1$, $2$. In this subsection, we shall first derive equations that apply to general values of $n$, and then specialise to these three cases, for which we will develop case-specific algorithms of nonlinear Gauss-Seidel relaxation. 

In code unit, the $f_R$ equation of motion of this model, Eq.~\eqref{eq:fR_eom_qsa}, can be written as
\begin{equation}
\label{eq:fR_eom_codeunit1}\tilde{c}^2\tilde{\boldsymbol{\nabla}}^2\tilde{f}_R = -\Omega_{\rm m}{a}^{-1}\left(1+\tilde{\delta}\right) + \frac{1}{3} \tilde{\bar{R}}(a) a^2 \left(\frac{\tilde{\bar{f}}_{R}}{\tilde{f}_R}\right)^{\frac{1}{n+1}} - 4\Omega_\Lambda a^2,
\end{equation}
where $\tilde{f}_R \equiv f_R$ and $\tilde{\bar{f}}_R\equiv\bar{f}_R(a)$ is the background value of $f_R$. 
The Newtonian force is still given by Eq.~\eqref{eq:F_N_codeunit} with $\tilde{\Phi}_{\rm N}$ governed by Eq.~\eqref{eq:GR_poisson_codeunit}. On the other hand, the fifth force in code unit can be written as
\begin{equation}\label{eq:F5_fR_codeunit}
\tilde{\boldsymbol{F}}_5 = \frac{1}{2}\tilde{c}^2\tilde{\boldsymbol{\nabla}}\tilde{f}_R,
\end{equation}
It is more convenient to define the following new, positive-definite, scalar field variable \cite{Bose:2016wms}
\begin{equation}\label{eq:fR_u}
    u \equiv (-{f}_R)^{1/(n+1)},
\end{equation}
where the minus sign is because $f_R<0$. Eq.~\eqref{eq:fR_eom_codeunit1} then becomes
\begin{equation}\label{eq:fR_eom_codeunit2}
    -\tilde{c}^2\tilde{\boldsymbol{\nabla}}^2\left(u^{n+1}\right) + \frac{\Omega_{\rm m}}{a}\delta + \frac{1}{3}\tilde{\bar{R}}(a)a^2  - \frac{1}{3} \tilde{\bar{R}}(a)a^2\left[-\bar{f}_R (a)\right]^{1/(n+1)}\frac{1}{u} = 0,
\end{equation}
where we have defined the following dimensionless background quantity:
\begin{equation}
    \tilde{\bar{R}}(a) \equiv \frac{\bar{R}(a)}{H_0^2} = 3 \qty(\Omega_{m} a^{-3} + 4\Omega_\Lambda),
\end{equation}
with $\bar{R}(a)$ being the background value of the Ricci scalar at scale factor $a$. Eq.~\eqref{eq:fR_eom_codeunit2} can be further simplified to
\begin{equation}\label{eq:fR_eom_codeunit}
    u^{n+2}_{i,j,k} + p u_{i,j,k} + q = 0,
\end{equation}
where 
\begin{eqnarray}
    p &\equiv& \frac{h^2}{6 \tilde{c}^2}\left[\frac{\Omega_{\rm m}}{a}\delta_{i,j,k} + \frac{1}{3} \tilde{\bar{R}}(a)a^2\right] - \frac{1}{6}L_{i,j,k},\\
    q &\equiv& -\frac{h^2}{6\tilde{c}^2}\frac{1}{3} \tilde{\bar{R}}(a)a^2\left[-\bar{f}_R(a)\right]^{1/(n+1)}
\end{eqnarray}
where $L_{i,j,k}$ was defined in Eq.~\eqref{eq:Lijk}, and we have neglected the tilde in $\tilde{\bar{f}}_R(a)$ because $\tilde{\bar{f}}_R=\bar{f}_R$ anyway.

Eq.~\eqref{eq:fR_eom_codeunit} is a polynomial for $u_{i,j,k}$, which can be analytically solved for the cases of $n=0$, $1$ and $2$. The case of $n=1$ has been discussed in Ref.~\cite{Bose:2016wms}, while cases of $n=0,2$ have not been studied before using nonlinear Gauss-Seidel schemes\footnote{The case of $n=2$ has been studied using simulations based on Newton-Gauss-Seidel relaxation \cite[e.g.,][]{Li:2011uw}.}. Here we discuss all three cases with equal details.

\begin{itemize}
    \item {\underline{\textbf{The case of} $n=2$}} 

    In this case, Eq.~\eqref{eq:fR_eom_codeunit} is a quartic equation of $u_{i,j,k}$. Define 
    \begin{eqnarray}
    \Delta_0 &\equiv& 12q,\nonumber\\ 
    \Delta_1 &\equiv& 27p^2.
    \end{eqnarray} 
    We see that $q<0$ and so $\Delta_0<0$ and $\Delta_1>0$. Eq.~\eqref{eq:fR_eom_codeunit} has 4 branches of analytical solutions:
    \begin{eqnarray}
    \label{eq:branch1}u_{i,j,k} &=& -S \pm \frac{1}{2}\sqrt{-4S^2+\frac{p}{S}},\\
    \label{eq:branch2}u_{i,j,k} &=&  S \pm \frac{1}{2}\sqrt{-4S^2-\frac{p}{S}},
    \end{eqnarray}
    where we have defined
    \begin{eqnarray}
    S &\equiv& \frac{1}{2}\sqrt{\frac{1}{3}\left(Q+\frac{\Delta_0}{Q}\right)},\nonumber\\
    Q &\equiv& \sqrt[3]{\frac{1}{2}\left[\Delta_1+\sqrt{\Delta_1^2-4\Delta_0^3}\right]}.
    \end{eqnarray}
    We need to find the correct branch of solution. First, note that $S$ is a square root, and so we can show that if the quantity under the square root is a positive number, then $S>0$. This is straightforward, as.
    \begin{equation}
    12S^2 = Q + \frac{\Delta_0}{Q} = \sqrt[3]{\frac{1}{2}\left[\sqrt{\Delta_1^2-4\Delta_0^3}+\Delta_1\right]} - \sqrt[3]{\frac{1}{2}\left[\sqrt{\Delta_1^2-4\Delta_0^3}-\Delta_1\right]} > 0,
    \end{equation}
    
    Consider first the limit $p\rightarrow0$. From the above equation we have
    \begin{equation}
    12S^2 \approx \sqrt[3]{\left(-\Delta_0\right)^{3/2}+\frac{1}{2}\Delta_1} - \sqrt[3]{\left(-\Delta_0\right)^{3/2}-\frac{1}{2}\Delta_1} \approx -\frac{1}{3}\frac{\Delta_1}{\Delta_0} = -\frac{3}{4}\frac{p^2}{q},
    \end{equation}
    which means that $S\simeq |p|\rightarrow0$ but $p/S \rightarrow \pm4\sqrt{-q}$ depending on the sign of $p$. This leads to the solution $u_{i,j,k}=\sqrt[4]{-q}$.
    
    Given that $S>0$, if $p>0$, Eq.~\eqref{eq:branch2} cannot be the physical branch because $u_{i,j,k}$ in this branch is complex. The `$-$' branch of Eq.~\eqref{eq:branch1} cannot be chosen either, because $u_{i,j,k}<0$, inconsistent with the requirement that $u_{i,j,k}>0$.
    
    If $p<0$, Eq.~\eqref{eq:branch1} cannot be the physical branch because $u_{i,j,k}$ in this branch is complex. Out of the two branches of Eq.~\eqref{eq:branch2}, we should choose `$+$', because this guarantees that when $p\rightarrow0^-$ we still have $u_{i,j,k}>0$.
    
    Therefore, the analytical solution can be summarised as
    \begin{align}\label{eq:fR_quartic_solns}
        u_{i,j,k} = \begin{cases}
            \displaystyle -S+\frac{1}{2}\sqrt{-4S^2+\frac{p}{S}}, & p>0, \\
            \displaystyle \sqrt[4]{-q}, & p=0, \\
            \displaystyle S+\frac{1}{2}\sqrt{-4S^2-\frac{p}{S}}, & p<0.
        \end{cases} 
    \end{align}
    Note that it can be shown that $8S^3<|p|$ because $\Delta_1=27p^2$ and $\Delta_0=12q<0$. This fact guarantees that in Eqs.~\eqref{eq:fR_quartic_solns} the square roots are real; it also guarantees that in the $p>0$ branch the condition $u_{i,j,k}>0$ is satisfied (in the $p<0$ branch it is satisfied automatically). 
    
    The existence of analytical solutions Eq.~\eqref{eq:fR_quartic_solns} indicates that, like in the symmetron model, in the $n=2$ case of $f(R)$ gravity here, it is not necessary to use the Newton approximation within the Gauss-Seidel relaxation, but the solution $u_{i,j,k}$ of cell $(i,j,k)$ can be solved given the density field in this cell and the approximate solutions of $u$ in the neighbouring cells. 
    
    \item {\underline{\textbf{The case of} $n=1$}} 
    
    In this case, Eq.~\eqref{eq:fR_eom_codeunit} is a cubic equation of $u_{i,j,k}$ \cite{Bose:2016wms}. Define $\Delta_0 \equiv -3p$, $\Delta_1 \equiv 27 q$ and the discriminant 
    \begin{equation}
        \Delta \equiv \Delta_1^2-4\Delta_0^3.
    \end{equation}
    We see that $q<0$ and so $\Delta_1<0$. The solution is given by
    \begin{align}\label{eq:fR_cubic_solns}
        u_{i,j,k} = \begin{cases}
            \displaystyle -\frac{1}{3}\left(C+\frac{\Delta_0}{C}\right), & \Delta>0, \\
            \displaystyle \sqrt[3]{-q}, & \Delta=0, \\
            \displaystyle -\frac{2}{3}\sqrt{\Delta_0}\cos\left(\frac{\Theta}{3} + \frac{2\pi}{3}\right), & \Delta<0,
        \end{cases} 
    \end{align}
    where 
    \begin{eqnarray}
        C &\equiv& \sqrt[3]{\frac{1}{2}\left[\Delta_1+\sqrt{\Delta_1^2-4 \Delta_0^3}\right]},\\
        \Theta &\equiv& \arccos \left(\frac{\Delta_1}{2\sqrt{\Delta_0^3}}\right).
    \end{eqnarray}
    Again, the exact analytical solutions given in Eq.~\eqref{eq:fR_cubic_solns} eliminates the need for Newton-Gauss-Seidel relaxations, and this has led to a significant improvement in the speed and convergence properties of simulations of this model compared with previous simulations \cite{Bose:2016wms}.
    
    \item {\underline{\textbf{The case of} $n=0$}} 
    
    In this case, Eq.~\eqref{eq:fR_eom_codeunit} is a quadratic equation of $u_{i,j,k}$. The solution in this case is simple and the physical branch is given by
    \begin{equation}\label{eq:fR_quadratic_solns}
        u_{i,j,k} = \frac{1}{2}\left[-p+\sqrt{p^2-4q}\right],
    \end{equation}
    which satisfies $u_{i,j,k}>0$.
    
\end{itemize}

