% !TEX root = DistrSeqCtrlAttacks_TASE19.tex

%
\begin{figure*}[t]
	\centering
	\includegraphics[width=0.98\textwidth]{CIPNtoTPN.pdf}
	\caption{Transformation between CIPN-based and TPN-compatible communication models; (a) a Tx/Rx place/transition pair in the CIPN formalism; (b) the same Tx/Rx place/transition pair modeled with as a TPN adjusted to the half-duplex, acknowledge-required unicast CSMA-CA-based channel, whose model is shown in (c); (d) model of the employed radio transceiver (i.e., the governing RF state machine TPN model). Note that each Tx/Rx net pair in (a) (from the model in Fig.~\ref{fig:modeling}(a)) is extended into a corresponding pair in (b), while only a single model from (c) and (d) are added to obtain the model from Fig.~\ref{fig:modeling}(b).}
	\label{fig:CIPNtoTPN}
\end{figure*}
%


\section{Security-Aware Modeling of the Channel  and Controller-Channel Interaction}
\label{subsec:channelAndCtrlChannelInteraction}

%We  now discuss how to complete the transformation of the controller model into a model from Fig.~\ref{fig:modeling}(b), by also capturing a suitable controller-channel interface (extracted from the transceiver specifications) that is compatible with a security-aware channel model. Specifically,
We now introduce a security-aware channel model, including a TPN-compliant controller-channel interface that enables model composition. Hence, we address modeling challenges to enable the transition from the security-agnostic model structure from Fig.~\ref{fig:modeling}(a), to the security-aware model composition shown in Fig.~\ref{fig:modeling}(b). We start by defining the attack model.

\subsection{Attack Model}
\label{subsec:attackModel}
%In this work, we
We assume %presence of
a powerful network-based adversary that:
\begin{enumerate}
  \item Has the full knowledge of the distributed system, %i.e., has access to the same CIPN controller models that are used to generate control code,
  including the CIPN models, generated code and analysis framework, as well as  the current state of all LCs (and their transceivers).
  \item Has network access and full communication protocol compliance, i.e., is able to transmit unsigned messages as any of the LCs, or intercept messages or %acknowledgement (ACK) packets
ACKs exchanged by~LCs,
  \item Is able to precisely time actions and align transmissions with legitimate network traffic, e.g., to interfere with legitimate messages by transmitting the carrier signal or a protocol-compliant message.
%  \item Has full access to the current state of the system, i.e., has knowledge of the current state of all LCs (and their transceivers).
\end{enumerate}

Thus, the adversary may mount the following attacks:
\begin{enumerate}
  \item \emph{Interception or delaying of legitimate packets (DoS):} With these attacks, adversarial transmissions occupy the channel (a)~blocking transmissions %initiated by
  from legitimate LCs to prevent or delay their access to the network, % access of the targeted LCs,
  or (b)~blocking ACKs on legitimate LC's transmissions to cause unnecessary retransmissions and slow down progression of the targeted transmitter~\cite{wirelessattack}.

  \item \emph{ACK spoofing:} The attacker may impersonate an ACK expected by a legitimate transmitter; e.g., following by interception of the transmission, the attacker may spoof the ACK misleading the legitimate transmitter into believing that the transmitted signal was received by the intended receiver~\cite{802.15.4auth}, both for regular and `heartbeat'/sync messages~\cite{ackattack1}.%\PA{@Vuk: check, new wording instead of old " Alternatively, the attacker may mislead a transmitter that the intended receiver of a packet is alive by spoofing the ACK~\cite{ackattack1}."}

  \item \emph{Impersonation/Masquerade:} %This type of attack pertains to an
  The adversary may transmit false event signals on behalf of a legitimate LC (i.e., impersonating another controller), with the goal to inject false commands~\cite{802.15.4auth} or sensor measurements; such attacks could e.g., allow the targeted receiver to resume execution while it is blocked waiting for %reception of
  an event signal, before the event %is physically attainable (i.e., before
   it is sent by the legitimate LC.

  \item \emph{Signal replacing/Message modification:} The adversary may modify content of a legitimate message %with the intention
  to deliver false event information. While logically the same, the attack procedure differs from intercepting a legitimate transmission followed~by a masquerading attack~\cite{ackattack2}, and thus is modeled~differently.\footnote{This type of attack is technically more challenging to perform compared to other attacks, especially over a wireless medium.}

  \item \emph{Replay attack:} The attack characterizes an adversary that records events signaled by the LCs and replays the sequence of events on behalf of one or more LCs; thus, maliciously emulating activity of LCs whose operation (s)he is interfering with~\cite{ackattack2}.% \todo{@Vuk: a ref in indusrial setup would be good}
\end{enumerate}

The above attack set, considered in this work, covers all reported attacks that, from the standpoint of low-level signaling of events, could have direct impact on Quality-of-Control (QoC) of the underlying physical process~\cite{wang_arxiv19,wirelessControl}. %\todo{@Vuk - fix}
%this attack models is adequate.~\cite{wirelessControl} \todo{@Vuk - fix}
Other attacks, such as attacks on {network routing policies}, are focused on higher-level information flows and are thus harder to directly relate to automation QoC~\cite{ackattack2}. Consequently, our goal is to model attacks by capturing their influence~on~the sequential control system and the resulting QoC, rather than the employed attack vector for any specific attacks; i.e., the attack model should be agnostic to the actual attack implementation.

\subsection{TPN-Based Modeling of Attack Impact}

Recall that CIPN models rely on platform-provided communication APIs for passing events between LCs; e.g., as in Fig.~\ref{fig:CIPNtoTPN}(a),
\verb!Send(destination,signal=value)! command within a place sends the updated \verb!value! of \verb!signal! to the \verb!destination! LC, while condition \verb!signal==value! on a transition within the model blocks execution until the signal corresponding to the desired value is received over the network. % (as shown in Fig.~\ref{fig:CIPNtoTPN}(a)).
To %solve the main challenge towards security-aware analysis, i.e.,
enable formal analysis of the attack impact on QoC of distributed automation, it is necessary to develop a TPN-compliant model of the interface (i.e., transceiver) between the controller and security-aware channel model; such model can be then composed with the TPN-based models described in Section~\ref{subsec:plantAndControllerInteraction}, % and \ref{sec:runtimemodel},
resulting in Fig.~\ref{fig:modeling}(b) architecture.

{
%There exist three main challenges to security-aware distributed automation modeling; i.e., a
Such security-aware formal model has to capture:
(1)~application-level (i.e., controller side) communication stack behavior, directly affected by
(2)~the channel-side (i.e., communication medium) attack model, and
(3)~the controller-channel interface.
%\end{enumerate}
Specifically, application-level (i.e., control-related) communication stack behavior, such as delays or blocking on communication peripheral resources, is of interest for security analysis, as this presents the main reflection of the communication-level attacks onto the control functionality. Therefore, when translating the CIPN communication model from Fig.~\ref{fig:CIPNtoTPN}(a) into a TPN-compliant model, it is necessary to capture application software states that directly affect progress of the control functionality, conditioned by data dependencies resolved via communication. Such models can be obtained from the actual application firmware running on the embedded LCs (i.e., source code). For example, when IEEE~\mbox{802.15.4} protocol is used, as in the case study presented in Sec~\ref{sec:evaluation}, the state-machine/TPN representation can be directly extracted from the radio driver (as done in Fig.~\ref{fig:CIPNtoTPN}(b)).
On the other hand, if more complex communication stack is considered (i.e., implementing higher communication layers), exiting state-machine extraction techniques (e.g.,~\cite{soteria}) can be employed.

Second, the channel model has to explicitly capture the channel states essential for supporting the attack models presented in Section~\ref{subsec:attackModel}---channel states that are not observable (or alterable) need not be modeled (e.g., bit-level signaling, or carrier-level modulation). Finally, a TPN-compliant interface between the controller and security-aware channel models is needed to allow for their formal composition, %of the controller and channel models
enabling system-level analysis of adversarial influence on the entire system. Therein, specific data link layer (OSI model layer 2) features are crucial for understanding retransmissions and ACK mechanics which, as we will show, affects design of attack detectors. Therefore, while controller models should capture application-level communication semantics, it is also necessary to include protocol-level details within the transceiver (XCVR) models, which act as the interface between the controllers and the medium (as shown in Fig.~\ref{fig:modeling}(b)). XCVR specifics are commonly available for the specific employed radio communication chip as RF circuitry control is usually state-machine based (e.g.,~referred to as the \emph{internal RF state machine}~\cite{mrf} in the case of radios used in our implementation).



On the other hand, explicit security-aware channel modeling is \emph{medium-, protocol-, and attack-dependent}. Fig.~\ref{fig:CIPNtoTPN}(c) and Fig.~\ref{fig:attackModels} show a security-aware model of a \emph{half-duplex, acknowledge-required unicast CSMA-CA-based communication channel} with respect to the previously defined attack model. While other medium/protocol variants can be easily modeled due to the expressiveness of TPNs, we consider this specific model as it applies to our physical setup described later in Section~\ref{sec:evaluation}. In the remaining of this section, we describe the transformation from the CIPN-based LC communication model to a TPN-compliant model assuming the aforementioned channel, while aiming to balance between the model expressiveness and capturing security-aware behavior required for analysis of QoC under attack.
}

%\todo{why is this here? you tell one story, high level list of things that need to be done, and all of a sudden there is a model of something that you didn't talk much about + what is `security-aware' here?}
%\todo{In general, I have troubles following this section, and how it relates to Fig. 5a, and 4a; After next subsection it goes better; what is also somewhat unclear here is what are the main challenges}




\begin{table}[t]
  \centering
    \begin{tabular}{p{1.6cm}|p{5.4cm}|p{0.4cm}}
      % after \\: \hline or \cline{col1-col2} \cline{col3-col4} ...
      Symbol & Description & SW acc.\\ \hline\hline
      \verb!ChBusy! & Indicator whether the channel is currently busy with a packet or ACK & YES \\ \hline
      \verb!N_RxBuf! & Local Rx buffer & YES \\ \hline
      \verb!N_RxAck! & Local flag indicating successful transmission, i.e., ACK reception & YES \\ \hline
      \verb!NXCVR_PTx! & Transceiver Tx payload buffer & YES \\ \hline
      \verb!NXCVR_PRx! & Transceiver Rx payload buffer & YES \\ \hline
      \verb!NXCVR_Tx! & Signal to XCVR initiating transmission & YES \\ \hline
      \verb!NXCVR_Txd! & Signal to XCVR indicating transmission & NO \\ \hline
      \verb!NXCVR_Rx! & Signal from XCVR indicating reception & YES \\ \hline
      \verb!NXCVR_TxAck! & XCVR signal initiating ACK transmission & NO \\ \hline
      \verb!NXCVR_RxAck! & XCVR signal indicating ACK reception & NO \\ \hline
      \verb!NXCVR_TxCnt! & XCVR retry counter & NO \\ \hline
      $\underline{t}_{Tx}^{Msg},\overline{t}_{Tx}^{Msg}$ & Message transmission time (bounds) & --- \\ \hline
      $\underline{t}_{Tx}^{Ack},\overline{t}_{Tx}^{Ack}$ & ACK transmission time (bounds) & --- \\ \hline
      $\underline{t}_{Tx}^{Boff},\overline{t}_{Tx}^{Boff}$ & Back-off time (bounds) & --- \\ \hline
      $t_{Tx}^{AckTO}$ & Data link layer ACK timeout & --- \\ \hline
      $t_{wfAck}$ & Application-level ACK timeout & --- \\ \hline
      $\underline{t}_{Ch}^{DoS},\overline{t}_{Ch}^{DoS}$ & Contention time due to DoS (bounds) & --- \\ \hline\hline
    \end{tabular}
  \caption{Symbols used in Fig.~\ref{fig:CIPNtoTPN} and Fig.~\ref{fig:attackModels}; third column (where applicable) indicates accessibility to application software (or only to the transceiver's internal RF state machine).}\label{tab:CIPNtoTPNsymbols}
\end{table}
%

\subsection{Security-Aware Modeling of the Channel and Controller-Channel Interaction}

Fig.~\ref{fig:CIPNtoTPN}(b) shows the TPN transmitter/receiver models that replace the platform-independent CIPN transmitter/receiver model in Fig.~\ref{fig:CIPNtoTPN}(a). Fig.~\ref{fig:CIPNtoTPN}(c) shows the nominal channel model (i.e., without adversarial influences), while Fig.~\ref{fig:CIPNtoTPN}(d) shows the transceiver (XCVR) model. Notice that both $LC_A$ and $LC_B$ have identical transceivers; thus, $N\in\{A,B\}$ in place/transition names. Table~\ref{tab:CIPNtoTPNsymbols} enumerates symbols (local flags, variables, and transition timing parameters) used in the models in Fig.~\ref{fig:CIPNtoTPN},~\ref{fig:attackModels}. The internal RF state machine can be in the \emph{listening}, \emph{transmitting a packet}, \emph{waiting for acknowledgement}, or \emph{transmitting an acknowledgement} states. The transceiver employed in our case study (in Sec.~\ref{sec:evaluation}), performs up to three retransmissions before signaling a transmission failure to the application. On the application level, an unbounded number of retransmissions are performed in case the transceiver returns failure. The TPN model in Fig.~\ref{fig:CIPNtoTPN}(b-d) models this interaction.


%%%% SOME DETAILED EXPLANATIONS GOING THROUGH THE NETS ARE HERE---KEEP HERE
%Initially, when the receiver's (i.e., $LC_B$'s) token is deposited into place \verb!Pb_wfRx!, the receiver is blocked on transition \verb!Tb_wfRx! waiting to receive signal \verb!s! with value \verb!1! (i.e., transition is guarded by receive buffer condition \verb!G:B_RxBuf==1!). On the other hand, the clear channel assessment (CCA) is performed by the transmitter ($LC_A$), when its token is deposited into the place \verb!Pa_wfTx!. If the channel is not busy (i.e., guard \verb!G:ChBusy==0! on transition \verb!Ta_wfTx! is true), the transmitter's token transitions to place \verb!Pa_wfAck!, where a transmission of signal \verb!s! with value \verb!1! is initiated (i.e., XCVR transmit payload buffer is initialized (\verb!U:AXCVR_PTx=1!) and transmission is initiated (\verb!U:AXCVR_Tx=1!)). As a result of the initiated transmission, after a random back-off time in the range $[\underline{t}_{Tx}^{B-off},\overline{t}_{Tx}^{B-off}]$ elapses, $LC_A$'s XCVR transitions from \emph{listen} to \emph{transmit} mode (i.e., \verb!PaXCVR_Tx!). Consequently, the transition \verb!Tch_wfTx! in the channel model is enabled and fires; message transmission takes non-deterministic time in the range $[\underline{t}_{Tx}^{Msg},\overline{t}_{Tx}^{Msg}]$, after which the channel can return to the idle place (i.e., transition over \verb!Tch_TxMsgFin! back to \verb!Pch_Idle!). This enables $LC_A$'s XCVR to switch to waiting for the ACK, while internally increasing the number of retransmissions (through update function \verb!U:AXCVR_TxCnt++!). An ACK is expected within the timeout $[t_{Tx}^{AckTO},t_{Tx}^{AckTO}]$.
%
%On the other hand, $LC_B$'s XCVR
%
%
% as the channel is declared busy and $LC_A$ has released the packet to the radio (i.e., \verb!G:M(Pa_wfAck)==1! is satisfied). $LC_A$ dwells in \verb!Pa_wfAck! until either the acknowledgement packet is successfully received on the transition \verb!Ta_ackSucc! (i.e., guard \verb!G:A_RxAck==1! becomes satisfied), or a timeout transition \verb!Ta_ackFail! fires (i.e., $t_{wfAck}$ elapses) after which the transmission is retried. The channel model now dwells in \verb!Pch_TxMsg!.
%
%The message transmission takes non-deterministic time in the range $[\underline{t}_{Tx}^{Msg},\overline{t}_{Tx}^{Msg}]$, after which the channel can return to the idle place (i.e., transition over \verb!Tch_TxMsgFin! back to \verb!Pch_Idle!), triggering update functions that mark $LC_A$'s transmission as finished, update channel state, and allow $LC_B$ to use the transmitted signal (i.e., \verb!G:A_sTxd=1!, \verb!ChBusy=0!, and \verb!B_sRx=A_sTx!, respectively). Consequently, $LC_B$ is no longer blocked on \verb!Tb_wfRx! as \verb!G:B_sRx==1! is satisfied (i.e., signal \verb!s==1! is received), and can acknowledge reception and continue execution. When $LC_B$ transitions over \verb!Tb_wfRx!, the channel is immediately set to busy and the ACK transmitted (via update functions \verb!U:ChBusy=1! and \verb!U:B_TxAck=1!), as CCA is not performed for ACK packets. As a result, \verb!Tch_wfAck! is enabled and the channel becomes busy transmitting the ACK by transitioning to place \verb!Pch_TxAck!. The ACK transmission takes non-deterministic time in the range $[\underline{t}_{Tx}^{Ack},\overline{t}_{Tx}^{Ack}]$, after which the channel returns to place \verb!Pch_Idle!, when update functions are invoked updating channel state, and variable \verb!A_RxAck! allowing the transmitter to resume execution.
%
%Nominally, the ACK process takes less than $t_{wfAck}$, and thus $LC_A$ successfully receives the ACK; it consequently transitions over \verb!Ta_ackSucc! as guard \verb!G:A_RxAck==1! is satisfied, which concludes the transmission process. Notice that $LC_A$'s local variable \verb!A_sTxd! (which is initially \verb!0!, is set in the channel model when $LC_A$'s message is transmitted, and reset by $LC_A$ when an ACK is not received) is not needed but will be used in Sec.~\ref{subsubsec:attackModeling} when attacks are introduced. Additionally, initial values of all model variables are \verb!0!. In the following, we show how this communication model can be extended to include adversarial influences defined in Sec.~\ref{subsec:channelAndCtrlChannelInteraction}.
%%%% SOME DETAILED EXPLANATIONS GOING THROUGH THE NETS ARE HERE---KEEP HERE

%
\begin{figure*}[t]
\vspace{-10pt}
	\centering
	\includegraphics[width=0.98\textwidth]{attackModels.pdf}
	\caption{Additional places, transitions, and arcs required to obtain a security-aware channel model for different attack types: (a) DoS, (b) ACK intercept/spoof, (c) message modification, and (d) masquerade. All attack-related components of the model are depicted in red color, while nominal components are shown partially for completeness in black (where relevant).}
	\label{fig:attackModels}
\end{figure*}
%
%\subsubsection{Attack Modelling}
%\label{subsubsec:attackModeling}
%
In the remaining of this section, we show how  the attacks described in Section~\ref{subsec:channelAndCtrlChannelInteraction} can be modeled as TPNs. Specifically, we describe additional places, transition, and arcs to be added to the nominal channel model shown in Fig.~\ref{fig:CIPNtoTPN}(c) to capture the attacks. To enhance model readability, Fig.~\ref{fig:attackModels} depicts only additional places and transitions in red color required to model a specific attack, while the nominal places and transitions are depicted in black (all parts of the nominal model not relevant for the specific attack are omitted therein).

%%%
%%%
%%%
\paragraph{DoS attack submodel} Fig.~\ref{fig:attackModels}(a) shows the DoS attack submodel. When the channel is idle, the attacker may decide to occupy the channel to prevent legitimate transmissions. He/she may do so at any time (non-deterministic choice) when the channel is not busy, and keep the channel busy arbitrarily long. In the model, the channel is kept busy for some non-deterministic time in the range $[\underline{t}_{Ch}^{DoS},\overline{t}_{Ch}^{DoS}]$, after which it is released by the attacker.% Packet and ACK interceptions are included in the following submodels.

%%%
%%%
%%%
\paragraph{ACK interception/spoofing submodel} Fig.~\ref{fig:attackModels}(b) shows the ACK intercept/spoof submodel. To model ACK interception, an additional transition is needed allowing the channel to return to idle state following ACK transmission, without the transmitter ($LC_A$) receiving the ACK sent by the receiver ($LC_B$); i.e., transition \verb!Tch_TxAckInt! is added as shown in Fig.~\ref{fig:attackModels}(b), and is \emph{not} associated with the update function \verb!U:BXCVR_RxAck=1!.
However, when ACK spoofing is considered, the attacker may transmit an ACK when the targeted receiver \emph{is not} in the process of acknowledging, while the targeted transmitter \emph{is} in the process of waiting an ACK.

Additionally, malicious ACK spoofing may be performed when the signal to which the ACK is intended to correspond is transmitted already, but the ACK has not yet been received by the sender (e.g., due to an intercepted ACK from the legitimate receiver). This is enabled with the additional net branch in Fig.~\ref{fig:attackModels}(b) starting with transition \verb!Tch_wfAckImp!. As a result of firing of this transition, the channel is declared busy and the spoofed ACK is assumed to take the same time as transmitting legitimate ACKs; thus,  the transition \verb!Tch_TxAckImp! has the same attributes as \verb!Tch_TxAck!, with the exception of the signal to the targeted transmitter signalling ACK transmission is done (i.e., update \verb!U:AXCVR_RxAck=1! is omitted).

%%%
%%%
%%%
\paragraph{Message intercept/modify submodel} Fig.~\ref{fig:attackModels}(c) shows the message intercept/modify submodel, where an additional transition \verb!Tch_TxMsgMod! (\verb!Tch_TxMsgInt!), {represented as one transition for conciseness}, is added. In the case of the modification attack, this transition in the model allows the attacker to deliver a signal different form the one originally transmitted (i.e., \verb!U:BXCVR_PRx=Pmod! where \verb!Pmod! is the payload modified by the attacker). In the case of packet interception, no update to the receiver's XCVR receiver buffer is made, and consequently the XCVR is not notified of a received packet (i.e., update functions are omitted and denoted as \verb!(.)! in Fig.~\ref{fig:attackModels}(c)).


%%%
%%%
%%%
\paragraph{Message impersonation submodel} Fig.~\ref{fig:attackModels}(d) presents the masquerade submodel. The additional transitions and places allow the attacker to make a non-deterministic choice to impersonate transmission of the expected transmitter whenever the channel is not busy, the targeted receiver is waiting for the corresponding signal, and the original transmitter is not in the process of sending this signal. Then, similarly to the nominal (legitimate) transmission model (shown in Fig.~\ref{fig:CIPNtoTPN}(c)), the transmission takes a non-deterministic time in the same range as legitimate transmissions. Note that the received payload on $LC_B$ is in this case the value \verb!Pinj! crafted by the attacker, rather than \verb!AXCVR_PTx!, normally transmitted by $LC_A$ in the adversary-free case.


%%%
%%%
\begin{remark}[Replay attacks]
Due to the introduced non-determinism, any specific sequence of attack actions are contained within the presented model (as long as the individual actions correspond to the attack model from Section~\ref{subsec:channelAndCtrlChannelInteraction}). Thus, replay attacks are covered by the presented model as they are only specific executions of the presented security-aware channel model. On the other hand, using a similar approach, finite memory replay attacks can be captured by a model that restricts inserted attack signals only to the previously transmitted messages, as done in~\cite{wang_arxiv19}.\QEDE
\end{remark}
%%%
%%%
\begin{remark}[Controller-plant VS. controller-channel interface modeling fidelity]
Control interface to the channel is modeled in far more detail than the interface to the plant, by abstracting away locally-connected actuator drives, relays, analog amplifiers, etc. The reason is that, in this work, we do not consider physical plant-level attacks. Hence, modeling the controller-plant interaction at a lower level of abstraction would unnecessarily increase model complexity. However, the presented techniques can be easily extended and the framework fully adapted to also cover physical attacks on the plant.\QEDE
\end{remark}
%%%
%%%

















%\subsection{Controller Runtime State Modeling}
%Finally, the last remaining construct in the CIPN-based controller model to be made TPN-compliant are places issuing system calls provided by the runtime environment (e.g., execution delay) or updating local controller state (e.g., manipulating global variables). Execution delays requested from the runtime environment can easily be modeled as timed transition with exact firing time (i.e., where the lower and upper firing time bound are the same, as in the example for ACK timeout). While in this work we consider single-threaded sequential automation examples, existing techniques for modeling parallel systems can be applied given the rich expressiveness of TPNs~\cite{CIPNtoTPN}. For example, in the case of multithreaded applications where task preemption is allowed, the operating system scheduler can be modeled as a separate component, even in the case of multi-processor platforms~\cite{TPNscheduling}. %or the upper bound on the firing time of a specific transition adjusted to include worst-case blocking time incurred from other lower-priority workload~\cite{}.
%%
%On the other hand, definition of global variables and functions is supported by state-of-the-art TPN tools (e.g.,~\cite{romeo}). Update functions that are invoked on firing of the transition to which the function is assigned and guard functions are generally not only marking- but also global variable-dependent, which allows for rich modeling of complex internal LC state updates, similarly as used to implement the controller-plant and controller-channel interface in Sec.~\ref{subsubsec:controllerPlantInteraction}~and~\ref{subsec:channelAndCtrlChannelInteraction}. 