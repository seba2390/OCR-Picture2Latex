% !TEX root = DistrSeqCtrlAttacks_TASE19.tex

%\PA{@Vuk: in \figref{exampleCIPN}, put the current (c) part on top and (a) and (b) below + adapt the references in the text accordingly}

\section{Motivating Example and Problem Description}
\label{sec:motivation}
%Building secure and correct-by-design RMS necessitates efficient techniques for systematic security analysis of distributed control applications deployed on IIoT-enabled local controllers (LCs). While a plethora of formal modeling frameworks is employed under the umbrella of IoT (e.g.,~\cite{iotsat,iotz3,iotautomata}), industrial automation is commonly based on GRAFCET (IEC~60848)/SFC (IEC~61131-3) control design, and consequently on the underlying formal semantics of Control Interpreted Petri Nets (CIPN). Therefore, in this paper we focus on security analysis of IIoT-enabled controllers formally described using CIPNs.

We first introduce CIPNs and the mother formalism of PNs, before presenting an illustrative distributed control application, used as a running example in this work to highlight security vulnerabilities caused by automation (i.e.,~control)~distribution. %We then show how to introduce a security-aware communication channel model along with suitable plant models, and base them on Time Petri Nets (TPN); we transform the CIPN-based controller representation into a TPN-compliant model to obtain a system-level security-aware model of the cyber-physical system. We use the composition of the controller, plant, and channel models to show violation of relevant safety properties in the presence of attacks, and demonstrate how inclusion of security services affects modeling and verification.

%
\begin{figure}[!t]
%\vspace{-16pt}
	\centering
	\includegraphics[width=0.462\textwidth]{exampleCIPN.pdf}
	\caption{Distributed Automation Example: Simple CIPN-based distributed control model of (b) conveyor monitor~and (c)~pick~\&~place controller; physical setup is illustrated in~(a).}
	\label{fig:exampleCIPN}
\end{figure}


\subsubsection*{Petri Nets (PNs)}
A Petri net is a 5-tuple $\mathbf{PN}=(P,T,F,W,M_0)$, where $P=\{P_1,...,P_m\}$ is a set of places (represented by circles), $T=\{T_1,...,T_n\}$ is a set of transitions (represented by bars) such that $P\cup T \neq \emptyset$ and $P\cap T = \emptyset$, while $F\subseteq\{P \times T\}\cup \{T\times P\}$ is the set of arcs between places and transitions (no arc connects two places or two transitions). $W$ is the vector of arc cardinalities which determines how many tokens are removed/deposited over specific arcs upon firing of corresponding transitions. The $\mathbf{PN}$'s state  is defined by its \emph{marking}, i.e., distribution of tokens (captured by dots inside places); $M_0$ is the initial marking (i.e., the initial token distribution). Functionally, current PN marking determines the system's state, while transition firing (i.e., token flow) represents a state change. A formal description of the PN semantics can be found~in~\cite{Murata1989541}.

\subsubsection*{Distributed Automation with CIPNs}
CIPNs are a version of PNs where arc cardinality is fixed to $1$ and the initial marking $M_0$ may initialize only one place with a token. In CIPNs, transitions' firing can be conditioned by system inputs (i.e., sensors) in the form \verb!sensor==value!, while actuation commands can be associated with places in the form \verb!actuator=command!. For distributed automation, functionality of each local controller (LC) is captured by the corresponding CIPN.
For (event) information exchange between LCs, places of a CIPN may invoke the communication API exposed by the LC runtime environment; % to transmit event information,
this is denoted as \verb!Send(signal,value)! for broadcast or \verb!Send({dest1,dest2,...},signal,value)! for uni/multicast transmissions. Dually, the receiving LC can condition its transitions with statements similar to conditioning on locally connected sensors (i.e., as \verb!signal==value!)~\cite{jakovljevic_tcst19}.

Formally, a CIPN is a 6-tuple $\mathbf{CIPN}=(P,T,F,C, A, M_0)$ where $P$, $T$, $F$, and $M_0$ are defined as for PNs; $C=\{C_1,...,C_n\}$ is a set of logical conditions %(i.e., Boolean functions)
enabling synchronization of the controller with sensors by guarding corresponding transitions in the $\mathbf{CIPN}$ model; %within the controller model;
$A=\{A_1,...,A_m\}$ is a set of actions %(i.e., Boolean or other functions)
on actuator outputs that are allocated to places; formal CIPN semantics is available in~\cite{David20101}. By its definition, CIPN semantics is deterministic (does~not support nondeterminism due to CIPNs use to only model controllers), which needs to be ensured during model~design~\cite{david1994petri}. % -- this has not been a limitation, .\todo{Z/V - check}

Distributed CIPN-based controller models are obtained directly by design, or by distributing existing  (i.e., centralized) controllers % distribution techniques
(e.g.,~as done in~\cite{jakovljevic_tcst19}). %starting from a conventional (i.e., centralized)~design.
%
Fig.~\ref{fig:exampleCIPN} shows a simple control application, built with two wireless nodes, that we will use as a %{illustrative}
running example in this work. %We begin by describing the system, whose physical configuration is shown in Fig.~\ref{fig:exampleCIPN}(a)), while referencing the corresponding control model, shown in Fig.~\ref{fig:exampleCIPN}(b-c).



\begin{example}
\label{ex:motivation}
%As a motivating example,
Consider a simple application from~Fig.~\ref{fig:exampleCIPN}.
Control over the physical system (Fig.~\ref{fig:exampleCIPN}(a)) is performed by the conveyor monitor ($LC_1$) and the pick~\&~place station controller ($LC_2$). Two sensors (e.g.,~proximity, retro-reflective) locally connected to $LC_1$ overlook two parallel incoming conveyor belts; they sense if a workpiece is ready to be picked from either of the conveyors % (by the pick~\&~place station),
and placed on the third, outgoing conveyor.
The CIPN-based controllers %(i.e., their CIPN-based model/specification)
for $LC_1$ and $LC_2$ are shown in Fig.~\ref{fig:exampleCIPN}(b-c).
Initially, $LC_1$ is in state \verb!Pcm_Init! where it is waiting for either of %the locally connected
its sensors to indicate workpiece presence (i.e.,~transition \verb!Tcm_Pres1! / \verb!Tcm_Pres2! is conditioned by the sensing event \verb!Pres1==1! / \verb!Pres2==1!).\footnote{For model readability, we employ descriptive notation for~places, transitions, conditions, and actions; e.g., transition \verb!Tctrl_wfRet! in controller $LC_2$ waits for the return cycle to finish, while place \verb+Pcm_TxCtrl_Pick1+ on the conveyor monitor sends signal \verb+Pick==1+ to the pick~\&~place controller.} Upon detection of a workpiece (i.e.,~when one of %the conditions
\verb!Pres1==1! / \verb!Pres2==1! is satisfied, and thus transition \verb!Tcm_Pres1! / \verb!Tcm_Pres2! is enabled), $LC_1$ sends a message to $LC_2$ %(through communication
(via API call \verb!Send(Pick,1)! / \verb!Send(Pick,2)! in place \verb!Pcm_TxCtrl_Pick1! / \verb!..._Pick2!); % \verb!Pcm_TxCtrl_Pick2!);
the message %containing the corresponding signal indicating
indicates which conveyor has a workpiece ready to be picked. $LC_1$ then waits for completion of the pick~\&~place operation.

Concurrently, $LC_2$'s initial state is \verb!Pctrl_Init! where the pick~\&~place station is commanded to halt (by \verb!PP_Act=0!). Once the signal \verb!Pick! is received from $LC_1$, based on its value the token in $LC_2$ model transitions over \verb!Tctrl_wfPick1! / \verb!Tctrl_wfPick2! into place \verb!Pctrl_P&P1! / \verb!Pctrl_P&P2! where the corresponding actuation command is given to the pick~\&~place station (i.e.,~\verb!PP_Act=1! / \verb!PP_Act=2!). After completion of the pick~\&~place operation, condition \verb!P&P_Complete==1! is satisfied, allowing the $LC_2$ to transition over \verb!Tctrl_P&Pcomplete! / \verb!Tctrl_P&Pcomplete! to \verb!Pctrl_Ret! where it commands the pick~\&~place station to return to home position (by \verb!PP_Act=-1!). $LC_2$ waits for completion of the pick~\&~place station return stroke (when %condition
\verb!Ret_Complete==1! evaluates to true); after it transitions back into \verb!Pctrl_SendCMfin!, where it signals %conveyor monitor
$LC_1$ that the workcycle is complete. $LC_2$ transitions over \verb!Tctrl_RetInit! back into the initial place \verb!Pctrl_Init!.
%
Finally, conveyor monitor $LC_1$ can also return to its initial state (formally, the token is deposited back into \verb!Pbm_Init! over \verb!Tbm_RetInit1! / \verb!Tbm_RetInit2!), as the condition \verb!Complete==1! is satisfied.\QEDE
\end{example}

%On the other hand, this model assumes ideal communication packet delivery rates, and absence of unpredictable communication channel behaviors. For instance, consider that an adversary with network access mounts an \emph{impersonation} attack~\footnote{This type of attack is also known as \emph{masquerade} attack.} at the beginning of the workcycle when $LC_A$ is waiting in place \verb!PaCTRL_wfRxV_bHome1! to receive a message from $LC_B$ signalling that the workpiece is picked up and cylinder $B$ is retracted. If the adversary impersonates $LC_B$ and sends the corresponding message to $LC_A$ before the workpiece is gripped and cylinder $B$ retracted, the manipulator and currently handled workpieces may incur significant physical damage due to early extending of cylinder $A$. Another example would be an adversary \emph{delaying} or \emph{blocking} some transmissions or acknowledgements between controllers.\footnote{This type of attack is also known as Denial-of-Service (DoS) attack.} For instance, $LC_B$ informs $LC_C$ when cylinder $B$ reaches its end position, so that gripper $C$ can perform gripping/releasing of the workpiece. Since gripper $C$ does not feature end position sensing, and $LC_B$ deterministically waits for $500~ms$ for the gripping/releasing operation to be completed before resuming execution, an adversary delaying or blocking messages from $LC_B$ could cause $LC_C$ to not perform as expected, compromising system safety. These examples indicate that the system can be easily compromised in the case when distribution of control tasks is performed without implementation of suitable security measures.

The CIPN-based control models from Example~\ref{ex:motivation} assume ideal communication (i.e., packet delivery), without unpredictable %communication
channel behaviors. For instance, consider an adversary with network access that mounts an \emph{impersonation} (i.e., spoofing or masquerade~\cite{wirelessattack}) attack % ~\footnote{This type of attack is also known as \emph{masquerade} attack.}
when $LC_2$ is waiting for a message from $LC_1$ %signaling
that a workpiece should be picked up. By sending % If the adversary sends
the corresponding message (e.g., by signaling \verb!Send(Pick,1)!), the attack will result in the pick~\&~place station  being commanded pickup by $LC_2$; hence, it may collide with upcoming workpieces, potentially incurring mechanical damage, or just waste a workcycle. Similar %consequences
 holds for \emph{message modification}~\cite{wirelessattack} (i.e., signal replacement~\cite{DESsupervisoryControl}) attacks,
 when the right conveyor belt contains a workpiece ready to be picked up (i.e., \verb!Pres_R==1!), %but $LC_1$ maliciously signals \verb!Send(Pick,2).!
 but the attacker intercepts the corresponding message and maliciously signals \verb!Send(Pick,2)!. %\todo{but $LC_1$ maliciously signals !Send(Pick,2).! -- where is the attacker?} %\PA{actually this section misses attacker model}
Also, if an adversary \emph{delays} or \emph{blocks} some transmissions or acknowledgements (ACKs)~between LCs (i.e., launching a Denial-of-Service (DoS) attack~\cite{wirelessattack}) %. For instance, $LC_2$ informs $LC_1$ when the pick~\&~place cycle is completed; delaying this signal may result in
the system may experience excessive downtime.

These examples illustrate that distributing control and automation functionalities may introduce security vulnerabilities as the system operation can be easily affected by an attacker with network~access.
Hence, in this work, we focus on security aspects of % the discrete-event distributed industrial IoT systems
IIoT-enabled distributed automation systems; our goal is to provide techniques to model and analyze system behaviors in the presence of  \emph{network-based attacks}, while enabling the use of analysis results %of the provided analysis
to modify (i.e., update)) the system to achieve attack-resilient operation.

\subsection{Overview of our Approach}
We start from a functional description %(i.e., specification) for each
of $N$ LCs expressed by $\mathbf{CIPN}_i$, $i=1,...,N$. We consider an attacker with full access to the network with {$M$ communication channels}. %We also assume that
The attacker is not able to compromise LCs, but has full knowledge of the state of each~LC. %\todo{check}
%
We introduce a design-time methodology illustrated in Fig.~\ref{fig:methodology} that starts with automatic transformation of CIPN-based control models to Timed Petri Net~(TPN)-based models; such models allow for explicit capturing of (i)~the communication semantics, (ii)~platform-based effects using timed transitions to model real non-zero execution and message propagation times, and most importantly (iii)~non-deterministic behaviors necessary to model adversarial actions. %While inherent determinism of CIPNs does not present a limitation when the formalism is used to specify controllers' behaviors, it prevents the use of CIPNs to model malicious actions~\cite{wang_arxiv19}. On the other hand, TPN's support for nondeterminism, as well as availability of open verification tools (e.g.,~\cite{romeo}), makes them a great candidate for security-aware modeling.

%\todo{give an outline here}
We show how the remaining closed-loop system components (i.e., the plant and communication channel in the presence of attacks) can be modeled within the TPN formalism. Furthermore, we  demonstrate how composition of these models enables system-wide analysis of control performance in the presence of attacks. Finally, we show how design-time formal verification results can be used during code generation for smart IIoT-based controllers, which facilitates adaptation  of LCs' firmware in order to address exposed security~concerns. %Our framework is summarized in~Fig.~\ref{fig:methodology}.

\begin{remark}[Petri nets vs. Automata/Finite-State Machines]
%In this work, we
We employ Petri Net-based modeling formalisms since CIPNs are the main formalism used to capture existing (including distributed) automation  systems. % (including distributed systems).
For example, GRAFCET~(IEC~60848) and SFC (IEC 61131-3) languages for programming
industrial control systems originate from Petri Nets, with their behavioral equivalence discussed in~\cite{David20101,GRAFCETtoTPN,SFCtoTPN}.
However, %it is important to highlight that
the proposed methodology, including network and attack modeling, can be directly extended to other discrete-event IoT systems whose behavior can be captured with automata/finite-state machines due to the fact that formal mappings between semantics of Petri nets and automata have been defined (e.g.,~as in~\cite{PNtransformation1,PNtransformation2}).\QEDE
%  Intuitively, Petri nets present means for automatic state spaces/underlying state machine generation. Infinitely large state spaces can be compactly represented with Petri nets~\cite{bobbioPNs}, and translation semantics between Petri nets and automata have been defined (e.g.,~\cite{PNtransformation1,PNtransformation2}). On the other hand, GRAFCET/SFC languages for programming industrial control gear originate from Petri nets, with their behavioral equivalence discussed in~\cite{David20101,CIPNtoTPN,Wightkin2011455}.\PA{needs to be fixed}
\end{remark}
%\PA{add a remark on relationship between PN and FSM/Automata; EMSOFT crowd is more comfortable with automata} 