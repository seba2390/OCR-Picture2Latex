

%%%%%%%%%%%%%%%%%
%								 %
% 		Multiparty Protocols	 %
%								 %
%%%%%%%%%%%%%%%%%
\section{Multiparty Protocols}
\label{app: mpc protocols}

Algorithm~\ref{algo: mpc binop}, $\MPC{b}$, is a selection control algorithm that directs the evaluation to the relevant multiparty computation algorithm based on the given binary operation $\binop\in\{\cdot,\div,+,-\}$. 

\begin{algorithm}[H]\footnotesize
\caption{$(\n^\pidA_3, ..., \n^\pidZ_3) \gets \MPC{b}(\binop, [\n^\pidA_1, ..., \n^\pidZ_1], [\n^\pidA_2, ..., \n^\pidZ_2])$}
\label{algo: mpc binop}
\begin{algorithmic}
 	\IF{$(\binop = \cdot)$}
		\FORALL{$\pid\in\{\pidA...\pidZ\}$} 
			\STATE $\n^\pid_3 = \MPC{mult}(\n^\pid_1, \n^\pid_2)$
		\ENDFOR
		\RETURN $(\n^\pidA_3, ..., \n^\pidZ_3)$
	\ELSIF{$(\binop = \div)$}
		\FORALL{$\pid\in\{\pidA...\pidZ\}$} 
			\STATE $\n^\pid_3 = \MPC{div}(\n^\pid_1, \n^\pid_2)$
		\ENDFOR
		\RETURN $(\n^\pidA_3, ..., \n^\pidZ_3)$
	\ELSIF{$(\binop = -)$}
		\FORALL{$\pid\in\{\pidA...\pidZ\}$} 
			\STATE $\n^\pid_3 = \MPC{sub}(\n^\pid_1, \n^\pid_2)$
		\ENDFOR
		\RETURN $(\n^\pidA_3, ..., \n^\pidZ_3)$
	\ELSIF{$(\binop = +)$}
		\FORALL{$\pid\in\{\pidA...\pidZ\}$} 
			\STATE $\n^\pid_3 = \MPC{add}(\n^\pid_1, \n^\pid_2)$
		\ENDFOR
		\RETURN $(\n^\pidA_3, ..., \n^\pidZ_3)$
	\ENDIF
\end{algorithmic}
\end{algorithm}


Each of the given multiparty protocols in Algorithm~\ref{algo: mpc binop} (i.e., $\MPC{mult},$ $\MPC{sub},$ $\MPC{add},$ $\MPC{div}$) must be defined using protocols that have been proven to uphold the desired properties within our proofs (i.e., correctness and noninterference). 
We give an example definition for $\MPC{mult}$ in Algorithm~\ref{algo: mpc mult}, but this definition can be swapped out with any protocol for the secure multiparty computation of multiplication that maintains the properties of correctness and noninterference. 
We defer the definition of all other SMC binary operations, rely on assertions that the protocols chosen to be used with this model will maintain both correctness and noninterference in our proofs. 
We chose this strategy as SMC implementations of such protocols will be proven to hold our desired properties on their own, and this allows us to not only leverage those proofs, but to also improve the versatility of our model by allowing such algorithms to be easily swapped out as newer, improved versions become available. 



%%%%%%%%%%%%%%%%%
%								 %
% 		Semantics				 %
%								 %
%%%%%%%%%%%%%%%%%
\section{Semantics}
\label{app: semantics}
\input{app-rules}
We show selected additional semantic rules in Figures~\ref{Fig: sem app} and~\ref{Fig: sem app arr} to give a more encompassing view of our semantic model.
In particular, we show a larger subset of array and pointer rules, as well as input/output and public allocation and deallocation. 
We use several algorithms within the rules in order to increase the readability of the rules and compartmentalize common functionalities between rules; we will discuss a few further here. 

The variations of $\PermL$ are all used to map the information given as arguments into the appropriate byte-wise permission tuples. This allows us to show the important information about the byte-wise permissions without the repetition of showing the list of permission tuples and getting into the more intricate details, particularly for pointer data structures which have a mix of public and private data and therefore a mix of permissions. 
Algorithms such as $\InputVal$ and $\OutputArr$ are, respectively, handlers for reading data in and writing data to a file. 
Algorithm $\SelectFreeable$ is used to evaluate whether the locations a pointer refers to are indeed freeable (i.e., all locations were allocated through the use of \TT{malloc} or \TT{pmalloc} and not the default location or a location allocated during a variable declaration. 
Algorithm $\Free$ is used to modify the permissions of the location that is being freed to be $\PermN$. 
All algorithms such as $\Update$, $\UpdateArr$, and $\UpdatePtr$ contain the intricacies of updating the specific type of data within memory. 

Algorithm $\Retrieve$ will go through memory and pull all values that are referred to at the $\nl$ locations of that pointer. This is a helper function to allow up to show the exact information that will be used within the multiparty protocol. 
Algorithm $\DynUpdate$ ensures we are tracking every location that is modified within a private-conditioned branch by checking if the current location we are modifying with the pointer dereference write is already tracked in $\DMap$, and if it is not, adding it and the original value for that location to $\DMap$. 
Algorithm $\GetLoc$ handles incrementing the given location and offset by the appropriate size in bytes. It returns the new location and offset that the pointer will refer to, without complicating the rule with all the redundancies of handling locations of different sizes and finding the appropriate position. 
Algorithm $\DerefPtrPub$ will take the location and offset that the pointer refers to as well as the expected type, and give back the value that is obtained from reading from that position. This handles all the intricacies of pointers with non-zero offsets, and ensures that we will always read data from memory as the expected type. 

We also handle pointers of higher levels of indirection; we chose not to show those rules here as the main concepts behind the rules are fairly similar to those shown. 
The full semantic model for \piccoC\ is available at \cite{amys-dissertation} (Chapter 5), including the algorithms used within the semantics and the full \vanillaC\ semantics. 



\subsection{Scoping}
In our semantics, we implement standard C scoping through our use of the environment $\gamma$. 
To illustrate this, Figure~\ref{Fig: scoping} contains a few rules with $\gamma$ and its additions highlighted in \red{red}. 
First, we show the Private Array Declaration rule, where we add a new mapping for the array variable and its newly allotted location to the environment and return the updated environment. 
Next, we have the standard Statement Sequencing rule, where we pass along all additions to the environment that were made within each statement. 
Finally we show the Public If Else True rule. Here, we have an updated environment $\RT{\gamma_1}$ returned from the evaluation of the \TT{then} branch $\stmt_1$; any new mappings introduced within $\stmt_1$ become out of scope once we exit this rule, so we return the original environment $\RT\gamma$. This way, any further references to local variables declared within $\stmt_1$ will no longer be found in the environment and cannot execute, as is expected. 



\begin{algorithm*}\footnotesize
\caption{$(\x_\mathit{mod}, \tagb) \gets \DynExtract(\stmt_1,\ \stmt_2, \gamma)$}
\label{algo: dyn extract}
\begin{algorithmic}
	\STATE $\tagb = 0$
 	\STATE $\x_\mathit{local} = [\ ] $
	\STATE $\x_\mathit{mod} = [\ ] $		
       \FORALL {$\stmt \in \{\stmt_1;\ \stmt_2\}$}												
		 \IF{$((\stmt ==\ \Type\ \x) \lor (\stmt ==\ \Type\ \x[\Expr]))$}
            			\STATE $\x_\mathit{local}.\mathit{append}(\x)$ 								
		\ELSIF{$((\stmt ==\ \x = \Expr) \land (\lnot\x_\mathit{local}.\mathit{contains}(\x)))$}			
            			\STATE $\x_\mathit{mod} = \x_\mathit{mod} \cup [\x]$
				\FORALL{$\Expr_1 \in \Expr$}
					\IF{$((\Expr_1 ==\ \plpl\x_1) \land (\lnot\x_\mathit{local}.\mathit{contains}(\x_1)))$}
						\STATE $\x_\mathit{mod} = \x_\mathit{mod} \cup [\x_1]$
					\ENDIF
				\ENDFOR	
		\ELSIF{$((\stmt ==\ \x[\Expr_1] = \Expr_2) \land (\lnot\x_\mathit{local}.\mathit{contains}(\x)))$}
				\IF{$(\Expr_1)\isPriv \gamma$}
					\STATE $\x_\mathit{mod} = \x_\mathit{mod} \cup [\x]$
				\ELSE
					\STATE $\tagb = 1$
				\ENDIF
				\FORALL{$\Expr \in \{\Expr_1, \Expr_2\}$}
					\IF{$((\Expr ==\ \plpl\x_1) \land (\lnot\x_\mathit{local}.\mathit{contains}(\x_1)))$}
						\STATE $\x_\mathit{mod} = \x_\mathit{mod} \cup [\x_1]$
					\ENDIF
				\ENDFOR
		\ELSIF{$((\stmt ==\ \plpl\x) \land (\lnot\x_\mathit{local}.\mathit{contains}(\x)))$}
				\STATE $\x_\mathit{mod} = \x_\mathit{mod} \cup [\x]$
		\ELSIF{$(\stmt == *\x = \Expr)$}
				\STATE $\tagb = 1$
				\FORALL{$\Expr_1 \in \Expr$}
					\IF{$((\Expr_1 ==\ \plpl\x_1) \land (\lnot\x_\mathit{local}.\mathit{contains}(\x_1)))$}
						\STATE $\x_\mathit{mod} = \x_\mathit{mod} \cup [\x_1]$
					\ENDIF
				\ENDFOR
		\ENDIF
	\ENDFOR
         \RETURN $(\x_\mathit{mod}, \tagb)$
\end{algorithmic}
\end{algorithm*}



\begin{algorithm*}\footnotesize
\caption{$(\gamma_1, \sigma_1, \locL) \gets \Initialize(\x_{\vl},\ \gamma, \sigma, n, \Acc)$}
\label{algo: initialize}
\begin{algorithmic}
	\STATE $\loc_\res = \phi(\mathit{temp})$
	\STATE $\gamma_1 = \gamma[\res\_\Acc \to (\loc_\res, \Priv\ \Int)]$
	\STATE $\byte_\res = \Encode(\Priv\ \Int, n)$
	\STATE $\sigma_1 = \sigma[\loc_\res \to (\byte_\res, \Priv\ \Int, 1, \VarPermL(\PermF, \Priv\ \Int, \Priv, 1))]$
	\STATE $\locL = [(\loc_\res, 0)]$
	\FORALL{$\x \in \x_{\vl}$}
		\STATE $(\loc_\x, \Type) = \gamma(\x)$	
		\STATE $\loc_t = \phi(\mathit{temp})$
		\STATE $\loc_e = \phi(\mathit{temp})$
		% record touched locs
		\STATE $\locL = \locL \addL[(\loc_\x, 0), (\loc_t, 0), (\loc_e, 0)]$
		\STATE $\gamma_1 = \gamma_1[\x\_t\_\Acc \to (\loc_t, \Type)][\x\_e\_\Acc \to (\loc_e, \Type)]$
		\STATE $(\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)) = \sigma_1(\loc_\x)$
		% Special case for if entire array is modified
		\IF{$(\Type = \Priv\ \Const\ \btype*)$} 
			% temp locs for array data
			\STATE $\loc_{ta} = \phi(\mathit{temp})$
			\STATE $\loc_{ea} = \phi(\mathit{temp})$
			% Decode x
			\STATE $[1, [(\loc_{xa}, 0)], [1], 1] = \DecodePtr(\Type, 1, \byte_{x})$
			% Look up x array data 
			\STATE $(\byte_{xa}, \Priv\ \btype, \nl, \PtrPermL(\PermF, \Priv\ \btype, \Priv, \nl)) = \sigma_1(\loc_{xa})$
			% add mappings for array data
			\STATE $\sigma_1 = \sigma_1[\loc_{ta} \to (\byte_{xa}, \Priv\ \btype, \nl, \VarPermL(\PermF, \Priv\ \btype, \Priv, \nl))]$
			\STATE $\sigma_1 = \sigma_1[\loc_{ea} \to (\byte_{xa}, \Priv\ \btype, \nl, \VarPermL(\PermF, \Priv\ \btype, \Priv, \nl))]$
			% Encode ptr repr.
			\STATE $\byte_{t} = \EncodePtr(\Type, [1, [(\loc_{t}, 0)], [1], 1])$
			\STATE $\byte_{e} = \EncodePtr(\Type, [1, [(\loc_{e}, 0)], [1], 1])$
			% add mappings for const
			\STATE $\sigma_1 = \sigma_1[\loc_t \to (\byte_{t}, \Type, 1, \PtrPermL(\PermF, \Type, \Priv, 1))]$
			\STATE $\sigma_1 = \sigma_1[\loc_e \to (\byte_{e}, \Type, 1, \PtrPermL(\PermF, \Type, \Priv, 1))]$
			% add locations touched
			\FORALL{$i \in \{0...\nl-1\}$}
				\STATE $\locL = \locL \addL [(\loc_{xa}, i), (\loc_{ta}, i), (\loc_{ea}, i)]$
			\ENDFOR
		\ELSE
			\STATE $\sigma_1 = \sigma_1[\loc_t \to (\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl))]$
			\STATE $\sigma_1 = \sigma_1[\loc_e \to (\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl))]$
		\ENDIF
	\ENDFOR									
	\RETURN $(\gamma_1, \sigma_1, \locL)$
\end{algorithmic}
\end{algorithm*}





\begin{algorithm*}\footnotesize
\caption{$(\sigma_4, \locL) \gets \Restore(\x_{\vl}, \gamma, \sigma, \Acc)$}
\label{algo: restore}
\begin{algorithmic}
	\STATE $\locL = [\ ]$
	\FORALL{$\x \in \x_{\vl}$}	 
		\STATE $(\loc_\x, \Type) = \gamma(\x)$
		\STATE $(\loc_t, \Type) = \gamma(\x\_t\_\Acc)$
		\STATE $(\loc_e, \Type) = \gamma(\x\_e\_\Acc)$
		% record touched locs
		\STATE $\locL = \locL \addL [(\loc_\x, 0), (\loc_t, 0), (\loc_e, 0)]$
		% Special case for if entire array is modified
		\IF{$(\Type = \Priv\ \Const\ \btype*)$}
			% look up x/t/e
			\STATE $(\byte_{xa}, \Type, 1, \VarPermL(\PermF, \Type, \Priv, 1)) = \sigma(\loc_\x)$
			\STATE $(\byte_{ta}, \Type, 1, \VarPermL(\PermF, \Type, \Priv, 1)) = \sigma(\loc_t)$
			\STATE $(\byte_{ea}, \Type, 1, \VarPermL(\PermF, \Type, \Priv, 1)) = \sigma(\loc_e)$
			% Decode x/t/e
			\STATE $[1, [(\loc_{xa}, 0)], [1], 1] = \DecodePtr(\Type, 1, \byte_{xa})$
			\STATE $[1, [(\loc_{ta}, 0)], [1], 1] = \DecodePtr(\Type, 1, \byte_{ta})$
			\STATE $[1, [(\loc_{ea}, 0)], [1], 1] = \DecodePtr(\Type, 1, \byte_{ea})$
			% Look up x/t array data 
			\STATE $\sigma_1[\loc_{xa} \to (\byte_t, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl))] = \sigma$
			\STATE $\sigma_2[\loc_{ta} \to (\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl))] = \sigma_1$
			% store in then
			\STATE $\sigma_3 = \sigma_2[\loc_{ta} \to (\byte_t, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)]$
			% look up else
			\STATE $(\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)) = \sigma_3(\loc_{ea})$
			% store in x
			\STATE $\sigma_4 = \sigma_3[\loc_{xa} \to (\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)]$
			% record touched locs
			\FORALL{$i \in \{0...\nl-1\}$}
				\STATE $\locL = \locL \addL [(\loc_{xa}, i), (\loc_{ta}, i), (\loc_{ea}, i)]$
			\ENDFOR
		\ELSE
			% look up x/t
			\STATE $\sigma_1[\loc_\x \to (\byte_t, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl))] = \sigma$
			\STATE $\sigma_2[\loc_t \to (\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)] = \sigma_1$
			% store in then
			\STATE $\sigma_3 = \sigma_2[\loc_t \to (\byte_t, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)]$
			% look up else
			\STATE $(\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)) = \sigma_3(\loc_e)$
			% store in x
			\STATE $\sigma_4 = \sigma_3[\loc_\x \to (\byte_\x, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)]$
		\ENDIF
		\STATE $\sigma = \sigma_4$
	\ENDFOR							
	\RETURN $(\sigma_4, \locL)$
\end{algorithmic}
\end{algorithm*}




\begin{algorithm*}\footnotesize
\caption{$(\valL, \n_{\res}, \locL) \gets \ResolveR(\x_{\vl}, \Acc, \gamma, \sigma)$}
\label{algo: resolve R}
\begin{algorithmic}
	\STATE $\valL = [\ ]$
	% look up res
	\STATE $(\loc_{\res}, \Priv\ \Int) = \gamma(\res\_\Acc)$
	\STATE $(\byte_{\res}, \Priv\ \Int, 1, \VarPermL(\PermF, \Priv\ \Int, \Priv, 1)) = \sigma(\loc_{\res})$
	\STATE $\n_{\res} = \Decode(\Priv\ \Int, \byte_{\res})$
	\STATE $\locL = [(\loc_{\res}, 0)]$
	\FORALL{ $\x \in \x_{\vl}$ }	
		% look up x	 		(== current else value)	
		% look up x_then	(== current then value)
		\STATE $(\loc_\x, \Type) = \gamma(\x)$
		\STATE $(\loc_t, \Type) = \gamma(\x_t)$	
		% Look up x/t	
		\STATE $(\byte_{x}, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)) = \sigma(\loc_\x)$
		\STATE $(\byte_{t}, \Type, \nl, \VarPermL(\PermF, \Type, \Priv, \nl)) = \sigma(\loc_t)$
		% record touched locs
		\STATE $\locL = \locL \addL [(\loc_\x, 0), (\loc_t, 0)]$
		% based on type look up in sigma, add 2-tuple V = V::[(v_t, v_e)] 
		% Maintain this constant ordering to ensure correct storage later on -> X[i] == V[i]
		\IF{ $(\Type = \Priv\ \btype)$ }	
			% Decode x/t
			\STATE $\val_{x} = \Decode(\Priv\ \btype, \byte_{x})$
			\STATE $\val_{t} = \Decode(\Priv\ \btype, \byte_{t})$
			% Add to V
			\STATE $\valL = \valL.\mathit{append}((\val_{t}, \val_{x}))$
		\ELSIF{ $(\Type = \Priv\ \Const\ \btype*)$ }	
			% Decode x/t
			\STATE $[1, [(\loc_{xa}, 0)], [1], 1] = \DecodePtr(\Type, 1, \byte_{x})$
			\STATE $[1, [(\loc_{ta}, 0)], [1], 1] = \DecodePtr(\Type, 1, \byte_{t})$
			% Look up xa/ta	
			\STATE $(\byte_{xa}, \Priv\ \btype, \nl, \VarPermL(\PermF, \Priv\ \btype, \Priv, \nl)) = \sigma(\loc_{xa})$
			\STATE $(\byte_{ta}, \Priv\ \btype, \nl, \VarPermL(\PermF, \Priv\ \btype, \Priv, \nl)) = \sigma(\loc_{ta})$
			\FORALL{$i \in \{0 ... \nl-1\}$}
				% Decode x/t
				\STATE $\val_{xi} = \DecodeArr(\Priv\ \btype, i, \byte_{xa})$
				\STATE $\val_{ti} = \DecodeArr(\Priv\ \btype, i, \byte_{ta})$
				% Add to V
				\STATE $\valL = \valL.\mathit{append}((\val_{ti}, \val_{xi}))$
				% record touched locs
				\STATE $\locL = \locL \addL [(\loc_{xa}, i), (\loc_{ta}, i)]$
			\ENDFOR
		\ELSIF{$(\Type = \Priv\ \btype*)$}	
			% Decode x/t
			\STATE $[\nl, \locL_\x, \tagbL_\x, \indir] = \DecodePtr(\Type, \nl, \byte_{x})$
			\STATE $[\nl, \locL_t, \tagbL_t, \indir] = \DecodePtr(\Type, \nl, \byte_{t})$
			% Add to V	
			\STATE $\valL = \valL.\mathit{append}(([\nl, \locL_t, \tagbL_t, \indir], [\nl, \locL_\x, \tagbL_\x, \indir]))$
		\ENDIF	
	\ENDFOR
	\RETURN $(\valL, \n_\res, \locL)$	
\end{algorithmic}
\end{algorithm*}


\begin{algorithm*}\footnotesize
\caption{$(\sigma_1, \locL) \gets \ResolveS(\x_{\vl}, \Acc, \gamma, \sigma, \valL)$}
\label{algo: resolve S}
\begin{algorithmic}
	\STATE $\locL = [\ ]$
	\STATE $\sigma_1 = \sigma$
	\FORALL{ $i \in \{0...|\valL| -1\}$ }			
		% look up x	 		(== current else value)	
		% look up x_then	(== current then value)
		\STATE $\x = \x_{\vl}[i]$
		\STATE $\val_\x = \valL[i]$
		\STATE $(\loc_\x, \Type) = \gamma(\x)$
		% record touched locs
		\STATE $\locL = \locL.\mathit{append}((\loc_\x, 0))$
		% based on type look up in sigma, add 2-tuple V = V::[(v_t, v_e)] 
		% Maintain this constant ordering to ensure correct storage later on -> X[i] == V[i]
		\IF{ $(\Type = \Priv\ \btype)$ }	
			% Update x	
			\STATE $\sigma_2 = \Update(\sigma_1,\ \loc_\x,\ \val_\x,\ \Type)$
			\STATE $\sigma_1 = \sigma_2$
		\ELSIF{ $(\Type = \Priv\ \Const\ \btype*)$ }	
			% Decode x/t
			\STATE $[1, [(\loc_{xa}, 0)], [1], 1] = \DecodePtr(\Type, 1, \byte_{x})$
			\FORALL{$\offset \in \{0 ... \nl-1\}$}
				\STATE $\val_\offset = \val_\x[\offset]$
				% Update offset
				\STATE $\sigma_{2+\offset} = \UpdateArr(\sigma_{1+\offset},\ (\loc_{xa},\offset),\ \val_\offset,\ \Type)$
				% record touched locs
				\STATE $\locL = \locL.\mathit{append}((\loc_{xa}, \offset))$
			\ENDFOR
			\STATE $\sigma_1 = \sigma_{2+\offset}$
		\ELSIF{$(\Type = \Priv\ \btype*)$}	
			\STATE $\sigma_2 = \UpdatePtr(\sigma_1,\ (\loc_\x, 0),\ \val_\x,\ \Type)$ 
			\STATE $\sigma_1 = \sigma_2$
		\ENDIF	
	\ENDFOR
	\RETURN $(\sigma_1, \locL)$	
\end{algorithmic}
\end{algorithm*}





\subsection{Array Overshooting}
\label{app: array oob}

\begin{minipage}{\textwidth}
\centering{\includegraphics[width=0.75\textwidth]{MemoryOvershootingVanC.pdf}}
\captionof{figure}{Types of overshooting array accesses.}
\label{Fig: arr oob read vanC}
\end{minipage}
\input{overshooting}





%%%%%%%%%%%%%%%%%
%								 %
% 		Metatheory				 %
%								 %
%%%%%%%%%%%%%%%%%
\section{Metatheory}
\label{app: metatheory}
In this section, we will provide our main definitions and metatheory, including proof sketches of the most crucial Theorems and Lemmas, to give the reader a more complete understanding and some intuition behind how our proofs work. 

\subsection{Correctness}
In our semantics, we give each evaluation an identifying code as a shorthand way to refer to that specific evaluation, as well as to allow us to quickly reason about the \vanillaC\ and \piccoC\ evaluations that are congruent to each other (i.e., a \vanillaC\ rule and an identical one handling only public data in \piccoC). 




The list of \vanillaC\ codes are as follows: 
$\vanillaCodes$ = 
	[$\mathit{mpb}$, $\mathit{mpcmpt}$, $\mathit{mpcmpf}$, $\mathit{mppin}$, 
	$\mathit{mpra}$, $\mathit{mpwe}$, $\mathit{mpfre}$, $\mathit{mpiet}$, $\mathit{mpief}$,
	$\mathit{mprdp}$, $\mathit{mprdp1}$, $\mathit{mpwdp}$, $\mathit{mpwdp1}$, 
	$\mathit{fls}$, $\mathit{ss}$, $\mathit{sb}$, $\mathit{ep}$, $\mathit{cv}$, $\mathit{cl}$, 
	$\mathit{r}$, $\mathit{w}$, $\mathit{ds}$, $\mathit{dv}$, $\mathit{dp}$, $\mathit{da}$, 
	$\mathit{wle}$, $\mathit{wlc}$, $\mathit{bp}$, $\mathit{bs}$, $\mathit{bm}$, $\mathit{bd}$, 
	$\mathit{ltf}$, $\mathit{ltt}$, $\mathit{eqf}$, $\mathit{eqt}$, $\mathit{nef}$, $\mathit{net}$, 
	$\mathit{mal}$, $\mathit{fre}$, $\mathit{wp}$, $\mathit{wdp}$, $\mathit{wdp1}$, $\mathit{rp}$, 
	$\mathit{rdp}$, $\mathit{rdp1}$, $\mathit{ra}$, $\mathit{wa}$, $\mathit{rao}$, $\mathit{wao}$, 
	$\mathit{rae}$, $\mathit{wae}$, $\mathit{loc}$, $\mathit{iet}$, $\mathit{ief}$,  
	$\mathit{inp}$, $\mathit{inp1}$, $\mathit{out}$, $\mathit{out1}$, $\mathit{df}$, $\mathit{ty}$, 
	$\mathit{fd}$, $\mathit{fpd}$, $\mathit{fc}$, $\mathit{pin}$, $\mathit{pin1}$, $\mathit{pin2}$]. 


The list of \piccoC\ codes are as follows: 
$\piccoCodes$ = 
	[$\mathit{mpb}$, $\mathit{mpcmp}$, 
	$\mathit{mpra}$, $\mathit{mpwa}$, $\mathit{mppin}$, $\mathit{mpdp}$, $\mathit{mpdph}$, 
	$\mathit{mpfre}$, 
	$\mathit{mprdp}$, $\mathit{mprdp1}$, 
	$\mathit{mpwdp}$, $\mathit{mpwdp1}$, $\mathit{mpwdp2}$, $\mathit{mpwdp3}$, 
	$\mathit{iet}$, $\mathit{ief}$, $\mathit{iep}$, $\mathit{iepd}$, $\mathit{wle}$, $\mathit{wlc}$, 
	$\mathit{dp}$, $\mathit{dp1}$, 
	$\mathit{rp}$, $\mathit{rp1}$, $\mathit{rdp}$, $\mathit{rdp1}$, $\mathit{rdp2}$, 
	$\mathit{wp}$, $\mathit{wp1}$, $\mathit{wp2}$, 
	$\mathit{wdp}$, $\mathit{wdp1}$, $\mathit{wdp2}$, $\mathit{wdp3}$, $\mathit{wdp4}$, $\mathit{wdp5}$, 
	$\mathit{da}$, $\mathit{da1}$, $\mathit{das}$, 
	$\mathit{ra}$, $\mathit{ra1}$, $\mathit{rea}$, 
	$\mathit{wa}$, $\mathit{wa1}$, $\mathit{wa2}$, 
	$\mathit{wea}$, $\mathit{wea1}$, $\mathit{wea2}$, 
	$\mathit{rao}$, $\mathit{rao1}$, 
	$\mathit{wao}$, $\mathit{wao1}$, $\mathit{wao2}$, 
	$\mathit{pin}$, $\mathit{pin1}$, $\mathit{pin2}$, $\mathit{pin3}$, $\mathit{pin4}$, 
	$\mathit{pin5}$, $\mathit{pin6}$, $\mathit{pin7}$, 
	$\mathit{mal}$, $\mathit{malp}$, $\mathit{fre}$, $\mathit{pfre}$, 
	$\mathit{cv}$, $\mathit{cv1}$, $\mathit{cl}$, $\mathit{cl1}$, 
	$\mathit{loc}$, $\mathit{ty}$, 
	$\mathit{df}$, $\mathit{fd}$, $\mathit{fpd}$, $\mathit{fc}$, $\mathit{fc1}$, 
	$\mathit{bp}$, $\mathit{bs}$, $\mathit{bm}$, $\mathit{bd}$, 
	$\mathit{ltf}$, $\mathit{ltt}$, $\mathit{eqf}$, $\mathit{eqt}$, $\mathit{nef}$, $\mathit{net}$, 
	$\mathit{dv}$, $\mathit{d1}$, $\mathit{r}$, $\mathit{r1}$, $\mathit{w}$, $\mathit{w1}$, $\mathit{w2}$, 
	$\mathit{ds}$, $\mathit{ss}$, $\mathit{sb}$, $\mathit{ep}$, 
	$\mathit{inp}$, $\mathit{inp1}$, $\mathit{inp2}$, $\mathit{inp3}$, 
	$\mathit{out}$, $\mathit{out1}$, $\mathit{out2}$, $\mathit{out}$]. 







\begin{figure*}[h]
\begin{subfigure}{0.55\textwidth}
\includegraphics[width=\textwidth]{WellAlignedEx.pdf}
\caption{Well-aligned accesses}
\label{fig: well-aligned}
\end{subfigure}
\quad
\begin{subfigure}{0.35\textwidth}
\includegraphics[width=\textwidth]{NotWellAlignedEx.pdf}
\caption{Not well-aligned accesses}
\label{fig: not well-aligned}
\end{subfigure}
\caption{Examples of alignment between \piccoC\ and \vanillaC\ in overshooting accesses by incrementing pointer \TT{p} three times.}
\label{fig: overshooting alignment}
\end{figure*}

\subsubsection{Erasure Function}
\input{erasure-ef}

\subsubsection{Selected Metatheory}
\input{short-correctness}

\subsection{Noninterference}
\label{app: noninterference}
\input{short-ni}

