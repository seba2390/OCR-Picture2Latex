
In this section we introduce our semantic and memory model. Our goal is to
formalize a general purpose SMC compiler, showing correctness with respect to standard C semantics
and non-interference to guarantee no leakage of private data. 
We therefore introduce two models, C (referred to as \vanillaC) as well as the semantics for the SMC compiler (referred to as \piccoC). 
We do not abstract away memory, instead we introduce a byte-level memory model, 
inspired by the memory model used by CompCert~\cite{leroy2012compcert}, a formally verified C compiler. 
Specifically, we build from their approach of byte-level representation of data and permissions. 

\begin{figure}
\begin{minipage}{0.48\textwidth}\footnotesize
$\begin{array}{l c l}
	\Type &::=& \RT{\llabel\ \btype} \mid \RT{\llabel\ \btype*} \mid \btype \mid {\btype*} \mid \Tlist \to \Type 
\\	\btype &::=& \Int \mid \Float \mid \Void 
\\	\llabel &::=& \rPriv \mid \rPub
\\	\Tlist &::=&  {[\ ]} \mid {\Type::\Tlist} 
\\ \\	\stmt &::=& {\var = \Expr} \mid {*\x = \Expr} \mid {\stmt_1; \stmt_2} \mid {\If (\Expr)\ \stmt_1\ \Else\ \stmt_2}

\\	  && \mid {\Type\ \x (\plist)\ \{ \stmt\}} \mid {\While (\Expr)\ \stmt} 
 \mid {\{ \stmt \}} \mid \decl \mid \Expr
\\	\Expr &::=& \Expr\ \binop\ \Expr \mid {\preop\ \x} \mid \var
		\mid {\x(\Elist)} \mid \builtin 
	\\	  && \mid {(\Type)\ \Expr}  \mid {( \Expr )}  \mid \val
\\	\decl &::=&  \Type\ \var \mid {\Type\ \x ( \plist )}
\\	\var &::=& \x \mid {\x[\Expr]} 
\\	\val &::=& n \mid (\loc, \offset) \mid [{\val_0},\ {...},\ {\val_n}] \mid \Null \mid \Skip
\\ \\ 	\builtin &::=& {\Malloc(\Expr)} \mid \RT{\PMalloc(\Expr,\ \Type)} \mid {\sizeof(\Type)}
	\\	  && \mid {\free(\Expr)} \mid \RT{\pfree(\Expr)} 
	\\ && \mid \RT{\smcinput(\var, e)} \mid \RT{\smcoutput(\var, e)}
\\ 	\binop &::=&{-} \mid {+} \mid \div \mid \cdot \mid {==}  \mid {!=} \mid {<}
\\	\preop &::=& \& \mid {*} \mid ++
\\	\Elist &::=& {\Elist,\ \Expr} \mid \Expr \mid \Void
\\	\plist &::=&  \plist,\ \Type\ \var \mid {\Type\ \var} \mid \Void
\end{array}$
\captionof{figure}{Combined \vanillaC /\piccoC\ Grammar. The color \red{red} denotes terms specific to programs written in \piccoC. 
} 	
\label{Fig: \piccoC grammar}
\end{minipage}
\qquad
\begin{tabular}{l}
\begin{minipage}{0.44\textwidth}\footnotesize
$\begin{array}{r l}	
% Configuration
\Config ::= & \epsilon \mid (\pid, \gamma, \sigma, \DMap, \Acc, \stmt) \Mid \Config \\
\\
% Environment
	\gamma ::=& [ \-\ ]\ \mid\ \gamma[\x\ \to\ (\loc,\ \Type)]							\\
% Memory
	\sigma ::=& [ \-\ ]\ \mid\ \sigma [\loc\ \to\ (\byte,\ \Type,\ n,\ \PermL)  	\\
% Permissions 
	\PermL ::=& [ \-\ ]\ \mid\ [(0,\ \llabel_0,\ \perm_0), ..., (\bytelen, \llabel_\bytelen, \perm_\bytelen)] \\
	\perm ::=& \PermF \mid \PermN		 									\\
% Permission Tuples - "Size"
	\bytelen ::= & \tau(\Type)\cdot n - 1		\\
% Change Map & locals map
	\DMap ::= & [ \-\ ] \mid \dmap::\DMap \\
	\dmap ::= & [ \-\ ] \mid ((\loc, \offset)\to(\val_1, \val_2, \tagb, \Type))::\dmap \\
\\ 
% Location List
	\locLL ::= & \epsilon \mid (\pid, \locL) \Mid \locLL \\
	\locL ::= & [ \-\ ] \mid (\loc, \offset)::\locL \\
	\codeLL ::= & \epsilon \mid (\pid, \codeL) \Mid \codeLL \\
	\codeL ::= & [ \-\ ] \mid \code::\codeL 
	\end{array}
$
\captionof{figure}{Configuration: party identifier $\pid$, environment $\gamma$, memory $\sigma$, \changeMap\ $\DMap$, accumulator $\Acc$, and statement $\stmt$.}
\label{Fig: mem model}
\end{minipage}
\end{tabular}
\end{figure}


Figure~\ref{Fig: \piccoC grammar} gives the combined \vanillaC\ and \piccoC\ grammar, which is a subset of the ANSI C grammar. 
We include one dimensional arrays, branches, loops, dynamic memory allocation, and pointers. 
Arrays are zero-indexed, and it is possible to overshoot their bounds. 
We chose not to include structs or multi-dimensional arrays, as they are an extension of this core subset.
The interested reader can find the full semantics within the scope of the grammar given in Appendix~\ref{app: semantics}.
We use the color \red{red} to denote terms in the \piccoC\ grammar that are not present in \vanillaC, including annotated types ($\llabel\ \btype$, $\llabel\ \btype *$), privacy labels ($\Pub$, $\Priv$), and primitive functions ($\PMalloc$, $\pfree$) for allocation and deallocation of 
memory for private pointers.

We denote types as $\Type$, basic types as $\btype$ ($\btype *$ as a pointer type), privacy annotations as $\llabel$, and function types as $\Tlist \to \Type$ 
(where $\Tlist$ is a type list, $[\ ]$ an empty list, and $::$ list concatenation). 
Values $\val$ include numbers $n$, locations ($\loc$, $\offset$) consisting of a memory block identifier and an offset, lists of values, $\Null$, and $\Skip$ (to show a statement being reduced to completion).
Declarations include variable and function declarations, where $\plist$ is the function parameter list.
For unary operations, we include: $\&$, to obtain the address of a variable; $*$, to allow dereferencing pointers; and $++$, to allow pre-incrementing and to model a basic pointer arithmetic. 


%%%%%%%%%%%%%%%%%%%%%%%
% 
%      	 Memory model input
% 
%%%%%%%%%%%%%%%%%%%%%%%
\input{mem-model}


%%%%%%%%%%%%%%%%%%%%%%%
%
%   Begin Vanilla C semantics description 
%
%%%%%%%%%%%%%%%%%%%%%%%
\input{vanillaCsemantics}


\input{vanCdescr}


%%%%%%%%%%%%%%%%%%%%%%%
%
%   Begin Picco C semantics description 
%
%%%%%%%%%%%%%%%%%%%%%%%
\input{piccoCsemantics}

\input{piccoCdescr}


%%%%%%%%%%%%%%%%%%%%%%%
%
%   picco C If Else description 
%
%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{\piccoC\ If Else} \label{subsec: \piccoC if else}
\input{if-else-desc}


\subsection{Overshooting Memory Bounds} \label{Sec: Overshooting}
%
It is possible to overshoot memory bounds in both \vanillaC\ and \piccoC. 
When overshooting occurs, we read the bytes of data as the type we expected it to be (i.e., bytes containing private data accessed by a public variable would be decoded as though they are public - no encryption or decryption occurs, but computations using the variable beyond that point will be garbage). 
This ensures that no information about private data can be leaked when overshooting. 
This is discussed further in Appendix~\ref{app: array oob} for the interested reader. 
We can only prove correctness over well-aligned accesses (i.e., those that iterate only over aligned elements of the same type, as with one array spilling into a subsequent array), as these would still produce readable data that is not garbage. 
When proving noninterference, we must prove that these cases (particularly those involving private data) cannot leak any information about the private data that is affected. We discuss this in more detail in the following section.








