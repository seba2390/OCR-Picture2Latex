
\begin{definition}[$\psi$] 
\label{Def: psi}
A \LocMap\ $\psi$ is defined as a list of lists of locations, in symbols $\psi = [\ ]\ |\ \psi[\locL]$,
that is formed by tracking which locations are privately switched during the execution of the statement $\RT{\pfree(\x)}$ in a \piccoC\ program $\rstmt$ to enable comparison with the \emph{congruent} \vanillaC\ program $\hstmt$. 
\end{definition}



\begin{definition}[$\rval \Pcong \hval$]
\label{Def: val psi cong}
A \piccoC\ value and \vanillaC\ value are \emph{$\psi$-congruent}, 
in symbols $\rval \Pcong \hval$, \\
if and only if either 
$\rval \neq (\rloc, \RT\offset)$, $\hval \neq (\hloc, \Hoffset)$ and $\rval \cong \hval$, \\
or 
$\rval = (\rloc, \RT\offset)$, $\hval = (\hloc, \Hoffset)$ and $(\rloc, \RT\offset) \Pcong (\hloc, \Hoffset)$. 
\end{definition}



\begin{definition}[$\RT\code \cong \codeV$]
\label{Def: code cong}
We define \emph{congruence} over \piccoC\ codes $\RT\code \in \piccoCodes$ and $\codeV \in \vanillaCodes$, in symbols $\RT\code \cong \codeV$, by cases as follows: 
\\ if $\RT\code = \codeV$, then $\RT\code \cong \codeV$, 
\\ if $\RT\code = \RT{\mathit{iep}} \lxor \RT{\mathit{iepd}}$, then $\codeV = \codeVV{mpiet} \lxor \codeVV{mpief}$ and $\RT\code \cong \codeV$, 
\\ if $\RT\code = \RT{\mathit{mpcmp}}$, then $\codeV = \codeVV{mpcmpt} \lxor \codeVV{mpcmpf}$ and $\code \cong \codeV$, 
\\ otherwise we have 
$[\RT{\mathit{malp}}] \cong [\codeVV{ty}, \codeVV{bm}, \codeVV{mal}]$, 
$\RT{\mathit{fc1}} \cong \codeVV{fc}$, $\RT{\mathit{pin3}} \cong \codeVV{pin}$, 
$\RT{\mathit{cl1}} \cong \codeVV{cl}$, $\RT{\mathit{mpwdp2}} \cong \codeVV{mpwdp1}$, 
$\RT{\mathit{cv1}} \cong \codeVV{cv}$, $\RT{\mathit{mpwdp}} \cong \codeVV{mpwdp}$, 
$\RT{\mathit{pin4}} \cong \codeVV{pin1}$, $\RT{\mathit{pin5}} \cong \codeVV{pin2}$, 
$\RT{\mathit{mpwdp3}} \cong \codeVV{mpwdp}$, $\RT{\mathit{pin6}} \cong \codeVV{pin1}$, 
$\RT{\mathit{pin7}} \cong \codeVV{pin2}$, $\RT{\mathit{r1}} \cong \codeVV{r}$, 
$\RT{\mathit{w1}} \cong \codeVV{w}$, $\RT{\mathit{w2}} \cong \codeVV{w}$, 
$\RT{\mathit{d1}} \cong \codeVV{d}$, $\RT{\mathit{wdp2}} \cong \codeVV{wdp1}$, 
$\RT{\mathit{dp1}} \cong \codeVV{dp}$, $\RT{\mathit{wdp3}} \cong \codeVV{wdp}$, 
$\RT{\mathit{rp1}} \cong \codeVV{rp}$, $\RT{\mathit{wdp4}} \cong \codeVV{wdp}$, 
$\RT{\mathit{wp1}} \cong \codeVV{wp}$, $\RT{\mathit{rdp1}} \cong \codeVV{rdp1}$, 
$\RT{\mathit{wp2}} \cong \codeVV{wp}$, $\RT{\mathit{da1}} \cong \codeVV{da}$, 
$\RT{\mathit{ra1}} \cong \codeVV{ra}$, $\RT{\mathit{wea2}} \cong \codeVV{wea}$, 
$\RT{\mathit{wea1}} \cong \codeVV{wea}$, $\RT{\mathit{rao1}} \cong \codeVV{rao}$, 
$\RT{\mathit{wa1}} \cong \codeVV{wa}$, $\RT{\mathit{wa2}} \cong \codeVV{wa}$, 
$\RT{\mathit{wa1p}} \cong \codeVV{wa}$, $\RT{\mathit{wa2p}} \cong \codeVV{wa}$, 
$\RT{\mathit{wao2}} \cong \codeVV{wao}$, $\RT{\mathit{wao1}} \cong \codeVV{wao}$, 
$\RT{\mathit{inp3}} \cong \codeVV{inp1}$, $\RT{\mathit{inp2}} \cong \codeVV{inp}$, 
$\RT{\mathit{out3}} \cong \codeVV{out1}$, and $\RT{\mathit{out2}} \cong \codeVV{out}$. 
\end{definition}








\begin{definition}[$\RT\Pi\Pcong\Sigma$]%\small
\label{Def: deriv cong}
Two derivations and \emph{$\psi$-congruent}, in symbols $\RT\Pi\cong_{\psi}\Sigma$, 
if and only if 
\\ $\RT\Pi \deriv ((\RT\pidA, \rrgamma^{\RT{\pidA}}_{},$ $\rrsigma^{\RT{\pidA}}_{},$ $\RT\DMap^{\RT{\pidA}}_{}$, $\rAcc^{\RT{\pidA}}_{},$ $\rstmt^{\RT{\pidA}})\ \Mid ...\Mid$ 
	$(\RT\pidZ, \rrgamma^{\RT{\pidZ}}_{},$ $\rrsigma^{\RT{\pidZ}}_{},$ $\RT\DMap^{\RT{\pidZ}}_{}$, $\rAcc^{\RT{\pidZ}}_{},$ $\rstmt^{\RT{\pidZ}}))$ 
	 \\$\Deval{\RT\locLL}{\RT\codeLL}$ 
	$((\RT\pidA, {\rrgamma^{\RT{\pidA}}_{\RT1}},$ ${\rrsigma^{\RT{\pidA}}_{\RT1}},$ $\RT\DMap^{\RT{\pidA}}_{\RT1}$, $\rAcc^{\RT{\pidA}}_{\RT1},$ ${\RT\val^{\RT{\pidA}}_{}}) \Mid ... \Mid$ 
	$(\RT\pidZ, {\rrgamma^{\RT{\pidZ}}_{\RT1}},$ ${\rrsigma^{\RT{\pidZ}}_{\RT1}},$ $\RT\DMap^{\RT{\pidZ}}_{\RT1}$, $\rAcc^{\RT{\pidZ}}_{\RT1},$ $\RT\val^{\RT{\pidZ}}))$
and 
\\$\Sigma \deriv ((\pidA,$ $\hgamma^\pidA,$ $\hsigma^\pidA,$ $\bsq,$ $\bsq,$ $\hstmt^\pidA)\Mid ...\Mid $
	$(\pidZ,$ $\hgamma^\pidZ,$ $\hsigma^\pidZ,$ $\bsq,$ $\bsq,$ $\hstmt^\pidZ))$ 
\\	$\Deval{}{\codeVLL}$ 
	$((\pidA,$ $\hgamma^\pidA_1,$ $\hsigma^\pidA_1,$ $\bsq,$ $\bsq,$ $\hval^\pidA)\Mid...\Mid$
	$(\pidZ,$ $\hgamma^\pidZ_1,$ $\hsigma^\pidZ_1,$ $\bsq,$ $\bsq,$ $\hval^\pidZ))$
such that 
\\$\{(\RT\pid, \rrgamma^{\RT{\pid}}_{},$ $\rrsigma^{\RT{\pid}}_{},$ $\RT\DMap^{\RT{\pid}}_{}$, $\rAcc^{\RT{\pid}}_{},$ $\rstmt^{\RT{\pid}})$ $\cong_{\psi_1}$ 
$(\pid,$ $\hgamma^\pid,$ $\hsigma^\pid,$ $\bsq,$ $\bsq,$ $\hstmt^\pid)\}^{\pidZ}_{\pid = \pidA}$, 
$\RT\codeLL \cong \codeVLL$, and 
\\$\{(\RT\pid, {\rrgamma^{\RT{\pid}}_{\RT1}},$ ${\rrsigma^{\RT{\pid}}_{\RT1}},$ $\RT\DMap^{\RT{\pid}}_{\RT1}$, $\rAcc^{\RT{\pid}}_{\RT1},$ $\RT\val^{\RT{\pid}}_{})$ $\cong_{\psi}$ 
$(\pid,$ $\hgamma^\pid_1,$ $\hsigma^\pid_1,$ $\bsq,$ $\bsq,$ $\hval^\pid)\}^{\pidZ}_{\pid = \pidA}$ such that $\psi$ was derived from $\psi_1$ and the derivation $\RT\Pi$. 
\end{definition}



\begin{definition}[$\RT{\val^1}\sim\RT{\val^2}$]%\small
\label{def: val sim}
Two values are \emph{corresponding}, in symbols $\RT{\val^1}\sim\RT{\val^2}$, 
if and only if either both $\RT{\val^1},\RT{\val^2}$ are public (including locations) and $\RT{\val^1}=\RT{\val^2}$, 
or $\RT{\val^1},\RT{\val^2}$ are private and $\erasure(\RT{\val^1}) = \erasure(\RT{\val^2})$.
\end{definition}



\begin{definition}[$\RT{\Config^1} \sim \RT{\Config^2}$]%\small
\label{def: config sim}
Two configurations are \emph{corresponding}, in symbols $\RT{\Config^1} \sim \RT{\Config^2}$ or 
$(\RT1, \RT{\gamma^1}, \RT{\sigma^1}, \RT{\DMap^1}, \RT{\Acc^1}, \RT{\stmt^1})$ $\sim$ $(\RT2, \RT{\gamma^2}, \RT{\sigma^2}, \RT{\DMap^2}, \RT{\Acc^2}, \RT{\stmt^2})$, 
if and only if 
$\RT{\gamma^1}=\RT{\gamma^2}$, $\RT{\sigma^1} \sim \RT{\sigma^2}$, $\RT{\DMap^1} \sim \RT{\DMap^2}$, $\RT{\Acc^1}=\RT{\Acc^2}$, and $\RT{\stmt^1}=\RT{\stmt^2}$. 
\end{definition}



\begin{axiom}[$MPC_b$]%\small
\label{axiom: mpc bop}
Given $\binop\in\{+,-,\cdot, \div\}$, values $\{\RT{\n^{\pid}_{1}},$ $\RT{\n^{\pid}_{2}}, \hn_{1},$ $\hn_{2}\}^{\pidZ}_{\pid=\pidA}\in\N$, 
\\
if $MPC_b(\binop,$ $[\RT{\n^{\pidA}_{1}}, ...,$ $\RT{\n^{\pidZ}_{1}}],$ $[\RT{\n^{\pidA}_{2}}, ..., \RT{\n^{\pidZ}_{2}}])$ $= (\RT{\n^{\pidA}_{3}}, ..., \RT{\n^{\pidZ}_{3}})$, 
$\{\RT{\n^{\pid}_{1}} \cong \hn_1\}^{\pidZ}_{\pid=\pidA}$, 
	and
$\{\RT{\n^{\pid}_{2}} \cong \hn_2\}^{\pidZ}_{\pid=\pidA}$,  
\\
then $\{\RT{\n^{\pid}_{3}} \cong \hn^\pid_3\}^{\pidZ}_{\pid=\pidA}$ 
such that $\hn_1\ \binop\ \hn_2 = \hn_3$. 
\end{axiom}


\begin{lemma}[$\RT{\Config^1} \sim \RT{\Config^2} \implies \RT{\Config^1}\Pcong\hConfig \land \RT{\Config^2}\Pcong\hConfig$]%\small
\label{lem: sim implies cong same}
Given two configurations $\RT{\Config^1},\RT{\Config^2}$ such that 
$\RT{\Config^1} = (\RT1, \RT{\gamma^1}, \RT{\sigma^1}, \RT{\DMap^1}, \RT{\Acc^1}, \RT{\stmt^1})$ and $\RT{\Config^2} = (\RT2, \RT{\gamma^2}, \RT{\sigma^2}, \RT{\DMap^2}, \RT{\Acc^2}, \RT{\stmt^2})$ and $\psi$, 
if $\RT{\Config^1} \sim \RT{\Config^2}$ 
then $\{\RT{\Config^\pid}\Pcong(\pid, \hgamma, \hsigma, \bsq, \bsq, \stmt)\}^2_{\pid=1}$. 
\end{lemma}
\begin{proof}[Proof Sketch]%\small
Using the definition of $\erasure$ and Definition~\ref{def: config sim}, there is only one possible \vanillaC\ configuration $\hConfig$ (modulo party ID) that can be obtained from both 
$\erasure(\RT{\Config^1})$ and $\erasure(\RT{\Config^2})$. 
\end{proof}




\begin{lemma}[Unique party-wise transitions]%\small
\label{lem: smc unique rules}
Given $((\RT\pid, \RT\gamma, \RT\sigma, \RT\DMap, \RT\Acc, \RT\stmt) \Mid \RT\Config)$
if $((\RT\pid, \RT\gamma, \RT\sigma, \RT\DMap, \RT\Acc, \RT\stmt) \Mid \RT\Config)$ $\Deval{\RT\locLL}{\RT\codeLL}$
   $((\RT\pid, \RT{\gamma_1}, \RT{\sigma_1}, \RT{\DMap_1}, \RT\Acc, \RT\val) \Mid \RT{\Config_1})$
then there exists no other rule by which $(\RT\pid, \RT\gamma, \RT\sigma, \RT\DMap, \RT\Acc, \RT\stmt)$ can step. 
\end{lemma}
\begin{proof}[Proof Sketch]%\small
By induction on $(\RT\pid, \RT\gamma, \RT\sigma, \RT\DMap, \RT\Acc, \RT\stmt)$. 
We verify that for every configuration, given $\RT\stmt$, $\RT\Acc$, and stored type information, there is only one corresponding semantic rule.
\end{proof}







\begin{theorem}[Confluence]%\small
\label{thm: smc confluence}
Given $\RT{\Config^\pidA} \Mid ... \Mid \RT{\Config^\pidZ}$ such that $\{\RT{\Config^\pidA} \sim \RT{\Config^\pid}\}^{\RT\pidZ}_{\RT\pid = \RT\pidA}$ 
\\
if $(\RT{\Config^\pidA} \Mid ... \Mid \RT{\Config^\pidZ})$ $\Deval{\RT{\locLL_1}}{\RT{\codeLL_1}}$ $(\RT{\Config^\pidA_1} \Mid ... \Mid \RT{\Config^\pidZ_1})$ such that $\exists \RT\pid\in\{\RT\pidA...\RT\pidZ\} \RT{\Config^\pidA_1} \not\sim \RT{\Config^\pid_1}$, 
\\
then $\exists$ $(\RT{\Config^\pidA_1} \Mid ... \Mid \RT{\Config^\pidZ_1})$ $\Deval{\RT{\locLL_2}}{\RT{\codeLL_2}}$ $(\RT{\Config^\pidA_2} \Mid ... \Mid \RT{\Config^\pidZ_2})$
\\ 
such that $\{\RT{\Config^\pidA_2} \sim \RT{\Config^\pid_2}\}^{\RT\pidZ}_{\RT\pid = \RT\pidA}$, 
$\{(\RT{\locLL^\pidA_1}\addL\RT{\locLL^\pidA_2}) = (\RT{\locLL^\pid_1}\addL\RT{\locLL^\pid_2})\}^{\RT\pidZ}_{\RT\pid = \RT\pidA}$, 
and $\{(\RT{\codeLL^\pidA_1}\addC\RT{\codeLL^\pidA_2}) = (\RT{\codeLL^\pid_1}\addC\RT{\codeLL^\pid_2})\}^{\RT\pidZ}_{\RT\pid = \RT\pidA}$.
\end{theorem}

\begin{proof}[Proof Sketch]%\small
By Lemma~\ref{lem: smc unique rules}, we have that there is only one possible execution trace for any given party based on the starting configuration. 
~\\ 
By definition of $\{\RT{\Config^\pidA} \sim \RT{\Config^\pid}\}^{\RT\pidZ}_{\RT\pid = \RT\pidA}$, 
we have that the starting states of all parties are corresponding, with identical statements. 
~\\ 
Therefore, all parties must follow the same execution trace and will eventually reach another set of corresponding states.
\end{proof}




\begin{axiom}
\label{correctness assumption}%\small
For purposes of correctness, 
we assume all parties are executing program $\RT\stmt$ 
from initial state $(\RT\pid, \RT{[\ ]}, \RT{[\ ]}, \RT{[\ ]}, \RT\AccZ, \RT\stmt)$
and corresponding input data. 
\end{axiom}



\begin{theorem}[Semantic Correctness]%\small
\label{Thm: app correctness}
~\\
For every configuration $\{(\RT\pid,\ \rrgamma^{\RT{\pid}}_{},$ $\rrsigma^{\RT{\pid}}_{},$ $\RT\DMap^{\RT{\pid}}_{}$, $\rAcc^{\RT{\pid}}_{},$ $\rstmt^{\RT\pid})\}^{\RT\pidZ}_{\RT\pid = \RT\pidA}$, 
$\{(\pid,$ $\hgamma^\pid,$ $\hsigma^\pid,$ $\bsq,$ $\bsq,$ $\hstmt^\pid)\}^{\pidZ}_{\pid = \pidA}$ and \LocMap\ $\psi$ 
\\ such that $\{(\RT\pid, \rrgamma^{\RT{\pid}}_{},$ $\rrsigma^{\RT{\pid}}_{},$ $\RT\DMap^{\RT{\pid}}_{}$, $\rAcc^{\RT{\pid}}_{},$ $\rstmt^{\RT{\pid}})$ $\Pcong$ 
$(\pid,$ $\hgamma^\pid,$ $\hsigma^\pid,$ $\bsq,$ $\bsq,$ $\hstmt^\pid)\}^{\pidZ}_{\pid = \pidA}$, 
\\ % a 
if $\RT\Pi \deriv ((\RT\pidA, \rrgamma^{\RT{\pidA}}_{},$ $\rrsigma^{\RT{\pidA}}_{},$ $\RT\DMap^{\RT{\pidA}}_{}$, $\rAcc^{\RT{\pidA}}_{},$ $\rstmt^{\RT{\pidA}})\ \Mid ...\Mid$ 
	$(\RT\pidZ, \rrgamma^{\RT{\pidZ}}_{},$ $\rrsigma^{\RT{\pidZ}}_{},$ $\RT\DMap^{\RT{\pidZ}}_{}$, $\rAcc^{\RT{\pidZ}}_{},$ $\rstmt^{\RT{\pidZ}}))$ 
	\\ \-\ \-\ \-\ $\Deval{\RT\locLL}{\RT\codeLL}$ 
	$((\RT\pidA, {\rrgamma^{\RT{\pidA}}_{\RT1}},$ ${\rrsigma^{\RT{\pidA}}_{\RT1}},$ $\RT\DMap^{\RT{\pidA}}_{\RT1}$, $\rAcc^{\RT{\pidA}}_{\RT1},$ ${\RT\val^{\RT{\pidA}}_{}}) \Mid ... \Mid$ 
	$(\RT\pidZ, {\rrgamma^{\RT{\pidZ}}_{\RT1}},$ ${\rrsigma^{\RT{\pidZ}}_{\RT1}},$ $\RT\DMap^{\RT{\pidZ}}_{\RT1}$, $\rAcc^{\RT{\pidZ}}_{\RT1},$ $\RT\val^{\RT{\pidZ}}))$ 
\\ for codes $\RT\codeLL \in \RT{\piccoCodes}$,
then there exists a derivation 
\\ % b
$\Sigma \deriv\ ((\pidA,$ $\hgamma^\pidA,$ $\hsigma^\pidA,$ $\bsq,$ $\bsq,$ $\hstmt^\pidA)\Mid ...\Mid $
	$(\pidZ,$ $\hgamma^\pidZ,$ $\hsigma^\pidZ,$ $\bsq,$ $\bsq,$ $\hstmt^\pidZ))$ 
	\\ $\Deval{}{\codeVLL}$ 
	$((\pidA,$ $\hgamma^\pidA_1,$ $\hsigma^\pidA_1,$ $\bsq,$ $\bsq,$ $\hval^\pidA)\Mid...\Mid$
	$(\pidZ,$ $\hgamma^\pidZ_1,$ $\hsigma^\pidZ_1,$ $\bsq,$ $\bsq,$ $\hval^\pidZ))$ 
\\ for codes $\codeVLL \in \vanillaCodes$ 
and 
% c
a \LocMap\ $\psi_1$ 
% d
such that 
\\ % f
$\RT\codeLL \cong \codeVLL$, 
% g
$\{(\RT\pid, {\rrgamma^{\RT{\pid}}_{\RT1}},$ ${\rrsigma^{\RT{\pid}}_{\RT1}},$ $\RT\DMap^{\RT{\pid}}_{\RT1}$, $\rAcc^{\RT{\pid}}_{\RT1},$ $\RT\val^{\RT{\pid}}_{})$ $\cong_{\psi_1}$ 
$(\pid,$ $\hgamma^\pid_1,$ $\hsigma^\pid_1,$ $\bsq,$ $\bsq,$ $\hval^\pid)\}^{\pidZ}_{\pid = \pidA}$, 
% h
and $\RT\Pi \cong_{\psi_1} \Sigma$.
\end{theorem}



\begin{proof}[Proof Sketch]
By induction over all \piccoC\ semantic rules. 

The bulk of the complexity of this proof lies with rules pertaining to Private If Else, handling of pointers, and freeing of memory.  We first provide a brief overview of the intuition for the simpler cases and then dive deeper
into the details for the more complex cases.  Full proofs are available in our artifact submission.

For the rules evaluating over public data, correctness follows simply as the \vanillaC\ and \piccoC\ rules for public data are nearly identical. For all the semantic rules that use general helper algorithms (i.e., algorithms in common to both \vanillaC\ and \piccoC), we also reason about the correctness of the helper algorithms, comparing the \vanillaC\ version and the \piccoC version. Correctness over such algorithms is easily proven, as these algorithms are nearly identical, differing on privacy labels as we do not have private data in \vanillaC. 

For all \piccoC\ multiparty semantic rules, we relate them to the multiparty versions of the \vanillaC\ rules. To reason about the multiparty protocols, we leverage Axioms, such as Axiom~\ref{axiom: mpc bop}, to prove these rules correct. These Axioms should be proven correct by a library developer to ensure the completeness of the formal model. The correctness of most multiparty semantic rules follows easily, with Multiparty Private Free being an exception. For this rule, we also must reason about our helper algorithms that are specific to the \piccoC\ semantics (e.g., $\UpdateBytesFree$, $\UpdatePtrLocs$). We leverage the correctness of the behavior of the multiparty protocol $\PFree$, to show that correctness of these algorithms follows due to the deterministic definitions of the algorithms. In this case, we must also show that the locations that are swapped within this rule (which is done to hide the true location) are deterministic based on our memory model definition. We use $\psi$ to map the swapped locations, enabling us to show that, if these swaps were reversed, we would once again have memories that are directly congruent. This concept of locations being $\psi$-congruent is particularly necessary when reasoning about pointers in other rule cases. 
For all the rules using private pointers, we will rely upon the pointer data structure containing a set of locations and their associated tags, only one of which being the true location. With this proven to be the case, it is then clear that the true location indicated within the private pointer's data structure in \piccoC\ will be $\psi$-congruent  with the location given by the pointer data structure in \vanillaC.
In our proof, we make the assumption that locations are not hard-coded, as hard-coded locations would lead to potentially differing results between \vanillaC\ and \piccoC\ execution due to the behavior of \TT{pfree}. Additionally, given the distributed nature of the \piccoC, it would not make sense to allow hard-coded locations, as a single program will be executed on several different machines.

For rule Private Malloc, we must relate this rule to the sequence of \vanillaC\ rules for Malloc, Multiplication, and Size Of Type. This is due to the definition of \TT{pmalloc} as a helper that allows the user to write programs without knowing the size of private types. This case follows from the definition of translating the \piccoC\ program to a \vanillaC\ program, $\bm{\erasure}({\PMalloc(\Expr,\ \Type)} 
= {(\Malloc(\sizeof(\bm{\erasure}(\Type)) \cdot \bm{\erasure}(\Expr)))})$.

For the Private If Else rules, we must reason that our end results in memory after executing both branches and resolving correctly match the end result of having only executed the intended branch. 
The cases for both of these rules will have two subcases - one for the conditional being true, and the other for false. 
To obtain correctness, we use multiparty versions of the if else true and false rules that execute both branches - this allows us to reason that both branches will evaluate properly, and that we will obtain the correct ending state once completed. 
For both rules, we must first show that $\DynExtract$ will correctly find all non-local variables that are modified within both branches, including non-assignment modifications such as use of the pre-increment operator $++\x$, and that all such modified variables will be added to the list (excluding pointers modified exclusively by pointer dereference write statements). We must also show that it will correctly find and tag if a pointer dereference write statement was found. These properties follow deterministically from the definition of the algorithm. 

For rule Private If Else Variable Tracking, we will leverage the correctness of $\DynExtract$, and that if $\DynExtract$ returns the tag 0, no pointer dereference writes were found. We then reason that $\Initialize$ will correctly create the assignment statements for our temporary variables, and that the original values for each of the modified variables will be stored into the \TT{else} temporary variables. The temporaries being stored into memory correctly through the evaluation of these statements follows by induction. Next we have the evaluation of the \TT{then} branch, which will result in the values that are correct for if the condition had been true - this holds by induction. 
We then proceed to reason that $\Restore$ will properly create the statements to store the ending results of the \TT{then} branch into the \TT{then} temporary variables, and restore all of the original values from the \TT{else} variables (the original values being correctly stored follows from $\Initialize$ and the evaluation of it's statements). The correct evaluation of the this set of statements follows by induction. 
Next we have the evaluation of the \TT{else} branch, which will result in the values that are correct for if the condition had been false - this holds by induction and the values having been restored to the original values properly.
We will then reason about the correctness of the statements created by $\Resolve$. These statements must be set up to correctly take the information from the \TT{then} temporary variable, the temporary variable for the condition for the branch, and the ending result for all variables from the \TT{else} branch. For the resolution of pointers, we insert a call for a resolution function ($\resolve$), because the resolution of pointer data is more involved. The evaluation of this function is shown in rule Multiparty Resolve Pointer Locations. By proving that this rule will correctly resolve the true locations for pointers, we will then have that the statements created by $\Resolve$ will appropriately resolve all 


For rule Private If Else Location Tracking, the structure of the case is similar to the rule for variable tracking, but with a few differences we will discuss here. 
For this rule, we will need to reason about $\DynUpdate$, and that we will catch all modifications by pointer dereference writes and properly add them to $\DMap$ if the location being modified is not already tracked. If a new mapping is added, we store the current value in $\val_\mathit{orig}$ (as this location has not yet been modified) and the tag has to be set to 0. This behavior will be used to ensure the correctness during resolution.
For $\DynInit$, we must reason that we correctly initialize the map $\DMap$ with all of the locations we found within $\DynExtract$ to be modified by means other than pointer dereference writes and store their original values in $\val_\mathit{orig}$. 
Then we can evaluate the \TT{then} branch, which will result in the values that are correct for if the condition had been true - this holds by induction. 
For $\DynRestore$, we reason that we properly store the results of the \TT{then} branch, and update the tag for the location to signify that we should use $\val_\mathit{then}$ instead of $\val_\mathit{orig}$. We will then restore the original values, leveraging the correctness of $\DynInit$ to prove this will happen correctly. 
Then we can evaluate the \TT{else} branch, which will result in the values that are correct for if the condition had been false - this holds by induction. 
For $\DynResolve$, we reason that we will create the appropriate resolution statements to be executed. For the \TT{then} result, these statements must use the value stored in $\val_\mathit{orig}$ if the tag is set to 0 (this occurs if the first modification to the location was a pointer dereference write within the \TT{else} branch), and the value stored in $\val_\mathit{then}$ if the tag is set to 1. We prove this to be the correct \TT{then} result through the correctness of $\DynUpdate$ and $\DynRestore$. The \TT{else} result must use the current value for that location in memory, which is proven to be the correct \TT{else} result through the correctness of $\DynInit$ and $\DynResolve$. In this way, we can prove the correctness the contents of the statements created by $\DynResolve$, and then the correctness of the evaluation of the statements created by $\DynRestore$ will hold as we discussed for with those created by $\Resolve$ for Private If Else Variable tracking. 
\end{proof}




