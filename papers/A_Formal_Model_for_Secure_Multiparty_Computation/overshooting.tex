
It is possible to overshoot memory bounds in both \vanillaC\ and \piccoC. 
Figure~\ref{Fig: arr oob read vanC} shows an example of an array read that overshoots the bounds of the array \TT{x} (for simplicity, \TT{x} is of size 1).  
The first access shown  is an in-bounds access -- this is the default behavior of a  correct
program.  The second access is an out-of-bounds access of a memory block of a different type, but the same size. This data would be read as if it was the type of the array, and may not be meaningful.  This corresponds to an access where implicit conversions between types is possible, but not always correct.
The third out-of-bounds access corresponds to reading out of a memory block of the same type. This data would be meaningful from a type perspective, but the specific value read may not be semantically meaningful to the program. 
 The fourth out-of-bounds access is of a memory block of a different type of a smaller size. This read would grab the data from the smaller memory block, then grab data from the next memory block(s) to obtain the correct amount for the expected type.  In this situation a value, which may not be meaningful, is constructed from two, or more, values in memory.
 The last out-of-bounds access is of a larger memory block, not aligned. This read would obtain a portion of the data of the larger memory block, and read it as the type of the array, thereby reading a partial value from memory.

With \piccoC, when dealing with array overshooting, we have the added complexity of private data, which has a different representation and is of a larger size than the corresponding C representation of the type. 
Additionally, we need to ensure that no leakage can occur, so we must consider all possible combinations of bytes from public and private data with either public or private variables. 
Consider reading a value from an overshot array and storing it into a variable. If both the data read and variable are private or both are public, no leakage can occur as these are the default cases.
Next, consider reading public data and storing into a private variable. The public data will be grabbed at the byte-level, and interpreted as though it is private (no encryption will occur), so no leakage occurs.
Third, we consider reading private data and storing in a public variable. The private data will be grabbed at the byte-level, and interpreted as though it is public. No decryption will occur, so no leakage can occur. This is similar in nature to reading a partial value in Figure~\ref{Fig: arr oob read vanC}. 
Fourth, consider if the data read is a mix of public and private data and stored in a public variable. Given that the private data will not be decrypted, this read will not result in any leakage, but a value is constructed from a mix
of private (encrypted) data and public data. 
Lastly, consider reading a mix of public and private data and storing into a private variable. Like before, the byte-level data will be merged and read as the expected type. 


Writes that occur out-of-bounds of an array have situations similar to out-of-bound read accesses (and can be illustrated as with the reads shown in Figure~\ref{Fig: arr oob read vanC}).
Writing private data out-of-bounds to a private location results in the data still residing in a private memory block, so no leakage will occur. 
Writing public data out-of-bounds to a public location is safe, as the data is already public. 
When writing private data out-of-bounds to a public location, the data will be written as-is -- no decryption will occur when the data is written to or later read back from that location -- therefore, there is no leakage.
Writing public data out-of-bounds to a private location or a mix of public and private locations is safe, as the data was already public; no encryption will occur. 
Lastly, writing private data out-of-bounds to a mix of locations will result in the data being written to the locations as-is. No decryption will occur when the data is written to any location or later read back, therefore, there is no leakage.

In \piccoC, we ensure this behavior, 
using algorithms $\ReadOOB$ and $\WriteOOB$. 
In particular, $\ReadOOB$ ensures that no matter what mix of byte-wise data we grab from memory, we will decode it as a value of the type of data in the array, ignoring it's true type. 
Similarly, $\WriteOOB$ ensures that we will write to memory the byte-wise encoding of the given value as the type for the array, without taking into consideration the type of the memory block(s) and without modifying any of the metadata within the memory block(s) we write to. 
In proving the correctness of \piccoC\ with relation to \vanillaC, the various possible alignments for reading and writing out-of-bounds poses complications due to the different sizes of private and public data (an example of this is shown in the Appendix, Figure~\ref{fig: overshooting alignment}). Therefore, we can only prove correctness over well-aligned accesses (i.e., those that iterate only over aligned elements of the same type). 
When proving noninterference, we must prove that these cases (particularly those involving private data) cannot leak any information about the private data that is affected. We discuss this in more detail in
the following section.















