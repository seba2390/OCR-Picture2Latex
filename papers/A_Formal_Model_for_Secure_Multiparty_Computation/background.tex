


\begin{figure*} \centering
\begin{tabular}{c}
\begin{lstlisting}
public int numParticipants=100, maxInput=100, inputSize[numParticipants];
public int historicFemaleSalAvg, historicMaleSalAvg, i, j;
private int salary[numParticipants][maxInput], maleCount=0; 
private int gender[numParticipants][maxInput], femaleCount=0;
private int avgMaleSalary=0, avgFemaleSalary=0; 

smcinput(historicFemaleSalAvg,1); smcinput(historicMaleSalAvg,1);
for (i=0; i<numParticipants; i++) 
	smcinput(inputSize[i], i+1); 
	smcinput(gender[i], inputSize[i], i+1); 
	smcinput(salary[i], inputSize[i], i+1); 
	
for (i=0; i<numParticipants; i++) 
	for (j=0; j<inputSize[i]; j++) 
		if (gender[i][j]==0) {
			avgFemaleSalary+=salary[i][j]; 
			femaleCount++;} 
		else { 
			avgMaleSalary+=salary[i][j]; 
			maleCount++;} 
			
avgFemaleSalary=(avgFemaleSalary/femaleCount)/2+historicFemaleSalAvg/2; 
avgMaleSalary=(avgMaleSalary/maleCount)/2+historicMaleSalAvg/2; 

for (i=1; i<numParticipants+1; i++) 
	smcoutput(avgFemaleSalary, i);  smcoutput(avgMaleSalary, i); 
\end{lstlisting}
\end{tabular}
\caption{Securely calculating the gender pay gap for 100 organizations.}
\label{Fig: salary vs gender}
\end{figure*}


We next motivate the need for formalization and discuss the challenges formalizing main language features presents. Let us consider an example SMC program that demonstrates how computation with private values can be specified and carried out. Figure~\ref{Fig: salary vs gender} presents an SMC program that securely computes the average salary of employees in a particular field by gender. This is representative of a real-world SMC deployment in the City of Boston gender pay gap study~\cite{Lapets18}, which evaluated pay inequalities by gender and race. While we list a simple program, the computation can be extended to securely compute comprehensive statistical information by gender, race, and other relevant attributes.

In this example, there are 100 organizations (line 1), each contributing a number of records about their employees, specified in the form of salary-gender pairs (lines 3--4). All records are private and must be protected from all participants. The computation proceeds by checking the gender field in a record and using the corresponding salary in the computation of either female or male average salary. Once the average salaries are computed privately, they are combined with publicly available historical averages using weighted average computation (lines 22-23).

When we talk about secure computation, we need to distinguish between the values which must be protected throughout the computation (and are not revealed to the participants) and the values requiring no protection which are therefore observable during the computation. In our specification, the former are marked as \emph{private} (e.g., salary-gender pairs and information derived from them) and the latter are marked as \emph{public} (e.g., the number of records that each organization contributes and historical average salaries). The ability to combine computation with private and public values is called \emph{mixed-mode} execution.

In our example, all inputs (public or private) are entered into the computation using the \texttt{smcinput} interface that expects the variable name, its dimension(s) (for array variables) and the index of the party supplying the input. When a private input enters the computation, it uses a different, cryptographically protected representation in accordance with the underlying secure multi-party computation techniques. That representation is maintained throughout the execution, which means that all operations on private data are carried out using the corresponding secure multi-party protocols and their true values are not observable. All public values are handled in the same way as in conventional computation, i.e., an SMC compiler does not modify the computation and the values are observable by any participant running the computation. Upon computation completion, any output is communicated to the intended recipient via the \texttt{smcoutput} interface. If \texttt{smcoutput} is used with a private variable, its true value can be recovered from its cryptographically protected representation by the output recipient only (and remains unknown to all other parties). Because output recovery happens after the computation completes, the disclosed output is the intended outcome of secure computation and is not subject to the security guarantees maintained during the computation (such as non-interference). 

The above interface distinguishes between different types of participants: those who \emph{supply inputs}, those who \emph{learn outputs}, and the parties \emph{carrying out the computation}. The computational parties can be different from input owners and output recipients and their selection may be based on the properties of the underlying secure multi-party computation techniques. For example, there are often constraints with respect to what fraction of computational parties can collude, i.e., combine their individual views during the computation, in order to maintain security of private values. This means that in our example, the participants can select a subset of them to run the computation or employ other parties such as cloud computing providers.

The main property this design guarantees is that  a computational party that is not an output recipient should learn nothing about the private values it handles during the computation.  To formalize this property about SMC programs we will show non-interference between private and public computations in mixed-mode programs. Non-interference ensures that private data does not directly affect publicly observable data and is crucial for mixed-mode execution. For the example given in Figure~\ref{Fig: salary vs gender}, non-interference ensures that the private data (e.g., \texttt{salary[i][j]}) does not affect any public data (e.g., \texttt{historicFemaleSalaryAvg}).

This is a distributed, mixed-mode computation, computed between multiple participants. Each individual salary should be kept private and none of the participants should be able to deduce  the salary (up to some number of colluding computational parties -- this is dependent on the cryptographic protocols used).
The computation is mixed-mode as it includes portions which are {\em protected} -- computations over private data (e.g., finding the sum of all the salaries and counting the total number of males and females), and portions which are {\em unprotected} -- local computations over public data (e.g., dividing the historic salaries by 2 in line 22 and 23). 
Secure computations by definition are distributed and governed by cryptographic protocols (e.g., conditional addition \texttt{sumFemaleSalary += salary[i][j];} on line 11).   This occurs because to do the increment operation to compute the total sum, each participant must interact during the operation. 


Given a program such as the one in our example, an SMC compiler will perform certain transformations such as substituting an operation on private values with the corresponding SMC protocol for performing that operation securely.  In addition, the SMC compiler also has to perform structural transformations to programs to ensure that there is no information flow from private to public variables based on the instructions that a computational party executes. This is called \emph{data-oblivious} (or data-independent) execution. This means that for private-conditioned branches, the execution must not reveal which branch gets executed.  
Given that our formal model must also ensure \emph{data-oblivious} execution, we have designed our formal model to embody these transformations, using big-step semantics to transform the original operations into the secure operations.  
We formalize this by showing that non-interference holds not only when considering the input-output functional behavior of a program, but also when considering the traces of execution of programs.












