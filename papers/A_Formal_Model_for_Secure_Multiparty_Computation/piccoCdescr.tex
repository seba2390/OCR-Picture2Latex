
\subsection{\piccoC\ Semantics} \label{smc C descr}


The \piccoC\ semantics are defined over multiple {\em interacting} parties.
The \piccoC\ semantics used to define the behavior of 
parties are mostly standard, with \emph{non-interactive} semantic rules identical to those of \vanillaC\ semantics aside from additional assertions over the privacy labels of data and properly managing the private data. 
A few notable exceptions are \emph{interactive} SMC operations (and in general operations over private values)
and the private-conditioned \Code{if else} statement, discussed in later in this section.    
To prevent leakage from within private-conditioned branches, we restrict all public side effects (i.e., the use of functions with public side effects, allocation and deallocation of memory, and any modifications to public variables). 
Additionally, in the case of pointer dereference write and array write statements, we have an additional check for when this occurs within a private-conditioned branch, as we need to perform additional analysis to ensure the location being written to is tracked properly due to the potential for the pointer's location being modified or an out-of-bounds array write. 
To enforce these restrictions, we use the assertion $\Acc = \AccZ$ within each restricted rule -- as the accumulator $\Acc$ is incremented at each level of nesting of a private-conditioned branch, this will result in a runtime failure. 
We annotate each evaluation with party-wise lists of the evaluation codes $\codeLL$ of all rules that were used during the execution of the rule (i.e., $\Deval{\locLL}{\codeLL}$) in order to keep an accurate evaluation tree, and party-wise lists of locations accessed $\locLL$ in order to show data-obliviousness (i.e., that given the same program and public data, we will always access the same set of locations). 


%%%%%%%%%%%%%%%%%%%%%%
%
% 		Basic Evaluations
%
%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Basic Evaluation} \label{subsec: picco basic eval}
% Less Than True
To better illustrate the correspondence between \piccoC\  and \vanillaC\  let us consider the Multiparty Binary Operation rule.
\piccoC\ rule Multiparty Binary Operation asserts that one of the given binary operators ($\cdot, +,-,\div$) is used and additionally that either expression contains private data with relation to the environment. 
We use the notation $(\Expr_{1}, \Expr_{2}) \isPriv \gamma$ to show this relation, and  
notation $\{...\}^{\pidZ}_{\pid = \pidA}$ to show that all parties will ensure that property holds locally.
We then use the multiparty protocol $\MPC{b}$, passing the given binary operator and the current values of $\n^\pid_1$ and $\n^\pid_2$ for each party $\pid$. 
This protocol will dictate how communication occurs and what data is exchanged between parties. 
We receive $\n^\pid_3$ as the result for each party, which we then return appropriately.   We assume that the protocol is implemented correctly (i.e. provided by the underlying SMC cryptographic library) and define this assumption formally, its impact on our noninterferences proof, and how to reason if a library adheres to our assumption later in Section~\ref{sec: noninterference}. 
Within the multiparty rules, each party maintains control of their own data, only sharing it with other parties in the ways dictated by the multiparty protocols. We choose to show the execution of the entire computational process here in order to emphasize what data is involved, and that each of the parties will take part in this computation. 

% Write Priv x = Pub
In rule Write Private Variable Public Value, we assert that $\Expr$ contains only public data,  
then evaluate $\Expr$ to $n$. We look up $\x$ in $\gamma$, asserting that it is a $\Priv\ \btype$ at location $\loc$. 
When we call $\Update$ to store this value to memory, we must pass $\Encrypt(n)$ as $\x$ is private and we are assigning it the public value $n$. 


%%%%%%%%%%%%%%%%%%%%%%
%
% 		Pointer Evaluations
%
%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Pointer Evaluations} \label{subsec: picco ptr eval}
In order to maintain data-oblivious execution, we need to allow storing multiple locations for pointers when they are modified within a private-conditioned branching statement. To achieve this, 
% Pointer structure
the structure of the data stored by pointers is as follows: the number $\nl$ of locations being pointed to; a list of $\nl$ locations being pointed to; a list of $\nl$ tags; and the level of indirection of the pointer. 
% 
The privacy labels of the byte-wise permissions corresponding to the number $\nl$ of locations to which the pointer refers, the list of $\nl$ locations, and the level of indirection will always be public, as it is visible to an observer of memory the number and which locations are touched by a pointer, and the level of indirection is visible in the source program.
%
The privacy labels of the permissions corresponding to the tags of public pointers will always be public; for private pointers, they will be private, as these protect an observer of memory from being able to tell which location is the true location. 
%
%%
% Priv Ptr Decl
In rule Private Pointer Declaration, we assert that the type of the variable being declared is an int or float pointer that is either declared as private or missing a privacy label (i.e., $\btype*$) and therefore is assumed to be private. 
As with the \vanillaC\ pointer declaration, we check the level of indirection and add the appropriate mappings to the environment and memory. 


%%%%%%%%%%%%%%%%%%%%%%
%
% 		Mem Alloc / Dealloc
%
%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Memory Allocation and Deallocation} \label{subsec: picco mem alloc/dealloc}
% PMalloc
When allocating private memory, we provide the \TT{pmalloc} builtin function to internally handle obtaining the size of the private type; the programmer to only needs to know how many elements of the given type they desire to allocate.
In rule Private Malloc, we assert that the given type is either private int or private float, as this function only handles those types, and that the accumulator $\Acc$ is $\AccZ$ (i.e., we are not inside an \Code{if else} statement branching on private data, as this function causes public side effects). 
Then we evaluate $\Expr$ to $n$ and obtain the next open memory location $\loc$ from $\phi$. We add to $\sigma{_1}$ the new mapping from $\loc$ to the tuple of a $\Null$ set of bytes; the type $\Type$; the size $n$; and a list of $\Priv$, $\PermF$ permissions. 
As with public \Code{malloc}, we return the new location, $(\loc, 0)$. 

% PFree
When deallocating private memory, we provide the \TT{pfree} builtin function to handle private pointers potentially having multiple locations. 
In the case of a single location, it behaves identically to Public Free; however, with multiple locations, we need to deterministically free a single location (which may or may not be the true location that was intended to be freed) to maintain data-obliviousness. We describe this case in more detail here.   
In rule Multiparty Private Free, we assert that $\x$ is a private pointer of type int or float, we are not inside a private-conditioned branch ($\Acc$ is $\AccZ$, as this rule causes public side effects), and that the number of locations the pointer refers to ($\nl$) is greater than 1 for all parties. 
We then assert that \emph{all} locations referred to by $\x$ are freeable (i.e., they are all memory blocks that were allocated via malloc) and proceed to retrieve the data that is stored for each of these locations.
This data and the tag lists are then passed to $\PFree$, as this is what we will need in order to privately free a location without revealing if it was the true location. 

To accomplish this, we must free one location based on publicly available information, regardless of the true location of the pointer. For that reason, and without loss of generality, we free the first location, $\loc_0$. 
Since $\loc_0$ may not be the true location and may be in use by other pointers, we need to do additional computation to maintain correctness without disclosing whether or not this was the true location. 
In particular, if $\loc_0$ is not the true location, we preserve the content of $\loc_0$ by obliviously copying it to the pointer's true location prior to freeing. 
This behavior is defined in function $\PFree$, and follows the strategy suggested in~\cite{Zhang18}.
$\PFree$ returns the modified bytes and tag lists. $\UpdateBytesFree$ then updates these in their corresponding locations in memory and marks the permissions of $\loc_0$ as $\PermN$ (i.e., this block has been freed). 
The remaining step is to update other pointers that stored $\loc_0$ on their lists to point to the updated location instead of $\loc_0$, which is accomplished by $\UpdatePtrLocs$. 



%%%%%%%%%%%%%%%%%%%%%%
%
% 		Array Evaluations
%
%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Array Evaluations} \label{subsec: picco arr eval}
With array evaluations, all evaluations that use a public index behave nearly identically to those over public data. 
The difference is that we have an additional check within array writes at a public index to see if we are in a private-conditioned branch; if so, we must ensure we properly track the modification made (this is because a public index that is not hard-coded could have lead to an out-of-bounds array write). 
We will discuss this further in the following section. 
When we have a private index, it is necessary to hide which location we a reading from or writing to to maintain data-obliviousness. One such semantic rule is Multiparty Array Read Private Index.
% 
% PUB 1D ARR READ PRIV INDEX
Here, we assert that the privacy label of $\Expr$ is private as this rule handles private indexing into a public array. 
We assert that $\x$ is a public array of type int or float, as we must return a private value when using a private index. 
Then we evaluate $\Expr$ to the private index $\ind$, and perform lookups to obtain the data of the array. 
Now, because we have a private index, we must obtain the value without revealing which location we are taking the value from. 
To do this, we use multiparty protocol $\MPC{ar}$, which returns a private number containing the value from the desired location.  
It is important to note here that even if the private index is beyond the bounds of the array, we do not access beyond the elements within the array, as that would reveal information about the private index. 
An example of how this protocol can be implemented is to iterate over all values stored in the array; at each value, we encrypt the current index number $m$, privately compare it to $\ind$, and perform a bitwise \Code{and} operation over this and the encrypted value $\n_m$ stored at index $m$. We perform a bitwise \Code{or} operation over each such value obtained from the array to attain our final encrypted value $\n$, which is returned. 
%






































