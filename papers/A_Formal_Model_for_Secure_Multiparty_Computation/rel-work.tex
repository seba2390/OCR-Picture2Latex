\paragraph*{SMC compilers}
Work on SMC compilers was initiated in 2004 and a significant body of work has been developed. Notable examples include two-party computation compilers and tools Fairplay~\cite{Malkhi04}, TASTY~\cite{Henecka10}, ABY~\cite{Demmler15a}, PCF~\cite{Kreuter13}, TinyGarble~\cite{Songhori15}, Frigate~\cite{Mood16}, SCVM~\cite{Liu14}, and ObliVM~\cite{Liu15}; three-party Sharemind~\cite{Bogdanov08}; and multi-party FairplayMP~\cite{BenDavid08},  VIFF~\cite{DamgardGKN09}, and more recently SCALE-MAMBA, which evolved from \cite{BendlinDOZ11,DamgardPSZ12,NielsenNOB12}.
These compilers use custom DSLs to represent user programs, and notable exceptions are CBMC-GC~\cite{Holzer12} (intended to support general-purpose ANSI-C programs in the two-party setting, but not all features were realized at the time) and PICCO~\cite{Zhang13,Zhang18} (takes programs written in an extension of C, supports all C features, and produces multi-party protocols).
%
The above compilers did not come with a formalism of their type
system~\footnote{The ObliVM publication~\cite{Liu15} suggests that
there is a type system behind the ObliVM language, but no further
information could be found.}, while this was later developed for
Sharemind~\cite{sokk16}. There are also SMC DSLs with formal models,
such as Wysteria~\cite{RastogiHH14} with a formal model based on an
operational semantics and Wys*~\cite{RastogiSH17} which provides
support for SMC by means of an embedded DSL hosted in F*, a
dependently typed language supporting full verification. A different
approach is given in~\cite{PettaiL15} with an automated technique to
prove SMC protocols secure.

We provide a summary of significant features supported
in recent compilers in Table~\ref{tab:smc-compilers} (Wys*~\cite{RastogiSH17} inherits its expressivity from Wysteria and is
omitted).
\begin{table} \small \centering \setlength{\tabcolsep}{1ex} \footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|} \hline
  \multirow{3}{*}{Compiler} & \multicolumn{6}{|c|}{Supported features} \\\cline{2-7}
  & \multirow{2}{*}{loops} & priv.  & mixed & float. & dyn. & seman. \\
  & & cond. & mode & point & mem. & formal. \\ \hline
  Fairplay~\cite{Malkhi04} & \hc & \fc & \ec & \ec & \ec & \ec \\ \hline
  Sharemind~\cite{Bogdanov08,jagomagis2010secrec} & \fc & \hc & \fc & \fc & \ec & \fc \\ \hline
  CBMC-GC~\cite{Holzer12} & \hc & \fc & \ec & \hc & \ec & \ec \\ \hline 
  PICCO~\cite{Zhang13,Zhang18} & \fc & \fc & \fc & \fc & \fc & \ec \\ \hline
  SCALE-MAMBA & \fc & \fc & \fc & \fc & \ec & \ec \\ \hline
  Wysteria~\cite{RastogiHH14} & \fc & \fc & \fc & \ec & \ec & \fc \\ \hline
  Frigate~\cite{Mood16} & \fc & \fc & \ec & \ec & \ec & \ec \\ \hline
  ABY~\cite{Demmler15a} & \hc & \hc & \fc & \fc & \ec & \ec \\ \hline
  ObliVM~\cite{Liu15} & \fc & \fc & \fc & \fc & \fc & \ec \\ \hline
  SCVM~\cite{Liu14} & \fc & \fc & \fc & \ec & \ec  & \fc \\ \hline
\end{tabular}
\caption{Language features supported in SMC compilers.} \label{tab:smc-compilers}
\end{table}
They are supporting loops, private-conditioned branches, supporting both private and public values (mixed mode), floating point arithmetic on private values, dynamically allocated memory, and having semantic formalism. 
Note that compilers that translate computation into Boolean circuits such as CBMC-GC need to unroll loops and thus can only support a bounded number of loop iterations, denoted as \hc\ in the table. 
ABY also appears to have this limitation and for that reason expects input sizes at compile time. 
Recent compilers that work with a circuit representation (e.g., Wysteria, ObliVM) store compiled programs using intermediate representation and perform loop unrolling and circuit generation at runtime. 
To the best of our knowledge, Sharemind permits updating only a single variable in a private-conditioned branch (i.e., \texttt{if (cond) a = b; else a = c;}). 
Similarly, in ABY the programmer has to encode all logic associated with conditional statements using multiplexers. 
CBMC-GC did not support floating point arithmetic based on open-source software at the time of publication. 

Dynamic memory management is often not discussed in prior work. CBMC-GC is said to support dynamic memory allocation, as long as this can be encoded as a bounded program, but the use of dynamic arrays and memory deallocation is not mentioned. PICCO explicitly supports C-style memory allocation and deallocation as well as dynamic arrays. ObliVM does not explicitly discuss dynamically allocated arrays, but we believe they are supported.
Similarly, out-of-bounds array access in user programs is also not typically discussed in the SMC literature. Therefore, it is difficult to tell what the behavior might be, i.e., whether the compiler checks for this and, if not, whether the behavior of the corresponding compiled program is undefined. Wysteria and PICCO are two notable exceptions: Wysteria has a strongly typed language and will prevent such programs from compiling (recall that it supports only static sizes). PICCO will compile programs with out-of-bounds memory accesses. While the behavior of such programs is undefined in C (and no correctness guarantees can be provided), its analysis demonstrates that no privacy violations take place. We formalize this behavior in this work.

\paragraph*{Non-interference}
Non-interference is a standard information flow security property guaranteeing that information about private data does not directly affect publicly observable data. We will show non-interference over executions of programs using the formal
model and its extension developed in this paper to prove security when SMC techniques and C language primitives are composed. Non-interference and its several variants have been extensively studied by means of language-based techniques, including type systems~\cite{VolpanoS97,AbadiBHR99}, runtime monitor~\cite{AustinF09,SabelfeldR09}, and multi-execution~\cite{DevrieseP10}, to cite a few. One of the challenges in guaranteeing non-interference when attackers can inspect the state of the computation is to guarantee that private information is not implicitly leaked by means of the control flow path, i.e., that the computation is data-oblivious. Several language-based methods have been designed to guarantee that systems are secure against leakage from branching statements, including timing analysis~\cite{Ford12} and multi-path execution~\cite{PlanulM13,Mitchell0SZ12,LaudP16}.
In particular, \cite{Mitchell0SZ12} considered an approach similar to the one we use here. However, these approaches do not prevent private data leakage from explicit memory management. Building on these early works,  several recent works~\cite{PatrignaniG17,AbateBCD0HPTT20} have shown that in the context of secure compilation the natural notion that one needs to consider is a form of non-interference extended to traces. Inspired by this work, this is the notion we use in this paper when reasoning about non-interference. 




