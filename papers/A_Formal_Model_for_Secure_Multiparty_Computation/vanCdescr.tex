

\subsection{\vanillaC\ Semantics} \label{van C descr}


%%%%%%%%%%%%%%%%%%%%%%%
% 
%       Codes For Evaluations
% 
%%%%%%%%%%%%%%%%%%%%%%%
In order to facilitate the correspondence between the \vanillaC\ and \piccoC\ semantics, we model our semantics using big-step evaluation judgements and define our C semantics with respect
to multiple {\em non interacting} parties that evaluate the same program. 
These judgements are defined over a six-tuple configuration $\Config = ((\pid, \gamma, \sigma, \DMap, \Acc, \stmt) \Mid \Config_1)$, where each rule is a reduction from one configuration to a subsequent. 
In the semantics, we denote the party identifier $\pid$;
the environment as $\gamma$; 
memory as $\sigma$;
a mapping structure for location-based tracking of changes at each level of nesting of private-conditioned branches $\DMap$;
the level of nesting of private-conditioned branches as $\Acc$; and
a big-step evaluation of a statement $\stmt$ to a value $\val$ using $\eval$.  
We use a $\hat{\ }$ and $\Veval$ to distinguish the \vanillaC\ semantics from those we use in the next section for \piccoC, as well as $\bsq$ in \vanillaC\ as a placeholder for $\Acc$ and $\DMap$ to maintain the same shape of configurations as that of \piccoC\ used in the next section. 
We annotate each evaluation with party-wise lists of the evaluation codes of all rules that were used during the execution of the rule (i.e., $\Veval_{\codeVLL}$) to facilitate reasoning over evaluation trees. 
We extend the list concatenation operator $::$ to also work over party-wise lists such as $\codeVLL$, defining its behavior as concatenating the lists within $\codeVLL$ by party (i.e., $[(1, \codeVL^1_1), (2, \codeVL^2_1)]::[(1,\codeVL^1_2)] = [(1, \codeVL^1_1::\codeVL^1_2), (2, \codeVL^2_1)]$). 
The assertions in each semantic rule can be read in sequential order, from left to right and top to bottom. 

We present a subset of  the \vanillaC\ semantics  rules in Figure~\ref{Fig: \vanillaC
  sem rules}, focusing on the most interesting rules. Specifically, we present rules for arrays and pointers
which we will compare with the rules for the
\piccoC\ semantics in Section~\ref{smc C descr}. Because the semantics
rules are mostly standard, we will describe one rule to familiarize 
the reader with our notation. 

Rule Multiparty Binary Operation is an example of a rule for the evaluation of a binary operation (comparison operations are handled separately). In \vanillaC, multiparty rules occur at the same time in all parties, but without any communication between the parties. 
We have the starting state $((\pidA,$ $\hgamma,$ $\hsigma,$ $\bsq,$ $\bsq,$ $\hExpr_1\ \binop\ \hExpr_2)$ $\Mid ...\Mid $ $(\pidZ,$ $\hgamma,$ $\hsigma,$ $\bsq,$ $\bsq,$ $\hExpr_1\ \binop\ \hExpr_2))$, 
with all parties at current environment $\hgamma$, current memory $\hsigma$, and the starting statement $\hExpr_1\ \binop\ \hExpr_2$.
First, all parties evaluate expression $\hExpr_1$, using the
current environment and memory states, 
resulting in environment $\hgamma$, memory
$\hsigma_1$, and number $\hn_1$.  We repeat this for
$\hExpr_2$. 
We then evaluate $\hn_1\ \binop\ \hn_2 = \hn_3$ here, and we will return $\hn_3$.  
The end state is then
$((\pidA, \hgamma, \hsigma_2, \bsq, \bsq, \hn_3)$ $\Mid ...\Mid$ $(\pidZ, \hgamma, \hsigma_2, \bsq, \bsq, \hn_3))$.

































