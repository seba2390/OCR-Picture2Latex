

\begin{figure*}[h]\footnotesize
\begin{tabular}{l}
\phantomsection\label{rule: da1}
Private Array Declaration \\
	\inferrule{\begin{array}{l}\begin{array}{l l}
		({\Expr}) \isPub \rrgamma \qq\qquad&
		((\Type = {\Priv\ \btype}) \lor (\Type = {\btype})) \land
			((\btype = \Int) \lor (\btype = \Float))
		\crcr
		&((\pid, \rrgamma,\ \sigma,\ {\DMap},\ \Acc,\ \Expr) \Mid  \Config) 
			\Deval{\locLL_1}{\codeLL_1} 
			((\pid, \rrgamma,\ \sigma{_1},\ {\DMap},\ \Acc,\ \nl) \Mid  \Config_1)
		\crcr \nl > 0
		& \byte = \EncodePtr({\Priv\ \Const\ \btype *},\ [1,\ [({\loc_1}, 0)],\ [1],\ 1]) 
		\crcr {\loc} = \phi() 
		& \byte_1 = \EncodeArr(\Priv\ \btype, \nl, \Null)   
		\crcr  {\loc_1} = \phi()
		&\RT{\gamma{_1} = \gamma[\x\ \to\ (\loc,\ {\Priv\ \Const\ \btype*})]} 
		\end{array}\crcr \begin{array}{l}
		\sigma{_2} = \sigma{_1}[{\loc} \to (\byte, {\Priv\ \Const\ \btype *}, 1, 
			\PtrPermL(\PermF, {\Priv\ \Const\ \btype*}, \Priv, 1))]
		\crcr 
		\sigma{_3} = \sigma{_2}[{\loc_1} \to (\byte_1,\ {\Priv\ \btype},\ \nl,\ 
			\ArrPermL(\PermF, \Priv\ \btype, \Priv, \nl))]
	\end{array}\end{array}}					
	{((\pid, \rrgamma,\ \sigma,\ {\DMap},\ \Acc,\ {\Type\ \x[\Expr]}) \Mid  \Config)\ 
		\Deval{\locLL_1 \addL (\pid, [(\loc, 0), ({\loc_1}, 0)])}{\codeLL_1 \addC \codeSP{da1}}  
		((\pid, \rgamma{_1},\ \sigma{_3},\ {\DMap},\ \Acc,\ \Skip) \Mid  \Config_1)}
\\ \\ 
\phantomsection\label{rule: ss}
Statement Sequencing \\
  	\inferrule{\begin{array}{l}
		((\pid,\ \rrgamma,\ \sigma,\ {\DMap},\ \Acc, {\stmt_1}) \Mid  \Config)\ 
			\Deval{\locLL_1}{\codeLL_1}  ((\pid, \rgamma{_1}, \sigma{_1}, {\DMap_1}, \Acc, \val_1) \Mid  \Config_1)
		\crcr
		((\pid, \rgamma{_1}, \sigma{_1}, {\DMap_1}, \Acc, {\stmt_2}) \Mid  \Config_1) 
			\Deval{\locLL_2}{\codeLL_2} ((\pid, \rgamma{_2}, \sigma{_2}, {\DMap_2}, \Acc, \val_2) \Mid  \Config_2)
	\end{array}}
	{((\pid, \rrgamma,\ \sigma,\ {\DMap},\ \Acc,\ {\stmt_1;\ \stmt_2}) \Mid  \Config)
		\Deval{\locLL_1 \addL \locLL_2}{\codeLL_1 \addC \codeLL_2 \addC \codeSP{ss}} 
		((\pid, \RT{\gamma{_2}},\ \sigma{_2},\ {\DMap_2},\ \Acc,\ {\val}) \Mid  \Config_2)}
\\ \\
\phantomsection\label{rule: iet}
Public If Else True \\
  	\inferrule{\begin{array}{l l}
		(\Expr) \isPub \rrgamma \qq &
		((\pid, \rrgamma,\ \sigma,\ {\DMap},\ \Acc, \Expr)\ \ \Mid  \Config)\ 
			\Deval{\locLL_1}{\codeLL_1}  ((\pid, \rrgamma,\ \sigma{_1}, {\DMap_1}, \Acc, \n)\quad\ \Mid  \Config_1) 
		\crcr \n\ \neq\ 0 
		& ((\pid, \rrgamma, \sigma{_1}, {\DMap_1}, \Acc, {\stmt_1}) \Mid  \Config_1) 
			\Deval{\locLL_2}{\codeLL_2} ((\pid, \rgamma{_1}, \sigma{_2}, {\DMap_2}, \Acc, \Skip) \Mid  \Config_2)
	\end{array}}
	{((\pid, \rrgamma,\ \sigma,\ {\DMap},\ \Acc,\ {\If\ (\Expr)\ \stmt_1\ \Else\ \stmt_2}) \Mid  \Config)\ 
		\Deval{\locLL_1\addL\locLL_2}{\codeLL_1 \addC \codeLL_2 \addC \codeSP{iet}}  ((\pid, \rrgamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ \Skip) \Mid  \Config_2)}
\end{tabular}
\caption{An illustration of scoping within \DynamicPicco\ rules. We highlight the environment $\RT\gamma$ and its modifications in \red{red}.}
\label{Fig: scoping}
\end{figure*}






\begin{figure*}\footnotesize
\begin{tabular}{l}
\phantomsection\label{rule: bm}
Public Multiplication \\
\inferrule{\begin{array}{l}
		({\Expr_1}, {\Expr_2}) \isPub \gamma \qq\quad
		((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\Expr_1}) \Mid  \Config) \ 
			\Deval{\locLL_1}{\codeLL_1}  ((\pid, \gamma,\ \sigma{_1},\ {\DMap_1},\ \Acc,\ {n_1}) \Mid  \Config_1) 
		\crcr 
		((\pid, \gamma,\ \sigma{_1},\ {\DMap_1},\ \Acc,\ {\Expr_2}) \Mid  \Config_1) \ 
			\Deval{\locLL_2}{\codeLL_2}  ((\pid, \gamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ {n_2}) \Mid  \Config_2) 
		\qq {n_1} \cdot {n_2} = {n_3}
	\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\Expr_1 \cdot \Expr_2}) \Mid  \Config)\ 
		\Deval{\locLL_1\addL\locLL_2}{\codeLL_1\addC \codeLL_2 \addC \codeSP{bm}} ((\pid, \gamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ {n_3}) \Mid  \Config_2) }
\\ \\
\phantomsection\label{rule: r1}
Read Private Variable \\
  	\inferrule{\begin{array}{l l} 
		\gamma(\x) = (\loc,\ \Priv\ \btype)\ \qquad 
		&\sigma(\loc) = (\byte,\ \Priv\ \btype,\ 1,\ \VarPermL(\PermF, \Priv\ \btype, \Priv, 1)) 
		\crcr &\Decode(\Priv\ \btype,\ \byte) = \n
	\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \x) \Mid  \Config)\ 
		\Deval{(\pid, [(\loc, 0)])}{\codeSP{r1}}  
		((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \n) \Mid  \Config)}		
\\ \\
\phantomsection\label{rule: mal}
Public Malloc \\
	\inferrule{\begin{array}{l l l}
		\Acc = \AccZ\qq
		& (\Expr) \isPub \gamma\qq
		& ((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \Expr) \Mid  \Config)\ 
			\Deval{\locLL_1}{\codeLL_1}  ((\pid, \gamma,\ \sigma{_1},\ {\DMap},\ \Acc,\ \n) \Mid  \Config_1)
		\crcr \loc = \phi()
		&& \sigma_2 = \sigma_1\big[\loc \to \big(\Null, \Void*, \n, \PermL(\PermF, \Void*, \Pub, \n)\big)\big]
	\end{array}}
	{\begin{array}{l}
		((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \Malloc (\Expr)) \Mid  \Config) 
			\Deval{\locLL_1 \addL (\pid, [(\loc, 0)])}{\codeLL_1 \addC \codeSP{mal}} 
			((\pid, \gamma,\ \sigma{_2},\ {\DMap},\ \Acc,\ (\loc, 0)) \Mid  \Config_1) 
	\end{array}}
\\ \\
\phantomsection\label{rule: fre}
Public Free \\ 
  	\inferrule{\begin{array}{l}\begin{array}{l l}	
		\gamma(\x) = (\loc,\ {\Pub\ \btype*})\quad\
		&	\sigma(\loc) = (\byte, \Pub\ \btype*, 1, \PermL(\PermF, \Pub\ \btype*, \Pub, 1)) 
		\crcr \Acc = \AccZ \qq 
		& 	\DecodePtr({\Pub\ \btype*},\ 1,\ \byte) = [1,\ [({\loc_1}, 0)],\ [1],\ 1]
		\end{array}\crcr \begin{array}{l l}
		\SelectFreeable(\gamma, [({\loc_1}, 0)], [1], \sigma) = 1\qq
		&	 \Free(\sigma,\ \loc_1) = (\sigma{_1}, (\loc_1, 0))
	\end{array}\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\free (\x)}) \Mid  \Config)\ 
		\Deval{(\pid, [(\loc, 0), (\loc_1, 0)])}{\codeSP{fre}}  
		((\pid, \gamma,\ \sigma{_1},\ {\DMap},\ \Acc,\ \Skip) \Mid  \Config)}
\\ \\
\phantomsection\label{rule: inp}
SMC Input Public Value \\
	\inferrule{ \begin{array}{l l}
		({\Expr}) \isPub \gamma \qq
		&((\pid, \gamma, \sigma, {\DMap}, \Acc, {\Expr} ) \Mid  \Config)\ 
			\Deval{\locLL_1}{\codeLL_1} ((\pid, \gamma, \sigma{_1}, {\DMap_1}, \Acc, {n})\quad \Mid  \Config_1) 	\qquad
		\crcr
		\gamma(\x) = (\loc, \Pub\ \btype)
		& \InputVal(\x, {n}) = {n_1}	\qq
		\crcr 
		\Acc =\AccZ \qq
		&((\pid, \gamma, \sigma{_1}, {\DMap_1}, \Acc, {\x = n_1} ) \Mid  \Config_1) 
			\Deval{\locLL_2}{\codeLL_2} ((\pid, \gamma, \sigma{_2}, {\DMap_2}, \Acc, \Skip) \Mid  \Config_2)
	\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\smcinput(\x,\ \Expr)}) \Mid  \Config) 
		\Deval{\locLL_1 \addL \locLL_2}{\codeLL_1 \addC \codeLL_2 \addC \codeSP{inp}}  
		((\pid, \gamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ \Skip) \Mid  \Config_2)}
\\ \\ 
\phantomsection\label{rule: out3}
SMC Output Private Array \\
	\inferrule{ \begin{array}{l}\begin{array}{l l}
		({\Expr_1}, {\Expr_2}) \isPub \gamma \qquad
		&	((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc, {\Expr_1} ) \Mid  \Config)\ 
				\Deval{\locLL_1}{\codeLL_1} ((\pid, \gamma, \sigma{_1}, {\DMap_1}, \Acc, {n}) \Mid  \Config_1) 
		\crcr \gamma(\x) = ({\loc}, {\Priv\ \Const\ \btype*}) \qquad
		&	((\pid, \gamma, \sigma{_1}, {\DMap_1}, \Acc, {\Expr_2} ) \Mid  \Config_1) 
				\Deval{\locLL_2}{\codeLL_2} ((\pid, \gamma, \sigma{_2}, {\DMap_2}, \Acc, {\nl}) \Mid  \Config_2)
		\end{array}\crcr\begin{array}{l}
			\sigma{_2}({\loc}) = ({\byte}, {\Priv\ \Const\ \btype*}, 1, 
					\PtrPermL(\PermF, {\Priv\ \Const\ \btype*}, \Priv, 1))
		\crcr \DecodePtr({\Priv\ \Const\ \btype*},\ 1,\ {\byte}) = [1,\ [({\loc_1}, 0)],\ [1],\ \Priv\ \btype,\ 1]
		\crcr \sigma{_2}({\loc_1}) = ({\byte_1},\ {\Priv\ \btype},\ {\nl},\ \ArrPermL(\PermF, \Priv\ \btype, \Priv, {\nl}))
		\crcr \forall \ind \in \{0, ..., \nl-1\} \qquad \DecodeArr({\Priv\ \btype},\ {\ind},\ {\byte_1})  = {m_\ind}
		\crcr \OutputArr(\x,\ {n},\ [{m_0},\ {...},\ {m_{\nl-1}}])
	\end{array}\end{array}}
	{\begin{array}{l}
	((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\smcoutput(\x,\ \Expr_1,\ \Expr_2)}) \Mid  \Config) 
		\crcr\Deval{\locLL_1 \addL \locLL_2 \addL (\pid, [(\loc, 0), (\loc_1, 0), ..., (\loc_1, n_1-1)])}{\codeLL_1 \addC \codeLL_2 \addC \codeSP{out3}}  
		((\pid, \gamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ \Skip) \Mid  \Config_2)
		\end{array}}
\\ \\ 
\phantomsection\label{rule: pin}
Pre-Increment Public Variable \\
  	\inferrule{\begin{array}{l l}
		\gamma (\x) = (\loc,\ \Pub\ \btype) \qquad
		&	\sigma(\loc) = (\byte,\ \Pub\ \btype,\ 1,\ \VarPermL(\PermF, \Pub\ \btype, \Pub, 1))
		\crcr \Acc =\AccZ \qquad
		&	\Decode(\Pub\ \btype,\ \byte) = {\n}	
		\crcr {\n_1} = {\n} + 1 
		&	\Update(\sigma,\ \loc,\ {\n_1},\ {\DMap},\ \Acc, \Pub\ \btype) = (\sigma{_1},\ {\DMap})
	\end{array}} 
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\plpl\x}) \Mid  \Config)\ 
		\Deval{(\pid, [(\loc, 0)])}{\codeSP{pin}}  
		((\pid, \gamma,\ \sigma{_1},\ {\DMap},\ \Acc,\ {\n_1}) \Mid  \Config)}
\\ \\
\phantomsection\label{rule: mprdp}
Multiparty Private Pointer Dereference Single Level Indirection\\ 
	\inferrule{\begin{array}{l}
		\{(\x) \isPriv \gamma^\pid\}^{\pidZ}_{\pid = \pidA} 
		\qq \{ \gamma^\pid(\x) = (\loc^\pid, \Priv\ \btype*)\}^{\pidZ}_{\pid = \pidA}
		\qq  \nl > 1  \crcr
		\{\sigma^\pid(\loc^\pid) = (\byte^\pid,\ {\Priv\ \btype*},\ \nl,\ \PtrPermL(\PermF, {\Priv\ \btype*}, \Priv, \nl))\}^{\pidZ}_{\pid = \pidA}
		\crcr 
		\{\DecodePtr({\Priv\ \btype*},\ \nl,\ \byte^\pid) = [\nl,\ \locL^\pid,\ \tagbL^\pid, 1] \}^{\pidZ}_{\pid = \pidA}
		\crcr 
		\{\Retrieve(\nl, \locL^\pid, \Priv\ \btype, \sigma^\pid) = ([\n^\pid_0, ...\n^\pid_{\nl-1}], 1)\}^{\pidZ}_{\pid = \pidA}
		\crcr \MPC{dv}([[\n^{\pidA}_{0}, ..., \n^{\pidA}_{\nl-1}], ..., [\n^{\pidZ}_{0}, ..., \n^{\pidZ}_{\nl-1}]], [\tagbL^\pidA, ..., \tagbL^\pidZ]) = (\n^{\pidA}, ..., \n^{\pidZ})
	\end{array}}
	{\begin{array}{l}
	((\pidA, \gamma^{\pidA}, \sigma^{\pidA}, \DMap^\pidA, \Acc, {* \x})\Mid ...\Mid 
	(\pidZ, \gamma^{\pidZ}, \sigma^{\pidZ}, \DMap^\pidZ, \Acc, {* \x}))
		\Deval{(\pidA, (\loc^\pidA, 0)\addL\locL^{\pidA}) \Mid ... \Mid (\pidZ, (\loc^\pidZ, 0)\addL\locL^{\pidZ})}{\codeMP{mprdp}}  
		\crcr((\pidA, \gamma^{\pidA}, \sigma^{\pidA}, \DMap^\pidA, \Acc, \n^{\pidA}_{})\Mid ...\Mid 
		(\pidZ, \gamma^{\pidZ}, \sigma^{\pidZ}, \DMap^\pidZ, \Acc, \n^{\pidZ}_{}))
		\end{array}}
\end{tabular}
\caption{Additional \DynamicPicco\ semantic rules.}
\label{Fig: sem app}
\end{figure*}







\begin{figure*}\footnotesize
\begin{tabular}{l}
\phantomsection\label{rule: ra1}
Private Array Read Public Index \\
  	\inferrule{
	\begin{array}{l}
	(\Expr) \isPub \gamma \qq
	((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \Expr) \Mid  \Config)\ 
		\Deval{\locLL_1}{\codeLL_1}  ((\pid, \gamma,\ \sigma{_1},\ {\DMap_1},\ \Acc,\ \ind) \Mid  \Config_1) \crcr
	\gamma(\x) = (\loc,\ {\Priv\ \Const\ \btype*}) \crcr
	\sigma{_1}(\loc) = (\byte,\ {\Priv\ \Const\ \btype*}, 1, 
		\PtrPermL(\PermF, {\Priv\ \Const\ \btype*}, \Priv, 1))
	\crcr \DecodePtr({\Priv\ \Const\ \btype*},\ 1,\ \byte) = [1,\ [({\loc_1}, 0)],\ [1],\ 1] 
	\qquad 0 \leq \ind \leq {\nl} -1 
	\crcr \sigma{_1}({\loc_1}) = ({\byte_1}, {\Priv\ \btype}, {\nl}, 
		\ArrPermL(\PermF, \Priv\ \btype, \Priv, {\nl})) 
	\crcr \DecodeArr({\Priv\ \btype},\ \ind,\ {\byte_1}) = \n_\ind 
	\end{array}}
	{ ((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\x[\Expr]}) \Mid  \Config)\ 
		\Deval{\locLL_1 \addL (\pid, [(\loc, 0), ({\loc_1}, \ind)])}{\codeLL_1 \addC \codeSP{ra1}}  ((\pid, \gamma,\ \sigma{_1},\ {\DMap_1},\ \Acc,\ {\n_\ind}) \Mid  \Config_1)}
\\ \\ 
\phantomsection\label{rule: wa}
Public Array Write Public Value Public Index \\
  	\inferrule{\begin{array}{l}
		({\Expr_1}, {\Expr_2}) \isPub \gamma \qquad\quad
		((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc, {\Expr_1}) \Mid  \Config)\ 
			\Deval{\locLL_1}{\codeLL_1}  ((\pid, \gamma,\ \sigma{_1},\ {\DMap_1},\ \Acc,\ \ind) \Mid  \Config_1) \crcr
		\Acc = \AccZ \qq\ \
		((\pid, \gamma, \sigma{_1}, {\DMap_1}, \Acc, {\Expr_2}) \Mid  \Config_1) 
			\Deval{\locLL_2}{\codeLL_2}  ((\pid, \gamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ \n) \Mid  \Config_2) \crcr
		\gamma(\x) = (\loc,\ {\Pub\ \Const\ \btype*})	\crcr
%		\val \neq \Skip \qquad
		\sigma{_2}(\loc) = (\byte, {\Pub\ \Const\ \btype*}, 1, \PtrPermL(\PermF, {\Pub\ \Const\ \btype*}, \Pub, 1)) 
		\crcr \DecodePtr({\Pub\ \Const\ \btype*}, 1, \byte) = [1,\ [({\loc_1, 0})],\ [1],\ 1]
		\crcr \sigma{_2}({\loc_1}) = ({\byte_1}, \Pub\ \btype, \nl, \ArrPermL(\PermF, \Pub\ \btype, \Pub, \nl))
		\qquad 0 \leq {\ind} \leq {\nl-1} 
		\crcr 
		 \UpdateArr(\sigma{_2},\ ({\loc_1}, \ind),\ \n,\ \Pub\ \btype) = \sigma{_3}
	\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\x[\Expr_1]\ = \Expr_2}) \Mid  \Config)\ 
		\Deval{\locLL_1 \addL \locLL_2 \addL (\pid, [(\loc, 0), (\loc_1, \ind)])}{\codeLL_1 \addC \codeLL_2 \addC \codeSP{wa}}  
		((\pid, \gamma,\ \sigma{_3},\ {\DMap_2},\ \Acc,\ \Skip) \Mid  \Config_2)}
\\ \\ 
\phantomsection\label{rule: rp}
Pointer Read Single Location \\
	\inferrule{\begin{array}{l l}
		\gamma(\x) = (\loc,\ {\llabel\ \btype*}) \qquad 
		& \sigma(\loc) = (\byte,\ {\llabel\ \btype*},\ 1,\ 
			\PtrPermL(\PermF, {\llabel\ \btype*}, \llabel, 1))
		\crcr &\DecodePtr({\llabel\ \btype*},\ 1,\ \byte) = [1,\ [({\loc_1}, \offset_1)],\ [1],\ \indir] 
	\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \x) \Mid  \Config)\ 
		\Deval{(\pid, [(\loc, 0)])}{\codeSP{rp}}  ((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {(\loc_1, \offset_1)}) \Mid  \Config)}
\\ \\
\phantomsection\label{rule: wp1}
Private Pointer Write \\
  	\inferrule{\begin{array}{l}
		\gamma(\x) = ({\loc}, {\Priv\ \btype*}) \qquad\
		((\pid, \gamma, \sigma, {\DMap}, \Acc, \Expr) \Mid  \Config) 
			\Deval{\locLL_1}{\codeLL_1} ((\pid, \gamma, \sigma{_1}, {\DMap_1}, \Acc, ({\loc_e}, \offset_e)) \Mid  \Config_1) \crcr
		(\Expr) \isPub \gamma \qq
		\sigma{_1}({\loc}) = (\byte,\ {\Priv\ \btype*},\ \nl, \PtrPermL(\PermF, {\Priv\ \btype*}, \Priv, \nl))
		\crcr \DecodePtr({\Priv\ \btype*},\ \nl,\ \byte) = [\nl,\ \locL,\ \tagbL,\ \indir]
		\crcr \UpdatePtr(\sigma{_1},\ {(\loc, 0)},\ [1,\ [({\loc_e}, \offset_e)],\ [1],\ \indir],\ 
			{\DMap_1},\ \Acc, \Priv\ \btype*) = (\sigma{_2},\ {\DMap_2}, 1) 
	\end{array}} 
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\x = \Expr}) \Mid  \Config)\ 
		\Deval{\locLL_1 \addL (\pid, [(\loc, 0)])}{\codeLL_1\addC\codeSP{wp1}}  ((\pid, \gamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ \Skip) \Mid  \Config_1)}
\\ \\ 
\phantomsection\label{rule: wdp3}
Private Pointer Dereference Write Single Location Private Value \\ 
	\inferrule{
	\begin{array}{l}
		(\Expr) \isPriv \gamma	\qq
		((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \Expr) \Mid  \Config) 
			\Deval{\locLL_1}{\codeLL_1} ((\pid, \gamma,\ \sigma{_1},\ {\DMap_1},\ \Acc,\ \n) \Mid  \Config_1) 
		\crcr \gamma(\x) = (\loc,\ {\Priv\ \btype*}) 
		\qq (\btype = \Int) \lor (\btype = \Float) 
		\crcr \sigma{_1}(\loc) = (\byte,\ {\Priv\ \btype*},\ 1,\ \PtrPermL(\PermF, {\Priv\ \btype*}, \Priv, 1)) 
		\crcr \DecodePtr({\Priv\ \btype*},\ 1,\ \byte) = [1,\ [(\loc_1, \offset_1)],\ [1],\ 1]
		\crcr \DynUpdate(\DMap_1, \sigma, [(\loc_1, \offset_1)],\ \Acc, \Priv\ \btype) = \DMap_2
		\crcr \UpdateOffset(\sigma{_1},\ ({\loc_1}, \offset_1),\ \n, \Priv\ \btype) = (\sigma{_2}, 1)
	\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {* \x = \Expr}) \Mid  \Config) 
		\Deval{\locLL_1 \addL (\pid, [(\loc, 0), ({\loc_1}, \offset_1)])}{\codeLL_1\addC\codeSP{wdp3}}  
		((\pid, \gamma,\ \sigma{_2},\ {\DMap_2},\ \Acc,\ \Skip) \Mid  \Config_1) }
\\ \\
\phantomsection\label{rule: pin1}
Pre-Increment Public Pointer Single Location \\
  	\inferrule{\begin{array}{l}
		\gamma (\x) = (\loc,\ {\Pub\ \btype*}) \crcr
		\sigma(\loc) = (\byte,\ {\Pub\ \btype*},\ 1,\ \PtrPermL(\PermF, {\Pub\ \btype*}, \Pub, 1))
		\crcr \DecodePtr({\Pub\ \btype*},\ 1,\ \byte) = [1,\ [({\loc_1}, \offset_1)],\ [1],\ 1]
		\crcr (({\loc_2}, \offset_2), 1) = \GetLoc(({\loc_1}, \offset_1), \tau({\Pub\ \btype}), \sigma)
		\crcr \UpdatePtr(\sigma,\ (\loc, 0),\ [1,\ [({\loc_2}, \offset_2)],\ [1],\ 1],\ {\DMap},\ \Acc, 
			\Pub\ \btype*) = (\sigma{_1},\ {\DMap_1}, 1)
	\end{array}} 
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ {\plpl\x}) \Mid  \Config)\ 
		\Deval{(\pid, [(\loc, 0)])}{\codeSP{pin1}}  
		((\pid, \gamma,\ \sigma{_1},\ {\DMap_1},\ \Acc,\ ({\loc_2}, \offset_2)) \Mid  \Config)}
\\ \\
\phantomsection\label{rule: rdp}
Pointer Dereference Single Location  \\ 
	\inferrule{\begin{array}{l}
		\gamma(\x) = (\loc,\ {\llabel\ \btype*}) 
		\qq  \sigma({\loc}) = ({\byte},\ {\llabel\ \btype*},\ 1,\ \PtrPermL(\PermF, {\llabel\ \btype*}, \llabel, 1)) 
		\crcr \DecodePtr({\llabel\ \btype*},\ 1,\ {\byte}) = [1,\ [({\loc_1}, \offset_1)],\ [1],\ 1] 
		\qquad\quad \DerefPtrPub(\sigma, \llabel\ \btype, ({\loc_1}, \offset_1)) = (\n, 1)
	\end{array}}
	{((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\  {* \x}) \Mid  \Config)\ 
		\Deval{(\pid, [(\loc, 0), ({\loc_1}, \offset_1)])}{\codeSP{rdp}}  ((\pid, \gamma,\ \sigma,\ {\DMap},\ \Acc,\ \n) \Mid  \Config)}
\end{tabular}
\caption{Additional \DynamicPicco\ semantic rules for arrays and pointers.}
\label{Fig: sem app arr}
\end{figure*}






















