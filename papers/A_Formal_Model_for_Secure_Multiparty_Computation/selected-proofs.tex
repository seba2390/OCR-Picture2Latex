

In this section we present the main methatheoretic results, 
with proof sketches and important definitions given in Appendix~\ref{app: metatheory}.
We will begin by discussing how we leverage multiparty protocols, then proceed to discuss 
the most challenging result, which is correctness. 
Once correctness is proven, noninterference follows from a standard argument, with some adaptations needed to deal with the fact that private data is encrypted and 
that we want to show indistinguishability of evaluation traces. 



\subsection{Multiparty Protocols}
In our semantics, we leverage multiparty protocols to compartmentalize
the complexity of handling private data. In the formal treatment this
corresponds to using Axioms in our proofs to reason about
protocols. These Axioms allow us to guarantee the desired properties
of correctness and noninterference for the overall model, to provide
easy integration with new, more efficient protocols as they become
available, and to avoid re-proving the formal guarantees for the
entire model when new protocols are added.  Proving that these Axioms
hold is a responsibility of the library implementor in order to have
the system fully encompassed by our formal model.  Secure
multiparty computation protocols that already come with guarantees
of correctness and security are the only ones worth considering, so the implementor would only need to
ensure that these guarantees match our definitions of correctness and
noninterference.


For example, if private values are represented using Shamir secret sharing~\cite{Shamir79}, Algorithm~\ref{algo: mpc mult}, $\MPC{mult}$, represents
a simple multiparty protocol for multiplying
private values from~\cite{Gennaro98}.
In Algorithm~\ref{algo: mpc mult}, lines 2 and
3 define the protocol, while lines 1, 4, and 5 relate the
protocol to our semantic representation.

\begin{algorithm*}\footnotesize
\caption{$\n^\pid_3 \gets \MPC{mult}(\n^\pid_1, \n^\pid_2)$}
\label{algo: mpc mult}
\begin{algorithmic}[1]
	\STATE Let $f_a(\pid) = \n^\pid_1$ and $f_b(\pid) = \n^\pid_1$.
	\STATE Party $\pid$ computes the value $f_a(\pid) \cdot f_b(\pid)$ and creates its shares by choosing a random polynomial $h_\pid(x)$ of degree $t$, such that $h_\pid(0)=f_a(\pid) \cdot f_b(\pid)$. Party $\pid$ sends to each party $i$ the value $h_\pid(i)$. 
	\STATE After receiving shares from all other parties, party $\pid$ computes their share of $a \cdot b$ as the linear combination $H(\pid) = \sum^{\pidZ}_{i=1} \lambda_i h_i(\pid)$.
	\STATE Let $n^\pid_3 = H(\pid)$
	\RETURN $n^\pid_3$
\end{algorithmic}
\end{algorithm*}

When computation is performed by $q$ parties, at most $t$ of whom may collude ($t < q/2$), Shamir secret sharing encodes a private integer $a$ by choosing a polynomial $f(x)$ of degree $t$ with random coefficients such that $f(0) = a$ (all computation takes place over a finite field). Each participant obtains evaluation of $f$ on a unique non-zero point as their representation of private $a$; for example, party $\pid$ obtains $f(\pid)$. This representation has the property that combining $t$ or fewer shares reveals no information about $a$ as all values of $a$ are equally likely; however, possession of $t+1$ or more shares permits recovering of $f(x)$ via polynomial interpolation and thus learning $f(0) = a$. 

Multiplication in Algorithm~\ref{algo: mpc mult} corresponds to each party locally multiplying shares of inputs $a$ and $b$, which computes the product, but raises the polynomial degree to $2t$. The parties consequently re-share their private intermediate results to lower the polynomial degree to $t$ and re-randomize the shares. Values $\lambda_\pid$ refer to interpolation coefficients which are derived from the computation setup and party $\pid$ index.

In order to preserve the correctness and noninterference guarantees of our
model when such an algorithm is added, a library developer will need
to guarantee that the implementation of this algorithm is correct, meaning that it has the expected input output behavior, and it guarantees noninterference on what is observable. 


\subsection{Correctness} \label{sec: erasure} 
We first show the correctness of the \piccoC\ semantics with respect
to the \vanillaC\ semantics. As usual we will do this by establishing
a simulation relation between a \piccoC\ program and a corresponding
\vanillaC\ program. To do so we face two main challenges.

First, we need to guarantee that
the private operations in a \piccoC\ program are reflected in the
corresponding \vanillaC\ program and that the evaluation steps between the two programs correspond. 
To address the former issue, we define an \emph{erasure function} $\bm{\erasure}$ which
translates a \piccoC\ program into a \vanillaC\ program by erasing all
labels and replacing all functions specific to \piccoC\ with their public equivalents. This function also translates memory.
As an example, let us consider
pmalloc; in this case, we have
$\bm{\erasure}({\PMalloc(\Expr,\ \Type)} 
= {(\Malloc(\bm{\erasure}(\Expr) \cdot \sizeof(\bm{\erasure}(\Type))))})$.
That is, pmalloc is rewritten to use malloc, and since the given private type is now public we can use the sizeof function to find the size we will need to allocate. 
To address the latter issue, we have defined our operational semantics in terms of big-step evaluation judgments which allow the evaluation trees of the two programs to have a corresponding structure. In particular, notice how we designed
the Private If Else rule to perform multiple operations in one step, guaranteeing that we have similar ``synchronization points'' in the two evaluation trees. 

Second, we need to guarantee that at each evaluation step the memory
used by a \piccoC\ program corresponds to the one used by the
\vanillaC\ program. 
Given that we simulate multiparty execution over $\pidZ$ parties in \piccoC, we will also use $\pidZ$ parties in \vanillaC. This allows us to easily reason about both local and global semantic rules, as each \piccoC\ party has a corresponding \vanillaC\ party at an identical position in the evaluation trace.
Unfortunately, just applying the function $\bm{\erasure}$ to the \piccoC\ memories in the evaluation trace is not enough. 
%
In our setting, with
explicit memory management, manipulations of pointers, and array overshooting, guaranteeing a correspondence between the memories becomes particularly
challenging. To better understand the issue here, let us consider
the rule Private Free, discussed in
Section~\ref{subsec: picco mem alloc/dealloc}. 
Remember that our semantic model associates a pointer
with a list of locations, and the Private Free rule frees the
first location in the list, and relocates the content of that location
if it is not the true location. 
Essentially, this rule may swap the content of two locations if the first location
in the list is not the location intended to be freed and 
make the \piccoC\ memory and the \vanillaC\ memory look quite
different. To address this challenge in the proof of correctness, we use a \emph{map}, denoted $\psi$,
to track the swaps that happen when the rule
Private Free is used. The simulation uses and modifies this map to
guarantee that the two memories correspond.
%
Another related challenge comes from array overshooting. If, by
overshooting an array, a program goes over or into memory blocks of
different types, we may end up in a situation where the locations in
the \piccoC\ memory are significantly different from the ones in the
\vanillaC\ memory. This is mostly due to the size of private types
being larger than their public counterpart. One option to address this
problem would be to keep a more complex map between the two
memories. However, this can result in a much more complex proof, for
capturing a behavior that is faulty, in principle. Instead, we prefer
to focus on situations where overshooting arrays are \emph{well-aligned}, in the sense that they access only memory locations and blocks of the right type and size. 
An illustration of this is given in the Appendix, Figure~\ref{fig: overshooting alignment}. 

Before stating our correctness, we need to introduce some notation.  We
use party-wise lists of codes $\codeLL = (\pidA, [\code_1,\ldots,\code_n])\Mid ... \Mid(\pidZ, [\code_1,\ldots,\code_n]),$ $\codeVLL = (\pidA, [\codeV_1,\ldots,\codeV_m])\Mid$ $...$ $\Mid(\pidZ, [\codeV_1,\ldots,\codeV_m])$ in evaluations (i.e.,
$\eval_{\codeLL})$ to describe the rules of the semantics that
are applied in order to derive the result.  We write
$\codeLL\cong \codeVLL$ to state that the \piccoC\
codes are in correspondence with the \vanillaC\
codes, $\codeLL^\pid$ to denote the list of codes for a specific party $\pid$, and $\codeLL_1::\codeLL_2$ to denote concatenation of the party-wise evaluation code lists. 
We write $\{...\}^\pidZ_{\pid =1}$ to show that an assertion holds for all parties. 
Almost every \piccoC\ rule is in one-to-one
correspondence with a single \vanillaC\ rule within an execution trace (exceptions being private-conditioned branches, \TT{pmalloc}, and multiparty comparison operations).

 We write ${\stmt}\cong \hstmt$ to state that the \vanillaC\ configuration statement $\hstmt$ can be obtained by applying the erasure function to the \piccoC\ statement ${\stmt}$. Similarly, we can extend this notation to configuration by also using the map $\psi$. That is, we write
$(\pid,$ $\gamma{},$ $\sigma{},$ $\DMap$, $\Acc,$ ${\stmt})$ $\cong_\psi$ $(\pid,$ $\hgamma{},$ $\hsigma{},$ $\bsq,$ $\bsq,$ $\hstmt)$ to state that the \vanillaC\ configuration  $(\pid,$ $\hgamma{},$ $\hsigma{},$ $\bsq,$ $\bsq,$ $\hstmt)$ can be obtained by applying the erasure function to the \piccoC\ configuration  $(\pid,$ $\gamma{},$ $\sigma{},$ $\DMap$, $\Acc,$ ${\stmt})$, and memory $\hsigma$ can be obtained from $\sigma{}$ by using the map $\psi$.


We state correctness in terms of  evaluation trees, since we will use evaluation trees to prove a strong form of noninterference  in the next subsection. We use capital Greek letters $\Pi, \Sigma$ to denote evaluation trees.  In the \piccoC\ semantics, we write $\Pi \deriv ((\pidA, \gamma^{{\pidA}}_{},$ $\sigma^{{\pidA}}_{},$ $\DMap^{{\pidA}}_{}$, $\Acc^{{\pidA}}_{},$ $\stmt^{{\pidA}})\ \Mid ...\Mid$ 
	$(\pidZ, \gamma^{{\pidZ}}_{},$ $\sigma^{{\pidZ}}_{},$ $\DMap^{{\pidZ}}_{}$, $\Acc^{{\pidZ}}_{},$ $\stmt^{{\pidZ}}))$ 
	$\Deval{\locLL}{\codeLL}$ 
	$((\pidA, {\gamma^{{\pidA}}_{1}},$ ${\sigma^{{\pidA}}_{1}},$ $\DMap^{{\pidA}}_{1}$, $\Acc^{{\pidA}}_{1},$ ${\val^{{\pidA}}_{}}) \Mid ... \Mid$ 
	$(\pidZ, {\gamma^{{\pidZ}}_{1}},$ ${\sigma^{{\pidZ}}_{1}},$ $\DMap^{{\pidZ}}_{1}$, $\Acc^{{\pidZ}}_{1},$ $\val^{{\pidZ}}))$, to stress that the evaluation tree $\Pi$ proves as conclusion that, for each party $\pid$, configuration  $(\pid,$ $\gamma^\pid,$ $\sigma^\pid,$ $\DMap^\pid$, $\Acc^\pid,$ $\stmt^\pid)$ evaluates to configuration
$(\pid,$ $\gamma^\pid_1,$ $\sigma^\pid_1,$ $\DMap^\pid_1$, $\Acc^\pid_1,$ $\val^\pid)$ by means of the codes in $\codeLL^\pid$. Similarly, for the \vanillaC\ semantics. We then write $\Pi\cong_\psi \Sigma$ for the extension to evaluation trees of the congruence relation with map $\psi$.


In order to properly reason about global multiparty rules, we must assert that all parties are executing from the same original program with corresponding start states and input. 
To do this, we first show that the non-determinism of the semantics will always bring all parties to the same outcome: given $\pidZ$ parties with corresponding start states, if we reach intermediate states that are not corresponding for one or more parties, then there exists a set of steps that will bring all parties to corresponding states again.


\begin{theorem}[Confluence]
\label{Thm: confluence}
Given ${\Config^\pidA} \Mid ... \Mid {\Config^\pidZ}$ such that $\{{\Config^\pidA} \sim {\Config^\pid}\}^{\pidZ}_{\pid = \pidA}$ 
\\
if $({\Config^\pidA} \Mid ... \Mid {\Config^\pidZ})$ $\Deval{{\locLL_1}}{{\codeLL_1}}$ $({\Config^\pidA_1} \Mid ... \Mid {\Config^\pidZ_1})$ such that $\exists \pid\in\{\pidA...\pidZ\} {\Config^\pidA_1} \not\sim {\Config^\pid_1}$, 
\\
then $\exists$ $({\Config^\pidA_1} \Mid ... \Mid {\Config^\pidZ_1})$ $\Deval{{\locLL_2}}{{\codeLL_2}}$ $({\Config^\pidA_2} \Mid ... \Mid {\Config^\pidZ_2})$
\\ 
such that $\{{\Config^\pidA_2} \sim {\Config^\pid_2}\}^{\pidZ}_{\pid = \pidA}$, 
$\{({\locLL^\pidA_1}\addL{\locLL^\pidA_2}) = ({\locLL^\pid_1}\addL{\locLL^\pid_2})\}^{\pidZ}_{\pid = \pidA}$, 
and $\{({\codeLL^\pidA_1}\addC{\codeLL^\pidA_2}) = ({\codeLL^\pid_1}\addC{\codeLL^\pid_2})\}^{\pidZ}_{\pid = \pidA}$.
\end{theorem}


We can now state our correctness result showing that if an \piccoC\ program $\stmt$ can be evaluated  to a value $\val$, and the evaluation is well-aligned (it is an evaluation where all the overshooting of arrays are well-aligned), then the \vanillaC\  program $\hat{\stmt}$ obtained by applying the erasure function to $\stmt$, i.e., $\stmt\cong\hat{\stmt}$, can be evaluated to $\hat{\val}$ where $\val\cong\hat{\val}$. This property can be formalized in terms of congruence: 
%
%
\begin{theorem}[Correctness]
\label{Thm: erasure}
For every configuration $\{(\pid,\ \gamma^{{\pid}}_{},$ $\sigma^{{\pid}}_{},$ $\DMap^{{\pid}}_{}$, $\Acc^{{\pid}}_{},$ $\stmt^{\pid})\}^{\pidZ}_{\pid = \pidA}$, 
\\ $\{(\pid,$ $\hgamma^\pid,$ $\hsigma^\pid,$ $\bsq,$ $\bsq,$ $\hstmt^\pid)\}^{\pidZ}_{\pid = \pidA}$ and \LocMap\ $\psi$ 
\\ such that $\{(\pid, \gamma^{{\pid}}_{},$ $\sigma^{{\pid}}_{},$ $\DMap^{{\pid}}_{}$, $\Acc^{{\pid}}_{},$ $\stmt^{{\pid}})$ $\Pcong$ 
$(\pid,$ $\hgamma^\pid,$ $\hsigma^\pid,$ $\bsq,$ $\bsq,$ $\hstmt^\pid)\}^{\pidZ}_{\pid = \pidA}$, 
\\ % a 
if $\Pi \deriv ((\pidA, \gamma^{{\pidA}}_{},$ $\sigma^{{\pidA}}_{},$ $\DMap^{{\pidA}}_{}$, $\Acc^{{\pidA}}_{},$ $\stmt^{{\pidA}})\ \Mid ...\Mid$ 
	$(\pidZ, \gamma^{{\pidZ}}_{},$ $\sigma^{{\pidZ}}_{},$ $\DMap^{{\pidZ}}_{}$, $\Acc^{{\pidZ}}_{},$ $\stmt^{{\pidZ}}))$ 
	\\ \-\ \-\ \-\ $\Deval{\locLL}{\codeLL}$ 
	$((\pidA, {\gamma^{{\pidA}}_{1}},$ ${\sigma^{{\pidA}}_{1}},$ $\DMap^{{\pidA}}_{1}$, $\Acc^{{\pidA}}_{1},$ ${\val^{{\pidA}}_{}}) \Mid ... \Mid$ 
	$(\pidZ, {\gamma^{{\pidZ}}_{1}},$ ${\sigma^{{\pidZ}}_{1}},$ $\DMap^{{\pidZ}}_{1}$, $\Acc^{{\pidZ}}_{1},$ $\val^{{\pidZ}}))$ 
\\ for codes $\codeLL \in {\piccoCodes}$,
then there exists a derivation 
\\ % b
$\Sigma \deriv ((\pidA,$ $\hgamma^\pidA,$ $\hsigma^\pidA,$ $\bsq,$ $\bsq,$ $\hstmt^\pidA)\Mid ...\Mid $
	$(\pidZ,$ $\hgamma^\pidZ,$ $\hsigma^\pidZ,$ $\bsq,$ $\bsq,$ $\hstmt^\pidZ))$ 
	\\ $\Deval{}{\codeVLL}$ 
	$((\pidA,$ $\hgamma^\pidA_1,$ $\hsigma^\pidA_1,$ $\bsq,$ $\bsq,$ $\hval^\pidA)\Mid...\Mid$
	$(\pidZ,$ $\hgamma^\pidZ_1,$ $\hsigma^\pidZ_1,$ $\bsq,$ $\bsq,$ $\hval^\pidZ))$ 
\\ for codes $\codeVLL \in \vanillaCodes$ 
and 
% c
a \LocMap\ $\psi_1$ 
% d
such that 
\\ % f
$\codeLL \cong \codeVLL$, 
% g
$\{(\pid, {\gamma^{{\pid}}_{1}},$ ${\sigma^{{\pid}}_{1}},$ $\DMap^{{\pid}}_{1}$, $\Acc^{{\pid}}_{1},$ $\val^{{\pid}}_{})$ $\cong_{\psi_1}$ 
$(\pid,$ $\hgamma^\pid_1,$ $\hsigma^\pid_1,$ $\bsq,$ $\bsq,$ $\hval^\pid)\}^{\pidZ}_{\pid = \pidA}$, 
% h
and $\Pi \cong_{\psi_1} \Sigma$.
\end{theorem}
The proof 
proceeds by induction on the evaluation tree $\Pi$ and the challenges are the ones 
discussed above related to memory management, and proving that the control flow of the erased program (and the corresponding memory) is correct with respect to the one of the \piccoC\ program.
%
\subsection{Noninterference} \label{sec: noninterference}
\piccoC\ satisfies a strong form of noninterference guaranteeing that two execution traces are indistinguishable up to differences in private values. This stronger version entails data-obliviousness. Instead of using execution traces, we will work directly with evaluation trees in the \piccoC\ semantics -- equivalence of evaluation trees up to private values implies equivalence of execution traces based on the \piccoC\ semantics. This guarantee is provided at the semantics level, we do not consider here compiler optimizations.   

For noninterference, it is convenient to introduce a notion of equivalence requiring that the two memories agree on publicly observable values. Because we assume that private data in memories are encrypted, and so their encrypted value is publicly observable, it is sufficient to consider syntactic equality of memories. Notice that if $\sigma_1=\sigma_2$ we can still have $\sigma_1\ell \neq \sigma_2\ell$, i.e., two executions starting from the same configuration can actually differ with respect to private data. 


We can now state our main noninterference result. 
\begin{theorem}[Noninterference over evaluation trees]
\label{Thm: strong noninterference}
For every environment $\{\gamma^{\pid}_{},$ $\gamma^{\pid}_{1},$ $\gamma'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$; 
memory $\{\sigma^{\pid}_{}$, $\sigma^{\pid}_{1}$, $\sigma'^{\pid}_{1} \}^{\pidZ}_{\pid = \pidA}\in\Mem$; 
\changeMap $\{\DMap^{\pid}_{}$, $\DMap^{\pid}_{1}$, $\DMap'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$;
accumulator $\{\Acc^{\pid}_{}$, $\Acc^{\pid}_{1}$, $\Acc'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}\in\N$; 
statement $\stmt$, values $\{\val^{\pid}_{}$, $\val'^{\pid}_{}\}^{\pidZ}_{\pid = \pidA}$; 
step evaluation code lists $\codeLL,\codeLL'$ and their corresponding lists of locations accessed $\locLL,\locLL'$; 
\\
if 
$\Pi \deriv\ ((\pidA, \gamma^{\pidA}_{},$ $\sigma^{\pidA}_{},$ $\DMap^{\pidA}_{}$, $\Acc^{\pidA}_{},$ $\stmt)\ \ \Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{},$ $\sigma^{\pidZ}_{},$ $\DMap^{\pidZ}_{}$, $\Acc^{\pidZ}_{},$ $\stmt))$ 
\\ \-\ \quad $\Deval{\locLL}{\codeLL}$ $((\pidA, \gamma^{\pidA}_{1},$ $\sigma^{\pidA}_{1},$ $\DMap^{\pidA}_{1}$, $\Acc^{\pidA}_{1},$ $\val^{\pidA}_{})\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{1},$ $\sigma^{\pidZ}_{1},$ $\DMap^{\pidZ}_{1}$, $\Acc^{\pidZ}_{1},$ $\val^{\pidZ}_{}))$ 
\\ and   
$\Sigma \deriv ((\pidA, \gamma^{\pidA}_{},$ $\sigma^{\pidA}_{},\ $ $\DMap^{\pidA}_{},\ $ $\Acc^{\pidA}_{},$ $\stmt)\ \ \Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{},\ $ $\sigma^{\pidZ}_{},\ $ $\DMap^{\pidZ}_{}$, $\Acc^{\pidZ}_{},$ $\stmt))$ 
\\ $\-\ \quad \Deval{\locLL'}{\codeLL'}$ $((\pidA, \gamma'^{\pidA}_{1},$ $\sigma'^{\pidA}_{1},$ $\DMap'^{\pidA}_{1}$, $\Acc'^{\pidA}_{1},$ $\val'^{\pidA}_{})\Mid ...\Mid (\pidZ, \gamma'^{\pidZ}_{1},$ $\sigma'^{\pidZ}_{1},$ $\DMap'^{\pidZ}_{1}$, $\Acc'^{\pidZ}_{1},$ $\val'^{\pidZ}_{}))$
\\ then $\{\gamma^{\pid}_{1}=\gamma'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\sigma^{\pid}_{1}=\sigma'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\DMap^{\pid}_{1} =\DMap'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\Acc^{\pid}_{1}=\Acc'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\val^{\pid}_{}=\val'^{\pid}_{}\}^{\pidZ}_{\pid = \pidA}$, 
$\codeLL=\codeLL'$, 
$\locLL = \locLL'$, 
$\Pi \loweq \Sigma$.
\end{theorem} 
%
Notice that low-equivalence of evaluation trees already implies the equivalence of the resulting configurations. We repeated them to make the meaning of the theorem clearer. 
This also proves data-obliviousness over memory accesses: in any two executions of the same program with the same public data, which locations in memory are accessed will be based on public data, and therefore identical between the two executions. 
As we proceed to prove Theorem~\ref{Thm: strong noninterference}, we leverage our Axioms reasoning about noninterference of the multiparty protocols.









