
\subsection{Memory Model} \label{subsec: mem model}
We assume the existance $n$ communicating parties, each with a separate memory.
Our memory model encodes each memory as a contiguous region of {\em blocks}, which are sequences of bytes and metadata.
We introduce an execution environment $\gamma$ and memory $\sigma$, shown in Figure \ref{Fig: mem model}.
Each block is assigned an identifier $\loc$ (to be discussed more later in this section). 
Blocks are never recycled nor cleared when they are freed. We chose this view of memory to preserve all allocated data, which, in conjunction with data-oblivious execution, represents the worst case for maintaining privacy. 
Direct memory access through pointers or manipulation of array indices allows programs to access any block for which the memory address is computable (e.g., as an offset or direct pointer access). 
To obtain the byte representations of data we leverage functions similar to CompCert, using $\Encode$ for values, $\EncodePtr$ for pointers, and $\EncodeFun$ for functions. Likewise, to obtain the human-readable data back, we use respective decode functions such as $\Decode$. We use a specialized version ($\DecodeArr$) for obtaining a specific index within an array data block.
We introduce the particulars in the following subsections.


% Fig: mem model moved to semantics.tex to be placed next to the grammar

\subsubsection{Environment} 
The environment, $\gamma$, maintains a mapping of each live variable $\x$ to its memory block identifier (where the data $\x$ is stored) and its type. 
At the start of a program, the environment is empty, i.e., $\gamma = [\-\ ]$. 
Variables that are no longer live are removed from the environment, based on scoping.  
We use the environment to facilitate the lookup of variables (i.e., for reads, writes, function calls) in memory $\sigma$. 



\subsubsection{Memory Blocks and Identifiers} \label{subsec: mem block}
The memory, $\sigma$ (shown in Figure~\ref{Fig: mem model}), is a mapping of each identifier $\loc$ to its memory block, which contains 
the byte representation $\byte$ of data stored there and metadata about the block.
Metadata consists of  
a type $\Type$ associated with the block, 
the number of elements $n$ of that type stored in $\byte$, 
and a list of byte-wise permissions tuples $[(0,\ \llabel_0,\ \perm_0), ..., (\bytelen,\ \llabel_\bytelen,\ \perm_\bytelen)]$, where $\bytelen = \tau(\Type)\cdot n - 1$ and function $\tau$ provides the size of the given type in bytes. 
A new memory block identifier is obtained from function $\phi$. 
These identifiers are monotonically increasing with each allocation. 
Every block is added to memory $\sigma$ on allocation, and is never cleared of data nor removed from $\sigma$ upon deallocation. 
Metadata cannot be accessed or modified directly by the program (the semantic rules control modification).
A memory block can be of an arbitrary size, which is constant and determined at allocation (with the exception of private pointers, to be discussed later in subsection~\ref{subsec: picco ptr eval}). 
We represent a memory location as a two-tuple of a memory block identifier and an offset. This allows us to use pointers to refer to any arbitrary memory location, as in C.





\subsubsection{Permissions} 
\label{subsec: permissions}
A permission $\perm$ can either be $\PermF$ (i.e., can be written to, read from, etc.) or 
$\PermN$ (i.e., already freed). 
These byte-wise permissions are modeled after a subset of those used by CompCert, and we extend their permission model by including a privacy label.
Each memory block has a list of permission tuples, one for each byte of data 
stored in that block. 
A permission tuple consists of the position of the byte that it corresponds to, and the privacy label $\llabel$ and permission $\perm$ for that byte of data. 
These permissions are important in reading and writing data to memory, especially when it comes to overshooting arrays and other out-of-bound memory accesses possible through the use of pointers. 
In particular, permissions allow us to keep track of deallocated memory (e.g. a block freed - note that the memory stored in the block itself is not overwritten or cleared and the block can still be accessed indirectly through direct
memory manipulations). 
All permission tuples corresponding to a memory block of a function type will have public privacy labels, as the instructions for a function are accessible from the program itself. 
Those for a normal variable or an array will have privacy labels corresponding to their type (i.e., public for public types, private for private types); those for pointers are more complex and will be discussed later in subsection~\ref{subsec: picco ptr eval}.  




\subsubsection{Malloc and Free}
Allocation of dynamic memory in C is provided by \TT{malloc}, which takes a number of bytes as its argument. 
When \Code{malloc} is called, 
a new memory block with identifier $\loc$ is obtained, initialized as a void type of the given size, and returned. 
This block then needs to be cast to the desired type. 
However, when dealing with private data, the programmer is unlikely to know the internal representation and the size of the private data types. 
For that reason, when allocating memory for private data, we adopt PICCO's \TT{pmalloc} functionality which takes two arguments: the type and the number of elements of that type to be allocated. 
The semantics then handle sizing the new memory block for the given private type. 
When \Code{free} or \Code{pfree} is called, if the argument is a variable of a pointer type, the permissions for all bytes of the location the pointer refers to will be set to $\PermN$, but the data stored there will not be erased. 
When \Code{pfree} is called with a pointer with a single location, it behaves identically to \Code{free}. 
The use of \TT{pfree} with multiple locations is a bit more involved, to be discussed later in Subsection~\ref{subsec: picco mem alloc/dealloc}. 
It is important to note that memory allocation and deallocation are public side effects, and therefore are {\em not allowed} within private-conditioned branches. 



\subsubsection{Public vs. Private Blocks}
To distinguish between public and private blocks, we assume that private blocks will be encrypted 
and we will use basic private primitives implementing specific operations to manage them. 
For modeling purposes, 
these primitives can decrypt the required blocks, perform 
the operations they are meant to implement, and encrypt the result. 
In our model, a program can also access private blocks by means of standard non-private operations or through of pointers. In this case, the operation will just interpret the encrypted value as a public value. This approach gives us a conceptual distinction between a \emph{concrete memory} and its corresponding \emph{logical content}, i.e. public values and values of the private data prior to encryption. Our model as described in the next section will work on concrete memories, but in Section~\ref{sec: noninterference}, for the proof of noninterference, it will be convenient to refer to the logical content of a memory. We will use the notation $\sigma\ell$ to denote the logical content of $\sigma$.  

