

\begin{definition}%\small
\label{def: loweq tree}
Two \piccoC\ evaluation trees $\Pi$ and $\Sigma$ are  \emph{low-equivalent}, in symbols $\Pi \loweq \Sigma$, if and only if $\Pi$ and $\Sigma$ have the same structure as trees, and for each node in $\Pi$ proving 
\\ \-\ \quad \-\ $((\pidA, \gamma^{\pidA}_{},$ $\sigma^{\pidA}_{},$ $\DMap^{\pidA}_{}$, $\Acc^{\pidA}_{},$ $\stmt)\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{},$ $\sigma^{\pidZ}_{},$ $\DMap^{\pidZ}_{}$, $\Acc^{\pidZ}_{},$ $\stmt))$ 
\\ $\Deval{\locLL}{\codeLL}$ $((\pidA, \gamma^{\pidA}_{1},$ $\sigma^{\pidA}_{1},$ $\DMap^{\pidA}_{1}$, $\Acc^{\pidA}_{1},$ $\val^{\pidA}_{})\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{1},$ $\sigma^{\pidZ}_{1},$ $\DMap^{\pidZ}_{1}$, $\Acc^{\pidZ}_{1},$ $\val^{\pidZ}_{}))$, the corresponding node in $\Sigma$ proves 
\\ \-\ \quad \-\ \-\ $((\pidA, \gamma^{\pidA}_{},$ $\sigma^{\pidA}_{},$ $\DMap^{\pidA}_{}$, $\Acc^{\pidA}_{},$ $\stmt)\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{},$ $\sigma^{\pidZ}_{},$ $\DMap^{\pidZ}_{}$, $\Acc^{\pidZ}_{},$ $\stmt))$ 
\\ $\Deval{\locLL'}{\codeLL'}$ $((\pidA, \gamma^{\pidA}_{1},$ $\sigma^{\pidA}_{1},$ $\DMap^{\pidA}_{1}$, $\Acc^{\pidA}_{1},$ $\val^{\pidA}_{})\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{1},$ $\sigma^{\pidZ}_{1},$ $\DMap^{\pidZ}_{1}$, $\Acc^{\pidZ}_{1},$ $\val^{\pidZ}_{}))$, $\codeLL = \codeLL'$ and $\locLL = \locLL'$.
\end{definition}



\begin{axiom}[$MPC_{ar}$]%\small
\label{axiom: mpc ar ni}
Given indices $\{\ind^{\pid}_{},$ $\ind'^{\pid}_{}\}^{\pidZ}_{\pid=\pidA}$, arrays $\{[\val^{\pid}_{1},$ $...,$ $\val^{\pid}_{n}]$, $[\val'^{\pid}_{1},$ $...,$ $\val'^{\pid}_{n}]\}^{\pidZ}_{\pid=\pidA}$, 
\\
if $MPC_{ar}((\ind^{\pidA}_{},$ $[\val^{\pidA}_{1},$ $...,$ $\val^{\pidA}_{n}]),$ $...,$ $(\ind^{\pidZ}_{},$ $[\val^{\pidZ}_{1},$ $...,$ $\val^{\pidZ}_{n}]))$ $= (\val^{\pidA}_{},$ $...,$ $\val^{\pidZ}_{})$, 
\\ \-\ \-\ 
$MPC_{ar}((\ind'^{\pidA}_{},$ $[\val'^{\pidA}_{1},$ $...,$ $\val'^{\pidA}_{n}]),$ $...,$ $(\ind'^{\pidZ}_{},$ $[\val'^{\pidZ}_{1},$ $...,$ $\val'^{\pidZ}_{n}]))$ $= (\val'^{\pidA}_{},$ $...,$ $\val'^{\pidZ}_{})$,  
\\ \-\ \-\ 
$\{\ind^{\pid}_{} = \ind'^{\pid}_{}\}^{\pidZ}_{\pid=\pidA}$, 
and $\{[\val^{\pid}_{1},$ $...,$ $\val^{\pid}_{n}] = [\val'^{\pid}_{1},$ $...,$ $\val'^{\pid}_{n}]\}^{\pidZ}_{\pid=\pidA}$
\\
then $\{\val^{\pid}_{} = \val'^{\pid}_{}\}^{\pidZ}_{\pid=\pidA}$. 
\end{axiom}



\begin{axiom}[$\MPC{b}$]%\small
\label{axiom: mpc b ni}
Given values $\{\val^{\pid}_{1},$ $\val^{\pid}_{2},$ $\val^{\pid}_{3},$ $\val'^{\pid}_{1},$ $\val'^{\pid}_{2},$ $\val'^{\pid}_{3}\}^{\pidZ}_{\pid=\pidA}$ and binary operation $\binop\in\{\cdot, +, -, \div\}$, 
\\
if $MPC_{b}(\binop,$ $\val^{\pidA}_{1},$ $\val^{\pidA}_{2}, ...,$ $\val^{\pidZ}_{1}, \val^{\pidZ}_{2})$ $= (\val^{\pidA}_{3}, ..., \val^{\pidZ}_{3})$, 
\\ \-\ \-\ 
$MPC_{b}(\binop,$ $\val'^{\pidA}_{1},$ $\val'^{\pidA}_{2}, ...,$ $\val'^{\pidZ}_{1}, \val'^{\pidZ}_{2})$ $= (\val'^{\pidA}_{3}, ..., \val'^{\pidZ}_{3})$,  
$\{\val^{\pid}_{1} = \val'^{\pid}_{1}\}^{\pidZ}_{\pid=\pidA}$, 
and $\{\val^{\pid}_{2} = \val'^{\pid}_{2}\}^{\pidZ}_{\pid=\pidA}$
\\
then $\{\val^{\pid}_{3} = \val'^{\pid}_{3}\}^{\pidZ}_{\pid=\pidA}$. 
\end{axiom}





\begin{theorem}[Multiparty Noninterference]%\small
\label{thm: NI app}
For every environment $\{\gamma^{\pid}_{},$ $\gamma^{\pid}_{1},$ $\gamma'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$; 
memory $\{\sigma^{\pid}_{}$, $\sigma^{\pid}_{1}$, $\sigma'^{\pid}_{1} \}^{\pidZ}_{\pid = \pidA}\in\Mem$; 
\changeMap $\{\DMap^{\pid}_{}$, $\DMap^{\pid}_{1}$, $\DMap'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$;
accumulator $\{\Acc^{\pid}_{}$, $\Acc^{\pid}_{1}$, $\Acc'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}\in\N$; 
statement $\stmt$, values $\{\val^{\pid}_{}$, $\val'^{\pid}_{}\}^{\pidZ}_{\pid = \pidA}$; 
step evaluation code lists $\codeLL,\codeLL'$ and their corresponding lists of locations accessed $\locLL,\locLL'$, 
party $\pid \in \{\pidA...\pidZ\}$; 
\\
if 
$\Pi \deriv ((\pidA, \gamma^{\pidA}_{},$ $\sigma^{\pidA}_{},$ $\DMap^{\pidA}_{}$, $\Acc^{\pidA}_{},$ $\stmt)\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{},$ $\sigma^{\pidZ}_{},$ $\DMap^{\pidZ}_{}$, $\Acc^{\pidZ}_{},$ $\stmt))$ 
\\ $\-\ \quad\Deval{\locLL}{\codeLL}$ $((\pidA, \gamma^{\pidA}_{1},$ $\sigma^{\pidA}_{1},$ $\DMap^{\pidA}_{1}$, $\Acc^{\pidA}_{1},$ $\val^{\pidA}_{})\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{1},$ $\sigma^{\pidZ}_{1},$ $\DMap^{\pidZ}_{1}$, $\Acc^{\pidZ}_{1},$ $\val^{\pidZ}_{}))$ 
\\ and   
$\Sigma \deriv ((\pidA, \gamma^{\pidA}_{},$ $\sigma^{\pidA}_{},$ $\DMap^{\pidA}_{}$, $\Acc^{\pidA}_{},$ $\stmt)\Mid ...\Mid (\pidZ, \gamma^{\pidZ}_{},$ $\sigma^{\pidZ}_{},$ $\DMap^{\pidZ}_{}$, $\Acc^{\pidZ}_{},$ $\stmt))$ 
\\ $\-\ \quad \-\ \Deval{\locLL'}{\codeLL'}$ $((\pidA, \gamma'^{\pidA}_{1},$ $\sigma'^{\pidA}_{1},$ $\DMap'^{\pidA}_{1}$, $\Acc'^{\pidA}_{1},$ $\val'^{\pidA}_{})\Mid ...\Mid (\pidZ, \gamma'^{\pidZ}_{1},$ $\sigma'^{\pidZ}_{1},$ $\DMap'^{\pidZ}_{1}$, $\Acc'^{\pidZ}_{1},$ $\val'^{\pidZ}_{}))$
\\ then $\{\gamma^{\pid}_{1}=\gamma'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\sigma^{\pid}_{1}=\sigma'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\DMap^{\pid}_{1} =\DMap'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\Acc^{\pid}_{1}=\Acc'^{\pid}_{1}\}^{\pidZ}_{\pid = \pidA}$, 
$\{\val^{\pid}_{}=\val'^{\pid}_{}\}^{\pidZ}_{\pid = \pidA}$, 
$\codeLL=\codeLL'$, 
$\locLL = \locLL'$, 
$\Pi \loweq \Sigma$.
~\\
\end{theorem} 


\begin{proof}[Proof Sketch]
By induction over all \piccoC\ semantic rules. We make the assumption that both evaluation traces are over the same program (this is given by having the same $\stmt$ in the starting states) and all public data will remain the same, including data read as input during the evaluation of the program. A portion of the complexity of this proof is within ensuring that memory accesses within our semantics remain data oblivious. 
Several rules follow fairly simply and leverage similar ideas, which we will discuss first, and then we will provide further intuition behind the more complex cases. 

For all rules leveraging helper algorithms, we must reason about the helper algorithms, and that they behave deterministically by definition and have data-oblivious memory accesses. Given this and that these helper algorithms do no modify the private data, we maintain the properties of noninterference of this theorem. First we reason that our helper algorithms to translate values into their byte representation will do so deterministically, and therefore maintain indistinguishability between the value and byte representation. We can then reason that our helper algorithms that take these byte values and store them into memory will also do so deterministically, so that when we later access the data in memory we will obtain the same indistinguishable values we had stored. 

It is also important to take note here our functions to help us retrieve data from memory, particularly in cases such as when reading out of bounds of an array. When proving these cases to maintain noninterference, we leverage our definition of how memory blocks are assigned in a monotonically increasing fashion, and how the algorithms for choosing which memory block to read into after the current one are deterministic. This, as well as our original assumptions of having identical public input, allows us to reason that if we access out of bounds (including accessing data at a non-aligned position, such as a chunk of bytes in the middle of a memory block), we will be pulling from the same set of bytes each time, and therefore we will end up with the same interpretation of the data as we continue to evaluate the remainder of the program. It is important to note again here that by definition, our semantics will always interpret bytes of data as the type it is expected to be, not the type it actually is (i.e., reading bytes of data that marked private in memory by overshooting a public array will not decrypt the bytes of data, but instead give you back a garbage public value). To reiterate this point, even when reading out of bounds, we will not reveal anything about private data, as the results of these helper algorithms will be indistinguishable.

To reason about the multiparty protocols, we leverage Axioms, such as Axiom~\ref{axiom: mpc b ni}, to reason that the protocols will maintain our definition of noninterference. With each of these Axioms, we ensure that over two different evaluations, if the values of the first run ($\val^\pid_1, \val^\pid_2$) are not distinguishable from those of the second ($\val'^\pid_1, \val'^\pid_2$), then the resulting values are also not distinguishable ($\val^\pid_3 = \val'^\pid_3$). These Axioms should be proven by a library developer to ensure the completeness of the formal model. 

For private pointers, it is important to note that the obtaining multiple locations is deterministic based upon the program that is being evaluated. A pointer can initially gain multiple locations through the evaluation of a private if else. Once there exists a pointer that has obtained multiple locations in such a way, it can be assigned to another pointer to give that pointer multiple locations. The other case for a pointer to gain multiple location is through the use of \TT{pfree} on a pointer with multiple locations (i.e., the case where a pointer has locations $\loc_1$, $\loc_2$, $\loc_3$ and we free $\loc_1$) - when this occurs, if another pointer had referred to only $\loc_1$, it will now gain locations in order to mask whether we had to move the true location or not. 
When reasoning about pointers with multiple locations, we maintain that given the tags for which location is the true location are indistinguishable, then it is not possible to distinguish between them by their usage as defined in the rules or helper algorithms using them. 
Additionally, to reason about \TT{pfree}, we leverage that the definitions of the helper algorithms are deterministic, and that (wlog), we will be freeing the same location. We will then leverage our Axiom about the multiparty protocol $\PFree$. After the evaluation of $\PFree$, it will deterministically update memory and all other pointers as we mentioned in the brief example above.

For both Private If Else rules, the most important element we must leverage is how values are resolved, showing that given our resolution style, we are not able to distinguish between the ending values. 
In order to do this, we also must reason about the entirety of the rule, including all of if else helper algorithms. 
First, we note that the evaluation of the \TT{then} branches follows by induction, as does the evaluation of the \TT{else} branch once we have reasoned through the restoration phase. 
For variable tracking, it is clear from the definitions of $\DynExtract$, $\Initialize$, and $\Restore$ that the behavior of these algorithms is deterministic and given the same program, we will be extracting, initializing, and restoring the same set variables every time we evaluate the program. For location tracking, $\DynInit$ is also immediately clear that it will be initializing the same locations each time. We must then reason about $\DynUpdate$, and how given a program, we will deterministically find the pointer dereference writes and array writes at public indices at corresponding positions in memory and add them to our tracking structure $\DMap$. Then we can reason that the behavior of $\DynRestore$ will deterministically perform the same updates, because $\DMap$ will contain the same information in every evaluation. 
Now, we are able to move on to reasoning about resolution, and show that given all of this and the definitions of the resolution helper algorithms and rule, we are not able to distinguish between the ending values.  

One of the main complexities of this proof revolves around ensuring \emph{data-oblivious memory accesses} (i.e. that we always access locations deliberately based on public information), particularly when handling arrays and pointers. Within the proof, we must consider all helper algorithms, and what locations are accessed within the algorithms as well as within the rules. What locations are accessed within the algorithms follows deterministically from the definition of the algorithms, and we return from the algorithms which locations were accessed in order to properly reason about the entire evaluation trace of the program. Our semantics are designed in such a way that we give the multiparty protocols all of the information they need, with all memory accesses being completed within the rule itself or our helper algorithms. This also helps show that memory accesses are purely local, not distributed operations.  
%
Within the array rules, the main concern is in reading from and writing at a private index. We currently handle this complexity within our rules by accessing all locations within the array in rules Multiparty Array Read Private Index and Multiparty Array Write Private Index. 
In Multiparty Array Read Private Index, we clearly read data from every index of the array ($\{\forall \ind \in \{0...\nl-1\} \quad \DecodeArr({\llabel\ \btype}, \ind, {\byte^\pid_1}) =  \n^\pid_\ind\}^{\pidZ}_{\pid = \pidA}$), then that data is passed to the multiparty protocol. 
Similarly, in Multiparty Array Write Private Index, we read data from every index of the array, pass it to the multiparty protocol, then proceed to update every index of the array with what was returned from the protocol. 
Within the multiparty protocols used in these two rules, we will ensure the usage of the data is data-oblivious within the main noninterference proof in the following subsection. 
All other array rules use public indices, and in turn only access that publicly known location.
Within the pointer rules, our main concern is that we access all locations that are referred to by a private pointer when we have multiple locations. For this, we will reason about the contents of the rules and the helper algorithms used by the pointer rules, which can be shown to deterministically do so.
\end{proof}




















