\section{Lessons learned}
\label{sec:lessons}

During design, implementation and testing, we adopted lessons that
served as general guidance:

\begin{enumerate}
    \item \emph{Don't store what you can compute.} Storing state in a 
        distributed system is expensive---not just in bytes and bandwidth, 
        but in complexity. Modifying that state requires transactions and forces
        components to synchronize. This complexity will necessarily infect the 
        rest of the system. If it is possible to recompute a result, the cost in 
        cycles buys a simpler design.
    \item \emph{Align your design with Kubernetes concepts.} Alignment enables
        integration and simplification. We did not have to implement any
        management of Streams instances in cloud-native Streams because we
        enforce one Streams instance per Kubernetes namespace. In legacy
        Streams, a domain managed multiple instances. We get that for free as
        our ``domain'' just becomes the Kubernetes cluster.
    \item \emph{Don't re-implement what Kubernetes already provides.} The value 
        in using a general purpose distributed platform is not having to 
        re-implement the basics. Designs which require implementing bespoke 
        versions of life cycle management, communication, storage or 
        configuration not only waste code and effort. Such designs are also less 
        likely to integrate well into Kubernetes, forcing even more bespoke 
        implementations of other features.
    \item \emph{Rely on Kubernetes for atomicity, consistency and redundancy.} 
        Kubernetes provides reliable storage, and sends totally ordered, reliable 
        notifications based on changes to the objects in that storage. Building 
        systems using these primitives allows for simpler, better integrated 
        designs.
    \item \emph{Always use hierarchical, deterministic naming.} Globally unique 
        names in a distributed system are a form of state: creating them requires 
        synchronization to avoid duplicates, and their metadata must be durably 
        stored. For top-level objects in a system, this property is 
        unavoidable. But named objects nested in those top-level objects do not
        need to be globally unique, as their top-level object is an implicit 
        namespace. Requiring such nested names to be globally unique imposes 
        unnecessary state management and synchronization. Hierarchical, 
        deterministic naming schemes allows other entities in the system to 
        \emph{compute} what the names must be.
\end{enumerate}

