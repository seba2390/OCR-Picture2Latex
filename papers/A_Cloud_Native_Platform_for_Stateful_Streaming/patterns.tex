\section{Cloud Native Patterns}
\label{sec:patterns}

We present the key abstractions that made the migration of IBM Streams from a
legacy platform to a cloud native platform possible: controllers, conductors,
coordinators and causal chains. The patterns are available as an open source
Java library at \url{http://www.github.com/ibm/cloud-native-patterns}.

\subsection{Controllers}
\label{sec:controller}

Kubernetes defines controllers as ``control loops that tracks at least one
resource type''~\cite{kubecontrollers}. We constrain that definition further: in
cloud native Streams, a controller is a control loop that tracks a single
resource type. Controllers take some action on creation, modification and
deletion of a resource type. As with regular resources, custom resources can be
monitored using controllers. Cloud native Streams makes extensive use of custom
resources to store platform related state (Figure~\ref{fig:actors}).
For each custom resource, it implements a concurrent controller deployed within
the instance operator. The instance operator also uses controllers
for traditional Kubernetes resources such as pods, nodes, and namespaces.

In cloud native Streams, a resource controller is responsible for monitoring
events on a single resource, saving state updates for this resource in a local
cache, and executing any action as a result of these events. We use the
microBean Kubernetes Controller library~\cite{microbean} as a starting point for
our controller abstraction. It implements both the informer and reflector
patterns as defined in the Go client~\cite{kubegoclient}.  In its most essential
form, a cloud native Streams controller is built by defining a set of three
event callbacks (\code{onAddition}, \code{onModification}, \code{onDeletion}), a
resource store, and providing both callbacks and store to an internal microBean
controller instance.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\linewidth]{figures/patterns}
  \caption{Clound native patterns: controller, conductor and coordinator. This example shows 
    two controllers and one conductor. The controller on the left uses the coordinator pattern to 
    update resources owned by the controller on the right. A conductor monitors events from both 
    resources.}
  \label{fig:patterns}
\end{figure}

The \emph{controller pattern} in Figure~\ref{fig:patterns} depicts the
relationships between these components. An \emph{event listener}
categorizes notifications it receives from the microBean informer into addition,
modification and deletion events on resources. Cloud native Streams
controllers, which derives from an event listener, implement the actions
to take in response to these events. The resource cache is used by the microBean
reflector to maintain a cached view of the resource pool based on the streams of
event it has received.

\subsection{Conductors}
\label{sec:conductor}

In contrast to controllers, the \emph{conductor pattern} (bottom-middle of
Figure~\ref{fig:patterns}) observes events from multiple resources and does not
save state updates in a local cache. Instead, they are concurrent control loops
that maintain a state machine that transitions based on resource events, all
towards a final goal. Conductors do not own any resources. Rather, they register
themselves with existing controllers as generic event listeners which receive
the same notifications that each controller does.

The conductor pattern solves the problem of synchronizing a particular action
based on asynchronous events generated by multiple actors. In cloud native
Streams, we encountered the conductor pattern in two main cases: job submission
and pod creation for PEs. For jobs, we need to know when to move the job's
status from the initial \code{Submitting} to the final \code{Submitted} state.
A job is not fully submitted until all of the resources that comprise it have
been fully created. Before we can create a pod for a PE, we must first ensure
that all of its dependencies exist, such as secrets or its \code{ConfigMap}.

In both cases, it is necessary to listen to multiple resource events and
maintain local tracking of the status of those resources in order to arrive at
the goal.

\subsection{Coordinators}
\label{sec:coordinator}

When asynchronous agents need to modify the same resource, we use the
\emph{coordinator pattern} (top-middle of Figure~\ref{fig:patterns}). The
coordinator pattern implements a multiple-reader, single-writer access model by
granting ownership of the resource to a single agent and serializing
asynchronous modification requests coming from other agents. Coordinators are
synchronous command queues that serially execute modification commands on
resources. In cloud native Streams, this pattern means that the controller for a
resource owns that resource, and other controllers which want to modify it must
make requests to that controller.

Many situations in cloud native Streams involve concurrent agents wanting to
modify resource they interact with. For example, a PE's launch count tracks how 
often the platform has started a PE. There are two instances when we must increment 
the PE launch count: pod failure and PE deletion. However, different agents handle 
those two events. Allowing them to asycnhronsouly modify the PE's launch would 
lead to race conditions.

Instead, we use the coordinator pattern. When a pod fails, it must be restarted.
Our pod controller overrides the default behavior of letting the kubelet restart
the pod. When the pod controller is notified of a failed pod, it must increase the restart
count of its owning PE. Doing so directly through a Kubernetes update command
could lead to race conditions between the PE controller and the pod controller.
Instead, we use the PE coordinator interface to let the PE controller execute
that command for us.

\subsection{Causal Chains}
\label{sec:causal}

A \emph{causal link} (Figure~\ref{fig:causal_links}) is a single actor
responding to a single resource change by synchronously changing one or more
other resources. These logical state transitions are atomic and composable. A
\emph{causal chain} (Figure~\ref{fig:causal_chain}) is the composition of
multiple causal links where the result of one is the input to another. It is an
asynchronous sequence of deterministic actions that implements a logical state transition
across multiple resources. Unlike the other patterns, causal links and chain are
not themselves actors in the system.  They are a pattern of behavior that
emerges from the interaction of multiple actors.

\begin{figure}[h]
  \centering
  \includegraphics[width=1\linewidth]{figures/causal_links}
  \caption{Causal Links}
  \label{fig:causal_links}
\end{figure}

Causal chains are an abstraction that derives from two principles: operational
states have a single source of truth provided by Kubernetes, and these states
can only be synchronously modified in a single place in the system. As a consequence, 
causal chains necessarily span across multiple actors: modifications initiated by one 
actor on a resource it controls cause another actor to make modifications to its 
own resource.

\begin{figure}[h]
  \centering
  \includegraphics[width=1\linewidth]{figures/causal_chain}
  \caption{Causal Chain}
  \label{fig:causal_chain}
\end{figure}

% figure for the next section
\begin{figure*}[t!]
  \centering
  \includegraphics[width=0.7\linewidth]{figures/actors_all}
  \caption{Clound native Streams actors and their interactions.}
  \label{fig:actors}
\end{figure*}

In cloud native Streams, a causal link drives the creation of a pod for a PE.
The pod conductor is the only actor which can create pods for PEs, and it only 
reacts to changes to a PE's launch count. It composes with four other causal 
links to create causal chains:

\begin{enumerate}
    \item \emph{PE creation}. The PE controller reacts to a new PE by incrementing 
        the launch count through the PE coordinator.
    \item \emph{Voluntarily PE deletion}. The PE controller recreates the PE resource, 
        which eventually leads to (1).
    \item \emph{Pod failure or deletion}. The pod controller increments the PE 
        launch count through the PE coordinator.
    \item \emph{Job submission}. The job conductor checks if any PEs for the job are 
        already running, and if they are, if the graph metadata for them has 
        changed. If yes, then the job conductor updates the graph metadata and 
        increments the launch count through the PE coordinator.
\end{enumerate}

By composing controllers, conductors and coordinators, we construct a
deterministic state machine out of an asynchronous distributed system.
Controllers are state machines that react to changes on a single resource kind,
but may produce changes on any resource. Conductors are state machines that
react to and produce changes on multiple resource kinds.  The composition of
controllers and conductors is necessarily itself a state machine, but it is the
addition of coordinators that makes the resulting state machine deterministic.

