\begin{abstract}


The rising popularity of declarative languages and the hard to debug nature thereof have motivated the need for applicable, automated repair techniques for such languages. However, despite significant advances in the program repair of imperative languages, there is a dearth of repair techniques for declarative languages. This paper presents {\technique}, an automated repair technique for faulty models written in Alloy, a declarative language based on first-order relational logic. {\technique} is backed with a novel strategy for bounded exhaustive, yet scalable, exploration of the spaces of fix candidates and a formally rigorous, sound pruning of such spaces. Moreover, different from the state-of-the-art in Alloy automated repair, that relies on the availability of unit tests, {\technique} does not require tests and can work with assertions that are naturally used in formal declarative languages. Our experience with using {\technique} to repair thousands of real-world faulty models, collected by other researchers, corroborates its ability to effectively generate correct repairs and outperform the state-of-the-art.

\begin{comment}
%In the same way that software source code is subject to defects, so are software specifications. Thus, the broad range of techniques for software quality assessment and improvement, including automated repair techniques, are also relevant in the context of software specification. 
%This paper is concerned with the automated repair of specifications written in Alloy, a formal specification language with support for automated specification assessment, and many applications in software analysis. 
We present \technique, a novel technique that automatically repairs faulty Alloy specifications, i.e., formal specifications in the Alloy language whose automated SAT-based evaluation, considered as the \emph{oracle} for repair, contradicts the expectations of the developer. Our technique has a number of features that distinguish it from previous Alloy specification repair techniques. Firstly, in contrast with previous techniques that require unit tests as part of the specification, our technique is able to operate under \emph{any} kind of repair oracle, supporting the assertions typically found in formal specification, as well as ``specification tests''. This is important since unit tests, widely available for programs, are not typically found in formal specifications. Secondly, given a defined set of mutation operations, a set of suspicious expressions and a maximum number of mutations to apply, \technique\ either finds a fix, or guarantees that such a fix is impossible, in terms of modifying the suspicious locations within the provided bound and with the given mutation operators. That is, the technique performs a bounded exhaustive exploration of the state space of fix candidates, 
%defined by the faulty locations, the mutation operators and the bound, 
as opposed to previous techniques that non-exhaustively explore the space of candidates, guided dynamically by fault localization.  

Since the space of ``bounded'' repair candidates is exhaustively considered, techniques for soundly pruning the state space (i.e., without losing possibly valid fixes) become highly relevant. Given a candidate repair for a specific suspicious location, \technique\ exploits both a syntactic analysis of the specification and a semantic analysis using the Alloy Analyzer for checking the \emph{feasibility} of this candidate, in the sense that fixing this specific repair candidate in its corresponding location preserves the feasibility of the overall repair. When feasibility fails, it allows us to prune, in a sound way, significant parts of the search space for repair candidates, thus reducing specification repair running times. 
%We present the technique and our pruning mechanisms. 
We evaluate the technique on a benchmark of Alloy specifications, including specifications previously used in assessing automated repair techniques for Alloy. The evaluation shows that our approach is less prone to overfitting than previous techniques, and pruning significantly reduces specification repair running times. 
\end{comment}

\end{abstract}
