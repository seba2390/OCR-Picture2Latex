\section{Introduction}

Software has become ubiquitous, and many of our activities depend directly or indirectly on it. Having adequate software development techniques and methodologies that contribute to producing quality software systems has therefore become essential for many human activities. A well-established approach to achieving quality is to emphasize good problem understanding and planning ahead of development, i.e., to put an emphasis on the analysis and design phases of software development \cite{Ghezzi+2002}. These phases need to deal with descriptions of software and problem domains, which are typically captured using specification, or modeling, languages. Techniques and tools that allow users to \emph{analyze} specifications are very important, as they help developers in discovering flaws, such as missing cases in the specifications, wrong interpretations of requirements, etc. Two main problems arise in this phase: correctly \emph{understanding} the problem situation (thus capturing the right problem), and correctly \emph{stating} the problem in the language at hand (thus capturing the problem right). In the context of \emph{formal specification}, where formalisms with formal syntax and semantics are employed, the latter problem is particularly relevant, as the developer has to master the notation to correctly capture, in a formal way, a given software description \cite{ClarkeWing1996}. Even for experienced developers, many times subtle errors arise, like mistakenly using the wrong expression to capture a property, omitting an operator or using an operator in place of another, leading to incorrect specifications that do not capture the developer's intentions \cite{Nelson+2017}. These kinds of mistakes share characteristics with program defects. Therefore, techniques for dealing with these defects and, in general, to assess or improve software quality (such as techniques for bug finding and program debugging), are also relevant in the context of software specifications. In particular, techniques for improving debugging, e.g., via the automation of fault localization or program repair, are pertinent in the context of software specification. 

This paper targets the problem of automatically repairing formal specifications, more precisely, specifications in Alloy \cite{Jackson2006}, a formal language that has many applications in software development and has been successfully applied in a number of domains such as the discovery of design flaws in telecommunication applications \cite{Zave2017}, the analysis of security mechanisms in mobile and IoT platforms \cite{Bagheri+2018,DBLP:conf/issta/AlhanahnahSB20,DBLP:conf/dsn/BagheriSBM16}, the automation of software testing \cite{Khalek+2011,DBLP:conf/icse/MirzaeiGBSM16,Abad+2013}, and the verification of programs \cite{Dennis+2006,Galeotti+2010,Galeotti+2013}, among other applications \cite{Jackson2019}. While specifications share a number of characteristics with programs, certain characteristics make it non-trivial to apply the broad range of techniques for program repair, in the context of specifications. For instance, as a way to tame the space of candidates, various program repair techniques such as \emph{GenProg} \cite{LeGoues+2012} only use \emph{coarse-grained} syntactic modifications, such as block replacement, swapping, deletion and insertion, but no \emph{intra-statement} modifications are allowed. The rationale is that good levels of repairability in programs are achieved via coarse-grained modifications thanks to \emph{redundancies} that are present in code, especially in larger programs. Such redundancies are not often seen in specifications, in particular due to the relative conciseness of specifications compared to programs. Other approaches to program repair, e.g., \emph{PAR} \cite{Kim+2013}, restrict the modifications to patterns learned from human-written patches, mined from large repositories categorizing fixes; such inputs for the repair process are not available in the context of formal specification, simply because, as opposed to source code, there are no large repositories of specifications. Finally, most program repair techniques rely directly or indirectly on the availability of \emph{test cases}; while there exist initiatives that incorporate test cases to specifications \cite{Sullivan+2018}, other forms of checking, such as property satisfiability and verification, are more naturally found in specifications. 

In this paper, we present \technique, a novel technique that automatically repairs faulty Alloy specifications. \technique\ has several features distinguishing it from the state of the art \cite{Wang+2018}. Firstly, the technique does not depend on test cases, neither for fault localization nor for specification repair; it supports any kind of specification oracle, notably the typical assertion checks and property satisfiability checks found in Alloy specifications, as well as test cases. It is then more widely applicable in the context of formal specification, where test cases are rarely found accompanying specifications. Secondly, the technique tackles automated repair in a \emph{bounded exhaustive} way, i.e., by exhaustively exploring \emph{all} possible repair candidates, for a given set of mutation operators and maximum number of applications (on a set of identified suspicious specification locations). Thus, it either finds a fix, or guarantees that no fix is possible, within the provided bound and with the considered mutation operators over the identified faulty locations. This approach is natural to the context of Alloy, where users are accustomed to bounded exhaustive analyses.

\technique\ supports fine-grained mutations and is designed to enable the repair of multi-location specification defects. Since bounded exhaustive exploration suffers from inherent scalability issues, our technique features a number of \emph{pruning} strategies, that leverage the use of the Alloy Analyzer to \emph{soundly} prune large parts of the candidate space. More precisely, given a candidate repair for a specific suspicious location, our technique exploits both a syntactic analysis of the specification and a semantic analysis using the Alloy Analyzer for checking the feasibility of this candidate, in the sense that applying this specific repair candidate to the corresponding location preserves the feasibility of the overall (multi-location) repair. When feasibility fails, it allows us to prune, in a sound way, i.e., without losing valid fixes, significant parts of the search space for repair candidates, thus reducing specification repair running times. 

We evaluate our technique on a benchmark of Alloy specifications, including specifications previously used in assessing ARepair \cite{Wang+2018,Wang+2019}, and a large benchmark of faulty Alloy specifications produced by students \cite{Macedo+2020}. Our evaluation shows that our pruning technique significantly reduces specification repair running times, duplicating the number of repairs that can be produced within a 1-hour timeout, and reducing the repair time by 62X, on average. Moreover, when specifications feature typical assertions, and these are used as oracles, our technique shows a significant improvement in overfitting reduction, compared to the test-based technique ARepair.

%The contributions of this paper are summarized as follows:
%\begin{enumerate}
%\item We present the technique underlying \technique, and show that our pruning mechanism is sound, i.e., no actual fix is ever discarded by the pruning mechanism.
%\item We evaluate \technique\  on a benchmark of Alloy models, including models previously used in assessing automated repair techniques, and show that \technique\ produces fixes of better quality.
%\item We discuss the appropriateness of \technique\  with respect to the Alloy methodology for developing models. We show that \technique\ is better suited than previous related work.
%\end{enumerate}

