\vspace{-1em}
\section{Introduction}
\label{sec:intro}
Injection attacks have been a long-standing security problem, listed as the first security risk in the OWASP Top 10 security risks~\cite{owasp_top_ten}. 
Among them, \updated{command}{input} injection \updated{}{(e.g., shell command/SQL injection)} is one of the most prevalent injection attacks. 
It happens when malicious inputs \updated{commands}{} (\updated{OS/}{}shell commands or SQL queries) are injected and executed on the victim system. 
%
Despite the effort in thwarting injection attacks~\cite{nguyen-tuong-sql,  Haldar_2005, chin_2009, csse, sqlcheck, sqlrand, halfond06fse, halfond_wasp, sekar_ndss, AMNESIA, CANDID, webssari, xie_aiken, pixy, wassermann_2007,wassermann_2008,minamide_2005, noxes, saner_2008}, \updated{command}{} injection vulnerabilities \updated{can be}{are} still \updated{exploited}{pervasive} in practice because, in part, the ever-evolving attacks \updated{are exploiting}{exploit} the limitations of the prevention measures.

\noindent
{\bf Existing Prevention Techniques.}
Input sanitization/validation is a recommended practice to prevent \updated{command}{input} injection attacks~\cite{Alkhalaf2014AutomaticDA, webssari, saner_2008}. However, implementing a sanitizer that can filter out all malicious inputs is extremely challenging due to the large and complex input space (e.g., grammars for OS/shell commands and SQL are expressive\updated{}{, allowing various inputs}). 
\revised{
\updated{}{Another straightforward approach is first identifying all allowed inputs on each call-site of APIs and only allowing them. However, this cannot prevent attacks that inject the allowed inputs twice. For instance, attackers can inject new ``\code{rm}'' commands to a vulnerable code snippet ``\code{system("rm logfile \$opt")}'' (Details can be found in Appendix~\ref{appendix:whitelist_approach}).}  
}
% and the complex input requirements and specifications (e.g., prohibited inputs in one context might be desirable in another context). 
%
%For example, filtering out special characters (e.g., `\code{'}' or `\code{;}') is a typical way of preventing shell command injection. However, in practice, completely restricting the use of special characters is difficult as some contents may require them (e.g., passwords are often encouraged to have special characters).
%Moreover, as input specifications (e.g., SQL grammars) are often evolving, introducing new keywords that can be abused in injection attacks, prevention techniques should be updated accordingly.
%
There are more advanced prevention techniques, such as those leveraging dynamic taint analysis~\cite{nguyen-tuong-sql,  Haldar_2005, chin_2009, csse, sqlcheck, halfond06fse}. However, they suffer from over/under tainting issues and runtime overhead.
Techniques that build models of benign commands/SQL queries to detect anomalies~\cite{sekar_ndss,  AMNESIA, CANDID} require accurate modeling of ever evolving attackers and target applications. %, which have been evolving over the years.
% that do not follow the pre-generated models/patterns of benign commands.


\noindent
{\bf Randomization-based Prevention.}
There are techniques~\cite{sqlrand,autorand} that randomize SQL keywords (in SQL engine and benign SQL queries) to prevent the execution of injected SQL queries that are not randomized. 
While the idea is effective, \updated{it has a critical limitation}{they have a critical limitation in their design choices}. 
To deploy the techniques, they rely on a proxy to translate a randomized query to a standard query using a \emph{parser}. %, instead of randomizing SQL engines directly.
\revised{
If the proxy's translator fails because of sophisticated SQL queries and grammar differences between SQLs (e.g., SQL dialects~\cite{sql_dialect} as discussed in Section~\ref{subsubsec:advanced_sql_injection}), malicious queries can be injected or benign queries may not be properly executed.
%
Diglossia~\cite{diglossia} is an injection attack prevention technique that proposes the dual-parsing approach. Unfortunately, it also relies on the accuracy of the parser used in the dual-parser (Details on how Diglossia will fail are presented in Section~\ref{subsec:comparison_existing}).
%
%{A straightforward approach to eliminate the proxy is to change the source code of SQL engines directly.}
%Unfortunately, we find that it is practically challenging because some SQL engines are closed source software (e.g., MSSQL), and \updated{the complexity of}{} parsers in SQL engines \updated{are difficult to handle}{contain various ad-hoc SQL query parsing code snippets, making it difficult to randomize them all}. 
%We have tried to randomize keywords in MySQL source code \updated{}{by replacing constant string keywords in the base parser created by Lex/Yacc}\updated{ and recompiled it. However,}{, but} \updated{the MySQL version}{it} did not function correctly.
%
\updated{Moreover,}{Other} randomization techniques~\cite{sqlrand,autorand} are susceptible to attacks that leak randomization key because their randomization scheme is not dynamically changing. Attackers can then prepare and inject a randomized command. 
}

%Moreover, we find that the limitation is caused by the design choice of using parsers and cannot be mitigated by engineering effort.
%avoiding detection. Worse, building a perfect parser is also an extremely challenging task, particularly with attackers exploiting bugs in parsers and bypassing detection techniques~\cite{xxx}.

\noindent
{\bf Our Approach.}
We propose a robust and practical randomization-based technique called \sysname to prevent \updated{command}{input} injection attacks.
The technique works by randomizing words in inputs (e.g., commands and SQL queries) and the subsystems  (e.g., shell process and SQL engine) that \updated{execute}{parse and run} the inputs.
%====
\updated{Once we randomize the command names and keywords in the subsystem}{The randomized subsystems does not allow} commands that are not properly randomized \updated{will not work}{to be executed}. For instance, if `\code{rm}' is randomized to `\code{\color{red}xc}' (\code{rm} $\mapsto$ \code{\color{red}xc}), the original command `\code{rm}' will result in an error (i.e., the command not found error) while `\code{\color{red}xc}' command will work as same as the original `\code{rm}.'
To ensure the \emph{intended benign commands} from applications work correctly with the randomization, we analyze target programs to identify and instrument the intended commands to be randomized. 
%Specifically, given a command found in a target program, if the definition of the command is originated from a trusted source (e.g., hardcoded commands or originated from trusted sources), we randomize it at runtime (Details in Section~\ref{subsec:instrumentation_comp}). 
To this end, legitimate commands are correctly randomized at runtime, while injected commands are not randomized and prevented from being executed.

\revised{
{\it 1) Revisiting Design Choices:}
To mitigate sophisticated attacks evading existing randomization based preventions~\cite{sqlrand, autorand}, we revisit the design choices made by existing techniques. 
%Specifically, we reduce the attack surface caused by the proxy and parser for randomization.
%
First, we eliminate the proxy and parser requirement for the shell process randomization by hooking APIs called before and after the shell process's original parser. 
%directly integrate the system into the shell process without using a proxy and parser for the shell process randomization.
%Specifically, we hook APIs that are called before and after the shell process's original parser. 
% of randomizing the command execution system from outside (e.g., via proxies),
%Second, for SQL engines that there are difficult to blend our technique in, we implement a proxy by hooking APIs that execute SQL queries (e.g., \code{mysql\_query()}), similar to the existing techniques~\cite{sqlrand-llvm,autorand}. 
%However, we overcome the critical weakness of the existing technique, leveraging parsers. Instead, we develop dual randomization scheme (Details in Section~\ref{subsubsec:database_random}) to prevent sophisticated attacks that exploit bugs or flaws of parsers to sneak malicious SQL queries. 
Second, for SQL engines that are difficult to blend our technique in, we develop a \emph{bidirectional randomization} scheme \updated{}{based on a scanner} (Details in Section~\ref{subsubsec:database_random}) to prevent sophisticated attacks (e.g., those exploiting bugs/flaws of parsers). % to sneak malicious SQL queries. 
Third, \updated{our technique}{\sysname} changes the randomization scheme at runtime so that even if an attacker learns a previously used randomization key and \updated{uses it to inject}{injects} a randomized command, the attack will fail.
}

%execute commands (e.g., \code{system()} and \code{mysql\_query()}) to randomize command names and SQL keywords without relying on parsers. 
%Specifically, 
%For applications (i.e., database engines) that we have to randomize from the outside, we leverage a scanner-based dual randomization technique, instead of using parser-based techniques that are vulnerable (Details in Section~\ref{subsubsec:database_random}). 
%Our technique is grammar and keyword agnostic. %preventing sophisticated attacks that existing techniques fail to handle.


%\sysname automatically randomizes the specification of commands by instrumenting the intended commands to be randomized in a target program. %, ensuring the correct execution of the intended commands. 
{\it 2) \updated{Practical and Generic}{} Program Analysis Approaches for \updated{Command}{Input} Randomization:}
We propose practical program analysis techniques that can effectively analyze large and complex programs for \updated{command}{input} randomization. 
In particular, we show that our approach, bidirectional data flow analysis (Section~\ref{subsubsec:composition}), is scalable to real-world applications including WordPress~\cite{wordpress}.
\updated{Our algorithm is also generic. We implement \sysname in multiple languages (including C/C++, PHP, JavaScript, and Lua).}{}
\updated{Our experiments show that \sysname effectively prevents all the attacks we tested with low overhead, 3.74\% for 32 real-world programs.}{}
%\vspace{-1em}
Our contributions are summarized as follows:

\vspace{-0.5em}
\begin{itemize}[leftmargin=*]
    %\setlength\itemsep{-0.5em}
    \item We propose an approach that can prevent various types of \updated{command}{input} injection attacks by randomizing \updated{how applications access the command targets (e.g., via command names, binary file paths, and SQL statements)}{the subsystems that run or process the inputs}\updated{ (e.g., shell commands or SQL queries)}{}.
    
    \item We design and develop \updated{a}{an effective} static data flow analysis technique \updated{}{called bidirectional analysis} that can identify intended commands in complex real-world applications. 
    \updated{We combine forward and backward data flow analyses to identify command compositions and prevent encoded commands from being used in non-command execution APIs.}{} 
    
    \item  We implement a prototype of \sysname in diverse programming languages, including C/C++, PHP, JavaScript and Lua. % to prevent three types of \updated{command}{input} injection attacks. 
    
    \item Our evaluation results show that it prevents 27 \updated{command}{input} injection attacks with low overhead (\updated{3.64}{$\approx$5}\%).
    
    \item  We release our implementation and data-sets publicly~\cite{csr-tool}.
    
\end{itemize}

