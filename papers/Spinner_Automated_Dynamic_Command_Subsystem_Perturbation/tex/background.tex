
\section{Definitions and Backgrounds}
\label{sec:background}

\begin{figure*}[htp]
    \centering
    \includegraphics[width=1.0\textwidth]{fig/moti_example}
    \vspace{-2em}
     \caption{Example of \sysname Preventing a Command Injection Attack}
     \vspace{-1em}
     \label{fig:moti_example}
\end{figure*}

%\autoref{fig:softwarestack} shows a typical workflow of an application that receives inputs and executes commands (e.g., shell commands or SQL queries). 
%Specifically, a program (\blkcc{2}) receives inputs from untrusted sources (\blkcc{1}) such as a remote network.

\noindent
{\bf Scope of \updated{Command}{Inputs for Randomization}.}
We consider three types of \updated{commands}{inputs to randomize}: OS/shell commands, SQL queries, and XML queries.
This is because they are commonly exploited in web server applications that \sysname aims to protect, according to the OWASP Top 10 document~\cite{owasp_top_ten}. % (i.e., OS/shell commands and SQL queries are mentioned in A1. XXE attacks is mentioned in A4).
Those inputs are used by a program to leverage external programs' functionalities. For example, a program can compress files by executing a shell command that executes `\code{gzip}'. 
SQL queries are \updated{commands to use the}{for} SQL engines to store and retrieve values to/from the database. An XML query is an interface for interacting with XML entities (e.g., reading and writing values in the entities).


\revised{
\noindent
\textbf{Choice of Term `Command.'}
\sysname focuses on preventing three different input injection attacks: shell injection, SQL injection, and XXE injection attacks.
In this paper, we use the term \emph{command} to include the three input types to facilitate the discussion. We consider SQL queries and XXE entities \emph{commands} as they eventually make the subsystem run or execute particular code.

\noindent
{\bf Command Execution APIs.}
We define a term \emph{Command Execution API} to describe APIs that execute a command or a query.
%Typically, it takes a string argument that holds a command \updated{}{or SQL query} that is composed by concatenating \updated{command names and options}{strings originated from various sources including remote users, constants, and configuration files}\updated{ in various ways}{}.
%It then calls APIs that execute commands, which we call \emph{Command Execution APIs}, with the composed commands as arguments.
%\code{system()} and \code{mysql\_query()} are examples and % for shell commands and SQL queries respectively. 
A list of command execution APIs is shown in Table~\ref{table:sinkfunctions}.


\noindent
{\bf Command Specification.}
A command passed to a command execution API should follow a certain specification. Specifically, shell commands should use correct command names or external executable binary file names. SQL queries should follow the predefined SQL keywords and grammar. 
If a command does not follow the specification (e.g., a wrong file name), its execution will fail.


\noindent
{\bf \updated{Command}{Input} Injection Vulnerability.}
\updated{Command}{Input} injection happens when an attacker injects malicious \updated{commands}{inputs} to the composed command string \updated{}{or SQL query string} passed to a command execution API as an argument.
In practice, programs may try to validate and sanitize suspicious inputs that might contain malicious \updated{commands}{inputs}.  % find some command injection attacks that bypasses.
% https://support.portswigger.net/customer/portal/articles/2590739-sql-injection-bypassing-common-filters-
%https://medium.com/@hninja049/command-injection-bypass-cheatsheet-4414e1c22c99
Typically, when a program composes a command, the command name (e.g., `\code{gzip}') is defined as a constant string or loaded from configuration files that are not accessible to attackers (hence can be trusted).
%and arguments are defined as constant or loaded from trusted files (e.g., configuration files (\blkcc{3})).
However, some programs allow users to define arguments of the command. % (e.g., file or folder names of the \code{gzip} command). 
As a result, attackers aim to inject malicious commands through the arguments.
After a command is composed, the program calls command execution APIs  (e.g., {\tt exec()}, {\tt system()}, or {\tt mysql\_query()}) to fulfill the command execution.
}

\noindent
{\bf Limitations of Existing Randomization Techniques.}
%The idea of randomizing input specification to prevent injection attacks is not new. 
There are existing techniques~\cite{sqlrand, autorand, isr2} that randomize the keywords and grammars.
% using \textit{parsers}. 
%
% this is wrong suggestion. Not 'ly': previous\hl{ly}
While we share the similar idea to them, our work differs from them as we aim to solve the following three limitations.

First, existing techniques leverage parsers to randomize/derandomize commands. Unfortunately, attackers often exploit bugs or design flaws in parsers to evade the prevention techniques that rely on them.
%Without a perfect parser, the existing techniques may fail to prevent advanced command injection attacks.
In particular, the parsers may not handle complicated benign inputs (e.g., because of the use of SQL dialects~\cite{sql_dialect}), breaking benign functionalities or allowing injection attacks. We elaborate details of such weaknesses of existing techniques in Section~\ref{subsubsec:advanced_sql_injection}. 
\vspace{-0.3em}
\hlbox{\sysname handles this by integrating our randomization scheme to the internal parser in the shell process and leveraging our bidirectional randomization scheme for SQL engines. The bidirectional randomization is grammar and keywords agnostic, meaning that attacks exploiting flaws of parsers will be prevented.
}%\sysname handles this limitation by cooperating existing parsers in OS/shell process

Second, existing automated approaches~\cite{autorand,sqlrand-llvm} leverage static analysis techniques to identify intended (i.e., benign) commands in the source code. We find that their static analysis techniques are not scalable to complex real-world applications. %The existing techniques may break the benign functionalities as they were not able to identify and randomize benign commands.
\vspace{-0.3em}
\hlbox{We propose a practical and scalable bi-directional data flow analysis (Details in Section~\ref{subsubsec:composition}) that can effectively identify benign commands in complex real-world applications.
}
Third, existing techniques randomize the command specification statically, meaning that the commands are randomized only once. If an attacker learns the randomization scheme (e.g., via information leak vulnerabilities), the attacker can inject randomized commands which will not be prevented.
%Attackers may leverage information leak vulnerabilities to obtain the randomized commands or observe output (i.e., error messages) that contains parts of randomized commands to infer the randomization key.
\vspace{-0.3em}
\hlbox{\sysname dynamically randomizes the command specification whenever a command execution API is called. To this end, even if an attacker learns a previously used randomization key, it will not help subsequent attacks.
}
% may learn the randomization scheme by sending  
%with a separate proxy for randomization/derandomization can be evaded by attacks that inject malicious commands 
%\sysname uses a SQL grammar agnostic scanner that is less fragile than a parser. %Moreover, \sysname's SQL randomization does not require to know a list of SQL keywords.

%\sysname prevents sophisticated command injection attacks (in Appendix~\ref{appendix:sqlrand-llvm}) by (1) directly hooking and randomizing the shell process and (2) leveraging the SQL agnostic dual randomization scheme (Section~\ref{subsubsec:database_random}). 
%As a result, \sysname is more robust in preventing sophisticated attacks.

%To this end, existing techniques implement proxies to implement the randomization scheme. More importantly, they leverage \emph{parsers} to pick keywords to randomize and derandomize. 
%Unfortunately, we find that those parsers are the weakest link that can be exploited by attackers. 
%Specifically, if an attacker provides a malicious input that cannot be properly handled by proxies (and their parsers), the attack can be successful. 

%\vspace{-0.5em}
\noindent
{\bf Threat Model.}
\sysname aims to prevent remote \updated{command}{input} injection attacks (including SQL/XXE injections) on server-side applications. 
We expect server-admins and web-developers as typical users of \sysname.
Client-side attacks such as XSS (Cross Site Scripting) and XSRF (Cross Site Request Forgery) are out of the scope.
%
We assume the subject program and inputs from trusted sources (defined by the user) are benign, but inputs from untrusted sources can include malicious commands. Typical trusted sources are local configuration files. 
%\sysname requires a target program that has intended commands originated from trusted sources. If a program allows an untrusted input to be executed directly, applying \sysname will simply prevent the functionality completely because there are no commands that can be trusted. For example, \sysname cannot be applied to a webshell (e.g., \code{system(\$\_GET[...])}) as it will prevent the \code{system()} completely.
We trust local software stacks, including OS kernel, applications, and libraries. If they are compromised, attackers can disable \sysname.
%
%This paper focuses on preventing remote command injection attacks. 
\sysname does not focus on preventing attacks that compromise non-command parts such as arguments of commands (e.g., a directory traversal attack).
\sysname does not aim to prevent \updated{}{binary} code injection\updated{attacks }{} (e.g., shellcode injection). \updated{There are existing randomization based techniques preventing code injection attacks~\cite{conf_ndss17_a2c,isr} and \sysname is specialized in preventing command injection attacks}{}
