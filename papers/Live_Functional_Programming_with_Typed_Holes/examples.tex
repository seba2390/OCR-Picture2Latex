% !TEX root = hazelnut-dynamics.tex
\newcommand{\examplesSec}{Live Programming in Hazel}
\section{\examplesSec} 
\label{sec:examples}

\input{fig-grades-example}


\newcommand{\overviewExample}[2]{\paragraph{Example {#1}: {#2}}}

Let us start with an example-driven overview of this paper's approach in \Hazel, a live programming environment being developed by \citet{HazelnutSNAPL}. The \Hazel user interface is based roughly on IPython/Jupyter \cite{PER-GRA:2007}, with a result appearing below each cell that contains an expression, and the \Hazel language is tracking toward feature parity with \Elm~(\url{elm-lang.org}) \cite{czaplicki2012elm,Elm}, a popular pure functional programming language similar to ``core ML'', with which we assume familiarity. \Hazel is intended initially for use by students and instructors in introductory functional programming courses (where \Elm~ has been successful \cite{DBLP:journals/corr/abs-1805-05125,zhang2018graphics}). 

For the sake of 
exposition, we have post-processed the screenshots in this section after generating them in \Hazel to make use of  ``syntactic and semantic sugar'' from \Elm~that was not available in \Hazel (which, as of this writing, implements little more than the language features described in Sec.~\ref{sec:calculus} and \ifarxiv Appendix \ref{sec:extensions}\else the appendix\fi). These conveniences are orthogonal to the contributions of this paper; all of the user interface features demonstrated in this section have been implemented and all of the computations can be expressed using standard ``encoding tricks''.

\input{examples-1}
\input{examples-2}
\input{examples-3}
\input{examples-4}


% \paragraph{Recap}
% %
% In the above four subsections, respectively, we considered programs with:
% %
% (1) empty expression holes,
% %
% (2) non-empty expression holes for ill-typed expressions,
% %
% (3) type holes, and
% %
% (4) non-empty expression holes for well-typed expressions.
% %
% Next, we will formally describe the novel dynamic semantics of \HazelnutLive{}
% that allows programs with combinations of these kinds of incompleteness to be
% evaluated.
