% !TEX root = hazelnut-dynamics.tex

\begin{abstract}
Live programming environments aim to provide programmers (and sometimes audiences) 
with continuous feedback about a program's dynamic behavior as it is being edited. 
The problem is that programming languages typically assign dynamic meaning only 
to programs that are \emph{complete}, i.e. syntactically well-formed and free
of type errors. Consequently,    
live feedback presented to the programmer exhibits temporal or perceptive gaps. 

This paper confronts this ``{gap problem}'' from type-theoretic first principles by developing 
\emph{a dynamic semantics for incomplete functional programs}, 
starting from the static semantics for incomplete functional programs developed in recent work on \Hazelnut. 
We model incomplete functional programs as expressions with \emph{holes}, 
with empty holes standing for missing expressions or types, and  non-empty holes 
operating as membranes around static and dynamic type inconsistencies. 
Rather than aborting when evaluation encounters any of these holes as in
some existing systems, evaluation proceeds around holes,
tracking the 
closure around each hole instance as it flows through the remainder of the program. Editor services can use the information in these hole closures 
to help the programmer develop and confirm their mental model of the behavior of the complete portions of the program as they decide how to fill the remaining holes. 
Hole closures also enable a \emph{fill-and-resume} operation that 
avoids the need to restart evaluation after edits that amount to hole filling. 
Formally, the semantics borrows machinery from both gradual type theory (which supplies the basis for handling unfilled 
type holes) and contextual modal type theory (which supplies a
logical basis for hole closures), combining these and developing additional machinery necessary 
to continue evaluation past holes while maintaining type safety. We have mechanized the metatheory of the core calculus, called \HazelnutLive{}, using the Agda proof assistant.

We have also implemented these ideas into the \Hazel programming environment. The implementation inserts holes automatically, following the \Hazelnut edit action calculus, to guarantee that every editor state has some (possibly incomplete)
type.
Taken together with this paper's type safety property, the 
result is  
a proof-of-concept live programming environment where rich dynamic feedback 
is truly available without gaps, i.e. for every reachable editor state.

%In our system, evaluation treats failed casts much like it treats expression holes (rather than immediately failing with a cast error, as in gradual type theory). Prior work on contextual modal type theory did not develop an operational semantics for programs with free metavariables, which correspond to programs with holes in our formulation. 


% These incomplete edit states are sometimes transient, but at other times, they persist for extended periods of time, e.g. when the programmer is filling in the branches of a large case analysis one-by-one, or when an edit causes type errors to appear throughout a program. %This gap can cause live programming services to lag behind the programmer's edits, in many cases for an extended period of time.
\end{abstract}
