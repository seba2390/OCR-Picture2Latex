\documentclass[10pt,conference]{IEEEtran}

\usepackage{graphicx}
\usepackage{xcolor,soul}

\definecolor{codeColor}{RGB}{139,26,26}

% Define your commands here
\newcommand{\ali}[1]{\textcolor{blue}{{\it Ali:#1}}}
\newcommand{\shantanu}[1]{\textcolor{red}{{ \it Shantanu:#1}}}

% \newcommand{\ali}[1]{\textcolor{blue}{}}
% \newcommand{\shantanu}[1]{\textcolor{red}{}}


\newcommand{\code}[1]{\textcolor{codeColor}{\textsf{#1}}}
\newcommand{\concept}[1]{\textbf{\textsf{#1}}}
\newcommand{\figref}[1]{Figure~\ref{#1}}
\newcommand{\secref}[1]{Section~\ref{#1}}
\newcommand{\listref}[1]{Listing~\ref{#1}}
\newcommand{\equationref}[1]{Equation~\eqref{#1}}
\newcommand{\tableref}[1]{Table~\ref{#1}}

\renewcommand{\hl}[1]{#1}

\newcommand{\citeme}[1]{%
  \begingroup
  \definecolor{hlcolor}{RGB}{255, 226, 176}\sethlcolor{hlcolor}%
  [\textcolor{orange}{\hl{\textbf{CITE}}}]%
  \endgroup
}

\newcommand{\subsubsubsection}[1]{\paragraph{\textbf{\textit{#1:}}}}
\usepackage{tikz}

\newcommand*\squared[1]{\tikz[baseline=(char.base)]{
% \node[shape=circle,draw,inner sep=0.8pt] (char) {#1};}}
\node[shape=rectangle,font=\bfseries,thin,draw=black,fill=yellow,text=black,inner sep=1pt] (char) {#1};}}


\graphicspath{{figures/}}

%----------------
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{CONSTRUCT: A Program Synthesis Approach for Reconstructing Control Algorithms from Embedded System Binaries in Cyber-Physical Systems}

% \title{Reconstructing Control Algorithms from Embedded System Binaries in Industrial Cyber-Physical Systems}


\author{\IEEEauthorblockN{
Ali Shokri\IEEEauthorrefmark{1},
Alexandre Perez\IEEEauthorrefmark{2},
Souma Chowdhury\IEEEauthorrefmark{3}, 
Chen Zeng\IEEEauthorrefmark{3}, 
Gerald Kaloor\IEEEauthorrefmark{2},
Ion Matei\IEEEauthorrefmark{2}, \\
Peter-Patel Schneider\IEEEauthorrefmark{2}, 
Akshith Gunasekaran\IEEEauthorrefmark{2}, and
Shantanu Rane\IEEEauthorrefmark{2}}
\IEEEauthorblockA{\IEEEauthorrefmark{1}Rochester Institute of Technology, NY, USA, as8308@rit.edu}
\IEEEauthorblockA{\IEEEauthorrefmark{2}Palo Alto Research Center (PARC), CA, USA, \{aperez, imatei, pfps, agunasekar, srane\}@parc.com}
\IEEEauthorblockA{\IEEEauthorrefmark{3} University at Buffalo, NY, USA, \{soumacho, czeng2, geraldka\}@buffalo.edu}
}


\maketitle

\begin{abstract}
%Cyber-physical systems (CPS) are composed of physical and computational components integrated and controlled by computer-based algorithms implemented as a controller software, and are vastly used in industrial mission- and safety-critical systems. Due to catastrophic consequences of failure of these systems, it is crucial to obtain a clear understanding of the behavior of the controller software and ensure its safety and reliability before deployment. Current approaches for supporting such investigations require decompilation of binary code of controller software, review of the decompiled code by skilled programmers, and manually creating a high-level representation of the underlying control algorithms that are understandable by subject matter experts. This is a time-consuming and error-prone task.
%To address this challenge, 
We introduce a novel approach to automatically synthesize a mathematical representation of the control algorithms implemented in industrial cyber-physical systems (CPS), given the embedded system binary. The output model can be used by subject matter experts to assess the system's compliance with the expected behavior and for a variety of forensic applications. Our approach first performs static analysis on decompiled binary files of the controller to create a sketch of the mathematical representation. Then, we perform an evolutionary-based search to find the correct semantic for the created representation, i.e., the control law. We demonstrate the effectiveness of the introduced approach in practice via three case studies conducted on two real-life industrial CPS. 

\end{abstract}

\begin{IEEEkeywords}
Program Synthesis, Cyber-physical Systems, Mathematical Representation, Genetic Algorithm
\end{IEEEkeywords}


\begin{figure*}[h]
  \centering
  \includegraphics[width=.97\textwidth]{figures/new_construct.pdf}
    \vspace{-6pt}

  \caption{An overview of the \textsc{CONSTRUCT} approach.}
  \label{fig:CONSTRUCT}
          \vspace{-6pt}
\end{figure*}

\section{Background and the Problem}
\label{sec:Introduction}

Cyber-physical systems (CPS) consist of heterogeneous physical and computational components which combine to enable critical functionalities, e.g., providing energy to a city or flying an autonomous plane for delivering packages \cite{barrere2021analysing}. A key part of a CPS is the embedded software that implements the control algorithms and is in form of binaries.
%prescribed by the system designer. 
For forensic investigations, especially in mission- and safety-critical industrial domains (e.g., military, energy, medical, transportation, and agriculture), it is crucial to reverse-engineer these algorithms as representation models to better understand their behavior and thus, investigate cause of failure in industrial accidents, detect counterfeit products or even infringement of intellectual property. % \citeme{}. 
%
%that are embedded in the system as binaries. Such investigations have numerous applications such as determining cause of failure in industrial accidents, detecting counterfeit products, and infringement of intellectual property \citeme{}. 
%
%In this paper, given the embedded binaries, we are concerned with automatic recovery of the control algorithm and generating its representation as a model that is understandable by subject matter experts to support their investigations.
%
%CPS designers use different modeling languages and tools (e.g., Modelica \cite{fritzson1998modelica} and OpenModelica~\cite{fritzson2006openmodelica}) to design the system and perform simulations. They then export the designed model as a standardized portable container called a \textit{Functional Mockup Unit (FMU)}~\cite{blochwitz2011functional} which is transportable between different tools. An FMU contains binary files (e.g., compiled C files) that implement the functionality of the CPS (e.g., the controller part), alongside text-based description files that introduce the inputs, outputs, and other variables used in the binary files. 
%
%In industrial settings, users of CPS might only have access to the FMU rather than the actual source code of the controller component. The unavailability of the source code, combined with the loss of human expertise in reading decompiled (and obfuscated) binaries can prevent subject matter experts to gain a clear and accurate understanding of the system's behavior to better assess the safety and reliability of the system before deployment. 
%This understanding is particularly important in mission- and safety-critical industrial domains such as military, energy, medical, transportation, and agriculture~\cite{serpanos2018cyber}.
%and prevent any damaging threats in the run-time (e.g., the system is malicious or weaponized). 
%
%Nevertheless, in addition to subject matter experts' unfamiliarity with low-level programming languages (e.g., C programming language), due to binary decompilation, the only available source code would be obfuscated and thus, not easily comprehensible. 
%Therefore, it is necessary to support subject matter experts with automatic approaches that can derive an accurate and interpretable model that represents the functionality of the underlying code given the CPS controller software binary~\cite{shbita2022automated}. 
%For instance, this functionality could be a widely used proportional–integral–derivative (PID) controller~\citeme{} that is a control loop mechanism leveraging feedback.     
%
%
The current techniques for construction of such representations heavily rely on intelligent experts (e.g., professional programmers) to manually review the decompiled binaries and create an abstraction of the software understandable by the code inspectors \cite{lyu2019safety}. This is a non-trivial, time-consuming, and error-prone task. 

%There have been attempts to create aforementioned representations of the code, however, these techniques still rely on intelligent experts (e.g., professional programmers) to manually review the decompiled binaries and create an abstraction of the software understandable by the code inspectors \citeme{}. This is a non-trivial, time-consuming, and error-prone task. 
%In addition, the controller part of a CPS in the FMU is mostly in form of a binary file. Hence, intelligent experts need to de-compile the binaries to be able to manually review the code. However, through the de-compilation process, the generated source code will be obfuscated, meaning that variable names, method names, and even in some cases class names are changed to meaningless and strange names which makes it dramatically hard to follow and understand the code.

To address these challenges, we introduce a novel approach for automatically synthesizing a mathematical representation of the controller software in a CPS. This representation enables subject matter experts to easily analyze the behavior, identify deviations from expected behavior, and avoid damaging threats.
%(e.g., malicious or weaponized software controller)
The synthesized representation follows the syntax and semantic of Modelica modeling language~\cite{fritzson1998modelica}, which is widely used in industry and is easily understandable by subject matter experts. 
%\vspace{-15pt}
%
\section{Approach}
\label{sec:Construct}
Figure~\ref{fig:CONSTRUCT} shows an overview of our approach, called \textbf{\underline{C}ode-based M\underline{o}del Sy\underline{n}thesi\underline{s} Pla\underline{t}form fo\underline{r} re-Constr\underline{u}cting \underline{C}ontrol Algori\underline{t}hms} \textsc{\textbf{(CONSTRUCT)}}, which automatically constructs mathematical representations of controller algorithms from CPS binaries. The input to \textsc{CONSTRUCT} is a Functional Mock-up Unit (FMU) which is a file produced by CPS designers and contains the controller binaries as well as a textual description about the controller's I/O variables. The output of \textsc{CONSTRUCT} is a mathematical representation of the controller of CPS in Modelica language. The main idea is to decompile the given binary, locate controller-related instructions in the decompiled code, construct the \textbf{structure} of the mathematical representation, and finally, add the \textbf{semantic} to the created structure. Below, we provide more details on each step.
% The main idea is to (1) extract the \textbf{structure} of the mathematical representation by translating the symbolic abstract syntax trees (ASTs) of decompiled C binary codes to symbolic ASTs in Modelica language, (2) leverage an evolutionary search technique (e.g., GA) to find the correct variable names for each symbolic name in Modelica AST and add the \textbf{semantic} to the created structure. Below, we provide more details on each step.

    \squared{1} \textbf{Decompile Binaries:} From description files in the FMU, \textsc{CONSTRUCT} identifies variable names and their attributes (e.g., type and initial value) that should be used in the mathematical model. It also decompiles the binary files inside the FMU using the popular Ghidra decompiler. The decompiled code contains symbolic (not actual) variable names. 
    
    \squared{2} \textbf{Isolate Mathematical Primitives:} CONSTRUCT performs static program analysis and localizes the mathematical primitives that are used in controller parts of the CPS. Some mathematical primitives differ in the decompiled version of the code compared to the original source code. CONSTRUCT incorporates a rule-based engine that is able to identify these complicated mathematical primitives in the decompiled code. 
    
    \squared{3} \textbf{Code-level AST to Model-level AST:} Next, CONSTRUCT creates ASTs of the isolated mathematical primitives in the decompiled binaries (C files) and translates them into algebraic equations in form of Modelica ASTs. Note that due to the decompilation of the binaries, the translated ASTs contain symbolic names, not the actual variable names used in the original source code of the controller.  %Therefore, we need to find the correct mapping between symbolic names and the actual variable names collected through the first step.
    
    \squared{4} \textbf{Modelica Model Synthesis:} \textsc{CONSTRUCT} uses Genetic Algorithm (GA) as an evolutionary search method to find the correct mapping between the symbolic names in the Modelica AST and the original I/O variable names retrieved from the description file inside the FMU. In this setting, the $i$th gene in a chromosome represents an I/O variable name that should be assigned to the $i$th symbol in the created Modelica AST. The baseline GA approach stochastically manipulates chromosomes and then tests whether the altered chromosome results in a syntactically and semantically correct Modelica AST (i.e., \textit{correct-by-testing (CbT)}). In contrast, we follow a \textbf{correct-by-construction (CbC)} paradigm where we carefully design GA operators (i.e., first population generation, mutation, and cross-over) such that every generated chromosome complies with Modelica syntax and semantic. This not only prunes the search space and reduces the number of trial and errors (and hence, makes the approach scalable), it also results in significantly more accurate mathematical representations. 
    % Moreover, it tremendously makes the approach scalable to the industrial level representations where there could be hundreds of equations and variables. 
    To find the error of the generated mathematical representation, we provide the same time series input to the given binary as well as the synthesized mathematical model, find their output distance, and compute the mean squared error (MSE).
    %For instance, if the type of variable $v_1$ is \textit{Real} but the type of symbol $s_1$ is \textit{Boolean}, then, our CbC approach does not consider mapping $v_1$ to $s_1$. In contrast, a baseline GA approach, which we refer to as \textit{correct-by-testing (CbT)}, does not take these constraints into account and might generate faulty solutions that result in crashes while simulating the synthesized model. To test the goodness of the most recent mutation, we compare the time series output by the embedded system against that output by our model using the most recent symbol-to-variable mapping, when excited by the same input.
    %The case study result (section~\ref{sec:PreliminaryResult}) shows how our CbC approach dramatically improves the quality of the solutions generated by GA in comparison with the base-line \textit{CbT} approach.
    %\ali{Scalability and generalizability of the approach.} \ali{How we measure the output of the GA to make sure it is correct.} \shantanu{I added a sentence about this above.}
 
\section{Evaluation}
\label{sec:PreliminaryResult}
To showcase the performance of our approach, we present the results of our experimental studies on synthesizing mathematical representations from binaries of three different built-in controllers shipped with Modelica, namely, \textit{PI}, \textit{PID}, and \textit{LimPID}, that are used in two real-world industrial CPS: (1) a \textit{Turtlebot Waffle Pi} which is a four-wheeled robot used in ground-mission applications, e.g., surfing the area and building maps, and (2) a \textit{PX4 Quadcopter} which is an autonomous flying robot used in different industrial applications, e.g., package deliveries. The computational complexity of the embedded controllers (and thus, their to-be-synthesized mathematical representations) increases from PI controller where it has only proportional (P) and integral (I) blocks, to PID where there are proportional (P), integral (I), and derivative (D) blocks, and finally, LimPID where it has more complexity compared to the two previous controllers, e.g., has multiple inputs.
In our experiments, the population size for the GA was considered 400 and the maximum number of generations was 10.
%,i.e., the synthesized mathematical representation for the PI controller consists of 8 equations, 18 variables, and 23 symbols. For the PID controller, these numbers are 6 equations, 37 variables, and 20 symbols, and for the LimPID controller, they are 13 equations, 80 variables, and 39 symbols. Furthermore, all variables and symbols in PI are of type Real, whilst the variables and symbols in PID and LimPID are of different types. This makes finding the correct mapping much harder in the latter two cases. In our experiments, the population size for the GA was considered 400 and the maximum number of generations was 10.
%
\begin{figure}[ht]
  \centering
  \includegraphics[width=.47\textwidth]{Case_Study_4.pdf}
  \caption{The result of synthesizing mathematical models based on the CbT (baseline) versus our CbC approach.}
  \label{fig:correct_by_construct_result}
\end{figure}
%
 Figure~\ref{fig:correct_by_construct_result} summarizes the results of our comparison study for our CbC approach against the baseline CbT approach. In this figure, X-axis denotes the generation number when we run the GA for finding the correct symbol to variable name mapping. Moreover, the Y-axis shows the MSE calculated based on the distance between the outputs of each of CbT and CbC approaches and the output of the actual binary, given the same input. 
 Even in the simplest controller (PI), our CbC approach is able to find more accurate mathematical representations compared to the baseline (CbT) approach. Interestingly, while in complex cases (PID and LimPID) the CbT approach is not able to generate even one representation that complies with Modelica language, not only our CbC approach can generate models that comply with Modelica syntax and semantic, but also the synthesized representations have relatively low error rates. The results show that the CbC approach outperforms the commonly used baseline approach, is able to generate accurate results to support subject matter experts in their investigations in industrial cases that the baseline CbT does not work, and is scalable to more complex controllers. 
 %Even in the simplest controller (Case 1), where all the variables and symbols are of the same type (i.e., Real), our CbC approach is able to find better mathematical representations compared to the base-line (CbT) approach. Interestingly, while in complex cases (Cases 2 and 3) the CbT approach is not able to generate even one single representation runnable by the simulator, our CbC approach can generate simulatable models that comply with Modelica syntax and semantic, and also have relatively good fitness scores. \ali{The lesson learned: The synthesis approach and CbC lead to tremendously better results.} \ali{How the results are compared to the other approaches (not just the baseline)?} \ali{How did the results help SEMs?} \ali{How scalable is the results in these experiments to the applications in industry?}


\section{Conclusion and Future Work}
\label{sec:Conclusion}
In this paper, we introduced CONSTRUCT, a novel program synthesis approach that automatically creates mathematical representations of control algorithms in cyber-physical systems. This approach leverages a genetic algorithm for injecting the semantics into the created representation. In future work, we are interested in evaluating the utility of constraint-based solvers, such as SMT solvers, for making the model synthesis more efficient.

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
