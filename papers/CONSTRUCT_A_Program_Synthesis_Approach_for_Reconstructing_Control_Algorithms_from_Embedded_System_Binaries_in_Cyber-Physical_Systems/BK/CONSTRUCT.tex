\section{CONSTRUCT}
\label{sec:Construct}
To address the mentioned challenges in understanding the behavior of cyber-physical systems, in this paper, we introduce our novel \textbf{Code-based MOdel SyNthesiS PlaTform foR re-ConstrUcting Control AlgoriThms} \textsc{\textbf{(CONSTRUCT)}} which automatically constructs mathematical representations of controller parts of cyber-physical systems. Figure~\ref{fig:CONSTRUCT} shows an overview of this approach. 
In summary, \textsc{CONSTRUCT} takes-in an FMU file which contains binaries and some descriptions about the cyber-physical model. 
The main idea is to create the structure of the mathematical model from the decompiled codes through AST translation, and then find the correct mappings between symbolic names and the actual variable names by leveraging an evolutionary search technique, Genetic Algorithm.
From the description files inside the FMU, \textsc{CONSTRUCT} identifies the variable names that should be used in the final mathematical model and some attributes of those variables. Then, it decompiles the binary files inside the FMU and localizes the mathematical primitives that are commonly used in controller parts of Cyber-physical systems. Next, it creates the AST of the decompiled sources and translates sub-ASTs that correspond to mathematical primitives to mathematical-formed ASTs. Note that through the decompilation process, the original variable names will be replaced with non-real symbolic names. We use Genetic Algorithm as an evolutionary search-based approach to find a correct mapping between the generated symbolic names of variables in the created mathematical representation and the original variable names retrieved from the description file inside the FMU. The output of \textsc{CONSTRUCT} is a mathematical representation that complies with syntax and semantic of Modelica modeling language. The Modelica language is vastly used for mathematical modeling purposes and provides opportunity for simulating mathematical models. 
We provide details on each step of \textsc{CONSTRUCT} as follows.

\begin{figure}[ht]
  \centering
  \includegraphics[width=.25\textwidth]{figures/CONSTRUCT_new.pdf}
  \caption{An overview of the \textsc{CONSTRUCT} approach.}
  \label{fig:CONSTRUCT}
\end{figure}

\subsection{Step 1: Binary Decompilation}
\ali{To be added by Shantanu/Peter.}

\subsection{Step 2: Mathematical Primitive Isolation \ali{Localization?}}
\ali{To be added by Shantanu/Peter.}

\subsection{Step 3: Transforming Code-level ASTs to Model-level ASTs}
\ali{To be added by Shantanu/Peter.}

\subsection{Step 4: Modelica Model Synthesis}
Since the original FMU is given as an input to \textsc{CONSTRUCT}, we can provide inputs to the FMU and receive its corresponding outputs. Although we have not a clear idea on the behavior of the FMU at this point, we can still rely on the binaries inside the FMU as an important source of information that we use while synthesizing the mathematical model. We basically use this FMU as an oracle to make sure that the synthesized mathematical model correctly represents the behavior of the cyber-physical system.
From the previous steps, we were able to create the structure of the mathematical representation, including equations and symbolic variable names. Moreover, from the description file of the FMU, we were able to collect the required information (e.g., name, type, etc.) on the variables that should be used in the equations. 

In this step, we aim to find a correct mapping between variable names and symbolic variables such that by providing the same input to the given FMU and the synthesized mathematical model, their output also be the same. Note that some of the variables in equations can be independent variables (e.g., they are not derivations of other variables), some might be derivations of the independent variables or other type of calculated variables, and the rest can be parameters i.e., constant values that their value remains unchanged regardless of the value of the input or output or other variables.

\subsubsection{Correct by Testing}
%\subsubsubsection{Problem Formulation}

In order to solve the mapping problem through genetic algorithm (GA), we need to first translate the original mapping problem as a GA problem, find a proper solution, and then, translate back the solution to a solution for the mapping problem. In a GA problem, one should represent possible solutions in the form of a \textit{chromosome}, which basically is a sequence of so-called \textit{genes}. Figure~\ref{fig:GA_Problem_Formulation} shows how we formulate our mapping problem as a GA problem.   

\begin{figure*}[h]
  \centering
  \includegraphics[width=.9\textwidth]{figures/GA_Problem_Formulation.pdf}
  \caption{The genetic algorithm problem formulation. }
  \label{fig:GA_Problem_Formulation}
\end{figure*}

\begin{itemize}
    \item \textbf{Solution representation:} 
 In our approach, we consider the length of a chromosome as the same as the number of symbolic variables that are present in the mathematical model, and each gene represents a variable number from the list of the variables that we extracted from the description file of the FMU (figure~\ref{fig:GA_Problem_Formulation}(a)). For instance, if the third gene in the chromosome equals number 5, it means that we assign the fifth variable in the variable list to the third symbol in the symbol list. Following this solution representation, even in the simple equation demonstrated in \secref{sec:Motivation} that has 3 equations, 12 symbols, and 13 variables, the number of possible solutions to explore is $12!$, around $480M$. Please note that upon finding a solution (i.e., a mapping between symbols and variables), one has to generate the equation, create an FMU based on the equation, and simulate the created FMU by providing inputs to receive its corresponding outputs. This process is a mandatory part of the approach to make sure about the correctness of the synthesized mathematical representation. Due to the mentioned over head in this process, it would not be feasible to explore all the possible solutions to find the best one. In fact, we use the power of GA to avoid such exploration.     
    
    \item \textbf{First population generation:} We randomly generate the first population, meaning that random numbers of variables will be assigned to random symbols (figure~\ref{fig:GA_Problem_Formulation}(b)). However, we make sure that no two genes in a chromosome have the same variable number. This ensures that each symbol will be assigned a unique variable in the synthesized mathematical representation. Moreover, at the end of this process, all the symbols will have one variable assigned to them. 

    \item \textbf{Mutation operation:}
    In order to mutate a chromosome, we randomly select two genes in the chromosome, and swap their value. Figure~\ref{fig:GA_Problem_Formulation}(c) demonstrates this process. 
    
    \item \textbf{Cross-over operation:}
    Given two chromosomes, we randomly select a crossing point and concatenate the first part of first parent to the second part of second parent, and also the first part of second parent to the second part of the first parent to create new children from the given two parents (figure~\ref{fig:GA_Problem_Formulation}(d)). \ali{Any guarantee on not appearance of a variable more than once in the children?}
    
    \item \textbf{Fitness:} In our approach, the fitness is a little bit different from the common sense of the fitness score which is the higher the fitness is, the better is the solution. In our case, the fitness is basically the distance between the output of the generated model with the output of the given FMU. Therefore, the lower the fitness is, we consider the found solution as more valuable. 

\end{itemize}

Following the explained approach, we expect to achieve better solutions (i.e., solutions with lower errors) through next generations. In other words, starting from the early generations, we might find symbol-variable mappings such that the output of their created FMUs have a considerable distance to the output of the given FMU. However, moving forward, we would like to see that the found mappings result in mathematical representations with lower distance between their output and the output of the original FMU. Finally, we would like to see that at some point, the output of the synthesized mathematical representation completely matches the output of the given FMU. However, as will explain further, this is not always the case.

\subsubsection{Correct by Construction}

In order to calculate the fitness of the generated chromosomes, we use the \textit{OpenModelica} to simulate the synthesized mathematical model and compare the output of the simulation against the simulation output of the reference FMU. To be simulatable, the synthesized mathematical model must follow certain syntax and semantic rules of \textit{Modelica} language . Otherwise, OpenModelica throws an exception and does not return an output. Nevertheless, during the individual (i.e., chromosome) generation by the baseline \textit{Correct by Testing} method, we observed that a considerable number of created mathematical representations do not comply with the expected syntax or semantic of Modelica language. In particular, we identified the following issues that can result in creation of non-simulatable mathematical representations. To mitigate these challenge, we followed the \textit{Correct by Construction} paradigm in which we make sure that all the operations in our GA approach generate simulatable solutions. 

\begin{itemize}
    \item \textit{Different types of variables:} We observed that it is quite possible that the symbolic, as well as actual variables in the equations might be from different types (e.g. Real, Boolean, or String). In such cases, we can not arbitrarily assign a variable to a symbol without considering the type compliance constraint. For example, whenever we find a symbolic statements such as the following, we infer that the type of the variable that will be assigned to $Symbol_2$ should be of type \textit{Boolean}:
    $Symbol_1 = if(Symbol_2) Symbol_3 else Symbol_4;$
    \item \textit{At least one independent variable per equation:} To be able to simulate the generated mathematical model, the OpenModelica requires all the equations to at least include one independent variable. Otherwise, the equation would be considered as too trivial and the simulation will not be carried out. 
    \item \textit{Equal number of the independent variables and the equations:} Another constraint that OpenModelica puts on the generated mathematical models is that the total number of independent variables used in the model should be equal to the number of the equations. Otherwise, the equation system would be considered as under- (in case that the number of variables is less than the number of equations) or over-estimation (in case that the number of variables is greater than the number of equations) and the simulation will not happen.
    \item \textit{Usage of I/O variables in the equations:} Another important constraint is that all the input and output variables should be used in the equations.  
\end{itemize}

By generating chromosomes that syntactically and semantically comply with Modelica language, we basically changed the paradigm of our synthesizer from \textbf{\textit{Correct-by-Testing}} to \textbf{\textit{Correct-by-Construct}}. In other words, instead of synthesizing models that we are not sure about their soundness, we changed our synthesis approach such that it only generates mathematical models that are \textbf{sound}, i.e., the model is simulatable by the simulator. 