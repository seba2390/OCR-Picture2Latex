
In this paper, we consider several new variants of the tiered vector. This section considers the theoretical
properties of these approaches. In particular we are interested in the number of memory accesses that are required for the different memory layouts, since this turns out to have an effect on the experimental running time.
In Section~\ref{sec:experimental} we analyze the actual impact in practice through experiments.

\subsection{Implicit Tiered Vectors}

As the degree of all nodes is always fixed at some constant value $w$ (it may be
changed for all nodes when the tree is rebuilt due to a full root), it is possible to layout the
offsets and elements such that no pointers are necessary to navigate the
tree. Simply number all nodes from left-to-right level-by-level starting in the
root with number 0. Using this numbering scheme, we can store all
offsets of the nodes in a single array and similarly all the elements of the leaves in another array.

To access an element, we only have to lookup the offset for each
node on the root-to-leaf path which requires $l-1$ memory probes plus the final
element lookup, i.e.\ in total $l$ which is half as many as
the original tiered vector.
 The downside with this representation is that it must allocate the
two arrays in their entirety at the point of initialization (or when rebuilding). This results in a $\Theta(n)$ space overhead which is worse than the $\Theta(n^{1-\epsilon})$ space overhead from the original tiered vector.

\begin{theorem} The implicit $l$-tiered vector solves the dynamic array problem for $l \geq 2$
using $O(n)$ extra space while supporting $\aaccess$ and $\aupdate$ in
$O(l)$ time requiring $l$ memory probes. The operations $\ainsert$ and
$\adelete$ take $O(2^l n^{1/l})$ time.
\label{thm:implicit}
\end{theorem}

\subsection{Lazy Tiered Vectors}

We now combine the original and the implicit representation, to get both few memory probes and little space overhead. Instead of having a single array storing all
the elements of the leaves, we store for each leaf a pointer to a location with an array containing the leaf's elements. The array is lazily allocated in memory when elements are actually inserted into it.

The total size of the offset-array and the element pointers in the leaves is $O(n^{1-\epsilon})$. At most two leaves are only partially full, therefore the
total space is now again reduced to $O(n^{1-\epsilon})$. To navigate a root-to-leaf path, we now need to look at $l - 1$ offsets, follow a pointer from a leaf to its array and access the element in the array, giving a total of $l + 1$
memory accesses.

\begin{theorem}
        The lazy $l$-tiered vector solves the dynamic array problem for $l \geq 2$ using
        $\Theta(n^{1-1/l})$ extra space while supporting $\aaccess$ and
        $\aupdate$ in $\Theta(l)$ time requiring $l+1$ memory probes. The
        operations $\ainsert$ and $\adelete$ take $O(2^l n^{1/l})$
        time.
\label{thm:lazy}
\end{theorem}

