We present a highly optimized implementation
of a data structure solving the \textit{dynamic array problem},
that is, maintain a sequence of elements subject to the following operations:

\begin{description}
    \item[$\quad\aaccess(i)$:] return the $i^{th}$ element
        in the sequence.
	\item[$\quad\aaccess(i, m)$:] return the $i^{th}$ through $(i+m-1)^{th}$
            elements in the sequence.
	\item[$\quad\ainsert(i, x)$:] insert element $x$ 
            immediately after the $i^{th}$ element.
	\item[$\quad\adelete(i)$:] remove the
            $i^{th}$ element from the sequence.
	\item[$\quad\aupdate(i, x)$:] exchange the $i^{th}$ element
            with $x$.
\end{description}
\noindent
This is a fundamental and well studied
data structure problem~\cite{Dietz:1989:OAL:645928.672529,
    Fredman:1989:CPC:73007.73040, Katajainen2001,
    Raman2001, Frederickson:1983:IDS:322358.322364,
    Brodnik:1999:RAO:645932.673194,
    Goodrich1999,Katajainen2016}
solved by textbook data structures like arrays and binary trees.
Many dynamic trees provide all the operations in
$O(\lg n)$ time including 2-3-4 trees, AVL trees, splay trees, etc.\
and Dietz~\cite{Dietz:1989:OAL:645928.672529} gives
a data structure that matches the lower bound
of $\Omega(\lg n/ \lg \lg n)$  showed by
Fredman and Saks~\cite{Fredman:1989:CPC:73007.73040}.
The lower bound only holds when identical complexities are required for all operations.
In this paper we focus on the variation where $\aaccess$ must run in $O(1)$ time.
Goodrich and Kloss present what they call \textit{tiered vectors}
\cite{Goodrich1999} with a time complexity of $O(1)$ 
for $\aaccess$ and $\aupdate$ and $O(n^{1/l})$ for $\ainsert$ and $\adelete$
for any constant integer $l \geq 2$, using ideas similar 
to Frederickson's in~\cite{Frederickson:1983:IDS:322358.322364}.
The data structure
uses only $o(n)$ extra space beyond that required to store the actual elements. 
At the core, the data structure is a tree with out degree
$n^{1/l}$ and \emph{constant} height $l - 1$.

Goodrich and Kloss compare the performance
of an implementation with $l = 2$ to that of
\textit{vector} from the standard library of Java
and show that the structure is competitive for
access operations while being significantly faster
for insertions and deletions.
Tiered vectors provide 
a performance trade-off between standard arrays and balanced binary trees
for the dynamic array problem.

\subparagraph{Our Contribution}

In this paper, we present what we believe is the first implementation of tiered vectors that supports more than 2 tiers. Our C++ implementation supports $\aaccess$ and $\aupdate$ in times that are competitive with the vector data structure from C++'s standard library while $\ainsert$ and $\adelete$ run more than $10.000\times$ faster. It performs $\aaccess$ and $\aupdate$ more than $40 \times$ faster than the multiset data structure from the standard library while $\ainsert$ and $\adelete$ is only a few percent slower. Furthermore multiset uses more than $10\times$ more space than our implementation. All of this when working on large sequences of $10^8$ 32-bit integers.

To obtain these results, we significantly decrease the number of memory probes per operation compared to the original tiered vector. Our best variant requires only half as many memory probes as the original tiered vector for $\aaccess$ and $\aupdate$ operations which is critical for the practical performance. Our implementation is cache efficient which makes all operations run fast in practice even on tiered vectors with several tiers.

We experimentally compare the different variants of tiered vectors. Besides the comparison to the two commonly used C++ data structures, vector and multiset, we compare the different variants of tiered vectors to find the best one. We show that the number of tiers have a significant impact on the performance which underlines the importance of tiered vectors supporting more than 2 tiers.

Our implementations are parameterized and thus support any number of tiers
$\geq 2$. We use techniques like \textit{template recursion} to keep the code rather
simple while enabling the compiler to generate highly optimized code.

The source code can be found at \url{https://github.com/mettienne/tiered-vector}.
