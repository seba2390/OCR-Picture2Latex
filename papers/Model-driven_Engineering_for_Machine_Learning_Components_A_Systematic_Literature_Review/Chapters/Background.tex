\section{Background and Related Work}~\label{sec:background}
%This section presents the background on MDE, ML, and MDE for systems with ML components. We further present the related work on the existing secondary and relevant studies.
\subsection{Model-driven Engineering}~\label{subsec:MDEBackground}
%The word \textit{model} originates from the Latin word \textit{modulus}, which means a measure, pattern, or example to follow~\cite{ludewig2003models}. 
%While modeling is relatively new to software engineering, it has been successfully applied for a long time in several traditional engineering domains~\cite{selic2012will,bucchiarone2020grand}. 
Model-driven Engineering (MDE) is a software development methodology that relies on models as the primary artifacts that drive the development process~\cite{ciccozzi2019execution, almonte2021recommender,hutchinson2011model}. This differs from traditional software development processes such as waterfall and agile, where the focus is on development phases like requirements engineering, design, and implementation, and models are only used as auxiliary artifacts to support these activities and serve as documentation~\cite{ciccozzi2019execution}. 
%In contrast to traditional software engineering using waterfall or agile methodology, where the focus is on the different phases of development, e.g., requirements engineering, design, implementation, and quality assurance, and the models are used to aid in requirements analysis or design, in MDE models are the primary artifact. 
The focus of MDE is on the continual refinement and transformation of models, beginning with computation-independent models (CIMs), to platform-independent models (PIMs) and then platform-specific models (PSMs)~\cite{brambilla2017model}. Finally, these models are transformed into code, documentation, configurations, and tests for the software system.

MDE relies on two key aspects: abstraction and automation~\cite{mohagheghi2009mde}. Models are abstractions of complex entities; they hide unwanted information so modelers can easily focus on areas of interest~\cite{schmidt2006model, brambilla2017model}. 
%Currently, MDE is the state-of-the-art in software abstraction~\cite{hutchinson2011model} by reducing complexity and offering a more intuitive and natural way to define software compared to programming languages~\cite{ciccozzi2019execution}. 
In MDE, models are automatically transformed into artifacts such as code, documentation, and other models to achieve various goals such as merging, translation, refinement, refactoring, or alignment~\cite{brambilla2017model}. These transformations help reduce developers' manual effort and production time by generating executable artifacts -- leading to improved software quality, reduced complexity, and decreased development time and effort~\cite{kelly2008domain}. There are two types of transformations in MDE: 1) Model-to-Text (M2T) transformations, for a given input model a M2T transformation produces a textual artifact such as code or documentation as output; and ) Model-to-model (M2M) transformations, for a given input model an M2M transformation produces a different kind of model, for example translating a model from one language to another~\cite{brambilla2017model}.

A model is created in a modeling language, conforming to a meta-model that defines the syntax and semantics of that language. There are two types of modeling languages: general-purpose languages (GPL) and domain-specific languages (DSL). GPLs are intended for modeling generic concepts applicable to multiple domains; some examples include the Unified Modeling Language (UML)~\cite{eriksson2003uml}, Petri-nets~\cite{peterson1977petri} and finite state machines~\cite{wagner2006modeling}. On the other hand, a DSL has modeling concepts tailored to a specific domain or context, like SysML for embedded systems, HTML for web page development, and SQL for database queries~\cite{brambilla2017model}.

While exploring the literature, one encounters terms similar to MDE: examples include model-driven architecture (MDA), model-driven development (MDD), and model-based engineering (MBE). MDA is an architectural standard~\cite{mda} developed by the Object Management Group (OMG) \cite{omg} for MDD. MDD refers to automatically generating artifacts from models, whereas MDE has a broader scope and includes analysis, validation~\cite{almonte2021recommender}, interoperability of artifacts and reverse engineering \cite{brambilla2017model}. MBE is a lighter version of MDE, where models are not necessarily the central focus of the engineering process; however, they provide critical support~\cite{brambilla2017model}. This SLR primarily focuses on MDE.

\subsection{Machine Learning}
Machine Learning (ML) is a branch of Artificial Intelligence (AI) that enables machines to learn patterns from data without being explicitly programmed~\cite{samuel1959machine}. ML algorithms are fed with existing data to \textit{train} them and produce an ML model. This trained ML model then has the capability to \textit{infer}, i.e., predict outcomes for new data inputs or also commonly known as \emph{ML model inference}~\cite{mueller2021machine}. For example, an ML model trained on stock prices for a company till September 2023 can predict stock prices in the following months. ML is preferable when solving problems that would require very complex and difficult-to-maintain traditional algorithms~\cite{geron2022hands}. Since ML algorithms can learn autonomously, they reduce complexity and facilitate easier maintenance~\cite{geron2022hands}. This ability of ML to minimise complexity, learn from changing data, and make future predictions is immensely valuable for businesses~\cite{lee2020machine}. According to a recent survey~\cite{rackspace2023report}, organizations report that applying ML increases employee efficiency by 20\%, innovation by 17\%, and lowers costs by 16\% -- leading to increased adoption of ML in practical settings~\cite{rackspace2023report}.

ML can further be divided into three broad categories: supervised learning, unsupervised learning, and reinforcement learning. The most suitable ML approach depends on the specific problem and data.
%
Supervised learning is when an ML algorithm is trained on a labeled dataset that has labels to define the meaning of data~\cite{mueller2021machine}. For example, a dataset with images labeled as ``cat'' or ``not cat'' images. Supervised learning algorithms learn to make classifications or predictions by learning patterns and relationships in labeled data~\cite{lee2020machine,mueller2021machine}. When the labels are discrete, this is known as \textit{classification} and when labels are continuous, this is known as \textit{regression}~\cite{mueller2021machine}. Once the algorithm is trained, the performance is evaluated on unseen or test data. Some popular supervised learning algorithms include linear regression, decision trees, naive Bayes classifier, support vector machines (SVM), random forest, and artificial neural networks (ANNs)~\cite{lee2020machine}. Supervised model applications include fraud detection and recommender systems~\cite{mueller2021machine}. 

Unsupervised learning is when an ML algorithm is trained on an unlabeled dataset with few or no labels to define the meaning of data~\cite{mueller2021machine,lee2020machine}. Unsupervised learning algorithms attempt to understand hidden patterns in data and group similar data together creating a classification of the data~\cite{mueller2021machine}. Unsupervised learning works without any guidance, hence it is most suitable for large volumes of data when classifications are unknown and data cannot be labeled~\cite{mueller2021machine}. Evaluating the performance of such algorithms can be challenging due to the lack of ground truth. Some popular unsupervised techniques include clustering, k-means, principal component analysis, and association rules~\cite{lee2020machine}. Applications of unsupervised models include customer segmentation and clustering user reviews~\cite{mueller2021machine}.

 Reinforcement learning is when an ML algorithm receives feedback on actions to guide the behavior toward an optimal outcome~\cite{mueller2021machine, lee2020machine}. Reinforcement learning algorithms are not trained with datasets; instead, they learn from trial and error in a simulated environment or a real-world environment~\cite{mueller2021machine}. Desired behaviors are rewarded and reinforcement learning algorithms attempt to maximize rewards through successful decisions~\cite{lee2020machine,mueller2021machine}. These algorithms are most suitable when sequential decision-making is required, interaction with an environment is possible and feedback is available. %However, reinforcement learning can be expensive since the algorithms require a large number of interactions with the environment to learn effectively. 
 Some popular reinforcement learning algorithms are Q-learning, temporal difference learning, hierarchal reinforcement learning, and policy gradient~\cite{lee2020machine}. Applications of reinforcement learning include robotics, self-driving cars, and game playing~\cite{lee2020machine}.
 
\subsection{Model-driven Engineering for Machine Learning (MDE4ML)}
%Models are a significant element of both MDE and ML. In MDE, models describe software systems in all phases of their life-cycle: requirements, design, implementation, testing and evolution~\cite{moin2022model}. ML models are mathematical models that learn patterns in data to make predictions~\cite{moin2022model}. 
Developing and managing systems with ML models and components is challenging. 
Some aspects of this complexity are immature requirements specification~\cite{kuwajima2020engineering, ahmad2023requirements}, constantly evolving data~\cite{baumann2022dynamic}, lack of ML domain knowledge~\cite{yohannis2022towards}, integration with traditional software \cite{atouani2021artifact}, responsible use of ML~\cite{yohannis2022towards}, and deployment and maintenance of ML models~\cite{kourouklidis2021model, langford2021modalas}. 

These complexities introduce several challenges. For example, Nils Baumann et al.~\cite{baumann2022dynamic} describe how challenging it is to handle changing datasets; ML engineers have to manually merge new and old datasets and re-train the entire ML model;  Benjamin Jahi et al. \cite{jahic2023semkis} point out how challenging it is to describe the dataset and neural network requirements to satisfy customer expectations;  Benjamin Benni et al. \cite{benni2019devops} state how the development of a correct ML pipeline is a highly demanding task, data scientists must have knowledge and experience to go through numerous data pre-processing and ML models to select the best one; and Kaan Koseler et al. \cite{koseler2019realization} mention the difficulties developers face when attempting to use ML techniques with big data, developers need to acquire knowledge of the problem space, domain and ML concepts. There is a need for solutions to efficiently and effectively address these challenges~\cite{raedler2023model}.
%All these challenges point towards the need for a technique that can efficiently and effectively address them.

A synergy between MDE and ML development exists, where software models are leveraged to drive the development and management of ML components~\cite{safdar2022modlf, yohannis2022towards, kourouklidis2021model}. This should not to be confused with AI or ML for MDE (AI4MDE), where intelligent agents and recommenders support users in modeling and related activities \cite{almonte2021recommender, gil2021artificial, boubekeur2020towards, saini2019teaching}. The application of MDE for ML-based systems (MDE4ML) offers many potential benefits to developers, such as reduced complexity~\cite{kourouklidis2021model, bucchiarone2020grand}, development effort, and time~\cite{yohannis2022towards,gatto2019modeling}. Domain experts, software engineers and ML novices can also take advantage of ML through the abstraction and automation of MDE \cite{shi2022feature,moin2022supporting, bucchiarone2020grand}. Additionally, MDE can also improve the quality of the ML-based system through easier maintainability, scalability~\cite{selic2003pragmatics}, reusability, and interoperability~\cite{brambilla2017model}.

\subsection{Key MDE4ML Related Work}
MDE4ML has received growing attention from researchers in recent years. We found six relevant secondary studies comprising SLRs, scoping reviews, and surveys. In their SLR \cite{raedler2023model}, the authors identify 15 primary studies on MDE for AI and analyze them with respect to MDE practices for the development of AI systems and the stages of AI development aligned with CRoss Industry Standard Process for Data Mining (CRISP-DM) \cite{wirth2000crisp} methodology. However, this study only considers a small subset of studies and performs a shallow analysis with no details about goals, end-users, types of models, implemented tools, and evaluation. A second SLR \cite{zafar2017systematic} reviews 24 papers on MDE for ML in the context of Big data analytics. This study has a narrower scope compared to ours and provides only a brief overview of the models, approaches, tools, and frameworks in the studies. In a third SLR \cite{li2022can}, 31 studies on no/low code platforms for ML applications are reviewed. This study is limited to no/low code approaches and therefore misses out on many other MDE for ML studies. A scoping review is presented in \cite{mardani2023model} on MDE for ML in IoT applications. The study examines 68 studies in depth; however, the review focuses more on MDE for IoT applications and only four of the selected studies apply ML techniques. A preliminary survey on DSLs for ML in Big data is presented in \cite{portugal2016preliminary}, with an extended version in \cite{portugal2016survey}. These surveys do not follow a systematic review process, include studies only for big data, and briefly highlight the DSLs and frameworks in the studies. From the analysis of existing literature, we found that the available secondary studies consist of limited subsets of papers on MDE for ML, lack analysis of key areas like goals, end-users, ML aspects, MDE approach details, evaluation methods, and limitations, and often do not follow a systematic and rigorous review process. Therefore, we aim to address these gaps in this SLR.

