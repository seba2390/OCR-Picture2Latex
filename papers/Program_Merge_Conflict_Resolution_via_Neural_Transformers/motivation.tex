\section{Motivating Example}
%\sarah{the intro here feels a bit sudden.}
% from Chris: I've tried to add an introduction to this section so that it feels less sudden.

We use a number of terms, concepts, and ideas throughout this paper.  To provide an intuition around how our approach works and concretely define terms and concepts, we begin with a motivating example of a small, but realistic merge conflict.



Fig.~\ref{fig:word1} provides an example merge conflict in JavaScript which shows the result of merging two concurrent changes to the same JavaScript file. Fig.~\ref{fig:word1}(a) on the left shows the standard \texttt{diff3} markers ``\texttt{<{}<{}<{}<{}<{}<{}< A.js}'', ``\texttt{||||||| O.js}'', ``\texttt{=======}'' and \\ ``\texttt{>{}>{}>{}>{}>{}>{}> B.js}'', which demarcate the conflicting regions introduced by programs $\mathcal{A}$, base $\mathcal{O}$, and $\mathcal{B}$ respectively. Here, $\mathcal{O}$ represents the lowest common ancestor of programs $\mathcal{A}$ and $\mathcal{B}$ in the version control history. We denote the program text of \texttt{diff3} conflicting regions as $A$, $B$, $O$. The program text outside the conflicting regions â€“ prefix and suffix -- is common to all three programs versions.
Normally conflicts files have the same name in different branches, but to avoid confusion, we name the original file in our example \texttt{O.js}, and the two concurrently edited versions of this file \texttt{A.js} and \texttt{B.js}.
\texttt{A.js} changes ``\texttt{var x''} to ``\texttt{let x}'' and the \texttt{10} to \texttt{11}, while \texttt{B.js} changes the \texttt{10} to \texttt{11} and also adds an argument \texttt{z}.

\thistool{} attempts to automatically resolve merge conflicts in two phases.  
First, \thistool{} represents each line-level merge conflict instance at the token level which localizes conflicting regions.  
Intuitively, \thistool{} converts the three line-structured source texts into three sequences of tokens (including space and line delimiters), applies the standard \texttt{diff3} algorithm to these token sequences, and then reconstructs the merged document at line level. 
Fig.~\ref{fig:word1}(b) shows the result of applying this token-level merge on Fig.~\ref{fig:word1}(a). 
As a result of token-level merge, the whole ``\texttt{let x = max(y,}'' string is cleanly merged, becoming a part of the program prefix, and ``\texttt{)}'' is prepended to the program suffix.  
Second, \thistool{} invokes an underlying neural model to suggest a resolution via classification for each token-level conflicting region and replaces the conflict region with the suggestion from the model (Fig.~\ref{fig:word1}(c)). 

Observe that the resolution does not consist of any single line from either $A$ or $B$ since both edits modify a common line in the base.
Hence, earlier neural approaches such as \texttt{DeepMerge}~\citep{Dinella2021} that are restricted to picking entire lines from the conflict region would not be able to provide the resolution. 
On the other hand, structured merge techniques (such as \jsfstmerge by~\cite{tavares2019javascript}) cannot resolve the conflict soundly as the conflict appears on a program statement, which leads to side effects (e.g. syntactically incorrect code).

A token-level merge can interleave edits within lines (i.e., tokens in which one edit does not conflict with another are trivially merged). Consider $\mathcal{A}$'s edit of the \texttt{var} to \texttt{let} keyword.  
Such non-conflicting edits suffice to demonstrate the above.
Token-level \texttt{diff3} is a syntactic merge algorithm and therefore cannot guarantee semantic or even syntactic correctness of the merged program. 
However, we observed that in practice, syntactic correctness is preserved the majority of the time (over 97\%).%, and in most cases (82\% of merge conflict resolutions) such a token-level merge matches the resolution that the developer provided in the repository history.

Likewise, consider the token-level conflict for the \texttt{max} function's arguments: an appropriate model trained on JavaScript should easily deduce that taking the edit from $\mathcal{B}$ (i.e., "11, z")  captures the behavior of $\mathcal{A}$'s edit as well. 
% \Shuvendu{Is this really true as the conflict region only has 11,z?}.  
The suggested resolution gives an intuitive demonstration of how \thistool{} turns a complex line-level resolution into a simpler token-level classification problem.
 %\Shuvendu{This paragraph is really talking about token-level merge, and nothing with the neural model. It should go where we motivate token level merge.}
%\Shuvendu{Can we move this to the section on Merge as Classification to motivate? to sec 4}
%\sarah{todd, shuvendu: we shouldnt use semantic correctness throughout the paper. }