\section{Skyline Computation Over Categorical Attributes}\label{sec:3}
Without loss of generality, for ease of explanation, we consider a relation with Boolean attributes, i.e., categorical attributes with domain size 2. We shall discuss the extensions of the algorithms for categorical attributes with larger domains later in this section.

Throughout this section, we consider the case in which precomputed indices are not available. First, we exploit the categorical characteristics of attributes by designing a tree data structure that can perform efficient {\em dominance} operations. Specifically, given a new tuple $t$, the tree supports three primitive operations -- i) INSERT($t$): inserts a new tuple $t$ to the tree, ii) IS-DOMINATED($t$): checks if tuple $t$ is dominated by any tuple in the tree, and iii) PRUNE-DOMINATED-TUPLES($t$): deletes the tuples dominated by $t$ from the tree. In Appendix \ref{ap:tree-optimizations}, we further improve the performance of these basic operations by proposing several optimization techniques. Finally, we propose two algorithms ST-S (Skyline using Tree Sorting-based) and ST-P (Skyline using Tree Partition-based) that incorporate the tree structure to state-of-art sorting- and partition-based algorithms.


\subsection{Organizing Tuples Tree}\label{subsec:tree}
\vspace{1mm}
\noindent{\bf Tree structure:} We use a binary tree to store tuples in the candidate skyline set. Consider an ordering of all attributes in $\mathcal{Q} \subseteq \mathcal{A}$, e.g., $[A_1, A_2, \ldots, A_{m'}]$.
In addition to tuple attributes, we enhance each tuple with a score, assessed using a function $F(\cdot)$. This score assists in improving performance during identification of the dominated tuples or while conducting the dominance check. The proposed algorithm is agnostic to the choice of $F(\cdot)$; the only requirement is that the function does not assign a higher score to a dominated tuple compared to its dominator.
The structure of the tree for Example~\ref{exmp:ST} is depicted in Figure~\ref{fig:tree}. The tree has a total of 5 ($=m'+ 1$) levels, where the $i$'th level ($1 \leq i \leq m'$) represents attribute $A_i$. The left (resp. right) edge of each internal node represents value 0 (resp. 1). Each path from the root to a leaf represents a specific assignment of attribute values. The leaf nodes of the tree 
store two pieces of information: i) $score$: the score of the tuple mapped to that node, and ii) \textit{tupleID List}: list of ids of the tuples mapped to that node. Note that all the tuples that are mapped to the same leaf node in the tree have the same attribute value assignment, i.e. have the same score.
Moreover, the attribute values of a tuple $t$ can be identified by inspecting the path from the root to a leaf node containing $t$. Thus, there is no requirement to store the attribute values of the tuples in the leaf nodes.
Only the leaf nodes that correspond to an actual tuple are present in the tree. 

\begin{exmp}\label{exmp:ST} 
As a running example through out this section, consider the relation $D$ with $n=5$ non-dominated tuples where its projection on $\mathcal{Q}=\{A_1,A_2,A_3,A_4\}$ is depicted in Table~\ref{tab:skylineTreeRunningExample}. 
The last column of the table presents the score of each tuple, utilizing the function $F(\cdot)$  provided in Equation~\ref{eq:score}.
\begin{align}\label{eq:score}
F(t_{\mathcal{Q}}) = \sum_{A_i \in \mathcal{Q}} 2^{i-1} \cdot t[A_i]
\end{align}
\end{exmp}



\begin{table}[!t]
\centering
\caption{Example~\ref{exmp:ST} relation}\label{tab:skylineTreeRunningExample}
\begin{tiny}
\begin{tabular}{cccccc}
    \hline 
    $tupleID$ & $A_1$ & $A_2$ & $A_3$ & $A_4$ & $Score$\\
    \hline 
    $t_1$ & 1 & 1 & 0 & 0 & 12\\
    \hline
    $t_2$ & 0 & 0 & 1 & 1 & 3\\
    \hline
    $t_3$ & 0 & 1 & 1 & 0 & 6\\
    \hline
    $t_4$ & 1 & 0 & 0 & 1 & 9\\
    \hline
    $t_5$ & 1 & 0 & 1 & 0 & 10\\
    \hline
\end{tabular}
\end{tiny}
\end{table}

\begin{figure*}[!t]
\begin{minipage}[t]{0.23\linewidth}
\centering
    \includegraphics[scale=0.80]{figures/SkylineTree.pdf}
    %\vspace{-8mm}
    \caption{Tree structure for relation in Example~\ref{exmp:ST}}
    \label{fig:tree}
\end{minipage}
\hspace{1mm}
\begin{minipage}[t]{0.23\linewidth}
\centering
    \includegraphics[scale=0.80]{figures/SkylineTreeDominate.pdf}
    %\vspace{-8mm}
    \caption{Prune dominated tuples}
    \label{fig:treePruneDominatedTuples}
\end{minipage}
\hspace{1mm}
\begin{minipage}[t]{0.23\linewidth}
\centering
    \includegraphics[scale=0.80]{figures/SkylineTreeDominateAfter.pdf}
    %\vspace{-8mm}
    \caption{Tree after removing dominated tuples}
    \label{fig:treePruneDominatedTuplesAfter}
\end{minipage}
\hspace{1mm}
\begin{minipage}[t]{0.23\linewidth}
\centering
    \includegraphics[scale=0.80]{figures/SkylineTreeDominated.pdf}
    %\vspace{-8mm}
    \caption{Check if tuple $t$ is dominated}
    \label{fig:treeCheckIfDominated}
\end{minipage}
\end{figure*}


\vspace{1mm}
\noindent{\bf INSERT($t$):} In order to insert a tuple $t$ into the tree, we start from the root. At level $i$ $(1 \leq i \leq m')$, we check the corresponding attribute value, $t[A_i]$. If $t[A_i] = 0$ (resp. $t[A_i] = 1$) and the left (resp. right) child of current node already exists in the tree, we simply follow the left (resp. right) child. Otherwise, we first have to create a new tree node as left (resp. right) child before traversing it. After reaching the leaf node at level $m'+1$, the $tupleID$ of $t$ is appended to \textit{tupleID List} and the $score$ value is assigned to newly constructed leaf.

\begin{algorithm}[!htb]
\caption{{\bf INSERT}}
\begin{algorithmic}[1]
\label{alg:insertTuple}
\STATE {\bf Input:} Tuple $t$, Node $n$, Level $l$, Query $\mathcal{Q}$;
%\STATE {\bf if} $n$ is $leaf$ node:
\STATE {\bf if} $l == |\mathcal{Q}| + 1$:
    \STATE \hindent {\bf if} $n.score$ is None: $n.score = score(t)$
    \STATE \hindent Append $t[tupleID]$ to $n.tupleIDList$
\STATE {\bf else}:
    \STATE \hindent {\bf if} $t[A_l]==0$:
        \STATE \hindent[2] {\bf if} $n.left$ is $None$:
           % \STATE \hindent[3] Create $left$ child of $t$
           \STATE \hindent[3] temp = {\it New} Node();
           \STATE \hindent[3] $t.left$ = temp;
        \STATE \hindent[2] INSERT($t$, $n.left$, $l+1$)
    \STATE \hindent {\bf if} $t[A_l]==1$:
        \STATE \hindent[2] {\bf if} $n.right$ is $None$:
           % \STATE \hindent[3] Create $right$ child of $t$
           \STATE \hindent[3] temp = {\it New} Node();
           \STATE \hindent[3] $t.right$ = temp;
        \STATE \hindent[2] INSERT($t$, $n.right$, $l+1$)
\end{algorithmic}
\end{algorithm}

\vspace{1mm}
\noindent{\bf PRUNE-DOMINATED-TUPLES($t$):} The pruning algorithm to delete from the tree, tuples dominated by $t$, is recursively developed as follows: We start from the root node of the tree. If $t[A_1] = 1$, we search both the left and right subtree. Otherwise, only the left child is selected. This is because if $t[A_1] = 1$, a tuple $t'$ dominated by $t$ can assume value  0 or 1 on attribute $A_1$. On the other hand, $t$ cannot dominate a tuple $t'$ if $t[A_1] = 0$ and $t'[A_1] = 1$. We follow the same approach at each internal node visited by the algorithm - at level $i$ $(1 \leq i \leq m)$, value of $t[A_i]$ is used to select the appropriate subtree. After reaching a leaf node, we compare $score(t_{\mathcal{Q}})$ with the $score$ value of leaf node. If both values are equal, no action is required, since, all the tuples mapped into the current leaf node have the same attribute value as $t_{\mathcal{Q}}$. Else, the leaf node is deleted from the tree. Upon return from the recursion, we check if both the left and right child of the current (internal) node are empty. In that case, the current node is also deleted from the tree.

Figure~\ref{fig:treePruneDominatedTuples} demonstrates the pruning algorithm for $t = \langle 1,0,1,1 \rangle$. Tuples in the tree that are dominated by $t$ are: $t_2$, $t_4$, and $t_5$. The bold edges represent paths followed by the pruning algorithm. Both the left and right children of node $a$ are visited since $t[A_1] = 1$, whereas, at nodes $f$ and $b$ only the left subtree is selected for searching. The final structure of the tree after deleting the dominated tuples is shown in Figure~\ref{fig:treePruneDominatedTuplesAfter}.

\begin{algorithm}[htb]
\caption{{\bf PRUNE-DOMINATED-TUPLES}}
\begin{algorithmic}[1]
\label{alg:pruneDominatedTuples}
\STATE {\bf Input:} Tuple $t$, Node $n$, Level $l$, Score $s$, Query $\mathcal{Q}$;

\STATE {\bf if} $n$ is $None$ or $n.minScore > s$ {\bf return}

\STATE {\bf if} $l == |\mathcal{Q}| + 1$ and $score(t_{\mathcal{Q}}) \neq n.score$:
    \STATE \hindent Delete $n$ from tree
    \STATE \hindent {\bf return}

\STATE {\bf if} $t[A_l] == 1$:
    \STATE \hindent PRUNE-DOMINATED-TUPLES($t$, $n.right$, $l+1$, $s$)
    \STATE \hindent $s' = s - weight(A_i)$
    \STATE \hindent PRUNE-DOMINATED-TUPLES($t$, $n.left$, $l+1$, $s'$)
\STATE {\bf else}:
    \STATE \hindent PRUNE-DOMINATED-TUPLES($t$, $n.left$, $l+1$, $s$)

\STATE {\bf if} Both $left$ and $right$ children of $n$ is $None$
    \STATE \hindent Delete $n$ from tree
\end{algorithmic}
\end{algorithm}


\vspace{1mm}
\noindent{\bf IS-DOMINATED($t$):} The algorithm starts traversing the tree from the root. For each node visited by the algorithm at level $i$ $(1 \leq i \leq m)$, we check the corresponding attribute value $t[A_i]$. If $t[A_i] = 0$, we search both the left and right subtree; otherwise, we only need to search in the right subtree. This is because when $t[A_i] = 0$, all the tuples dominating $t$ can be either 0 or 1 on attribute $A_i$. If we reach a leaf node that has an attribute value assignment which is different than that of $t$ (i.e., $score \neq score(t)$), $t$ is dominated.  Note that, when $t[A_i] = 0$ both the left and right subtree of the current node can have tuples dominating $t$, while the cost of identifying a dominating tuple (i.e., the number of nodes visited) may vary depending on whether the left or right subtree is visited first. For simplicity, we always search in the right subtree first. If there exists a tuple in the subtree of a node that dominates tuple $t$, we do not need to search in the left subtree anymore. 

Figure~\ref{fig:treeCheckIfDominated} presents the nodes visited by the algorithm in order to check if the new tuple $t = \langle 0,0,1,0 \rangle$ is dominated. We start from the root node $a$ and check the value of $t$ in attribute $A_1$. Since $t[A_1] = 0$, we first search in the right subtree of $a$. After reaching to node $d$, the algorithm back-tracks to $b$ (parent of $d$). This is because $t[A_3] = 1$ and $d$ has no actual tuple mapped under it's right child. Since $t[A_2] = 0$ and we could not identify any dominating tuple in the right subtree of $b$, the algorithm starts searching in the left subtree and moves to node $c$. At node $c$, only the right child is selected, since $t[A_3] = 1$. Applying the same approach at node $f$, we reach the leaf node $e$ that contains the tupleID $t_5$. Since the value of the $score$ variable at leaf node $e$ is different from $score(t)$, we conclude that tuples mapped into $e$ (i.e., $t_5$) dominate $t$.

Please refer to Appendix~\ref{ap:tree-optimizations} for further optimizations on the tree data structure.

\begin{algorithm}[htb]
\caption{{\bf IS-DOMINATED}}
\begin{algorithmic}[1]
\label{alg:isDominated}
\STATE {\bf Input:} Tuple $t$, Node $n$, Level $l$, Score $s$, Query $\mathcal{Q}$; \qquad {\bf Output:} True if $t$ is dominated else False.
\STATE {\bf if} $n$ is $None$ or $s > n.maxScore$: {\bf return}

\STATE {\bf if} $l == |\mathcal{Q}|$ and $score(t_{\mathcal{Q}}) \neq n.score$: {\bf return} True
\STATE {\bf if} $l == |\mathcal{Q}|$ and $score(t_{\mathcal{Q}}) = n.score$: {\bf return} False

\STATE {\bf if} $t[A_l] == 0$:
    \STATE \hindent $s' = s + weight(A_i)$
    \STATE \hindent $dominated$ = IS-DOMINATED($t$, $n.right$, $l+1$, $s'$)
    \STATE \hindent {\bf if} $dominated$ == True: {\bf return} True
    \STATE \hindent {\bf return} IS-DOMINATED($t$, $n.left$, $l+1$, $s$)
\STATE {\bf else}:
    \STATE \hindent {\bf return} IS-DOMINATED($t$, $n.right$, $l+1$, $s$)
\end{algorithmic}
\end{algorithm}



\subsection{Skyline using Tree}\label{sec:ST}

Existing works on skyline computation mainly focus on two optimization criteria: reducing the number of dominance checks (CPU cost), limiting communication cost with the backend database (I/O cost). Sorting-based algorithms reduce the number of dominance check by ensuring that only the skyline tuples are inserted in the candidate skyline list. Whereas, partition-based algorithms achieve this by skipping dominance tests among tuples inside incomparable regions generated from the partition. However, given a list of tuples $\mathcal{T}$ and a new tuple $t$, in order to discard tuples from $\mathcal{T}$ that are dominated by $t$, both the sorting- and partition-based algorithms need to compare $t$ against all the tuples in $\mathcal{T}$. This is also the case when we need to check whether $t$ is dominated by $T$. The tree structure defined in \S\ref{subsec:tree} allows us to perform these operations effectively for categorical attributes. Since the performance gain achieved by the tree structure is independent of the optimization approaches of previous algorithms, it is possible to combine the tree structure with existing skyline algorithms. We now present two algorithms ST-S (Skyline using Tree Sorting-based) and ST-P (Skyline using Tree Partition-based) that incorporates the tree structure into existing algorithm.

\vspace{1mm}
\noindent{\bf ST-S:} ST-S combines the tree structure with a sorting-based algorithm. Specifically, we have selected the SaLSa~\cite{bartolini2008efficient} algorithms that exhibits better performance compared to other sorting-based algorithms. The final algorithm is presented in Algorithm~\ref{alg:st-s}. The tuples are first sorted according to ``maximum coordinate'', maxC, criterion\footnote{Assuming larger values are preferred for each attribute.}. Specifically, Given a skyline query $\mathcal{Q}$, $maxC(t_{\mathcal{Q}}) = (max_{A\in \mathcal{Q}}\{t[A]\}, sum(t_{\mathcal{Q}}))$, where $sum(t_{\mathcal{Q}}) = \sum_{A\in \mathcal{Q}} t[A]$. A tree structure $T$ is used to store the skyline tuples. Note that the monotonic property of the scoring function $maxC(\cdot)$ ensures that all the tuples inserted in $T$ are skyline tuples. The algorithm then iterates over the sorted list one by one, and for each new tuple $t$, if $t$ is not dominated by any tuple in tree $T$, it is inserted in the tree (lines 7-8). For each new skyline tuple, the ``stop point'' $t_{stop}$ is updated if required (line 10-12). The algorithm stops if all the tuples are accessed or $t_{stop}$ dominates the remaining tuple. Detailed description of the ``stop point'' can be found in the original SaLSa paper~\cite{bartolini2008efficient}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%We now present the Skyline using Tree Algorithm (ST) that utilizes the tree data structure defined in \S\ref{subsec:tree} for discovering skylines.  Therefore, it is possible to incorporate the tree data structure into existing skyline algorithms and improve the performance further. The ST algorithm we are going to proposed in this section is adaption of stat-of-art sorting-based algorithm SaLSa~\cite{bartolini2008efficient}. The partition-based algorithms does not perform well for categorical attributes. Hence, are skipped from consideration (See \S\ref{sec:relWork} for details). We first start with a brief description of SaLSa and then describe how it can be incorporated with ST algorithm.

%Sorting based algorithms tries to reduce the total number of dominance test by discarding the no skyline points with fewer number of dominance test. This can be achieved by sorting the tuples in relation using a monotonic scoring function. In addition of sorting, . As the algorithm progress, SaLSa maintains a \textit{stopping point}, selected from the skylines that are already discovered. In addition it defines an {\em unread domain} that is dynamically updated after reading each point. The unread domain can be considered as an hyper rectangle that contains points that are yet to be accessed for dominance check. SaLSa stops when the stop point dominates the unread region. The authors also showed that the correctness and as well as performance of the algorithm depends on the choice of scoring function $F(\cdot)$. The number of tuples needed to be accessed can be minimized by sorting data according to ``maximum coordinate'', maxC, criterion\footnote{Assuming larger values are preferred for each attribute.}. Specifically, $maxC(t) = (min_j\{t[j]\}, sum(t))$, where $sum(t) = \sum_{j=1}^mp[j]$. 


%The final ST algorithm is presented in Algorithm~\ref{alg:st}. First, we sort the tuples in descending order of their maxC value. The algorithm then starts scanning tuples from the \textit{sorted list} one by one. For each new tuple $t$ ST checks whether the tuple is dominated by tuple $t'_\mathcal{Q}$ in $T$. If not $t$ is a skyline tuple and inserted in $T$. The stopping point $t_{stop}$ is updated if the minimum attribute value of current skyline tuple $t$ is grater then minimum attribute value of $t_{stop}$ (Line 10-11). The algorithm stops when all the tuples are accessed or $t_{stop}$ dominates the remaining tuples (Line 6). Note that sorting the tuples using a monotonic property of maxC function ensures that all the tuples inserted into $T$ are skyline in $D$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{algorithm}[htb]
\caption{{\bf ST-S}}
\begin{algorithmic}[1]
\label{alg:st-s}
\STATE {\bf Input:} Tuple list $\mathcal{T}$, Query $\mathcal{Q}$ and Tree $T$; \\ {\bf Output:} $\mathcal{S}_\mathcal{Q}$
\STATE Sort tuples in $D$ using a monotonic function $maxC(\cdot)$
\STATE {\bf if} $T \text{ is } None$: $T \leftarrow$ {\it New} Tree()% for storing the candidate skyline set.
\STATE $t_{stop} \leftarrow$ undefined
\STATE {\bf for} each tuple $t \in D$
    \STATE \hindent {\bf if} $t_{stop}^+ \geq maxC(t_{\mathcal{Q}})$ and $t_{stop} \neq t$: {\bf return}
    \STATE \hindent {\bf if not} IS-DOMINATED($t_\mathcal{Q}$, $T.rootNode$, 1, $score(t)$)
        \STATE \hindent[2] INSERT($t_\mathcal{Q}$, $T.rootNode$, 1)
        \STATE \hindent[2] Output $t_\mathcal{Q}$ as skyline tuple.
        \STATE \hindent[2] $t^+ \leftarrow  min_{A \in \mathcal{Q}}\{t[A]\}$
        \STATE \hindent[2] {\bf if} $t^+ > t_{stop}^+$: $t_{stop} \leftarrow t_{\mathcal{Q}}$
\end{algorithmic}
\end{algorithm}


\vspace{1mm}
\noindent{\bf ST-P:} We have selected the state-of-art partition-based algorithm BSkyTree~\cite{lee2014scalable} for designing ST-P. The final algorithm is presented in Algorithm~\ref{alg:st-p}. Given a tuple list $\mathcal{T}$, the SELECT-PIVOT-POINT method returns a pivot tuple $p^V$ such that it belongs to the skyline of $\mathcal{Q}$ (i.e., $\mathcal{S_{\mathcal{Q}}}$). Moreover, $p^V$ partitions the tuples in $\mathcal{T}$ in a way such that the number of dominance test is minimized (details in~\cite{lee2014scalable}). Tuples in $\mathcal{T}$ are then split into $2^{|\mathcal{Q}|}$ lists, each corresponding to one of the $2^{|\mathcal{Q}|}$ regions generated by $p^V$ (lines 7-9). Tuples in $\mathcal{L}[0]$ are dominated by $p^V$, hence can be pruned safely. For each pair of lists $\mathcal{L}[i]$ and $\mathcal{L}[j]$ ($max \geq j> i \geq 1$), if $\mathcal{L}[j]$ partially dominates $\mathcal{L}[i]$, tuples in $\mathcal{L}[i]$ that are dominated by any tuple in $\mathcal{L}[j]$ are eliminated. Finally, skylines in $\mathcal{L}[i]$ are then discovered in recursive manner (lines 10-15).

\begin{algorithm}[htb]
\caption{{\bf ST-P}}
\begin{algorithmic}[1]
\label{alg:st-p}
\STATE {\bf Input:} Tuple list $\mathcal{T}$ and query $\mathcal{Q}$; \\ {\bf Output:} $\mathcal{S}_\mathcal{Q}$
\STATE {\bf if} $|\mathcal{T}| \leq 1$: {\bf return} $\mathcal{T}$
\STATE $max \leftarrow 2^{|\mathcal{Q}|} - 2$ //\textit{Size of the lattice}
\STATE $\mathcal{L}[1, max] \leftarrow \{\}$ 
\STATE $p^V \leftarrow$ SELECT-PIVOT-POINT($\mathcal{T}$)
\STATE $\mathcal{S_\mathcal{Q}} \leftarrow \mathcal{S_\mathcal{Q}} \cup p^V$ //\textit{$p^V$ is a skyline tuple}
\STATE {\bf for} each tuple $t \in \mathcal{T}$
    \STATE \hindent $B^i \leftarrow$ $|\mathcal{Q}|$-bit binary vector corresponds to
    $t$ wrt $p^V$
    \STATE \hindent {\bf if} $i \neq 0$: $\mathcal{L}[i] \leftarrow \mathcal{L}[i] \cup t$
\STATE {\bf for} $i \leftarrow \text{ max to } 1$
    \STATE \hindent $T \leftarrow$ {\it New} Tree()
    \STATE \hindent Insert tuples in $\mathcal{L}[i]$ in $T$
    \STATE \hindent {\bf for} $\forall j \in [max, i)$ : $B^j \succeq B^i$
        \STATE \hindent[2] {\bf for} $\forall t \in \mathcal{L}[j]$: PRUNE-DOMINATED-TUPLES($t_{\mathcal{Q}}$, $T.rootNode$, 1, $score(t_{\mathcal{Q}})$)
    \STATE \hindent $\mathcal{S_\mathcal{Q}} \leftarrow \mathcal{S_\mathcal{Q}} \cup $ ST-P(tuples in $T$)
\STATE {\bf return} $\mathcal{S_{\mathcal{Q}}}$
\end{algorithmic}
\end{algorithm}


\vspace{1mm}
\noindent{\bf Performance Analysis:} We now provide a theoretical analysis of the performance of primitive operations utilized by ST-S and ST-P. To make the theoretical analysis tractable, we assume that the
underlying data is i.i.d., where $p_i$ is the probability of having value 1 on attribute $A_i$.

The cost of INSERT-TUPLE($t_\mathcal{Q}$) operation is $O(m')$, since to insert a new tuple in the tree one only needs to follow a single path from the root to leaf. For IS-DOMINATED($t_\mathcal{Q}$) and PRUNE-DOMINATED-TUPLES($t_\mathcal{Q}$), we utilize the number of nodes visited in the tree as the performance measure of these operations.

Consider a tree $T$ with $s$ tuples;  Let $Cost(l, s)$ be the expected number of nodes visited by the primitive operations.


\begin{theorem}\label{thm:expectedCostSTISDominated}
Considering a relation with $n$ binary attributes where $p_i$ is the probability that a tuple has value 1 on attribute $A_i$, the expected cost of IS-DOMINATED($t_\mathcal{Q}$) operation on a tree $T$, containing $s$ tuples is:
\begin{small}
\begin{align}\label{eq:expectedCostSTISDominated}
    \nonumber
    C(m', s) &= 1 \\
    \nonumber
    C(l, 0) &= 1 \\
    C(l, s) &= 1 + \sum_{i=0}^s {s \choose i} (1-p_l)^i p_l^{s-i} C'(l, i, s-i)
\end{align}
\end{small}
\hspace{-1mm}where $S(l, s-i) = 1 - (1 - \prod\nolimits_{i=1}^{|\mathcal{A}_{ones(t[l+1:m'])}|}p_i)^{s-i}$ and\footnote{$\mathcal{A}_{ones(t[l+1:m'])} = \{A_i | t[A_i] = 1, l+1 \leq i \leq m'\}$ is the set of remaining attributes of $t$ that has value equals 1.} $C'(l, i, s-i) = C(l+1, s-i) + (1-p_l)(1-S(l, s-i))C(l+1, i)$
\end{theorem}
Please refer to Appendix~\ref{sec:appendixProof} for the proof.

\begin{theorem}\label{thm:expectedCostSTPruneDominatedTuples}
Given a boolean relation $D$ with $n$ tuple and the probability of having value 1 on attribute $A_i$ being $p_i$, the expected cost of PRUNE-DOMINATED-TUPLES($t_\mathcal{Q}$) operation on a tree $T$, containing $s$ tuples is
\begin{small}
\begin{align} \label{eq:expectedCostSTPruneDominatedTuples}
    \nonumber
    C(m', s) &= 1 \\
    \nonumber
    C(l, 0) &= 1 \\
    C(l, s) &= 1 + \sum_{i=0}^s {s \choose i} (1-p_l)^i p_l^{s-i} (C(l+1, i) + p_lC(l+1, s-i))
\end{align}
\end{small}
\end{theorem}
The proof is available in Appendix~\ref{sec:appendixProof}

Figure~\ref{fig:expectedCostST}
uses Equations~\ref{eq:expectedCostSTISDominated} and~\ref{eq:expectedCostSTPruneDominatedTuples} to provide an expected cost for the IS-DOMINATE and PRUNE-DOMINATED-TUPLES operations, for varying numbers of tuples in $T$ ($s$) where $m'=20$.
%presents a simulation of $C(l, s)$ as a function of $s$ (number of tuples in $T$) for IS-DOMINATE operation over a relation with $m=20$ attributes. 
%\textcolor{red}{Gautam: explain why you choose to give a simulation. Was it because a closed form was difficult?}
We compare its performance with the appraoch, where candidate skyline tuples are organized in a list.
Suppose there are $s$ tuples in the list; the best case for the domination test occurs when the first tuple in the list dominates the input tuple ($O(1\times m')$), while in the worst case, none or only the very last tuple dominates it ($O(s\times m')$)~\cite{borzsony2001skyline}. Thus, on average the dominance test iterates over half of its candidate list (i.e., $\dfrac{s}{2}\times m'$ comparisons).
On the other hand, in order to prune tuples in the list that are dominated by $t_\mathcal{Q}$, existing algorithms need to compare $t_\mathcal{Q}$ with all the entries in the list. Hence, expected cost of PRUNE-DOMINATED-TUPLES is $s \times m'$. From the figure, we can see that the expected number of comparisons required by the two primitive operations are significantly less when instead of a list, tuples are organized in a tree. Moreover, as $p_i$ increases, the cost of the primitive operations decreases. This is because, when the value of $p_i$ is large, the probability of following left edge (edges corresponds value $0$) of a tree node decreases. 

%We investigate the performance of the primitive operations over non-uniform i.i.d. relation by setting different $p_i$ value to each attribute. Specifically, for each attribute, we set $p_i$ uniformly in range $[0.2, 0.6]$. Even with this skewed distribution, the cost of the primitive operations doesn't increase much.

%The expected number of comparisons required by an IS-DOMINATE operation is significantly less than the comparisons performed when candidate skylines are organized in a list. Moreover, the expected cost of IS-DOMINATE over a relation with non-uniform attributes is slightly less than the expected cost of uniform attributes. For non-uniform , we set $p_1 = 0.8$ (probability of having $1$ on attribute $A_1$) and  $p_{20} = 0.2$ (probability having $1$ on attribute $A_{20}$). All the other values are set in between, i.e., $p_i = 0.8 - 0.03 \times (20 - i) \, (2 \leq i \leq 19)$.

The above simulations show that the tree structure can reduce the cost of dominance test effectively thus improving the overall performance of ST algorithms. Although the analysis has been carried out for i.i.d. data, our experimental results in \S\ref{sec:experiments} show similar behavior for other types of datasets.

\begin{figure}
\begin{subfigure}{.49\linewidth}
  \centering
  \includegraphics[scale=.45]{figures/expectedCostIsDominated.pdf}
  %\vspace{-2mm}
  \caption{\begin{tiny}IS-DOMINATED\end{tiny}}
  \label{fig:expectedCostIsDominated}
\end{subfigure}
\begin{subfigure}{.49\linewidth}
  \centering
  \includegraphics[scale=.45]{figures/expectedPrunedDominated.pdf}
  \caption{\begin{tiny}PRUNE-DOMINATED-TUPLES \end{tiny}}
  \label{fig:expectedPrunedDominated}
\end{subfigure}
%\vspace{-3mm}
\caption{Expected cost of IS-DOMINATED and PRUNE-DOMINATED-TUPLES operations as a function of $s$}
\label{fig:expectedCostST}
\end{figure}


\subsection{Extension for Categorical Attributes}\label{ap:STCategorical}
We now discuss how to modify ST algorithm for relations having categorical attributes. We need to make the following two changes:

\begin{itemize}
    \item The tree structure designed in \S\ref{subsec:tree} needs to be modified for categorical attribute.
    \item We also need to change the tree traversal algorithms used in each of the three primitive operations.
\end{itemize}

\noindent{\bf Tree structure:} The tree structure will not be binary anymore. In order to incorporate categorical attributes, each node $u$ at level $l$ ($1 \leq l \leq m$) of the tree now should have $|Dom(A_l)|$ children, one for each attribute value $v \in Dom(A_l)$. We shall index the edges from left to right, where the left most edge corresponds to the lowest attribute value and the attribute value corresponding to each edge increases as we move from left most edge to right most edge.

\vspace{1mm}
\noindent{\bf INSERT($t$):} After reaching a node $u$ at level $l$, select the $t[A_l]$-th child of $u$ for moving to the next level of the tree.

\vspace{1mm}
\noindent{\bf IS-DOMINATED($t$):} We need to follow all the edges that has index value grater or equal to $t[A_l]$.

\vspace{1mm}
\noindent{\bf PRUNE-DOMINATED-TUPLES($t$):} Search in all the subtrees reachable by following edges with index value less than or equal to $t[A_l]$.