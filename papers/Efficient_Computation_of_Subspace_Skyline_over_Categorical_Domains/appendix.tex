\appendix

\section{Tree Data Structure Optimizations}\label{ap:tree-optimizations}

\vspace{1mm}
\noindent{\bf Early termination:} The tree structure described in \S\ref{subsec:tree}, does not store any information inside internal nodes. We can improve the performance of primitive operations (i.e., reduce the number of nodes visited) by storing some information inside each internal node. Specifically, each internal node maintains two variables \textit{minScore} and \textit{maxScore}. The \textit{minScore} (resp. \textit{maxScore}) value of an internal node is the \textit{minimum} (resp. \textit{maximum}) tuple score of all the tuples mapped in the subtree rooted at that node. The availability of such information at each internal 
node assists in skipping search inside irrelevant regions.

While searching the tree to discover tuples dominated by or dominating a specific tuple $t$, we also maintain an additional variable \textit{currentScore}, which initially is the same as $score(t)$ at the root of the tree. During traversals, if we follow an edge that matches the corresponding attribute value of $t$, \textit{currentScore} remains the same\footnote{An edge selected by the algorithm coming out from an internal node at level $i$ matches the attribute value of $t$ if $t[A_i] = 0$ (resp. $t[A_i] = 1$) and we follow the \textit{left} (resp. \textit{right}) edge.}. However, if the edge selected by the algorithm differs from the actual attribute value, we update the \textit{currentScore} value accordingly. In the PRUNE-DOMINATED-TUPLES($t$) operation, we compare the \textit{minScore} value of each internal node visited by the algorithm with \textit{currentScore}. If the \textit{minScore} value of a node $u$ is higher than \textit{currentScore}, we stop searching in the subtree rooted at $u$, since it's not possible to have a tuple $t'$ under $u$ that is dominated by $t$ (due to monotonicity). Similarly, while checking if $t$ is dominated by any other tuple in the tree, we stop traversing the subtree rooted at an internal node $u$ if \textit{currentScore} is higher than the \textit{maxScore} value of $u$.

Figure~\ref{fig:treeAugmented} presents the value of \textit{minScore} and \textit{maxScore} at each internal node of the tree for the relation in Table~\ref{tab:skylineTreeRunningExample}. Consider a new tuple $t = \langle 1,0,0,0 \rangle$. In order to prune the tuples dominated by $t$, we start from the root node $a$. At node $a$ \textit{currentScore} = $score(t)$ = 8. Since, $t[A_0] = 1$, we need to search both the left and right subtree of $a$. The value of \textit{currentScore} at node $c$ remains unchanged since the edge that was used to reach $c$ from $a$ matches the value of $t[A_0]$. However, for $b$  the value of \textit{currentScore} has to be updated. The \textit{currentScore} value at node $b$ is obtained by changing the value of $t[A_0]$ to 0 (values of the other attributes remain
the same as in the parent node) and compute the score of the updated tuple. Note that the value of \textit{currentScore} is less than \textit{minScore} in both nodes $b$ and $c$. Hence we can be sure that no tuple in subtrees rooted at node $b$ and $c$ can be dominated by $t$.

\begin{figure}[!h]
  \centering
  \includegraphics[scale=1.3]{figures/SkylineTreeAugmented.pdf}
  \vspace{-6mm}\caption{Example: Early termination}
  \label{fig:treeAugmented}
\end{figure}

%\vspace{1mm}
%\noindent{\bf Ordering of Attributes:} 
%\textcolor{red}{TBD}
%The ordering of attributes can have impact on the performance of the primitive operations. Let $freq(A_i)$ be the number of tuples in $D$ that have attribute $A_i$ value set to 1.

\section{Extending the Data Structure for Categorical Attributes}\label{ap:STCategorical}
We now discuss how to modify ST algorithm for relations having categorical attributes. We need to make the following two changes:

\begin{itemize}
    \item The tree structure designed in \S\ref{subsec:tree} needs to be modified for categorical attribute.
    \item We also need to change the tree traversal algorithms used in each of the three primitive operations.
\end{itemize}

\noindent{\bf Tree structure:} The tree structure will not be binary anymore. In order to incorporate categorical attributes, each node $u$ at level $l$ ($1 \leq l \leq m$) of the tree now should have $|Dom(A_l)|$ children, one for each attribute value $v \in Dom(A_l)$. We shall index the edges from left to right, where the left most edge corresponds to the lowest attribute value and the attribute value corresponding to each edge increases as we move from left most edge to right most edge.

\vspace{1mm}
\noindent{\bf INSERT($t$):} After reaching a node $u$ at level $l$, select the $t[A_l]$-th child of $u$ for moving to the next level of the tree.

\noindent{\bf IS-DOMINATED($t$):} We need to follow all the edges that has index value grater or equal to $t[A_l]$.

\noindent{\bf PRUNE-DOMINATED-TUPLES($t$):} Search in all the subtrees reachable by following edges with index value less than or equal to $t[A_l]$.

%Figure~\ref{fig:treeNodeCategorical} (a) shows the structure of an internal node  corresponding to an attribute $A$ with $Dom(A) = 4$. Given a new tuple $t$ with $t[A] = 1$, edges of $u$ traversed by the primitive operations for $t[A]$ are shown in bold lines.
%
%\begin{figure}[!h]
%  \centering
%  \includegraphics[scale=1]{figures/treeNodeCategorical.pdf}
%  \caption{Tree node for categorical attribute}
%  \label{fig:treeNodeCategorical}
%\end{figure}

\section{TOP-DOWN}\label{ap:top-down}

\begin{figure}[!h]
  \centering
  %\vspace{-4mm}
  \includegraphics[scale=1.10]{figures/latticeTopDown.pdf}
  %\vspace{-3mm}
  \caption{Nodes traversed by TOP-DOWN Algorithm}
  \label{fig:latticeTopDown}
\end{figure}

Here we provide the details of the TOP-DOWN algorithm proposed in \S~\ref{sec:topdown}.
Given a subspace skyline query $\mathcal{Q}$, consider the corresponding subspace lattice. Each node $u$ in the lattice corresponds to a {\em unique} attribute combination which can be represented by a unique $id$. We assume the existence of the following two functions, (i) $ID(C)$: returns the $id$ of an attribute value combination, and (ii) $InvID(id, m^\prime)$: returns the corresponding attribute-value combination for $id$. The details of these functions can be found in~\cite{preisinger2007hexagon}.

We observe that given a node identifier $id$, one can identify the ids of the parents (resp. children) 
of its corresponding node by calling the two functions $InvID$ and $ID$.
To do so, we first determine the corresponding attribute combination of $id$. Then identify its parents' (resp. children) 
combinations by incrementing (resp. decrementing) the value of each attribute, and finally compute the id of each combination using the function $ID$.
TOP-DOWN starts by traversing the lattice from the top node of the lattice. At this node all attributes have the maximum possible value; then conducts
 a {\em BFS} over it while constructing the level $(i-1)$ nodes from the non-empty nodes at level $i$. A node in the lattice 
is dominated if either one of its parents is dominated or there exists a tuple in the relation that matches the combination of one of its parents.

Let $id$ denote the id of the node in the lattice currently scanned by TOP-DOWN. The algorithm first identifies the parents of the current node and checks if all of them (i) have been constructed (i.e. have not been dominated) and (ii) are marked as \textit{not present} (i.e., there is no tuple in $D_{\mathcal{Q}}$ that had the combination of one of its parents).
If so, the algorithm then checks if there exist tuples in $D_{\mathcal{Q}}$ with the same attribute value combination. We use the term \textit{querying a node} in order to refer to this operation. Algorithm~\ref{alg:topDownGetTuples} presents pseudocode of this operation for a specific attribute value combination. If no such tuple exists in $D_\mathcal{Q}$, it marks $id$ as \textit{not present} and moves to the element. Otherwise, it labels $id$ as \textit{present} and outputs the tuples, returned from GET-TUPLES, as the skyline. The TOP-DOWN algorithm queries a node only when the attribute value combination corresponding to the node is incomparable with the skylines discovered earlier. The algorithm stops when there are no other ids in its processing queue.

% we first compute the maximum level (for the binary attribute it's $|Q|$) and size of the corresponding lattice. We then create an array with length equal to the size of the lattice. Each element in the array corresponds to a node in the lattice, hence, represents a specific attribute value combination. Each node $u$ in the lattice has an unique $id$ assigned to it (\textcolor{red}{define in \S\ref{sec:background}}). This value is computed from the attribute value combination that $u$ represents (using function $ID(u)$) and used for indexing $u$ in the array. Initially, all the elements in the array are marked \textit{not visited}. We then start traversing the elements of the array in ascending order of their corresponding node's \textit{lattice level} value. Elements that are at the same level of the lattice are traversed in ascending order of their corresponding node's $id$.

%Let $e$ denotes an element in the array that TOP-DOWN is scanning currently. If $e$ is marked \textit{not present}, we first compute the attribute value combination corresponds to $e$. This is done by applying function $\inv{ID}$ (\textcolor{red}{define in \S\ref{sec:background}}) on the index of $e$. The algorithm then checks if there exist tuples in $D_{\mathcal{Q}}$ with the same attribute value combination. We use the term \textit{query a node} in order to refer to this operation. Algorithm for \textit{querying a node} for a specific attribute value combinations is described in Algorithm~\ref{alg:topDownGetTuples}. If no such tuple exists in $D_\mathcal{Q}$, we mark $e$ as \textit{not present} and move to the element. Otherwise, we label $e$ as \textit{present} and elements in array that are dominated by $e$ are marked \textit{dominated}. In addition, we output the tuples returned by GET-TUPLES as the skyline. This is because TOP-DOWN algorithm queries a node only when the attribute value combination corresponding to the node is incomparable with the skylines discovered earlier. The algorithm stops when all the remaining elements in the array are marked \textit{dominated}.

\begin{algorithm}[htb]
\caption{{\bf GET-TUPLES}}
\begin{algorithmic}[1]
\label{alg:topDownGetTuples}
\STATE {\bf Input:} Array $values$, Sorted lists $\mathcal{L_Q}$; 
\STATE {\bf Output:} List of tuples that have the same attribute value assignment as $values$.
\STATE $tupleIDSet = \emptyset$
\STATE {\bf for} $i = 1$ to $len(values)$ {\bf do}
    \STATE \hindent[2] $currValue = values[i]$
    \STATE \hindent[2] $currtupleIDSet = $ Get all tupleIDs from $L_i \in \mathcal{L_Q}$ that has value $currValue$
    \STATE \hindent[2] $tupleIDSet = tupleIDSet \cap currtupleIDSet$

\STATE $tupleList = [\,]\,$
\STATE {\bf for} $tupleID$ in $tupleIDSet$ {\bf do}
    \STATE \hindent[2] Construct new tuple $t_{new}$ with attribute values same as $values$ and $t[tupleID] = tupleID$
    \STATE \hindent[2] $tupleList.append(t_{new})$
\STATE {\bf return} $tupleList$;
\end{algorithmic}
\end{algorithm}

The lattice structure for the subspace skyline query $\mathcal{Q}$ in Example~\ref{exmp:subspaceSkyline} is shown in Figure~\ref{fig:latticeTopDown}. Each node $u$ in the lattice represents a specific attribute value assignment in the data space corresponding to $\mathcal{Q}$. For example, the top-most node in the lattice represents a tuple $t$ with all the attribute values 1 (i.e., $t[A_i] = 1, \forall A_i \in \mathcal{Q}$). We start from the top node of the lattice. No tuple in $D_{\mathcal{Q}}$ has value 1 on all the attributes in $\mathcal{Q}$. Therefore, TOP-DOWN marks this node \textit{not present (np)}. We then move to the next level and start scanning nodes from the left. There exists a tuple $t_6 \in D_\mathcal{Q}$ with attribute values $\langle 1, 1, 1, 0 \rangle$. Hence, we mark this node \textit{present (p)} and output $t_6$ as skyline. 
%Nodes in the lattice that are dominated by current node $\langle 1, 1, 1, 0 \rangle$, are marked \textit{dominated (d)}. If we reach a node in that lattice that is already dominated by some other node scanned earlier, TOP-DOWN skip querying that node. 
The algorithm stops after querying node $\langle 0, 1, 0, 1 \rangle$. % stop traversing the lattice further since all the remaining nodes in the lattice are marked \textit{dominated (d)}. Nodes for which we have to perform query over the $\mathcal{L_Q}$ are marked \textit{p}, and \textit{np} (colored in grey).
TOP-DOWN only needs to query 6 nodes (i.e., check 6 attribute value combinations) in order to discover the skylines. Note that the number of nodes queried by TOP-DOWN is proportional to the number of attributes in $\mathcal{Q}$ and inversely proportional to the relation size $n$. This is because with large $n$ and small $|\mathcal{Q}|$, the likelihood of having tuples in the relation that correspond to the upper-level nodes of the lattice is high.

\vspace{1mm}
\noindent{\bf Algorithm GET-TUPLES:} The algorithm to retrieve tuples in the relation matching the attribute value combination of a specific node is described in Algorithm~\ref{alg:topDownGetTuples}. The algorithm accepts two inputs: (1) $values$ array representing the value of each attribute $A_i \in \mathcal{Q}$, and (2) Sorted lists $\mathcal{L_Q}$. For each attribute $A_i \in \mathcal{Q}$ ($1 \leq i \leq m'$), the algorithm retrieves the set of tupleIDs $S_i$, that have value equals $values[i]$. This is done by performing a search operation on sorted list $L_i$. %\textcolor{red}{Gautam: need a bit more explanation. why B-tree? how are various sorted list operations implemented in B-Trees, and what is their complexity? Maybe even move this to prelim section?}\textcolor{red}{Farhad will add~\cite{chaudhuri2004probabilistic} as ref. and move this to prelim/exp. section.} 
The set of tupleIDs that are discovered in every $S_i$ are the ids of the tuple that satisfy the current attribute value combination. We identify 
these ids by performing a set intersection operation among all the $S_i$s ($1 \leq i \leq m'$). Once the ids of all the tuples that match 
values of array $values$ are identified, the algorithm creates tuples for each id with the same attribute value and returns the tuple list.

\begin{algorithm}[!htb]
\caption{{\bf TOP-DOWN}}
\begin{algorithmic}[1]
\label{alg:st}
\STATE {\bf Input:} Query $\mathcal{Q}$, Sorted lists $\mathcal{L_Q}$; \\ {\bf Output:} $\mathcal{S}_\mathcal{Q}$.
%\STATE $L_\mathcal{Q} = \{L_i | A_i \in \mathcal{Q}\}$
\STATE $processed = \emptyset$;
\STATE $C = $ the attribute combination of $\mathcal{Q}$ with maximum possible value for each attribute
\STATE addQ$(queue,ID(C))$
\STATE {\bf while} $queue$ is not empty {\bf do}
    \STATE \hindent $id =$ delQ$(queue)$
    \STATE \hindent {\bf for} $pid$ in parents$(InvID(id))$
        \STATE \hindent[2] {\bf if} $pid\notin processed$ or $pid$ is marked as present
            \STATE \hindent[3] {\bf continue} {\it //skip this node}
    \STATE \hindent $tupleList = $ GET-TUPLES($values, L_\mathcal{Q}$)        
    \STATE \hindent {\bf if} $len(tupleList) == 0$:
        \STATE \hindent[2] append $processed$ by $\langle id,$\textit{not present}$\rangle$
        \STATE \hindent[2] $children = $ children$(InvID(id))$
        \STATE \hindent[2] {\bf for} $c\in children$
            \STATE \hindent[3] {\bf if} $c$ is not in $queue$: addQ$(queue,c)$
    \STATE \hindent {\bf else}:
        \STATE \hindent[2] append $processed$ by $\langle id,$\textit{present}$\rangle$
        \STATE \hindent[2] Output all the tuples in $tupleList$ as skyline.    
\end{algorithmic}
\end{algorithm}

\vspace{1mm}
\subsubsection{Performance Analysis}\label{sec:TOP-DOWN-performance}
For each non-dominated node in the lattice, the TOP-DOWN algorithm invokes the function GET-TUPLES. Hence, we measure the cost of TOP-DOWN as the number of nodes in the lattice for which we invoke GET-TUPLES, times the cost of executing GET-TUPLES function.
Since the size of all sorted lists is equal to $n$, applying binary search on the sorted lists to obtain tuples with a specified value 
on attribute $A_i$ requires $O(\log(n))$; thus the retrieval cost from all the $m'$ lists is $O(m'\log(n))$. Still taking the intersection between the lists is in $O(nm')$, which makes the worst case cost of the GET-TUPLES operation to be $O(nm')$. %and using the set operations to take the intersect among them is 
%In GET-TUPLES, we need to perform $m'$ B-Tree traversal (\textcolor{red} {Gautam: what is ``b-tree traversal''? why does it cost O(n)?}, one for each sorted list $L_i \in \mathcal{L_Q}$ and $m'$ set intersection operation. The execution time of both of these operations is $O(n)$. Therefore, the time complexity of GET-TUPLES function is $O(m'n)$.
Let $k$ be the cost of GET-TUPLES operation over $\mathcal{L_Q}$, for the given relation $D$.
%Given a database with fixed number of tuples $n$, let us assume the cost of querying over $\mathcal{L_Q}$ is constant $k$. \textcolor{red} {Gautam: explain why this assumption of ``fixed'' n and ``constant'' k.}
Moreover, considering $p_i$ as the probability that a tuple has value $1$ on the binary attribute $A_i$, we use $C(l)$ to refer to the expected cost of
 TOP-DOWN algorithm starting from a node $u$ at level $l$ of the lattice. %\textcolor{red} {Gautam: so far in the discussion, you have not explained that the database is generated randomly. So the words  ``expected cost'', ``probability'' etc. are not clear. Also, here you use Cost(l), while in the theorem below you use C(l).} Moreover, consider $p_{!\emptyset}(l)$ be the probability of finding a tuple $t \in \mathcal{D_Q}$ that corresponds to the attribute value combination of $u$.

\begin{theorem}\label{thm:expectedCostTopDown}
Consider a boolean relation $D$ with $n$ tuples and the probability of having value 1 on attribute $A_i$ being $p_i$, and a subspace skyline query $\mathcal{Q}$ with $m'$ attributes. The expected cost of TOP-DOWN on $D$ and $\mathcal{Q}$ starting from a node at level $l$ is described by the following recursive forumula:
\begin{small}
\begin{align}\label{eq:expectedCostTopDown}
\nonumber
C(m') &= k/m'\\
C(l) &= 
\begin{cases}
    k +  (1-p_{!\emptyset}(l)) m' C(l+1) & \quad \text{if } l = 0\\
    \frac{1}{l} \{ k + (1-p_{!\emptyset}(l) (m'-l) C(l+1) \} & \quad \text{otherwise}\\
\end{cases}
\end{align}
\end{small}
\hspace{-1mm}where $p_{!\emptyset}(l) = 1 - (1 - \prod_{i=1}^{l}(1-p_i)\prod_{i=1}^{m'-l}p_i ) ^ n$.
\end{theorem}

\begin{proof}
Consider a node $u$ at level $l$ of the lattice. Node $u$ represents a specific attribute value assignment with $l$ number of 0s and $(m' - l)$ number of 1s. Querying at node $u$ will return all tuples in dataset that have the same attribute value assignment as $u$. Let $p(t, l)$ be the probability of a tuple $t \in \mathcal{D_Q}$ having $l$ number of 0s and $(m' - l)$ number of 1s.

\begin{align}
p(t, l) = \prod\nolimits_{i=1}^{l}(1-p_i)\prod\nolimits_{i=1}^{m'-l}p_i
\end{align}

If querying at node $u$ returns at-least one tuple then we do not need to traverse the nodes dominated by $u$ anymore. However, if there exists no tuple in $D_{\mathcal{Q}}$ that corresponds to the attribute value combination of $u$, we at-least have to query the nodes that are immediately dominated by $u$. Let $p_{!\emptyset}(l)$ be the probability that there exists a tuple $t \in D_{\mathcal{Q}}$ that has the same attribute value assignment as $u$. Then,

\begin{align}
p_{!\emptyset}(l) = 1 - (1 - \prod_{i=1}^{l}(1-p_i)\prod_{i=1}^{m'-l}p_i ) ^ n
\end{align}

There are total $(m' - l)$ number of nodes immediately dominated by $u$. Therefore, Cost at node $u$ is the cost of query operation (i.e., $k$) plus with $(1 - p_{!\emptyset}(l))$ probability the cost of querying its $(m'-l)$ immediately dominated nodes.

\begin{align}
C(l) = k +  (1-p_{!\emptyset}(l)) (m' - l) C(l+1)
\end{align}

Note that a node $u$ at level $l$ has total $l$ number of immediate dominators causing the cost at node $u$ to be computed $l$ times. However, TOP-DOWN only needs to perform only one query at node $u$. Hence, the actual cost can be obtained by dividing the computed cost with value $l$.
\end{proof}


\begin{figure}[!h]
  \centering
  \includegraphics[scale=.60]{figures/expectedCostTopDown.pdf}
  \vspace{-4mm}\caption{Expected number of nodes queried vs. query length}
  \label{fig:performanceTopDown}
\end{figure}


\noindent{\bf Limitation:}
We use Equation~\ref{eq:expectedCostTopDown} to compute $|C(l)|$ as a function of $|\mathcal{Q}|$ over three uniform relations containing one million tuples with cardinality 2, 4, and 6 respectively. The expected cost increases exponentially as we increase the query length. Moreover, the expected cost also increases when the attributes in $\mathcal{Q}$ have higher cardinality.
%\textcolor{red} {Gautam: explain why you need to use a simulation.}



\section{Proofs}\label{sec:appendixProof}
In this section, we provide detailed proofs for the theorems from the main section of the paper.

\textsc{Theorem~\ref{thm:expectedCostSTISDominated}.} {\em
Considering a relation with $n$ binary attributes where $p_i$ is the probability that a tuple has value 1 on attribute $A_i$, the expected cost of IS-DOMINATED($t_\mathcal{Q}$) operation on a tree $T$, containing $s$ tuples is as specified in Equation~\ref{eq:expectedCostSTISDominated}.
}

\begin{proof}
Consider $t$ be the tuple for which we have to check if it is dominated. IS-DOMINATED stops the recursion when we reach a leaf node or move to a node that is empty (i.e., has no tuple mapped under it). Therefore, $C(m', s) = 1$ and $C(l, 0) = 1$.

Let us assume that we are in node $u$ at level $l$ of the tree and there are $s$ tuples mapped in the subtree rooted at $u$. 

If $t[A_l] = 0$, IS-DOMINATED first searches in the right subtree. If no tuple $t'_\mathcal{Q}$ in the right subtree dominates $t_\mathcal{Q}$, we then move to the left subtree. Let us assume the right subtree of $u$ contains $s_{right}$ number of tuples ($s_{right} \leq s$). Let $S(l, s_{right})$ be the probability that there exists a tuple in the right subtree of $u$ containing $s_{right}$ tuples that dominates $t_\mathcal{Q}$. In order for a tuple $t'_\mathcal{Q}$ to dominate $t_\mathcal{Q}$, it must have at-least value 1 on the attributes in $\mathcal{A}_{ones(t[l+1:m'])}$. This is because, since $t'[A_i] \geq t[A_i]$ ($1 \leq i \leq l-1$) and $t'[A_l] > t[A_l]$, having value 1 on attributes in $\mathcal{A}_{ones(t[l+1:m'])}$ is enough for $t'_\mathcal{Q}$ to dominate $t_\mathcal{Q}$. Hence, the probability of $t'_\mathcal{Q}$ dominating $t_\mathcal{Q}$ is $\prod\nolimits_{i=1}^{|\mathcal{A}_{ones(t[l+1:m'])}|}p_i$. Therefore,

\begin{align}
    S(l, s_{right}) = 1 - (1 - \prod\nolimits_{i=1}^{|\mathcal{A}_{ones(t[l+1:m])}|}p_i)^{s_{right}}
\end{align}

The expected cost of IS-DOMINATED, when $t[A_l] = 0$ is then,
\begin{align}
    (1- S(l, s_{right})) C(l+1, s-s_{right}) + C(l+1, s_{right})
\end{align}

If $t[A_l] = 1$, IS-DOMINATED will always search in the right subtree. Hence, the expected cost when $t[A_l] = 0$ is,
\begin{align}
    C(l+1, s_{right})
\end{align}

A node at level-$l$ containing $s$ tuples under it with the probability of having 1 on attribute $A_l$ being $p_l$, the left subtree will have $i$ tuples with the binomial probability ${s \choose i} (1-p_l)^i p_l^{s-i}$. Hence, expected cost node $u$, $C(l, s)$ is,

\begin{align}
\nonumber
1 + \sum_{i=0}^s {s \choose i} & (1-p_l)^i p_l^{s-i} ( C(l+1, s-i) + \\
                               & (1-p_l)(1-S(l, s-i))C(l+1, i))
\end{align}
\end{proof}



\textsc{Theorem~\ref{thm:expectedCostSTPruneDominatedTuples}.} {\em
Given a boolean relation $D$ with $n$ tuple and the probability of having value 1 on attribute $A_i$ being $p_i$, the expected cost of PRUNE-DOMINATED-TUPLES($t_\mathcal{Q}$) operation on a tree $T$, containing $s$ tuples is as computed in Equation~\ref{eq:expectedCostSTPruneDominatedTuples}.
}


\begin{proof}
PRUNE-DOMINATED-TUPLES($t_\mathcal{Q}$) stops the recursion when we reach a leaf node or move to a node that is empty (i.e., has no tuple mapped under it). Therefore, $C(m', s) = 1$ and $C(l, 0) = 1$.

Suppose we are in node $u$ at level $l$ of the tree and there are $s$ tuples mapped in the subtree rooted at $u$. 

If $t[A_l] = 0$, we need to search only in the left subtree. Whereas, for $t[A_l] = 1$ we need to search both the left and right subtree.

Let $p_l$ be the probability of having value $1$ on attribute $A_l$. The left subtree of node $u$ at level $l$ (with $s$ tuples under it) will have $i$ tuples with the binomial probability ${s \choose i} (1-p_l)^i p_l^{s-i}$. Hence, expected cost at node $u$, $C(l, s)$, is:

\begin{align}
\nonumber
1 + \sum_{i=0}^s {s \choose i}(1-p_l)^i & p_l^{s-i} ( (1 - p_l)C(l+1, i) +\\
                                & p_l (C(l+1, i) + C(l+1, s-i) ) )
\end{align}
\end{proof}

\textsc{Lemma~\ref{lemma:expectedDiscovery}.} {\em
Considering $p_i$ as the probability that a tuple has value 1 on the binary attribute $A_i$, the expected number of tuples discovered by TA-SKY after iterating $i$ lines is as computed in Equation~\ref{eq:expectedDiscovery}.
}
\begin{proof}
The probability that a tuple $t$ is discovered by iterating $i$ rows is one minus the probability that $t$ is not discovered in any of the $m^\prime$ lists in $\mathcal{L_Q}$. Formally:
\begin{align}
P_{seen}(t,i) = 1 - \Pi_{j=1}^{m^\prime} P_{!seen}(t,i,L_j)
\end{align}
where $P_{!seen}(t,i,L_j)$ is the probability that $t$ is not discovered at list $L_j$ until row $i$.
$P_{!seen}(t,i,L_j)$ depends on the number of $(tupleId, value)$ pairs with value $1$ in list $L_j$. A list $L_j$ has $k$ number of $(tupleId, value)$ pairs with value $1$ if the database has $k$ tuples with value $1$ on attribute $A_j$, while others have value $0$ on it. Thus, the probability that $L_j$ has $k$ number of $(tupleId, value)$ pairs with value $1$:
\begin{align}
P_{L_j}(k) = {n\choose k}(1-p_j)^{n-k}p_j^k
\end{align}
$t$ is not seen until row $i$ at list $L_j$ if either of the following cases happen:
\begin{itemize}
\item $t[A_j] = 0$ and (considering the random positioning of tuples in lists) $t$ is located after position $i$ in list $L_j$ for all the cases that $L_j$ has $k \, (k < i)$ number of $(tupleId, value)$ pairs with value $1$. %\textcolor{red}{if $k \geq i$, probability of not seeing $t$ after iteration $i$ is $1$.[abol: this is already considered by saying that (i) the list only has the tupleids of the tuples that have value 1 on that attribute and (ii) plugging the list length in the analysis! So I believe the current analysis for this component is wrong and should get rolled back to what it was. We can discuss if it is not clear.]} 
\item $t[A_j] = 1$ and (considering the random positioning of tuples in lists) $t$ is located after position $i$ in list $L_j$ for all the cases that $L_j$ has $k \, (k > i)$ number of $(tupleId, value)$ pairs with value $1$.
\end{itemize}
Thus:
\begin{align}
\nonumber
&P_{!seen}(t,i,L_j) = \\ 
&(1 - p_j) \Big(\sum_{k=0}^{i-1}P_{L_j}(k)\frac{n-i}{n-k} + \sum_{k=i}^{n}P_{L_j} \Big) + p_j\sum_{k=i+1}^n P_{L_j}(k) \frac{k-i}{k}
\end{align}
We now can compute $P_{seen}(t,i)$ as following:
\begin{align}
\nonumber
&P_{seen}(t,i) = \\
&1 - \prod_{j=1}^{m^\prime} \bigg( (1 - p_j) \Big(\sum_{k=0}^{i-1}P_{L_j}(k)\frac{n-i}{n-k} + \sum_{k=i}^{n}P_{L_j} \Big) +\\ \nonumber &p_j\sum_{k=i+1}^n P_{L_j}(k) \frac{k-i}{k} \bigg)
\end{align}
Having the probability of a tuple being discovered by iterating $i$ lines, the expected number of tuples discovered by iterating $i$ lines is:
\begin{align}
\nonumber
&E_{seen}[i] = n P_{seen}(t,i) = \mbox{ Equation~\ref{eq:expectedDiscovery}}
\end{align}
\end{proof}




\textsc{Theorem~\ref{thm:expectedCostTA-SKY}.} {\em
Given a subspace skyline query $\mathcal{Q}$, the expected number of sorted access performed by TA-SKY on a $n$ tuple boolean database with probability of having value $1$ on attribute $A_j$ being $p_j$ is,
\begin{align*}
m^\prime \sum_{i=1}^n i\times P_{stop}(i)
\end{align*}
where $P_{stop}(i)$ is computed using Equations~\ref{eq:stopi-1},~\ref{eq:stopi-2}, and~\ref{eq:stopi-3}.
}

\begin{proof}
Let us first compute the probability that algorithm stops after visiting $i$ rows of the lists. Please note that the algorithm checks the stopping condition at iteration $i$ if $cv_{ij} = 0$ for at least one sorted list. Thus the algorithm stops when (1) $cv_{ij} = 0$ for at least one sorted list AND (2) there exists a tuple among the discovered ones that dominates the maximum possible tuple in the remaining lists.

Suppose $i^\prime$ tuples have seen at least in one of the list so far. Using Lemma~\ref{lemma:expectedDiscovery} we can set $i^\prime = E_{seen}[i]$. Let $P_{j0}(i)$ be the probability that $cv_{ij} = 0$ for sorted list $L_j$.
\begin{align}
P_{j0} = (1 - p_j)^{n-i}
\end{align}

Moreover, Consider $P_0(i, k)$ be the probability that after iteration $i$, $cv_i = 0$ for $k$ sorted lists and $\mathcal{Q}_k$ is corresponding attribute set. Therefore,
\begin{align}
P_0(i, k) = {m^\prime \choose k} \prod_{A_j \in \mathcal{Q}_k} P_{j0} \prod_{A_j \in \mathcal{Q} \setminus \mathcal{Q}_k} (1 - P_{j0})
\end{align}

For a given setting that $cv_i = 0$ for $k$ sorted lists, the algorithm stops, {\it iff} there exists at least one tuple among the discovered ones that dominate the maximum possible value in $m'$ sorted lists; i.e. the value combination that has $0$ in $k$ and $1$ in all the remaining $m^\prime - k$ positions.

A tuple $t$ need to have the value $1$ in all the $m^\prime - k$ list and also \emph{at least one value $1$ in one of the $k$ lists ($\mathcal{Q}_k$)} to dominate the maximum possible remaining value. The probability that a given tuple satisfies this condition is:
\begin{align}
P_{stop}(t, \mathcal{Q}_k) = \underset{\forall A_j \in \mathcal{Q}\backslash \mathcal{Q}_k} {\Pi} p_j (1-\underset{\forall A_j \in \mathcal{Q}_k} {\Pi} (1 - p_j))
\end{align}
Thus, the probability of having at least one tuple that satisfies the dominating condition is:
\begin{align}
P_{dominate}(i, k) = {m^\prime \choose k} \times (1 - (1 - P_{stop}(t, \mathcal{Q}_k))^{i^\prime})
\end{align}

We now can compute the probability distribution of the algorithm cost as following:
\begin{align}
P_{stop}(i) = \sum_{k=1}^m P_0(i, k) \times P_{dominate}(k)
\end{align}

Finally, the expected number of sorted access performed by TA-SKY is:
\begin{align}
m^\prime \sum_{i=1}^n i\times P_{stop}(i)
\end{align}
\end{proof}