
% INTRO

% However, that is not the case, since the rise of these free model databases means unclean models with lack of semantic annotation.  While semantically aware software relies on these annotation.  In addition, it's difficult to hand specify and label all the semantic relationship between objects (give some example).  Our solution: use data driven methods (cite some work?) to learn priors for objects (so we can auto-annotate some important parts, perhaps this is too overreaching) and priors for object to object relationships in scenes. Propose using the learned priors to provide context based autosuggestion for 3D scene design software. (briefly mention how we extend and go beyond ClutterPalette - something short, forceful that makes us sound infinitely better)

%(point out that for the computer to help humans with scene design, a lot of manual annotation is required. Much of the prior works assumes these manual annotation - which is simply not available, or private assets. recently some work using statistics for scene design - enabling automated generated, only a couple of papers exploring how the statistics can be used for interactive scene design).

% LEARNING


%\todo{Mention that for priors based on scene type, we have a dummy ``All'' scene type.  If scene type provided, use statistics for scene type, otherwise for ``All''.  All our scenes are interior ``Room''s so ``All'' would be equivalent to generic ``Room''.}  

%\paragraph{Object Occurrence Priors}
%Occurrence priors are given by simple Bayesian statistics of objects occurring in scenes: $P_\textit{occ}(C_{o}|C_{s}) = \frac{\text{count}(C_{o} \text{~in~} C_{s})}{\text{count}(C_{s})}$

%\paragraph{Support Hierarchy Priors}
%We estimate the probability of a object category $C_c$ occurring in a scene of type $C_s$ and being supporting by a given support parent category $C_p$ as a simple conditional probability based on normalized observation counts:
 
%$P_\textit{occ}(C_{c}|C_{p}, C_{s}) = \frac{\text{count}(C_{c} \text{~on~} C_{p} \text{~in~} C_{s})}{\text{count}(C_{p} \text{~in~} C_{s})}$
