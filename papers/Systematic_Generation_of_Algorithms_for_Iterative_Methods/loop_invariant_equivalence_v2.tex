\section{Equivalence of Loop Invariants}
\label{sec:equivalence}

For direct methods, one observes that finer partitionings lead to additional loop invariants. A finer partitioning here means that we partition along one dimension in more than the usual two parts. Some of those loop invariants lead to truly new algorithms that cannot be derived with a coarser partitioning. Intuitively, one can say that those algorithms expose intermediate steps that are not exposed with a coarser partitioning. Others are in some sense redundant, because they lead to algorithms that are computationally equivalent to algorithms derived from different loop invariants. We then consider those loop invariants to be equivalent. Those loop invariants may or may not have the same granularity. This means that two loop invariants from a $3 \times 3$ partitioning can be equivalent, but it is also possible that a $2 \times 2$ loop invariant is equivalent to a loop invariant obtained from a $3 \times 3$ partitioning.

This is relevant for the derivation of algorithms for iterative methods because we compare different partitionings in Section \ref{sec:MatrixRepresentationPartitionings}. Even more important, the partitioning that is used for iterative methods behaves differently in this regard, as discussed in Section \ref{sec:RemarkEquivalence}.

In this section, we show what equivalence means in this context and under which conditions this behavior occurs. We begin by introducing the notion of equivalence for algorithms and then extend the results to loop invariants.

\subsubsection{Equivalence of Algorithms}

The triangular continuous-time Sylvester equation, which will serve as an example, is defined as $AX+XB=C$ with $A$ and $B$ being triangular. In the following, we assume A and B to be lower and upper triangular, respectively:
%The triangular continuous-time Sylvester equation, which will serve as an example, is defined as follows:
%
$$X:= \Psi ( A, B, C) \equiv
\left\{
\begin{aligned}
P_\text{pre}: \{ &\text{\ttfamily Input}[A] \land \text{\ttfamily Matrix}[A] \land \text{\ttfamily LowerTriangular}[A] \land \\
		&\text{\ttfamily Input}[B] \land \text{\ttfamily Matrix}[B] \land \text{\ttfamily UpperTriangular}[B] \land \\
		&\text{\ttfamily Input}[C] \land \text{\ttfamily Matrix}[C] \land \\
		&\text{\ttfamily Output}[X] \land \text{\ttfamily Matrix}[X] \} \\
P_\text{post}: \{ &AX + XB = \hat{C} \}
\end{aligned}
\right.$$
%
Applying a $1 \times 3$ partitioning to $X$ results in the following PME:
%
$$
\myFlaOneByThree{
X_L = \Psi(A, B_{TL}, \hat{C}_L)}
%
{\begin{aligned}
X_M = \Psi(&A, B_{MM}, \\
&\hat{C}_M - X_L B_{TM})
\end{aligned}}
%
{\begin{aligned}
X_R = \Psi(&A, B_{BL}, \\
&\hat{C}_R - X_L B_{TR} - X_M B_{MR})
\end{aligned}}
$$
%
At this point, we introduce a new notation for loop invariants taken from \cite{Fabregat-Traver:thesis}. Instead of a logical predicate, the PME is used, leaving out those (sub)expressions that are not part of the loop invariant. If entire blocks are not included, we use the symbol $\neq$ to express that no constraints are imposed on this part. We now choose the following two loop invariants and derive the corresponding updates, skipping the intermediate steps.
%
\begin{align*}
&P_\text{inv} = \myFlaOneByThree{X_L = \Psi(A, B_{TL}, \hat{C}_L)}	{\neq}	{\neq}\\
&P_\text{inv}' = \myFlaOneByThree{X_L = \Psi(A, B_{TL}, \hat{C}_L)}	{X_M = \Psi(A, B_{MM}, \hat{C}_M - X_L B_{TM})}	{\neq}
\end{align*}
%
The updates are for $P_\text{inv}$ and $P_\text{inv}'$ are:
%
\begin{align*}
P_\text{inv}: C_1 &:= \hat{C}_1 - X_0 B_{01}\\
X_1 &:= \Psi(A, B_{11}, C_1) \\
P_\text{inv}': C_2 &:= \hat{C}_2 - X_0 B_{02} - X_1 B_{12} \\
X_2 &:= \Psi(A, B_{22}, C_2)
\end{align*}
%
Obviously, the updates for $X_1$ and $X_2$ only differ in the indices, which are shifted by one. $B_{22}$ is  the next block following $B_{11}$ on the main diagonal of $B$, and $C_2$ is the next set of columns following $C_1$ in $C$. Considering that those updates happen inside a loop, as the computation unfolds, they will both point to the same parts of $B$ and $C$, respectively.

Written as above, the updates for $C$ do not immediately appear equivalent. Using BLAS operations, $C_1$ would be updated with one call to GEMM, $C_2$ with two. However, when we rewrite the update for $C_2$ as follows, it is easy to see that it is equivalent to just one GEMM operation.
%
$$C_2 := \hat{C}_2 - \myFlaOneByTwo{X_0}{X_1} \myFlaTwoByOne{B_{02}}{B_{12}}$$
%
Similarly to $C_1$ and $C_2$, $X_0$ and $\myFlaOneByTwo{X_0}{X_1}$ will, at some point during the computation, contain the same parts of $X$. The same is true for $B_{01}$ and $$\myFlaTwoByOne{B_{02}}{B_{12}}\text{.}$$ Hence, we consider both algorithms to be equivalent. Note that in general, the equivalence can be much less obvious, requiring much more elaborate rewriting.

In the example above, it is easy to see that simply by replacing quantities in one update with the corresponding quantities of the other update, it is possible to transform one update into the other. The only constraint is that if one quantity replaces another, both must have matching sizes. Since we do not specify any concrete dimension and the size of some parts changes during the computation, we have to compare them using a symbolic representation of those sizes. Let us begin with listing the dimensions of all operands of the Sylvester equation:
%
\begin{itemize}
\item[-] $X$ and $C$ are of size $n \times m$.
\item[-] $A$ is of size $n \times n$.
\item[-] $B$ is of size $m \times m$.
\end{itemize}
%
After the repartitioning, we specify the sizes as follows.
%
%$$AX + XB = C$$
%
%
\renewcommand{\kbldelim}{(}
\renewcommand{\kbrdelim}{)}
%
$$
\kbordermatrix{
& b i & \omit & b & \omit & b & \omit & b j + c \\
n & X_0 & \omit\vrule & X_1 & \omit\vrule & X_2 & \omit\vrule & X_3
}
$$
%
$$
\kbordermatrix{
& b i & \omit & b & \omit & b & \omit & b j + c \\
n & C_0 & \omit\vrule & C_1 & \omit\vrule & C_2 & \omit\vrule & C_3
}
$$
%
$$
\kbordermatrix{
& b i & \omit & b & \omit & b & \omit & b  j + c \\ 
b i & B_{00} & \omit\vrule & B_{01} & \omit\vrule & B_{02} & \omit\vrule & B_{03} \\ \cline{2-8}
b & 0 & \omit\vrule & B_{11} & \omit\vrule & B_{12} & \omit\vrule & B_{13} \\ \cline{2-8}
b & 0 & \omit\vrule & 0 & \omit\vrule & B_{22} & \omit\vrule & B_{23} \\ \cline{2-8}
b j + c & 0 & \omit\vrule & 0 & \omit\vrule & 0 & \omit\vrule & B_{33}
}
$$
%
$b$ is the block size, $b i$ and $b j$ are unspecified multiples of the block size. $c$ is an additional constant that is nonzero if the block size $b$ does not divide $m$ and/or $n$. Blocks with constant sizes, that is, any combination of $n$, $m$ and $b$, can only be replaced with blocks of the corresponding quantities that have the exact same sizes. For example, it is possible to replace $X_1$ with $X_2$, or $B_{22}$ with $B_{11}$.

Similarly, the dimensions have to match for quantities with variable sizes. If one dimension is a multiple of the block size, any other multiple of the block size matches. As an example, $b i$ matches $b i + b$, and $b j + c + 2b$ matches $b j + c$. It is important to note that $b i$ does not match $b$, because the former is variable, and the latter is constant. Thus, two valid replacements are:
%
\begin{align*}
B_{00} &\rightarrow \myFlaTwoByTwo{B_{00}}{B_{01}}{0}{B_{11}} \\
\myFlaOneByTwo{C_{2}}{C_{3}} &\rightarrow C_3
\end{align*}
%
Returning to the initial example, the replacement to transform the update for the loop invariant $P_\text{inv}$ into the one for the loop invariant $P_\text{inv}'$ is the following:
%
\begin{align*}
B_{01} &\rightarrow \myFlaTwoByOne{B_{02}}{B_{12}} \\
B_{11} &\rightarrow B_{22} \\
C_1 &\rightarrow C_2 \\
X_0 &\rightarrow \myFlaOneByTwo{X_0}{X_1} \\
X_1 &\rightarrow X_2
\end{align*}
%
%It should be noted that the method presented here is not constructive, that is, given two algorithms, it is 
%
%It should be noted that it is in general not easy to find a replacement that transforms one five loop invariant or algorithm into a 

\subsubsection{Equivalence of Loop Invariants}

As mentioned earlier, we consider two loop invariants to be equivalent if the resulting algorithms are equivalent. To determine this equivalence, however, it is not necessary to derive algorithms. The same method of replacing quantities can be performed directly on the loop invariants. If, with such a replacement, one loop invariant can be transformed into another one, both would result in the same update. Consequently, the loop invariants themselves are equivalent.

%To see that two loop invariants are equivalent, however, it is not necessary to deriver algorithms. The same method of replacing quantities can be performed on the loop invariants itself. If, by replacing quantities in one loop invariant and flattening the resulting expression, this loop invariant can be transformed into another one, both would result in the same update. 

%The same approach can be used to determine if two loop invariants result in the same update without even deriving that update. 

Let us demonstrate this for the loop invariants $P_\text{inv}$ and $P_\text{inv}'$. We choose the following replacements:
%
\begin{align*}
X_L &\rightarrow \myFlaOneByTwo{X_{L}}{X_{M}} \\
C_L &\rightarrow \myFlaOneByTwo{C_{L}}{C_{M}} \\
B_{TL} &\rightarrow \myFlaTwoByTwo{B_{TL}}{B_{TM}}{0}{B_{MM}}
\end{align*}
%
Applying those to the loop invariant
%
$$P_\text{inv} = \myFlaOneByThree{X_L = \Psi(A, B_{TL}, \hat{C}_L)}	{\neq}	{\neq}\text{,}$$
%
the equation for computing $X_L$ becomes
%
$$\myFlaOneByTwo{X_{L}}{X_{M}} = \Psi \left(A,\myFlaTwoByTwo{B_{TL}}{B_{TM}}{0}{B_{MM}}, \myFlaOneByTwo{\hat{C}_{L}}{\hat{C}_{M}} \right) \text{.}$$
%
Flattening the expressions, we obtain the second loop invariant, $P_\text{inv}'$:
%
$$P_\text{inv}' = \myFlaOneByThree{X_L = \Psi(A, B_{TL}, \hat{C}_L)}	{X_M = \Psi(A, B_{MM}, \hat{C}_M - X_L B_{TM})}	{\neq}$$
%
\subsubsection{Equivalence of Loop Invariants of Different Granularities}

The presented method of term rewriting can also be used to decide whether an algorithm or loop invariant is equivalent to a different one obtained with a finer or coarser partitioning. So far, the quantities on both sides of the replacements originated from the same partitioned object. Now, each operand is partitioned twice, using partitionings of two different granularities. Parts obtained from one are replaced with parts of the other. %In addition to that, both partitionings have to use the same block size $b$.
Apart from that, exactly the same rules for the replacement hold.

We demonstrate this with a more involved example: The inverse of a lower triangular matrix. A $2 \times 2$ partitioning yields the following PME, using $\tilde{X}$ and $\tilde{L}$ to avoid confusion:
%
\begin{align}
\myFlaTwoByTwo	{\tilde{X}_{TL} := \tilde{L}_{TL}^{-1}}				{0}
				{\tilde{X}_{BL} := -\tilde{L}_{BR}^{-1} \tilde{L}_{BL} \tilde{X}_{TL}}	{\tilde{X}_{BR} := \tilde{L}_{BR}^{-1}} \label{eq:PME:loTriInv}
\end{align}
%
This is the $3 \times 3$ PME:
%
$$
\myFlaThreeByThree{X_{TL} := L_{TL}^{-1}}				{0}					{0}
				{X_{ML} := -L_{MM}^{-1} L_{ML} X_{TL}}	{X_{MM} := L_{MM}^{-1}}	{0}
				{X_{BL} := -L_{BR}^{-1} L_{BM} X_{ML} -L_{BR}^{-1} L_{BL} X_{TL}}		{X_{BM} := -L_{BR}^{-1} L_{BM} X_{MM}}	{X_{BR} := L_{BR}^{-1}}
$$
%
We will show that the two loop invariants below are equivalent:
%

\vspace{8pt}
%\begin{centering}
\begin{tabular}{cc}
$\myFlaTwoByTwo	{\tilde{X}_{TL} := \tilde{L}_{TL}^{-1}}				{0}
				{\tilde{X}_{BL} := -\tilde{L}_{BR}^{-1} \tilde{L}_{BL} \tilde{X}_{TL}}	{\neq}$ &
$\myFlaThreeByThree{X_{TL} := L_{TL}^{-1}}				{0}					{0}
				{X_{ML} := -L_{MM}^{-1} L_{ML} X_{TL}}	{\neq}	{0}
				{X_{BL} := -L_{BR}^{-1} L_{BM} X_{ML} -L_{BR}^{-1} L_{BL} X_{TL}}		{\neq}	{\neq}$
\end{tabular}
%\end{centering}
\vspace{8pt}

%\begin{gather*}
%\myFlaTwoByTwo	{X_{TL} := L_{TL}^{-1}}				{0}
%				{X_{BL} := -L_{BR}^{-1} L_{BL} X_{TL}}	{\neq} 
%\myFlaThreeByThree{X_{TL} := L_{TL}^{-1}}				{0}					{0}
%				{X_{ML} := -L_{MM}^{-1} L_{ML} X_{TL}}	{\neq}	{0}
%				{X_{BL} := -L_{BR}^{-1} L_{BM} X_{ML} -L_{BR}^{-1} L_{BL} X_{TL}}		{\neq}	{\neq}
%\end{gather*}
%
To do so, we first need to choose an appropriate replacement. The replacement used in this example will transform the $2 \times 2$ loop invariant into the $3 \times 3$ loop invariant, so some parts of the coarser loop invariant will be replaced with multiple parts of the finer one.
%
\begin{align}
\tilde{X}_{TL} &\rightarrow X_{TL} \label{eq:replacement:XTL}\\
\tilde{L}_{TL} &\rightarrow L_{TL} \label{eq:replacement:LTL}\\
\tilde{X}_{BL} &\rightarrow \myFlaTwoByOne{X_{ML}}{X_{BL}} \label{eq:replacement:XBL}\\
\tilde{L}_{BL} &\rightarrow \myFlaTwoByOne{L_{ML}}{L_{BL}} \label{eq:replacement:LBL}\\
\tilde{L}_{BR} &\rightarrow \myFlaTwoByTwo{L_{MM}}{0}{L_{BM}}{L_{BR}} \label{eq:replacement:LBR}
\end{align}
%
To make sure that it is a valid replacement, it is necessary to check if the dimensions of the objects on both sides of the replacements match. The sizes of $L$, and likewise $X$, are as follows:
%
$$
\kbordermatrix{
& b i & \omit & b j + c \\
b i & \tilde{L}_{TL} & \omit\vrule &  0 \\ \cline{2-4}
b j + c & \tilde{L}_{BL} & \omit\vrule & \tilde{L}_{BR}
}
\qquad
\kbordermatrix{
& b i & \omit & b & \omit & b j + c \\
b i & L_{TL} & \omit\vrule & 0 & \omit\vrule & 0 \\ \cline{2-6}
b & L_{ML} & \omit\vrule & L_{MM} & \omit\vrule & 0 \\ \cline{2-6}
b j + c & L_{BL} & \omit\vrule & L_{BM} & \omit\vrule & L_{BR}
}
$$
The replacements (\ref{eq:replacement:XTL}) and (\ref{eq:replacement:LTL}) are easily seen to be correct, as all parts have size $bi \times bi$. In case of (\ref{eq:replacement:XBL}) and (\ref{eq:replacement:LBL}), the left-hand sides have the dimensions $(bj+c) \times b$, and the right-hand sides $(bj+c + b) \times b$. The number of rows matches because both are a multiple of the block size $b$, plus a constant $c$. Similarly, the last replacement (\ref{eq:replacement:LBR}) is valid, as the sizes $(bj+c) \times (bj+c)$ and $(bj+c + b) \times (bj+c + b)$ are equivalent.

Applying this replacement to the coarser loop invariant, we obtain two assignments:
%
\begin{align}
X_{TL} &:= L_{TL}^{-1} \\
\myFlaTwoByOne{X_{ML}}{X_{BL}} &:= -\myFlaTwoByTwo{L_{MM}}{0}{L_{BM}}{L_{BR}}^{-1} \myFlaTwoByOne{L_{ML}}{L_{BL}} X_{TL} \label{eq:loTriInv1}
\end{align}
%
Clearly, the first one already has the exact same shape as in the finer loop invariant. The second one, however, requires some rewriting. To be able to compute the product on the right-hand side, we first have to find the symbolic inverse of
%
$$\myFlaTwoByTwo{L_{MM}}{0}{L_{BM}}{L_{BR}}\text{.}$$
%
We obtain it from the PME of the inverse of a lower triangular matrix, (\ref{eq:PME:loTriInv}), by eliminating all occurrences of parts of $X$ and replacing the corresponding quantities:
%
$$\myFlaTwoByTwo{L_{MM}}{0}{L_{BM}}{L_{BR}}^{-1} = \myFlaTwoByTwo{L_{MM}^{-1}}{0}{-L_{BR}^{-1}L_{BM} L_{MM}^{-1}}{L_{BR}^{-1}}$$
%
Assignment (\ref{eq:loTriInv1}) then becomes
%
\begin{align}
X_{ML} &:= - L_{MM}^{-1} L_{ML} X_{TL} \label{eq:loTriInv2}\\
X_{BL} &:= L_{BR}^{-1}L_{BM} L_{MM}^{-1} L_{ML} X_{TL} - L_{BR}^{-1} L_{BL} X_{TL} \label{eq:loTriInv3}
\text{.}
\end{align}
%
The assignment for $X_{ML}$ is now identical to the one in the $3 \times 3$ loop invariant. While the assignments for $X_{BL}$ still differ, we observe that it is possible to replace a subexpression of (\ref{eq:loTriInv3}) with $- X_{ML}$:
%
$$X_{BL} := L_{BR}^{-1}L_{BM} \underbrace{L_{MM}^{-1} L_{ML} X_{TL}}_{- X_{ML}} - L_{BR}^{-1} L_{BL} X_{TL}$$
%
Thus, we obtain the following expression, which is the same as the assignment for $X_{BL}$ in the finer loop invariant:
%
$$X_{BL} := - L_{BR}^{-1}L_{BM} X_{ML} - L_{BR}^{-1} L_{BL} X_{TL}$$
%

%\todo{Address the question how to find those replacements? I'm not sure if there is a systematic way. Note that coarser $\rightarrow$ finer is in general a lot easier?}

%\todo{we could also use the PME of a lower triangular system}

%\subsubsection{Simplified Notation}
%
%\todo{include or not? not}
%
%It is even easier to decide whether two loop invariants are equivalent if in every block, either the entire expression is part of the loop invariant, or no constrains are imposed at all. Reconsider the loop invariant $P_\text{inv}$:
%%
%$$\myFlaOneByThree{X_L = \Psi(A, B_{TL}, \hat{C}_L)}	{\neq}	{\neq}$$
%%
%Instead of the expression, we simply write $=$, so the loop invariant becomes
%%
%$$\myFlaOneByThree{=}	{\neq}	{\neq}.$$
%%
%Similarly, $P_\text{inv}'$ is transformed into
%%
%$$\myFlaOneByThree{=}	{=}	{\neq}\text{.}$$
%%
%To see that those two loop invariants are equivalent, we replace $( = )$ with $( = \;\mid\; = )$ and $( \neq \;\mid\; \neq )$ with $( \neq )$ (or vice versa) to transform one loop invariant into the other. Again, the rules for the replacements remain the same, and this formalism also allows us to compare loop invariants of different granularities. The advantage is that it is much simpler to decide if a replacement is valid. All we have to do is to look at the sizes of the object that appears on the left hand side of the equations in the loop invariant. In our example, this is $X$. The sizes after partitioning are
%%
%$$
%\kbordermatrix{
%& b i & \omit & b & \omit & b j + c \\
%n & X_L & \omit\vrule & X_M & \omit\vrule & X_R
%}\text{,}
%$$
%%
%so $X_L$ can be replaced with $\myFlaOneByTwo{X_L}{X_M}$, and $\myFlaOneByTwo{X_M}{X_R}$ can be replaced with $X_R$.
%
%On the downside, this method can only be applied if both loop invariants include nothing but complete blocks. That is, it can not be applied to the following loop invariant:
%%
%$$\myFlaOneByThree{X_L = \Psi(A, B_{TL}, \hat{C}_L)}	{\hat{C}_M - X_L B_{TM}}	{\neq}$$