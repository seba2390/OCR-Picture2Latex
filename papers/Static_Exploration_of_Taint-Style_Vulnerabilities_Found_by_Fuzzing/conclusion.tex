Fuzzing is a time-tested technique for discovering taint-style vulnerabilities in software.
However, fuzzing is mainly limited by test coverage, and the availability of fuzzable test cases.
% Owing to this practical limitation, fuzzers fall short of exhaustively enumerating the list of potentially recurring vulnerabilities.
In this paper, we leverage static analysis to perform an exhaustive search by using fuzzer-discovered vulnerabilities as a starting point.

We use fault localization techniques to narrow down the search for vulnerable code patterns.
Subsequently, localized code is used to automatically generate vulnerability templates.
False positives have been the primary drawback of static analysis tools.
As a remedy, we propose a ranking algorithm that brings attention to potential vulnerabilities in untested code.

We evaluate our approach on multiple versions of the Open vSwitch codebase, a popular virtual switch used in data centers.
Using static exploration of fuzzer-discovered vulnerabilities, we were able to discover an additional potential vulnerability in untested code.
Furthermore, we show that a vulnerability template derived from a dated vulnerability would have helped discover a recurring vulnerability in a later software release.
This shows that static vulnerability exploration has the potential to weed out flaws at an early stage of software development.
Indeed, our case study highlights the need to complement existing software testing approaches like fuzzing with static analysis.

Our work leaves open multiple avenues for future work.
At present, we rely on manual validation of statically discovered faults.
This may be complemented using selective symbolic execution tools such as {\it angr} so that additional diagnostics such as path reachability and concrete test input may be obtained.
Orthogonally, the precision of our templates can be improved by modeling data sanitization functions more precisely.