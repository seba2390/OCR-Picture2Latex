%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Method}
\label{s:method}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Adaptive Dataset Surface Filter}
\label{s:adaptive-surface-filter}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The purpose of this filter is to extract the outer surface of an
hyper tree grid. 
It is worth noting that the \texttt{Geometry} filter already provides
this capability,~cf.\cite{harel:17}.
However, an additional constraint is added, namely an emphasis on
rendering speed in dimension~$2$.
Our method to address this need is to exploit level-of-detail
properties, culling those parts of the data set that are not
\emph{visible}, i.e., not contained in the visualization frustum
formed by the camera and object positions.
The algorithm explores each tree in the grid, searching for those
faces of the different leaf cells that belong to the surface.
At the end of the computation, the result is a polygonal mesh
(concretely, a \texttt{vtkPolyData} instance) containing an array of
rectangular cells, that can be used to render the surface of the hyper
tree.

The main difference between this adaptive geometry filter and the
non-adaptive one is that it allows for the use of the \emph{renderer}
parameters to reduce the computational work.
Note that currently, this feature is only available when working with
a $2$-dimensional mesh and a parallel projection is set.
When working under these circumstances, the filter computes only the
part of the surface of the grid that is going to be rendered.
This also means that whenever any of the parameters of the
camera associated to the renderer are modified, the output surface
must be subsequently recomputed.

In order to traverse a $2$-dimensional hypertree grid, the algorithm
uses a \emph{geometric cursor}.
We briefly recall here that this cursor provides information about the
size and the coordinates of the cells of the tree and the number of
children, cf.\cite{harel:17} for details.
The algorithm then recursively processes the entire tree, cell by cell
starting from the root level and using a depth-first search (DFS)
order.
In order to cull those cells that are below a certain size in the
rendering window, the DFS traversal is not allowed to descend below
the following maximum depth:
\begin{equation}
\label{eq:level-max}
\delta_{\max}(w,z,s,f) = \frac{\log(wz) - \log{s}}{\log{f}}
\end{equation}
where $w$, $z$, $s$ and $f$ respectively denote the size,
zoom-in factor, scale of the rendering window, and the branching
factor of the hypertree grid.

If the cell to be processed is outside of the rendering
area, it is discarded, which results in reducing the amount of
computational work to be performed by the algorithm. 
Non-leaf cells only need to recursively process their children.
Leaf cells are processed, unless they are masked, in which case they
shall not participate in the output surface.
If a cell is not masked, its geometry and topology are computed, and
these are added to the list of points and cells defining the polygonal
mesh output.

When the input is a $3$-dimensional hyper tree grid we find a different
situation, as we only want to generate the outer surface we need to
omit internal surfaces: in this case, the same method as that used by
the \texttt{Geometry} filter is used.

%%%%%%%%%%%%%%%%
\begin{figure}[ht!]
\centering
\begin{minipage}[t]{0.9\columnwidth}
\includegraphics[width=\columnwidth]{HyperTreeBinary2D-Supercursor-VonNeumannV2.png}
\end{minipage}
\caption{Von Neumann supercursor of a cell that has neighbors with
arbitrary depths, in a $3$-deep, $2$-dimensional binary AMR mesh.} 
\label{fig:HyperTreeBinary2D-SupercursorV2}
\end{figure}
%%%%%%%%%%%%%%%%
This information can be readily retrieved when using a \emph{Von Neumann
supercursor}, as illustrated in
Figure~\ref{fig:HyperTreeBinary2D-SupercursorV2} (cf.~\cite{harel:17}
for details).
Once again, we start processing the tree from the root level. 
If the cell that we are processing is a non-leaf cell we recursively
process its children.
Once arrived at a leaf cell, each of its 6 faces (as the cell is then
viewed as a rectangular prism) is analyzed: if a face belongs
to an unmasked cell and has no neighbor or the neighbor is masked,
then that face belongs to the surface to be generated. 
In this case, its geometry and topology are computed and appended to
the list of quadrangles defining the output geometry.
Note that the $3$-dimensional case of this filter is identical to that
of the \texttt{Geometry} filter which we implemented, as renderer
information is taken into account in this case.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Selection Extraction Filter}
\label{s:extract-selected-filters}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In order to extend the set of filters operating on hypertree
grids to include data analysis capabilities, we started by
extending the selection and extraction methodology of \VTK{} so it can
natively operate on hypertree grids.
We recall that extraction filters are designed to generate subsets
of cells from an input mesh, based on some selection process.
In terms of implementation, the object to be processed is sent to the
first input \emph{port} of the filter, whereas the \emph{selection},
i.e. an instance of a \texttt{vtkSelection} object, is given to a
second port.
This is a first difference with all hypertree grid  filters that we
implemented so far, which operate on a single input, and therefore
only make use of a single input port.
In addition, we wanted to support two different kind of selection modes:
by location (i.e., a geometric criterion) and by identifier (i.e., a
topological criterion).

When the selection mode is by location, the user must provides a list of
coordinates.
The algorithm then recursively explores the tree using a geometric
cursor until it reaches a leaf cell, again using DFS traversal.
In this mode of operation, only non-masked leaf cells can  be
selected, so all others are ignored.
A geometric cursor is also used, so that size and position of
selected cells can be easily retrieved.
The algorithm then checks whether any of these locations are
contained inside each of the traversed cell limits.
In this case, the cell is selected, and  the filter can return two
kinds of outputs: if the \texttt{PreserveTopology} flag is set to
true, then the selection process is made by means of a mask array
attached to the grid.
We recall that such an array associates a value for every cell of the
input hyper tree grid, with value of $1$ for selected cells and a
value of $0$ for non-selected cells. 
On the other hand, when the \texttt{PreserveTopology} flag is not set,
the output result is an unstructured grid containing all selected
cells. 
In the $2$-dimensional case, this output grid is made of
\texttt{VTK\_QUAD} elements, whereas in the $3$-dimensional it only contains
\texttt{VTK\_HEXAHEDRON} cells.

The other mode of operation of the filter is when the
\texttt{vtkSelection} is a list of identifiers (Ids).
In this case, the algorithm is going to search the tree, looking for
these Ids.
Starting from the root cells of the hypertree grid, each constituting
tree is traversed in DFS order.
Given a cell that is not masked by the material mask array, we compare
its global Id with the values contained in the list of identifiers.
If the cell is in the array, it should be selected, otherwise we
keep recursively searching through its children.
We use again a geometric cursor because we need to compute the
coordinates of the points of the selected cells, as with the other
mode of operation.
Here also, the output of the filter is an unstructured grid containing
\texttt{VTK\_QUAD} cells in the $2$-dimensional case, and
\texttt{VTK\_HEXAHEDRON} cells in the $3$-dimensional case.
