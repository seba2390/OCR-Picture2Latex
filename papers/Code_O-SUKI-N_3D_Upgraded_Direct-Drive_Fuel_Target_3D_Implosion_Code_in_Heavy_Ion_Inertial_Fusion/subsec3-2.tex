%\documentclass[preprint,12pt]{elsarticle}
%\include{begin}

%----- Conversion Code
\subsection{Conversion code}
The Euler meshes are constructed based on the size of the small Lagrange mesh in the conversion code. The 3D conversion process is performed after setting the upper limit of the Euler total mesh number. In order to meet the computer resource limitation, this prescription is employed in the O-SUKI-N 3D code. 

\begin{enumerate}
\item{\bf boundary\_set.cpp}
The function makes the boundary point data between DT and Al layer. 
\item{\bf check\_quantities.cpp}
The function outputs the data of the transformed Euler mesh as a text (csv) file. 
\item{\bf define\_convert.h}
Define the variables necessary for the conversion code.

\item{\bf GenerateEulerMesh.cpp}
The procedure determines the number of the Euler meshes and to secure the necessary memory, just before the data conversion.
\item{\bf Interpolation.cpp}
The function interpolates the data on the Lagrangian mesh to those on the Euler meshes. Figure \ref{interpolation_speed} shows the interpolation method from the Lagrange data to the Euler data. The "MeshSearch.cpp" provides the relation between the Lagrangian mesh location and the Euler mesh location. The following interpolation equation is used to obtain each physical quantity on the Euler meshes. For example, here $\bm u$ shows a velocity. 

\begin{eqnarray}\label{eq:interpolation}
	\bm u(P)&=&\frac{1}{sumR}\nonumber\\		
		&\times&\left[\Bigl(\frac{1}{r_{i,j,k}}\Bigr)^2\bm u_{i,j,k}+\Bigl(\frac{1}{r_{i+1,j,k}}\Bigr)^2\bm u_{i+1,j,k}+\Bigl(\frac{1}{r_{i+1,j+1,k}}\Bigr)^2\bm u_{i+1,j+1,k}\right.\nonumber\\
		&+&\Bigl(\frac{1}{r_{i,j+1,k}}\Bigr)^2\bm u_{i,j+1,k}+\Bigl(\frac{1}{r_{i,j,k+1}}\Bigr)^2\bm u_{i,j,k+1}+\Bigl(\frac{1}{r_{i+1,j,k+1}}\Bigr)^2\bm u_{i+1,j,k}\nonumber\\
		&+&\left.\Bigl(\frac{1}{r_{i+1,j+1,k}}\Bigr)^2\bm u_{i+1,j+1,k}+\Bigl(\frac{1}{r_{i,j+1,k+1}}\Bigr)^2\bm u_{i,j+1,k+1}\right]
	\end{eqnarray}

\begin{eqnarray}
	sumR&=&\left(\frac{1}{r_{i,j,k}}\right)^2+\left(\frac{1}{r_{i+1,j,k}}\right)^2+\left(\frac{1}{r_{i+1,j+1,k}}\right)^2+\left(\frac{1}{r_{i,j+1,k}}\right)^2\nonumber\\
	&+&\left(\frac{1}{r_{i,j,k+1}}\right)^2+\left(\frac{1}{r_{i+1,j,k+1}}\right)^2+\left(\frac{1}{r_{i+1,j+1,k+1}}\right)^2+\left(\frac{1}{r_{i,j+1,k+1}}\right)^2\nonumber
\end{eqnarray}

\begin{figure}[H]
	\centering
	\includegraphics[width=12cm]{images/speed_in.eps}
	\caption{Interpolation of velocity}\label{interpolation_speed}
\end{figure}

Usually the Euler mesh size is small compared with the size of the Lagrange mesh. For the interpolation of physical quantities other than velocity, the physical quantity of the corresponding Lagrange mesh acquired by the "MeshSearch.cpp" is interpolated by the 0th order method. On the other hand, if the corresponding Lagrange mesh is smaller than the Euler mesh, it is done in the same way shown in Fig. \ref{interpolation_speed} and Eq. (\ref{eq:interpolation}) for the example velocity interpolation. This is the special treatment in 3D to optimize the required memory size. 

\item{\bf main\_convert.cpp}
This is the main procedure of the conversion code. The procedure selects the output Lagrangian data transferred to the Euler code among the Lagrangian data sets obtained in the Lagrangian code. The Lagrangian meshes are deformed along with the fluid motion. The Lagrangian code stops, before no mesh is crushed. The conversion range is the all DT layer and a part of the Aluminum region. The volume of the Al region is 2.5 times larger than the thickness of the DT layer. The required number of the Euler meshes is calculated. The Lagrange data sets are examined from the data set from the time of 2ns earlier than the last output data set. The function selects the conversion date, which has the smallest number of the Euler mesh required. If the number of Euler meshes exceeds the number of Euler meshes set in the ''input\_LC.h'', the Euler mesh total number is forced to set to the upper limit defined beforehand. 



\item{\bf MeshSearch.cpp}
This procedure examines the location of each Euler mesh among the Lagrangian meshes. The MeshSearch function divides a Lagrange mesh into 12 triangular tetrahedra as shown in Fig. \ref{meshcut}, and examines if the definition point of an Euler mesh is contained in the specific Lagrange mesh. 

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{images/meshcut.eps}
	\caption{One Lagrange mesh and 12 triangular tetrahedra}\label{meshcut}
\end{figure}

In Fig. \ref{meshsearch}, $\vec P$ represents a coordinate vector of a specific Euler mesh and $\vec R$ represents a coordinate vector of the Lagrangian mesh. The $point1$, $point2$, $point3$, $point4$ and $\vec V_P$ are the positions specified in Fig. \ref{meshsearch}, and vectors composed of the position vectors are as follows: 
\begin{eqnarray*}
	\begin{cases}
		{\vec V}_{11}={\vec R}_{point2}-{\vec R}_{point1}\\
		{\vec V}_{12}={\vec R}_{point3}-{\vec R}_{point1}\\
		{\vec V}_{P1}={\vec P}-{\vec R}_{point1}
	\end{cases}
	\begin{cases}
		{\vec V}_{21}={\vec R}_{point3}-{\vec R}_{point1}\\
		{\vec V}_{22}={\vec R}_{point4}-{\vec R}_{point1}\\
		{\vec V}_{P2}={\vec P}-{\vec R}_{point1}
	\end{cases}\\
	\begin{cases}
		{\vec V}_{31}={\vec R}_{point4}-{\vec R}_{point1}\\
		{\vec V}_{32}={\vec R}_{point1}-{\vec R}_{point1}\\
		{\vec V}_{P3}={\vec P}-{\vec R}_{point1}
	\end{cases}
\begin{cases}
		{\vec V}_{41}={\vec R}_{point4}-{\vec R}_{point2}\\
		{\vec V}_{42}={\vec R}_{point3}-{\vec R}_{point2}\\
		{\vec V}_{P4}={\vec P}-{\vec R}_{point2}
	\end{cases}
\end{eqnarray*}

\begin{figure}[H]
	\centering
	\includegraphics[width=10cm]{images/Con_meshP.eps}
	\caption{An Euler mesh point $P$ in a tetrahedron of the Lagrange mesh. }\label{meshsearch}
\end{figure}

If the point $P$ is in the triangular pyramid, the following conditions are met. 

\begin{eqnarray}
		\begin{cases}
			\left({\vec V}_{11}\times{\vec V}_{12}\right)\cdot{\vec V}_{P1}>0\\
			\left({\vec V}_{21}\times{\vec V}_{22}\right)\cdot{\vec V}_{P2}>0\\
			\left({\vec V}_{31}\times{\vec V}_{32}\right)\cdot{\vec V}_{P3}>0\\
			\left({\vec V}_{41}\times{\vec V}_{42}\right)\cdot{\vec V}_{P4}>0
		\end{cases}
\end{eqnarray}

\item{\bf output.cpp}
In this procedure the converted data is output. 
\item{\bf read\_variable.cpp}
This procedure reads the file data output by the Lagrange code, after the Lagrangian data set selection. 
\end{enumerate}

%\include{end}