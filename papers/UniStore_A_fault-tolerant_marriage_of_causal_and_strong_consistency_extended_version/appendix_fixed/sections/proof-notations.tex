
\subsection{Notations} \label{ss:proof-notations}

We use $\cl$ to range over clients from a finite set $\clients$.
We also use the following notations
to refer to different types of variables and their values
(below are some typical examples).
\begin{itemize}
  \item $\snapVC^{m}_{d}$:
    The variable $\snapVC$ at replica $p^{m}_{d}$.
  \item $(\snapVC^{m}_{d})_{e}$:
    The value of variable $\snapVC^{m}_{d}$
    after the event $e$ is performed at replica $p^{m}_{d}$.
  \item $\snapVC^{m}_{d}(\realtime)$:
    The value of $\snapVC^{m}_{d}$ at some specific time $\realtime$.
  \item $\pastVC_{\cl}$: The variable $\pastVC$ at client $\cl$.
  \item $(\pastVC_{\cl})_{e}$:
    The value of variable $\pastVC_{\cl}$
    after the event $e$ is performed at client $\cl$.
  \item $\snapvc_{(\readkey, e)}$:
    The actual value of \emph{parameter} $\snapvc$ of handler \readkey{}
    for event $e$.
  \item $\commitvc_{(\commitcausal, e)}$:
    The value of the \emph{local variable} $\commitvc$
    in procedure \commitcausal{}
    after event $e$ is performed.
\end{itemize}
Besides, we use $\coord(t)$ to denote the coordinator partition
of transaction $\tvar$.

Each transaction is associated with a snapshot vector and a commit vector.

\begin{appdefinition}[Snapshot Vector] \label{def:snapshotvc}
  Let $\tvar \in \txs$ be a transaction.
  Let $d \triangleq \dc(\tvar)$ and $m \triangleq \coord(\tvar)$.
  We define its snapshot vector $\snapshotVC(\tvar)$ as
  \[
    \snapshotVC(\tvar) \triangleq (\snapVC^{m}_{d})_{\startoftx(\tvar)}[\tvar].
  \]
\end{appdefinition}

\begin{appdefinition}[Commit Vector] \label{def:commitvc}
  Let $\tvar \in \txs$ be a transaction.
  Let $d \triangleq \dc(\tvar)$ and $m \triangleq \coord(\tvar)$.
  We define its commit vector $\commitVC(\tvar)$ as follows.
  \begin{itemize}
    \item If $\tvar$ is a read-only causal transaction, then
      \[
        \commitVC(\tvar) \triangleq (\snapVC^{m}_{d})_{\commitoftx(\tvar)}[\tvar].
      \]
    \item If $\tvar$ is an update causal transaction, then
      \[
        \commitVC(\tvar) \triangleq \commitvc_{(\commitcausal, \commitoftx(\tvar))}.
      \]
    \item If $\tvar$ is a committed strong transaction, then
      \[
        \commitVC(\tvar) \triangleq vc_{(\commitstrong, \commitoftx(\tvar))}.
      \]
  \end{itemize}
\end{appdefinition}

\begin{applemma} \label{lemma:snapshotvc-commitvc}
  \[
    \forall \tvar \in \txs.\; \commitVC(\tvar) \ge \snapshotVC(\tvar).
  \]
\end{applemma}

\begin{proof} \label{proof:snapshotvc-commitvc}
  We perform a case analysis according to the type of $\tvar$.
  \begin{itemize}
    \item $\textsc{Case I}$: $\tvar$ is a read-only causal transaction.
      By Definition~\ref{def:snapshotvc} of $\snapshotVC(\tvar)$,
      Definition~\ref{def:commitvc} of $\commitVC(\tvar)$,
      and Assumption~\ref{assumption:client-well-formed},
      \[
        \commitVC(\tvar) = \snapshotVC(\tvar).
      \]
    \item $\textsc{Case II}$: $\tvar$ is an update causal transaction.
      By lines~\code{\ref{alg:unistore-coord}}{\ref{line:commitcausal-commitvc}}
      and \code{\ref{alg:unistore-coord}}{\ref{line:commitcausal-commitvc-d}},
      \[
        \commitVC(\tvar) \ge \snapshotVC(\tvar).
      \]
    \item $\textsc{Case III}$: $\tvar$ is a strong transaction.
      By line~\code{\ref{alg:unistore-strong-commit}}{\ref{line:commitstrong-call-certify}}
      and (\ref{eqn:gcf-commitvc}),
      \[
        \commitVC(\tvar) \ge \snapshotVC(\tvar).
      \]
  \end{itemize}
\end{proof}

For client $\cl$, we use $\cldc(\cl)$ to denote the data center
to which $\cl$ is currently attached.
We also use $\txs|_{\cl}$ to denote the set of transactions issued by $\cl$.
Formally,
\[
  \txs|_{\cl} \triangleq \set{\tvar \in \txs \mid \client(\tvar) = cl}.
\]

For a transaction $\tvar$ and a partition $m$,
we use $\ws(\tvar)[m]$ to denote the subset of $\ws(\tvar)$
restricted to partition $m$.
Formally,
\[
  \ws(\tvar)[m] \triangleq \set{\langle k, v \rangle \in \ws(\tvar)
  \mid \partitionofproc(k) = m}.
\]

For notational convenience, we also define
\begin{align*}
  \log(\tvar) \triangleq \set{\langle k, v, \commitVC(\tvar), \lclock(\tvar)
    \rangle \mid \langle k, v \rangle \in \ws(\tvar)},
\end{align*}
and
\begin{align*}
  \log(\tvar)[m] \triangleq \set{\langle k, v, \commitVC(\tvar), \lclock(\tvar)
    \rangle \mid \langle k, v \rangle \in \ws(\tvar)[m]}.
\end{align*}
For a key $k \in \Key$ and a transaction $\tvar \in \txs_{k}$,
let $\log(\tvar)[k]$ be the unique tuple
\[
  \langle k, v, \commitVC(\tvar), \lclock(\tvar) \rangle
\]
in $\log(\tvar)$.
