
\subsection{Assumptions} \label{ss:assumptions}

We take the following assumptions about \unistore.

\begin{appassumption} \label{assumption:clock}
  For any replica $p^{m}_{d}$ in data center $d$,
  $\clockVar$ at $p^{m}_{d}$ is strictly increasing until $d$ (may) crash.
\end{appassumption}

\begin{appassumption} \label{assumption:message}
  Replicas are connected by reliable FIFO channels:
  messages are delivered in FIFO order,
  and messages between correct data centers
  are guaranteed to be eventually delivered.
\end{appassumption}

\begin{appassumption} \label{assumption:failure-model}
  We assume that in an execution of \unistore, any clients
  and up to $f$ data centers may crash and that $D > 2f$.
\end{appassumption}

\begin{appassumption} \label{assumption:fairness}
  We assume fairness of procedures of \unistore:
  In an execution, if a procedure is enabled infinitely often,
  then it will be executed infinitely often.
\end{appassumption}

\begin{appassumption} \label{assumption:client-well-formed}
  We consider only \emph{well-formed} executions,
  in which for each client:
  \begin{itemize}
    \item transactions are issued in sequence; and
    \item both \fence{} and \clattach{} events
      can be issued only outside of transactions.
  \end{itemize}
\end{appassumption}

\begin{appassumption} \label{assumption:complete-execution}
  We consider only executions where
  every causal commit event (i.e., \commitcausaltx) completes
  and every strong commit event (i.e., \commitstrongtx) that calls the TCS completes.
\end{appassumption}

We make the last assumption to simplify the technical development. The other
assumptions come from the system model.
