
\section{Consistency Model Specification} \label{section:spec}

\subsection{Relations} \label{ss:relations}

For a binary relation $\relation \subseteq A \times A$
and an element $a \in A$, we define
$\relation^{-1}(a) = \set{b \mid (b, a) \in \relation}$.
For a non-empty set $A$ and a total order $\relation \subseteq A \times A$,
we let $\max\limits_{\relation}(A)$ be the maximum element in $A$
according to $\relation$. Formally,
\[
  \max_{\relation}(A) = a \iff A \neq \emptyset
    \land \forall b \in A.\; a = b \lor (b, a) \in \relation.
\]
If $A$ is empty, then $\max\limits_{\relation}(A)$ is undefined.
We implicitly assume that $\max\limits_{\relation}(A)$ is defined
whenever it is used.

We call a binary relation a \emph{(strict) partial order}
if it is irreflexive and transitive.
We call it a \emph{total order} if it additionally
relates every two distinct elements one way or another.
\subsection{Operations and Events} \label{ss:operations}

Transactions in \unistore{} can start, read and write keys, and commit.
We assume that each transaction is associated with a unique transaction identifier
$\tidvar$ from a set $\tids$ (corresponding to
line~\code{\ref{alg:unistore-coord}}{\ref{line:start-return}}).
Besides, clients can issue on-demand barriers and migrate between data centers.

Let $\Key$ and $\Val$ be the set of keys and values, respectively.
We define $\OP$ as the set of all possible operations
\begin{align*}
  \OP = \;&\set{\start(\tidvar) \mid \tidvar \in \tids} \;\cup \\
    &\set{\commitcausaltx(\tidvar) \mid \tidvar \in \tids} \;\cup \\
    &\set{\commitstrongtx(\tidvar, \decvar) \mid \\
      &\quad \tidvar \in \tids, \decvar \in \set{\commit, \abort}} \;\cup \\
    &\set{\fence} \;\cup \\
    &\set{\clattach(j) \mid j \in \D} \;\cup \\
    &\set{\read(\tidvar, k, v), \updateproc(\tidvar, k, v) \mid \\
      &\quad \tidvar \in \tids, k \in \Key, v \in \Val}.
\end{align*}
We denote each invocation of such an operation by an \emph{event}
from a set $E$, usually ranged over by $e$.
A function $\opfunc : E \to \OP$ determines the operation a given event denotes.
Formally, we use the following notation to denote different types of events.
\begin{itemize}
  \item $E$: The set of all events.
  \item $S$: The set of \start{} events. That is,
    \[
      S = \set{e \in E \mid \exists \tidvar \in \tids.\;
        \opfunc(e) = \start(\tidvar)}.
    \]
  \item $R$: The set of \read{} (read) events. That is,
    \begin{align*}
      R = \set{&e \in E \mid \exists \tidvar \in \tids, k \in \Key, v \in \Val.\; \\
        &\quad \opfunc(e) = \read(\tidvar, k, v)}.
    \end{align*}
  \item $U$: The set of \updateproc{} (update) events. That is,
    \begin{align*}
      U = \set{&e \in E \mid \exists \tidvar \in \tids, k \in \Key, v \in \Val.\; \\
        &\quad \opfunc(e) = \updateproc(\tidvar, k, v)}.
    \end{align*}
  \item $C_{\causalentry}$: The set of \commitcausaltx{} events. That is,
    \begin{align*}
      C_{\causalentry} = \set{&e \in E \mid \exists \tidvar \in \tids.\; \\
        &\quad \opfunc(e) = \commitcausaltx(\tidvar)}.
    \end{align*}
  \item $C_{\strongentry}$: The set of \commitstrongtx{} events
    with decision $\decvar = \commit$. That is,
    \begin{align*}
      C_{\strongentry} &= \set{e \in E \mid \exists \tidvar \in \tids.\; \\
        &\opfunc(e) = \commitstrongtx(\tidvar, \commit)}.
    \end{align*}

  \item $C \triangleq C_{\causalentry} \uplus C_{\strongentry}$:
    The set of all commit events.
  \item $\Fence$: The set of \fence{} events. That is,
    \[
      \Fence = \set{e \in E \mid \opfunc(e) = \fence}.
    \]
  \item $\Attach$: The set of \clattach{} events. That is,
    \[
      \Attach = \set{e \in E \mid \exists j \in \D.\; \opfunc(e) = \clattach(j)}.
    \]
  \item $R_{k}$: The set of read events on key $k$. That is,
    \begin{align*}
      R_{k} = \set{&e \in E \mid \exists \tidvar \in \tids, v \in Val.\; \\
        &\quad \opfunc(e) = \read(\tidvar, k, v)}.
    \end{align*}
  \item $U_{k}$: The set of update events on key $k$. That is,
    \begin{align*}
      U_{k} = \set{&e \in E \mid \exists \tidvar \in \tids, v \in Val.\; \\
        &\quad \opfunc(e) = \updateproc(\tidvar, k, v)}.
    \end{align*}
\end{itemize}

For different types of events, we define
\begin{itemize}
  \item $\key(e)$: The key that the read or update event
    $e \in R \cup U$ accesses.
  \item $\rval(e)$: The return value of the read event $e \in R$.
  \item $\uval(e)$: The value written by the update event $e \in U$.
\end{itemize}
\subsection{Transactions} \label{ss:transactions}

\begin{appdefinition}[Transactions] \label{def:tx}
  A transaction $\tvar$ is a triple $(\tidvar, \txnevents, \po)$, where
  \begin{itemize}
    \item $\tidvar \in \tids$ is a unique transaction identifier;
    \item $\txnevents \subseteq E \setminus (\Fence \cup \Attach)$
      is a finite, non-empty set of events;
    \item $\po \subseteq \txnevents \times \txnevents$
      is the program order, which is total.
  \end{itemize}
  We only consider well-formed transactions: according to the $\po$ order,
  $\tvar$ starts with a \start{} event, then performs some number of
  \read{}/\updateproc{} events, and ends with a commit event (\commitcausaltx{}
  or \commitstrongtx).
\end{appdefinition}

In the following, we denote components of $t$ as in $t.\tidvar$.
For simplicity, we assume a dedicated \emph{initial} transaction $\tvar_{0}$
which installs initial values to all possible keys before the system launches.

We use the following notations to denote different types of transactions.
\begin{itemize}
  \item $\txs$: The set of all committed transactions.
  \item $\txs_{k}$: The set of committed transactions that update key $k$.
    We also use $C_{k}$ to denote the set of commit events of transactions
    in $\txs_{k}$.
  \item $\causaltxs$: The set of transactions that
    end with the \commitcausaltx{} events.
    We call them causal transactions.
    Causal transactions will always be committed.
  \item $\allstrongtxs$: The set of transactions that
    end with the \commitstrongtx{} events.
    We call them strong transactions.
    Strong transactions can be committed or aborted.
  \item $\strongtxs$: The set of \emph{committed} strong transactions.
\end{itemize}

We have $\txs = \causaltxs \uplus \strongtxs$.
For each transaction $\tvar \in \txs$, we define
\begin{itemize}
  \item $\tidselector(\tvar) \in \tids$:
    The transaction identifier $t.\tidvar$ of $\tvar$.
  \item $\events(\tvar) \subseteq S \cup R \cup U \cup C$:
    The set $t.\txnevents$ of events in $\tvar$.
  \item $\ws(\tvar) \subseteq \Key \times \Val$:
    The write set of $\tvar$.
    It is the set of keys with their values that $\tvar$ updates,
    which contains at most one value per key.
    Formally,
    \[
      \ws(\tvar) \triangleq \set{(\key(e), \uval(e)) \mid e \in t.\txnevents \cap U}.
    \]
  \item $\rs(\tvar) \subseteq \Key$: The read set of $\tvar$.
    It is the set of keys that $\tvar$ reads.
    Formally,
    \[
      \rs(\tvar) \triangleq \set{\key(e) \mid e \in t.\txnevents \cap R}.
    \]
  \item $\startoftx(\tvar) \in S$:
    The \start{} event of $\tvar$.
    Formally, it is the unique event in the set $t.\txnevents \cap S$.
  \item $\commitoftx(\tvar) \in C$: The commit event of $\tvar$.
    Formally, it is the unique event in the set $t.\txnevents \cap C$.
  \item $\ud(\tvar, k) \in U_{k}$: The \emph{last} update event on key $k$, if any,
    in transaction $\tvar$. Formally,
    \[
      \ud(\tvar, k) \triangleq \max\limits_{\po}(\events(\tvar) \cap U_{k}).
    \]
\end{itemize}

Besides, we define
\begin{align}
  \W(\tvar) &\triangleq \set{k \in \Key \mid \langle k, \_ \rangle \in \ws(\tvar)}, \label{eq:W-def}\\
  \R(\tvar) &\triangleq \rs(\tvar) \cup \W(\tvar).\label{eq:R-def}
\end{align}

For a read event $e$ on key $k$ in transaction $\tvar$,
if there exist update events on $k$ preceding $e$ in $\tvar$,
then $e$ is called an \emph{internal} read event.
Otherwise, $e$ is called an \emph{external} read event.
We denote the sets of internal reads and external reads
by $\intread$ and $\extread$, respectively.
That is, $R = \intread \uplus \extread$.

We also distinguish commit events
for read-only transactions from those for update transactions,
and denote their sets by $\rocommit$ and $\updatecommit$, respectively.
That is, $C = \rocommit \uplus \updatecommit$.

For notational convenience,
for an event $e \in E \setminus (\Fence \cup \Attach)$, we also define
$\txfunc(e)$ to be the transaction containing $e$ and
\begin{align*}
  \startoftx(e) &\triangleq \startoftx(\txfunc(e)), \\
  \commitoftx(e) &\triangleq \commitoftx(\txfunc(e)).
\end{align*}
\subsection{Abstract Executions} \label{ss:cm}

Clients interacts with \unistore{} by issuing transactions
and \fence{} and \attach{} events.
We use histories to record such interactions in a single computation.
Note that histories only record committed transactions.
\begin{appdefinition}[Histories] \label{def:histories}
  A \emph{history} is a tuple
  \[
    H = (X, \client, \dc, \so)
  \]
  such that
  \begin{itemize}
    \item $X \subseteq \txs \cup \Fence \cup \Attach$
      is a set of committed transactions and \fence{} and \attach{} events;
    \item $\client: X \to \clients$ is a function that returns
      \begin{itemize}
        \item the client $\client(t)$ which issues the transaction
          $\tvar \in (X \cap \txs)$,
        \item the client $\client(\fencerange)$ which issues the \fence{} event
          $\fencerange \in (X \cap \Fence)$, or
        \item the client $\client(\attachrange)$ which issues the \attach{} event
          $\attachrange \in (X \cap \Attach)$;
      \end{itemize}
    \item $\dc: X \to \D$ is a function
      that returns the original data center $\dc(\tvar)$
      of transaction $\tvar \in (X \cap \txs)$,
      $\dc(\fencerange)$ of \fence{} event $\fencerange \in (X \cap \Fence)$,
      or $\dc(\attachrange)$ of \attach{} event $\attachrange \in (X \cap \Attach)$;
    \item $\so \subseteq X \times X$ is the \emph{session order} on $X$.
      Consider $\txevents_{1}, \txevents_{2} \in X$.
      We say that $\txevents_{1}$ precedes $\txevents_{2}$
      in the session order, denoted $\txevents_{1} \rel{\so} \txevents_{2}$,
      if they are executed by the same client
      and $\txevents_{1}$ is executed before $\txevents_{2}$.
  \end{itemize}
\end{appdefinition}
In the following, we denote components of $H$ as in $H.X$
and often shorten $H.X$ by $X$ when it is clear.
Let $V_{H} \triangleq \bigcup (H.X \cap T).Y$
be the set of transactional events in history $H$.

A consistency model is specified by a set of histories.
To define this set, we extend histories with two relations,
declaratively describing how the system processes transactions
and \fence{} events.

\begin{appdefinition}[Abstract Executions] \label{def:ae}
  An \emph{abstract execution} is a triple
  \[
    A = ((X, \client, \dc, \so), \vis, \ar)
  \]
  such that
  \begin{itemize}
    \item $(X, \client, \dc, \so)$ is a history;
    \item Visibility $\vis \subseteq X \times X$ is a partial order;
    \item Arbitration $\ar \subseteq X \times X$ is a total order.
  \end{itemize}
\end{appdefinition}
For $H = (X, \client, \dc, \so)$,
we often shorten $((X, \client, \dc, \so), \vis, \ar)$ by $(H, \vis, \ar)$.
\subsection{Partial Order-Restrictions Consistency} \label{ss:por}

We aim to show that \unistore{} implements a transactional variant
of \emph{Partial Order-Restrictions consistency
(\por{} consistency)}~\cite{red-blue, por} for LWW registers.
A history $H$ of \unistore{} satisfies \por, denoted $H \models \por$,
if it can be extended to an abstract execution that satisfies several axioms,
defined in the following:
\begin{align*}
  H \models \por \iff\; &\exists \vis, \ar.\; (H, \vis, \ar) \models \\
                 &\qquad \retval \;\land \\
                 &\qquad \cc \;\land \\
                 &\qquad \conflictaxiom \;\land \\
                 &\qquad \ev.
\end{align*}
$\unistore$ satisfies $\por$, denoted $\unistore \models \por$,
if all its histories do.

Given an abstract execution $A = (H, \vis, \ar)$,
the axioms are defined as follows.
\begin{appdefinition}[$\retval$, \cite{framework-concur15}] \label{def:retval}
  The Return Value Consistency (\retval) specifies
  the return value of each read event.
  \[
    \retval \triangleq \intretval \land \extretval.
  \]
  Here $\intretval$ requires an internal read event $e$
  on key $k$ to read from the last update event on $k$ preceding $e$
  in the same transaction. Formally,
  \begin{align*}
    &\intretval \triangleq \forall e \in \intread \cap R_{k} \cap V_{H}. \\
        &\quad \rval(e) = \uval\big(\max_{\po}(\po^{-1}(e) \cap U_{k})\big).
  \end{align*}
  $\extretval$ requires an external read event $e$
  on key $k$ to read from the last update event on $k$
  in the last transaction preceding $\txfunc(e)$ in $\ar$,
  among the set of transactions visible to $\txfunc(e)$.
  Formally,
  \begin{align*}
    &\extretval \triangleq \forall e \in \extread \cap R_{k} \cap V_{H}. \\
        &\quad \rval(e) =
          \uval\Big(
                \ud\big(\max_{\ar}\big(\vis^{-1}(\txfunc(e)) \cap \txs_{k}\big), k\big)
               \Big).
  \end{align*}
\end{appdefinition}

\begin{appdefinition}[\cc, \cite{sebastian-book}] \label{def:cc}
  \begin{align*}
    \cc \triangleq\; &\cv \;\land \\
                   &\ca,
  \end{align*}
  where
  \[
    \cv \triangleq (\so\; \cup \vis)^{+} \subseteq \vis;
  \]
  \[
    \ca \triangleq \vis \subseteq \ar.
  \]
\end{appdefinition}

The Conflict Ordering property requires that
out of any two conflicting strong transactions,
one must be visible to the other.
Formally,
\begin{appdefinition}[Conflict Relation] \label{def:conflict-relation-tx}
  The conflict relation, denoted by $\conflict$, between strong transactions
  is a symmetric relation defined as follows:
  \begin{align*}
    &\forall \tvar, \tvar' \in \strongtxs.\; \tvar \conflict \tvar' \iff \\
      &\quad (\R(\tvar) \cap \W(\tvar') \neq \emptyset) \lor
             (\W(\tvar) \cap \R(\tvar') \neq \emptyset).
  \end{align*}
\end{appdefinition}

\begin{appdefinition}[\conflictaxiom] \label{def:conflictaxiom}
  \begin{align*}
    &\conflictaxiom \triangleq
      \forall \tvar_{1}, \tvar_{2} \in X \cap \strongtxs.\; \\
        &\quad \tvar_{1} \conflict \tvar_{2} \implies
          \tvar_{1} \rel{\vis} \tvar_{2} \lor \tvar_{2} \rel{\vis} \tvar_{1}.
  \end{align*}
\end{appdefinition}
The Eventual Visibility property requires that
a transaction that originates at a correct data center,
that is visible to some \fence{} events,
or that is a strong transaction
eventually becomes visible at all correct data centers.
Let $\C \subseteq \D$ be the set of correct data centers.
Formally,
\begin{appdefinition}[\ev] \label{def:ev}
  \begin{align*}
    &\ev \triangleq \forall \tvar \in X \cap \txs.\; \\
      &\quad \dc(\tvar) \in \C \lor
        (\exists \fencerange \in \Fence.\; \tvar \rel{\vis} \fencerange) \lor \tvar \in \strongtxs \\
        &\qquad \implies \left\lvert \left\{\tvar' \in \txs
          \mid \lnot (\tvar \rel{\vis} \tvar') \right\} \right\rvert < \infty.
  \end{align*}
\end{appdefinition}
