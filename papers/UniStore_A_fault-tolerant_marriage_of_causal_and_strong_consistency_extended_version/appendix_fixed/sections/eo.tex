
\subsection{Execution Order} \label{ss:eo}

\begin{appdefinition}[Execution Points] \label{def:ep}
  Let $k$ be a key.
  The ``execution point'' $\ep(e, k)$ of event
  $e \in (\extread \cap R_{k}) \cup C_{k}$ is defined as follows:

  \begin{itemize}
    \item If $e \in \extread \cap R_{k}$,
      then $\ep(e, k)$ is at
      line~\code{\ref{alg:unistore-replica}}{\ref{line:readkey-read}};
    \item If $e \in C_{k} \cap C_{\causalentry}$,
      then $\ep(e, k)$ is at
      line~\code{\ref{alg:unistore-replica}}{\ref{line:commit-oplog}}
      for this particular key $k$;
    \item If $e \in C_{k} \cap C_{\strongentry}$
      then $\ep(e, k)$ is at
      line~\code{\ref{alg:unistore-strong-commit}}{\ref{line:deliverupdates-oplog}}
      for delivery of the update of $\txfunc(e)$ on this particular key $k$.
      Note that \deliver{} is asynchronous with the commit event $e$.
  \end{itemize}
\end{appdefinition}

\begin{appdefinition}[Per-key Execution Order] \label{def:perkey-eo}
  Let $k$ be a key.
  Suppose that $\set{e_{1}, e_{2}} \subseteq (\extread \cap R_{k}) \cup C_{k}$.
  Event $e_1$ is executed before event $e_2$, denoted $e_1 \rel{\eok} e_2$,
  if $\ep(e_{1}, k)$ is executed before $\ep(e_{2}, k)$ in real time.
\end{appdefinition}

\begin{applemma} \label{lemma:vis-perkey-eo}
  Let $k \in \Key$ be a key, $\tvar \in \txs_{k}$ be a transaction,
  and $e \in \extread \cap R_{k}$ be an external read event.
  Suppose that $d \triangleq \dc(\tvar) = \dc(\txfunc(e))$.
  Then
  \[
    \tvar \rel{\vis} \txfunc(e) \implies \commitoftx(\tvar) \rel{\eok} e.
  \]
\end{applemma}

\begin{proof} \label{proof:vis-perkey-eo}
  By Definition~\ref{def:vis-tx} of $\vis$,
  \[
    \timestamp(\tvar) \le \timestamp(\startoftx(e)).
  \]
  Since $e \in \extread$, by Lemma~\ref{lemma:ts-extread},
  \[
    \timestamp(\tvar) \le \snapvc_{(\readkey, e)}.
  \]
  In the following, we distinguish between two cases
  according to whether $\tvar \in \causaltxs$
  or $\tvar \in \strongtxs$.
  Let $m \triangleq \partitionofproc(k)$.
  \begin{itemize}
    \item $\textsc{Case I}$: $\tvar \in \causaltxs$.
      By Lemma~\ref{lemma:ts-commit},
      \[
        \tsfunc(\tvar) = \commitVC(\tvar) \le \snapvc_{(\readkey, e)}.
      \]
      Therefore, after line~\code{\ref{alg:unistore-replica}}{\ref{line:readkey-wait-util-knownvc}}
      for $e$,
      \begin{align}
        (\knownVC^{m}_{d})_{e}[d]
        &\ge \snapvc_{(\readkey, e)}[d] \notag \\
        &\ge \commitVC(\tvar)[d].
        \label{eqn:vis-perkey-eo-knownvc-commitvc-causal}
      \end{align}
      By Lemma~\ref{lemma:knownvc-local-d},
      \commit{} of Algorithm~\ref{alg:unistore-replica}
      for $\ws(\tvar)[m] \ni \langle k, \_ \rangle$
      finishes before $e$ starts at replica $p^{m}_{d}$.
      By Definition~\ref{def:perkey-eo} of $\eok$,
      \[
        \commitoftx(\tvar) \rel{\eok} e.
      \]
    \item $\textsc{Case II}$: $\tvar \in \strongtxs$.
      By Lemma~\ref{lemma:ts-commit},
      \[
        \tsfunc(\tvar) = \commitVC(\tvar) \le \snapvc_{(\readkey, e)}.
      \]
      Therefore, after line~\code{\ref{alg:unistore-replica}}{\ref{line:readkey-wait-util-knownvc}}
      for $e$,
      \begin{align}
        (\knownVC^{m}_{d})_{e}[\strongentry]
        &\ge \snapvc_{(\readkey, e)}[\strongentry] \notag \\
        &\ge \commitVC(\tvar)[\strongentry].
        \label{eqn:vis-perkey-eo-knownvc-commitvc-strong}
      \end{align}
      By Lemma~\ref{lemma:knownvc-strong},
      \deliver{} of Algorithm~\ref{alg:unistore-strong-commit}
      for $\ws(\tvar)[m] \ni \langle k, \_ \rangle$
      finishes before $e$ starts at replica $p^{m}_{d}$.
      By Definition~\ref{def:perkey-eo} of $\eok$,
      \[
        \commitoftx(\tvar) \rel{\eok} e.
      \]
  \end{itemize}
\end{proof}
