
\begin{algorithm*}[t]
  \caption{Transaction execution at $p^m_d$}
  \label{alg:unistore-replica}
  \begin{algorithmic}[1]
    \WhenRcv[$\Call{\readkey}{\snapvc, k} \from p$]
      \label{line:function-readkey}
      \For{$i \in \D \setminus \set{d}$}
        \label{line:readkey-uniformvc-i}
        \State $\uniformVC[i] \gets \max\{\snapvc[i], \uniformVC[i]\}$
          \label{line:readkey-uniformvc}
      \EndFor
      \State {\bf wait until} $\knownVC[d] \geq \snapvc[d]
          \land \strongcolor{\knownVC[\strongentry] \ge \snapvc[\strongentry]}$
        \label{line:readkey-wait-util-knownvc}
      \hStatex
      \State $\langle v, \commitvc, \lccolor{\lcvar} \rangle \gets \snapshotproc(\oplog[k], \snapvc)$
        \label{line:readkey-read}
        \Comment{returns the last update to key $k$ by a transaction}
      \State  \Comment{
          with the highest Lamport timestamp such that $\commitvc \leq \snapvc$}
      \State \send $\versionproc(v, \lccolor{\lcvar}) \sendto p$
        \label{line:readkey-return}
    \EndWhenRcv

    \Statex
    \WhenRcv[$\Call{\prepare}{\tidvar, \wbuffvar, \snapvc} \from p$]
      \label{line:function-preparecausal}
      \For{$i \in \D \setminus \set{d}$}
        \State $\uniformVC[i] \gets \max\set{\snapvc[i], \uniformVC[i]}$
        \label{line:preparecausal-uniformvc}
      \EndFor

      \State \var $\tsvar \gets \clockVar$
        \label{line:preparecausal-ts}
      \State $\preparedcausal \gets \preparedcausal \cup
        \set{\langle \tidvar, \wbuffvar, \tsvar \rangle}$
        \label{line:preparecausal-preparedcausal}
      \State \send $\Call{\prepareack}{\tidvar, \tsvar} \sendto p$
        \label{line:preparecausal-call-preparecausalack}
    \EndWhenRcv

    \Statex
    \WhenRcv[$\Call{\commit}{\tidvar, \commitvc, \lccolor{\lcvar}}$]
      \label{line:function-commit}
      \State \wait\until $\clockVar \geq \commitvc[d]$
        \label{line:commit-wait-clock}

      \hStatex
      \State $\langle \tidvar, \wbuffvar, \_ \rangle \gets \find(\tidvar, \preparedcausal)$
        \label{line:commit-find}
      \State $\preparedcausal \gets \preparedcausal \setminus \set{\langle \tidvar, \_, \_\rangle}$
        \label{line:commit-preparedcausal}

      \ForAll{$\langle k, v \rangle \in \wbuffvar$}
        \State $\oplog[k] \gets \oplog[k] \cdot \langle v, \commitvc, \lccolor{\lcvar} \rangle$
        \label{line:commit-oplog}
      \EndFor

      \State $\committedcausal[d] \gets \committedcausal[d] \cup
        \set{\langle \tidvar, \wbuffvar, \commitvc, \lccolor{\lcvar} \rangle}$
        \label{line:commit-committedcausal}
    \EndWhenRcv

    \Statex
    \Function{\uniformbarrier}{$\vc$} \label{line:function-uniformbarrier}
      \State \wait\until $\uniformVC[d] \ge \vc[d]$
        \label{line:uniformbarrier-wait-uniformvc-d}
    \EndFunction

    \Statex
    \Function{\attach}{$\vc$}
      \label{line:function-attach}
      \State \wait\until $\forall i \in \D \setminus \set{d}.\; \uniformVC[i] \ge \vc[i]$
        \label{line:attach-wait-condition}
    \EndFunction
  \end{algorithmic}
\end{algorithm*}