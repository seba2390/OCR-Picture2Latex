
\begin{algorithm*}[t]
  \caption{Atomic transaction commit protocol at $\pvar^{m}_{d}$: recovery}
  \label{alg:unistore-recovery}
  \begin{algorithmic}[1]
    \Upon[$\Omega_{m} \neq \trustedVar$]
      \State $\trustedVar \gets \Omega_{m}$
      \If{$\trustedVar = \pvar^{m}_{d}$}
        \recover()
      \Else{}
        $\send \nack(\ballotVar) \sendto \trustedVar$
      \EndIf
    \EndUpon

    \Statex
    \WhenRcv[\nack($b$)]
      \State \pre $\trustedVar = \pvar^{m}_{d} \land \ballotvar > \ballotVar$
      \hStatex
      \State $\ballotVar \gets \ballotvar$
      \State \recover()
    \EndWhenRcv

    \Statex
    \Function{\recover}{\null}
      \label{line:function-recover}
      \State \send $\Call{\newleader}{\text{any ballot } \ballotvar
        \text{ such that } \ballotvar > \ballotVar
          \land \leaderof(\ballotvar) = \pvar^{\mvar}_{\dvar}}
          \sendto \replicas(\mvar)$
    \EndFunction

    \Statex
    \WhenRcv[$\newleader(\ballotvar) \from \pvar$]
      \label{line:function-newleader}
      \If{$\trustedVar = \pvar \land \ballotVar < \ballotvar$}
        \label{line:newleader-if}
        \State $\statusVar \gets \recovering$
          \label{line:newleader-status}
        \State $\ballotVar \gets \ballotvar$
          \label{line:newleader-ballot}
        \State $\doNotWaitFor \gets \emptyset$
        \State $\send \Call{\newleaderack}{\ballotVar, \cballot,
          \preparedstrong, \decidedstrong} \sendto \pvar$
          \label{line:newleader-call-newleaderack}
      \Else{}
        $\send \Call{\nack}{\ballotVar} \sendto \pvar$
      \EndIf
    \EndWhenRcv

    \Statex
    \WhenRcv[$\set{\newleaderack(\ballotvar, \cballotvar_{j},
      \preparedstrongvar_{j}, \decidedstrongvar_{j}) \mid p_{j} \in Q}
        \;\text{\bf from a quorum}\; Q$]
        \label{function:newleaderack}
      \State \pre $\statusVar = \recovering \land \ballotVar = \ballotvar$
        \label{line:newleaderack-precondition}
      \hStatex
      \State \var $J \gets$ the set of $j$ with maximal $\cballotvar_{j}$
        \label{line:newleaderack-J}
      \State $\decidedstrong \gets \bigcup\limits_{j \in J} \decidedstrongvar_{j}$
        \label{line:newleaderack-decidedstrong}
      \State $\preparedstrong \gets \set{\langle \tidvar, \_, \_, \_, \_, \_, \lccolor{\_} \rangle
        \in \bigcup\limits_{j \in J} \preparedstrongvar_{j} \mid
          \langle \tidvar, \_, \_, \_, \lccolor{\_} \rangle \notin \decidedstrong}$
        \label{line:newleaderack-preparedstrong}
      \State \var $\maxPrep \gets \max\set{\tsvar \mid
        \langle \_, \_, \_, \_, \_, \tsvar, \lccolor{\_} \rangle \in \preparedstrong}$
        \label{line:newleaderack-maxprep}
      \State \var $\maxDec \gets \max\set{\commitvc[\strongentry] \mid
        \langle \_, \_, \_, \commitvc, \lccolor{\_} \rangle \in \decidedstrong}$
        \label{line:newleaderack-maxdec}
      \State \wait\until $\clockVar \ge \max\set{\maxPrep, \maxDec}$
        \label{line:newleaderack-wait-clock}

      \hStatex
      \State $\cballot \gets \ballotvar$
        \label{line:newleaderack-cballot}
      \State \send $\newstate(\ballotVar, \preparedstrong, \decidedstrong)
        \sendto \replicas(\mvar) \setminus \set{\pvar^{\mvar}_{\dvar}}$
        \label{line:newleaderack-call-newstate}
    \EndWhenRcv

    \Statex
    \WhenRcv[\newstate($\ballotvar, \preparedstrongvar, \decidedstrongvar$) \from $\pvar$]
      \label{line:function-newstate}
      \State \pre $\statusVar = \recovering \land \ballotvar \ge \ballotVar$
        \label{line:newstate-precondition}
      \hStatex
      \State $\cballot \gets \ballotvar$
        \label{line:newstate-cballot}
      \State $\preparedstrong \gets \preparedstrongvar$
        \label{line:newstate-preparedstrong}
      \State $\decidedstrong \gets \decidedstrongvar$
        \label{line:newstate-decidedstrong}
      \State $\statusVar \gets \follower$
        \label{line:newstate-status}
      \State $\send \Call{\newstateack}{\ballotvar} \sendto \pvar$
        \label{line:newstate-call-newstateack}
    \EndWhenRcv

    \Statex
    \WhenRcv[\newstateack($\ballotvar$)] {\bf from a set of processes}
      \textbf{that together with} $\pvar^{\mvar}_{\dvar}$ \textbf{form a quorum}
      \State \pre $\statusVar = \recovering \land \ballotVar = \ballotvar$
      \hStatex
      \State $\statusVar \gets \restoring$
      \ForAll{$t = \langle \tidvar, \wbuffvar, \rsvar, \snapvc, \_, \_, \lccolor{\lcvar} \rangle
        \in \preparedstrong$}
        \If{$\Call{\certify}{\restoring, \tidvar, \wbuffvar, \rsetvar, \snapvc, \lccolor{\lcvar}} = \unknowntx$}
          \State $\doNotWaitFor \gets \doNotWaitFor \cup \set{t}$
        \EndIf
    \EndFor
    \EndWhenRcv

    \Statex
    \Upon[$\preparedstrong \subseteq \doNotWaitFor \land \statusVar = \restoring$]
      \State $\statusVar \gets \leaderproc$
      \State $\doNotWaitFor \gets \emptyset$
    \EndUpon
  \end{algorithmic}
\end{algorithm*}
