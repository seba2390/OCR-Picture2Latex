% !TEX root = ../BTBook.tex

\chapter{Design principles}
\label{ch:design_principles}
%\graphicspath{{design/game_ai_figs/}}
\graphicspath{{design/}}

BTs are fairly easy to understand and use, but to make full use of their potential it can be good to be aware of a set of design principles that can be used in different situations. In this chapter, we will describe these principles using a number of examples.
First, in Section~\ref{sec:explicit_conditions}, we will describe the benefit of using explicit success conditions in sequences,
then, in Section~\ref{sec:implicit_sequences}, we describe how the reactivity of a BT can be increased by creating implicit sequences, using Fallback nodes.
In Section~\ref{sec:dt}, we show how BTs can  be designed in a way that is similar to Decision Trees.
Then, in Section~\ref{sec:safety}, we show how safety can be improved using sequences.
Backchaining is an idea used in automated planning, and in Section~\ref{design:sec:back_chaining} we show how it can be used to create
deliberative, goal directed, BTs.
Memory nodes and granularity of BTs is discussed in 
 Sections~\ref{sec:design:memory} and \ref{design:sec:granularity}.
Finally, we show how easily all these principles can be combined at different levels of a BT in Section~\ref{design:sec:combinations}.




\section{Improving Readability using Explicit Success Conditions}
\label{sec:explicit_conditions}

One advantage of BTs is that the switching structure is clearly shown in the graphical representation of the tree. However, one thing that is not shown is the details regarding when the individual actions return  Success and Failure.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\columnwidth]{sequence}
\caption{Simple Sequence}
\label{design:fig:sequence}
\end{figure}
 Consider the sequence in Figure~\ref{design:fig:sequence}. One can assume that Unlock Door returns Success when it has unlocked the door, but what if it is called when the door is already unlocked? Depending on the implementation it might either return Success immediately, or actually try to unlock the door again, with the possibility of returning Failure if the key cannot be turned further. A similar uncertainty holds regarding the implementation of Open Door (what if the door is already open?) and Pass through Door.
 To address this problem, and remove uncertainties regarding the implementation, explicit Success conditions can be included in the BT.


\begin{figure}[h]
\centering
\includegraphics[width=0.9\columnwidth]{explicit_sequence}
\caption{Sequence with explicit success conditions. Note how each action is paired with a condition through a Fallback node, making the success condition of the pair explicit.}
\label{design:fig:explicit_sequence}
\end{figure}

In Figure~\ref{design:fig:explicit_sequence}, the BT from Figure~\ref{design:fig:sequence} has been extended to include explicit success conditions. These conditions are added in a pair with the corresponding action using a Fallback node. Now, if the door is already unlocked and open, the two first conditions of Figure~\ref{design:fig:explicit_sequence}
will return Success, the third will return Failure, and the agent will proceed to execute the action Pass through Door.


\section{Improving Reactivity using Implicit Sequences}
\label{sec:implicit_sequences}

It turns out that we can  improve the reactivity of the BT in Figure~\ref{design:fig:explicit_sequence} even further,
using the fact that BTs generalize the Teleo-Reactive approach, see Section~\ref{sec:BT_generalize_TR}.
Consider the case when the agent has already passed the door, but the door is closed behind it. The BT in Figure~\ref{design:fig:explicit_sequence}
would then proceed to unlock the door, open it, and then notice that it had already passed it and return Success.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\columnwidth]{implicit_sequence}
\caption{An Implicit Sequence is constructed using a Fallback node, reversing the order of the actions and pairing them with appropriate preconditions.}
\label{design:fig:implicit_sequence}
\end{figure}

The key observation needed to improve reactivity is to realize that the goal is to get through the door, and that the other actions are just means to get to
that goal. In the BT in Figure~\ref{design:fig:implicit_sequence} we have reversed the order of the actions in order the check the goal state first.
We then changed fallbacks to sequences and vice versa, and finally changed the conditions. Now, instead of checking outcomes, or success conditions as we did in 
Figure~\ref{design:fig:explicit_sequence}, we check preconditions, conditions needed to execute the corresponding actions, in Figure~\ref{design:fig:implicit_sequence}.
First the BT checks if the agent has passed the door, if so it returns Success. If not, it proceeds to check if the door is open, and if so passes through it. If neither of the previous conditions are satisfied, it checks if the door is unlocked, and if so starts to open it. As a final check, if nothing else returns Success, it checks if it has the key to the door. If it does, it tries to open it, if not it returns Failure.



The use of implicit sequences is particularly important in cases where the agent needs to undo some of its own actions, such as closing a door after passing it.
A systematic way of creating implicit sequences is to use back chaining, as described in Section~\ref{design:sec:back_chaining}.

\section{Handling Different Cases using a Decision Tree Structure}
\label{sec:dt}
Sometimes, a reactive switching policy can be easily described in terms of a set of cases, much like a Decision Tree.
Then, the fact that BTs generalize Decision Trees can be exploited, see Section~\ref{sec:BT_generalize_DT}.

A simple Pac-Man example can be found in Figure~\ref{design:fig:dt}. The cases are separated by the two conditions \emph{Ghost Close} and \emph{Ghost Scared}.
If no ghost is close, Pac-Man continues to eat pills. If a ghost is close, the BT checks the second condition, \emph{Ghost Scared}, which turns true if Pac-Man eats a Power Pill. If the ghost is scared, Pac-Man chases it, if not, Pac-Man avoids the Ghost.

\begin{figure}[h]
\centering
\includegraphics[width=0.4\columnwidth]{bts/figures/pacman_3}
\caption{Simple Pac-Man example using a Decision Tree structure.}
\label{design:fig:dt}
\end{figure}


\section{Improving Safety using Sequences}
\label{sec:safety}

In some agents, in particular robots capable of performing irreversible actions such as falling down stairs or damaging equipment, it is very important to be able to guarantee that some situations will never occur. These unwanted situations might be as simple as failing to reach the recharging station before running out of battery, or as serious as falling down a staircase and hurting someone.

\begin{figure}[h]
\centering
\includegraphics[height=3cm]{safety}
\caption{A BT that is guaranteed not to run out of batteries, as long as Main Task keeps the robot close enough to the recharging station so that 20\% of battery will be enough to travel back.}
\label{design:fig:safety}
\end{figure}

A Sequence node can be used to guarantee safety, as shown in Figure~\ref{design:fig:safety}.
Looking closer at the BT in Figure~\ref{design:fig:safety} we see that it will probably lead to an unwanted chattering behavior. It will recharge until it reaches just over 20\%
and then start doing Main Task, but the stop as soon as the battery is back at 20\%,
and possibly end up chattering i.e. quickly switching between the two tasks.
The solution is to make sure that once recharging, the robot waits until the battery is back at 100\%. This can be achieved by the BT in Fig~\ref{design:fig:safety_hysteresis}.

\begin{figure}[h]
\centering
\includegraphics[height=4cm]{safety_hysteresis}
\caption{By changing the condition in Fig.~\ref{design:fig:safety} the robot now keeps recharging  until the Battery level reaches 100\%. }
\label{design:fig:safety_hysteresis}
\end{figure}

\section{Creating Deliberative BTs using Backchaining}
\label{design:sec:back_chaining}

BTs can also be used to create deliberative agents, where the actions are carried out in order to reach a specific goal. 
We will use an example to see how this is done.
Imagine we want the agent to end up inside a house. To make that goal explicit, we create the trivial BT in Figure~\ref{design:fig:back_chaining_1},
with just a single condition checking if the goal is achieved or not.


\begin{figure}[h]
\centering
\includegraphics[width=0.2\columnwidth]{back_chaining_1}
\caption{A BT composed of a single condition checking if the goal is achieved.}
\label{design:fig:back_chaining_1}
\end{figure}

Now imagine we have a set of small BTs such as the ones in 
Figures~\ref{design:fig:back_chaining_2} and~\ref{design:fig:back_chaining_3}, each on the format of the general Postcondition-Precondition-Action (PPA) BT in 
Figure~\ref{design:fig:back_chaining_general}.


\begin{figure}[h]
\centering
\includegraphics[height=3cm]{back_chaining_2}
\caption{PPA for achieving the postcondition Is Inside House. If the postcondition is not satisfied already, the BT checks the precondition Door is Open, if so it executes the action Go Inside.}
\label{design:fig:back_chaining_2}
\end{figure}

If we have such a set, be can work our way backwards from the goal (backchaining) by replacing preconditions with PPAs having the corresponding postcondition. Thus replacing the single condition in Figure~\ref{design:fig:back_chaining_1} with the PPA of Figure~\ref{design:fig:back_chaining_2} we get Figure~\ref{design:fig:back_chaining_2} again, since we started with a single condition.
More interestingly, if we replace the precondition Door is Open in Figure~\ref{design:fig:back_chaining_2} with the PPA of Figure~\ref{design:fig:back_chaining_3} we get the BT of Figure~\ref{design:fig:back_chaining_4}

\begin{figure}[h]
\centering
\includegraphics[width=0.9\columnwidth]{back_chaining_3}

\caption{PPA for achieving the postcondition Door is Open. If the postcondition is not satisfied, the BT checks the first precondition Door is Unlocked, if so it executes the action Open Door, if not it checks the second set of preconditions, starting with Has Crowbar, if so it checks Door is Weak, if both are satisfied it executes Brake Door Open.}

\label{design:fig:back_chaining_3}
\end{figure}


\begin{algorithm2e}[h]
\KwData{Set of Goal Conditions $C_i$, and a set of PPAs}
\KwResult{A reactive BT working to achieve the $C_i$s }
  Replace all $C_i$ with PPAs having $C_i$ as postcondition\;
 \While{the BT returns Failure when ticked}{
      replace one of the preconditions returning Failure (inside a PPA)
       with another complete PPA having the corresponding condition as postcondition, and therefore including at leaves one action to achieve the failing condition \;
    }    \caption{Pseudocode of Backchaining Algorithm}
  \label{design:alg:backchaining}
\end{algorithm2e}



\begin{figure}[h]
\centering
\includegraphics[width=0.9\columnwidth]{back_chaining_4}
\caption{The result of replacing \emph{Door is Open} in Figure~\ref{design:fig:back_chaining_2} with the PPA of Figure~\ref{design:fig:back_chaining_3}.}
\label{design:fig:back_chaining_4}
\end{figure}

Thus we can iteratively build a deliberative BT by applying   Algorithm~\ref{design:alg:backchaining}.
Looking at the BT in Figure~\ref{design:fig:back_chaining_4} we note that it first checks if the agent \emph{Is Inside House}, if so it returns Success. If not it checks if \emph{Door is Open}, and if it is, it proceeds to \emph{Go Inside}. If not it checks if \emph{Door is Unlocked} and correspondingly executes \emph{Open Door}. Else it checks if \emph{Door is Weak}, and it \emph{Has Crowbar} and proceeds to \emph{Brake Door Open} if that is the case. Else it returns Failure. If an action is executed it might either succeed, which will result in a new condition being satisfied and another action being executed until the task is finished, or it might fail. If \emph{Go Inside} fails, the whole BT returns Failure, but if \emph{Open Door} fails, the conditions \emph{Door is Weak} and \emph{Has Crowbar} are checked.

\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{back_chaining_general}
\caption{General format of a PPA BT. The Postcondition $C$ can be achieved by either one of actions $A_1$ or $A_2$, which have Preconditions $C_{1i}$ and $C_{2i}$ respectively.}
\label{design:fig:back_chaining_general}
\end{figure}

In general, we let the PPA have the form of Figure~\ref{design:fig:back_chaining_general}, with one postcondition $C$ that can be achieved by either one of a set of actions $A_i$, each of these action are combined in a sequence with its corresponding list of preconditions $C_{ij}$, and these action precondition sequences are fallbacks for achieving the same objective. We see that from an efficiency point of view it makes sense to put actions that are most likely to succeed first (to avoid unnecessary failures) and check preconditions that are most likely to fail first (to quickly move on to the next fallback option).


%Despite BTs have the great advantage of being easy to use and understand they require some effort and experience to be fully exploited. 
%In this chapter, we present some design principles and recommendations to employ when designing a task switching policy using BTs.
%We start showing how to achieve a \emph{closed-loop} execution of tasks in a modular and hierarchical way (\ref{design:sec:cl}). Then we give some hints on how to find a good balance between a complex reactive BT and an easy feed-forward BT (\ref{design:sec:granularity}). We then show how to use the design pattern of the implicit sequences mentioned in Section~\ref{properties:sec:propDef} for robust task executions (X.X). We conclude the chapter with some insight on control flow nodes with memory (X.X).

%\section{Realization of the Closed-loop Task Execution}
%\label{design:sec:cl}
%Taking advantages of the \say{tick-driven} execution and fallback composition of BTs, we can easily achieve a \emph{closed-loop} task execution.
%When there is a sequence of actions to be performed in a closed-loop fashion, it is advisable to couple each Action node in the sequence with a Condition node in a Fallback composition.
%
%Each condition has to represent, in a broad sense, effects of the respective action. Due to the semantic of the Fallback composition, the Action is executed only if the Condition is not satisfied. This enables us to always monitor if the effects of an action previously executed still hold and if the execution of an action to execute is actually needed, as in Example~\ref{design:ex:closed} below.
%
%\begin{example}[Closed-loop Task Execution]   
%\label{design:ex:closed}
%
%Consider an assembly task for an industrial robot that coexists in a semi-structured environment with human workers. The tasks to perform are \emph{find object}, \emph{pick object}, \emph{assemble object}, and \emph{place object}. A closed-loop execution of this task can be represented with the BT in Figure~\ref{design:fig:closed}. Note that the BT can reactively handle the unexpected changes due to the human worker in the line such as: the worker pick up the object that the robot is trying to reach, the worker takes away the object from the robots grippers, the worker assemble the last object.
%
%\begin{figure}[h]
%\missingfigure[figwidth=\columnwidth]{real example}
%\caption{Closed loop example}
%\label{design:fig:closed}
%\end{figure}
%\end{example}
%
%

\section{Creating Un-Reactive BTs using Memory Nodes}
\label{sec:design:memory}
As mentioned in Section~\ref{bt:sec:mem}, sometimes a child, once executed, does not need to be re-executed for the whole execution of a task. 
Control flow nodes with memory	are used to simplify the design of a BT avoiding the unwanted re-execution of some nodes. The use of nodes with memory is advised exclusively for those cases where there is no unexpected event that will undo the execution of the subtree in a composition with memory, as in the 
example below.
%example~\ref{design:ex:mem} below.

%\begin{example}[Nodes with Memory]   
Consider the behavior of an industrial manipulator in a production line that has to \emph{pick}, \emph{move}, and \emph{place} objects. The robot's actions are carried out in a fixed workspace, with high precision. Human operators
make sure that nothing on the line changes. If they need a change in the line,
the software is manually updated accordingly. In this example the robot operates in a structured environment that is fully predictable in space and time. In this case we can disregard any unexpected change enabling us to describe the desired behavior
by a Sequence with memory of pick and place as in Figure~\ref{design:fig:mem}. In this scenario, after picking we can be sure that the object does not slips out of the robot's grippers. Hence while the robot is moving the object, the BT does not need to check if the object is still picked.  
\label{design:ex:mem}
\begin{figure}[h]
\centering
  \includegraphics[width=0.6\textwidth]{memoryexample}
\caption{Example of a Un-Reactive Sequence composition of the behaviors pick, move, and place.}
\label{design:fig:mem}
\end{figure}
%\end{example}



\section{Choosing the Proper Granularity of a BT}
\label{design:sec:granularity}

In any modular design, 
 we need to decide the granularity of the modules. In a BT framework, this is translated into the choice of what to represent as a leaf node (single action or condition) and what to represent as a BT. 
The following two cases can be considered.


\begin{itemize}
\item 
It makes sense to encode the behavior in a single leaf when the potential
 subparts of the behavior are always used and executed in this particular combination.%, see Example~\ref{design:ex:reused} below.
 
\item
It makes sense to encode a behavior as a sub-BT, braking it up into conditions, actions and flow control nodes,
when the subparts are likely to be usable in other combinations in other parts of the BT,
and when the reactivity of BTs can be used to re-execute parts of the behavior when needed.%, see Example~\ref{design:ex:closed} below.
 
%Module to be re-used: It is advisable to aggregate a behavior in a leaf node whenever that behavior has to he reused in different parts of the tree or in different projects. As in Example~\ref{design:ex:reused} below.%Consider the BT in Figure~\ref{}. The action XXX has to be reused in XXX, hence XXX.
%\item Modules may have to be re-executed due to unexpected changes in the environment: It is advisable to separate a behavior in different sub-behaviors whenever the execution of a sub-behavior might be undone by unexpected uncontrollable changes (e.g. environmental changes) as in Example~\ref{design:ex:closed} below. In that case, we do not separate the different steps of \emph{assemble object} as we do not need to account for any affecting unexpected changes during the execution of the different steps. 
\end{itemize}


%\begin{example}[Re-use]   
\label{design:ex:reused}
Consider the BT in Figure~\ref{design:fig:reused} describing the behavior of a humanoid robot. The actions \emph{sit} and \emph{stand} 
cannot be divided into meaningful sub-behaviors.
%are re-used in different parts of the tree.

\begin{figure}[h]
\centering
  \includegraphics[width=\textwidth]{bts/figures/hugeBT}
\caption{Robot activity manager}

\label{design:fig:reused}
\end{figure}
%\end{example}


%\begin{example}[Re-execution needed]   
\label{design:ex:closed}

Consider an assembly task for an industrial robot that coexists in a semi-structured environment with human workers. The tasks to perform are \emph{pick object}, \emph{assemble object}, and \emph{place object}. A closed-loop execution of this task can be represented with the BT in Figure~\ref{design:fig:closed}. Note that the BT can reactively handle  unexpected changes, possibly produced by the human worker in the line, such as when the worker picks up an object that the robot is trying to reach, or the object slipping out of the robot gripper while the robot is moving it, etc. If we had instead chosen to aggregate the actions \emph{pick object}, \emph{assemble object}, and \emph{place object} into a single action 
we would lose reactiveness when, for example, the robot has to re-pick an assembled object that slipped out from the robot's grippers. With a single action the robot would try to re-assemble an already assembled object. 
\begin{figure}[h]
\centering
  \includegraphics[width=\textwidth]{closedexample}
\caption{Closed loop example}
\label{design:fig:closed}
\end{figure}
%\end{example}
%

The advice above should give the designer an idea on how to reach a balanced BT that is neither too \emph{fine grained} nor too \emph{compact}. A fine grained BT might be unreasonably complex. While a compact BT may risk being not sufficiently reactive, by executing too many operations in a feed-forward fashion, losing one main advantage of BTs.



\section{Putting it all together}
\label{design:sec:combinations}

\begin{figure}[h]
\centering
  \includegraphics[width=10cm]{burglar_implicit_sequence}
\caption{Implicit sequence design of the activities of a burglar.}
\label{design:fig:burglar_implicit_sequence}
\end{figure}


In this section, we will show how the modularity of BTs make it very straightforward to combine the design principles described in this chapter at different levels of a BT.
Image we are designing the AI for a game character making a living as a burglar.
Its daily live could be filled with stealing and spending money, as described in the BT of Figure~\ref{design:fig:burglar_implicit_sequence}.
Note that we have used the Implicit Sequence design principle from Section~\ref{sec:implicit_sequences}.
The intended progression is driving around until a promising house is found, enter the house and find indications of money nearby,
steal the money and then leave the house to spend the money.

\begin{figure}[h]
\centering
  \includegraphics[width=7cm]{burglar_safety}
\caption{If the escape (or fight) action is efficient enough, this sequence construction will guarantee that the burglar is never caught.}
\label{design:fig:burglar_safety}
\end{figure}

Performing the actions described above, the burglar is also interested in  not beeing captured by the police. Therefore we might design a BT handling when to escape, and when to fight the cops trying to catch it.
This might be considered a safety issue, and we can use the design principle for improving safety using sequences, as described in Section~\ref{sec:safety} above.
The result might look like the BT in Figure~\ref{design:fig:burglar_safety}.
If cops are nearby the burglar will first try to escape, and if that fails fight. If anytime during the fight, the escape option is viable, the burglar will switch to escaping.


\begin{figure}[h]
\centering
  \includegraphics[width=10cm]{back_chaining_4}
\caption{Using backchaining, a BT of desired complexity can be created to get a burglar into a house, this is the same as Figure~\ref{design:fig:back_chaining_4}. }
\label{design:fig:burglar_into_house}
\end{figure}

We saw in Section~\ref{design:sec:back_chaining} how backchaining could be used to create a BT of the desired complexity for achieving a goal. That
same BT is shown here in Figure~\ref{design:fig:burglar_into_house} for reference.

Now, the modularity of BTs enable us to combine all these BTs, created with different design principles, into a single, more complex BT,
as shown in Figure~\ref{design:fig:burglar_combined}.
Note that the reactivity of all parts is maintained, and the switches between different sub-BTs happen just the way they should, for example from Drive Around, to Braking a Door Open (when finding a house), to Fighting Cops (when the police arrives and escape is impossible) and then Stealing Money (when police officers are defeated).
We will come back to this example in the next chapter on BT extensions.

\begin{figure}[h]
\centering
  \includegraphics[width=0.9\textwidth]{burglar_combined}
\caption{A straightforward combination of the BTs in Figures~\ref{design:fig:burglar_implicit_sequence},  \ref{design:fig:burglar_safety}, and   \ref{design:fig:burglar_into_house}.}
\label{design:fig:burglar_combined}
\end{figure}
