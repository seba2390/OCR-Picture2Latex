% !TEX root = ../BTBook.tex

\chapter{Formal Analysis of How Behavior Trees  Generalize Earlier Ideas}
\label{chap:btsvsothers}
\label{ch:btsvsothers}
\graphicspath{{btsvsothers/figures/}}
In this chapter, we will formalize the arguments of Chapter~\ref{ch:earlier_ideas}, using the tools developed in Chapter~\ref{ch:properties}.
In particular, we prove that BTs generalize Decision Trees (\ref{btsvsothers:sec:analogyDTs}), the Subsumptions Architecture (\ref{btsvsothers:sec:analogySA}), Sequential Behavior Compositions (\ref{btsvsothers:sec:analogySBCs}) and the Teleo-Reactive Approach (\ref{btsvsothers:sec:analogyTRs}).
Some of the results of this chapter were previously published in the journal paper \cite{colledanchise2017behavior}.





\section{How BTs Generalize Decision Trees}
\label{btsvsothers:sec:analogyDTs}
%Decision Trees are tree structures that aggregate a number of \emph{If clauses}, that leads to a given  decision or prediction.
%Each leaf of the tree represents a particular decision, prediction, conclusion, or action to be carried out, and each non-leaf represent a predicate to be checked.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=10cm]{decisionTreeEx}
\caption{The Decision Tree of a robot control system. The decisions are interior nodes, and the actions are leaves. }
\label{btsvsothers:fig:decisionTreeEx}
\end{center}
\end{figure}

%A typical decision tree is shown in Figure \ref{btsvsothers:fig:decisionTreeEx}. The predicates, evaluating to True/False are found in the interior nodes of the Tree, while the Actions/Conclusions are found at the leaves. Without loss of generality we consider binary Decision Trees, the extension to multiple choice nodes is straightforward.

Consider the Decision Tree of Figure  \ref{btsvsothers:fig:decisionTreeEx}, the robot has to decide whether to perform a given task or recharge its batteries. This decision is taken based upon the urgency of the task, and the current battery level.
The following Lemma shows how to create an equivalent BT from a given Decision Tree.

\begin{lemma}
\label{btsvsothers:lem:DTBT}
 Given a Decision Tree as follows
 \begin{equation}
 \label{btsvsothers:eq:DT}
DT_i = \begin{cases}
DT_{i1} & \mbox{if predicate $P_i$ is true} \\ 
DT_{i2} & \mbox{if predicate $P_i$ is false} \\ 
\end{cases}
\end{equation}
where 
$DT_{i1}$, $DT_{i2}$ are either atomic actions, or subtrees with identical structure, we can create an equivalent BT by setting
 \begin{equation}
 \bt_i=\mbox{Fallback}( \mbox{Sequence}(P_i,\bt_{i1}),\bt_{i2})
\end{equation}
for non-atomic actions, $ \bt_i = DT_{i}$ for atomic actions
 and requiring all actions to return Running all the time.
 
 The original Decision Tree and the new BT are equivalent in the sense that the same
 values for $P_i$ will always lead to the same atomic action being executed.
 The lemma is illustrated in Figure~\ref{btsvsothers:fig:decisionTreeEq}.
\end{lemma}
\begin{proof}
The BT equivalent of the Decision Tree is given by

\begin{equation*}
 \bt_i=\mbox{Fallback}( \mbox{Sequence}(P_i,\bt_{i1}),\bt_{i2})
\end{equation*}
For the atomic actions always returning Running we have  $r_i=R$,
for the actions being predicates we have that $r_i=P_i$.
This, together with Definitions \ref{bts:def.seq}-\ref{bts:def.fallb} gives that
\begin{equation}
f_i(x) = \begin{cases}
f_{i1} & \mbox{if predicate $P_i$ is true} \\ 
f_{i2} & \mbox{if predicate $P_i$ is false} \\ 
\end{cases}
\end{equation}
which is equivalent to (\ref{btsvsothers:eq:DT}).
\end{proof}

Informally, first we note that by requiring all actions to return Running, we basically disable the feedback functionality that is built into the BT. Instead whatever action that is ticked will be the one that executes, just as the Decision Tree.
Second the result is a direct consequence of the fact that the predicates of the Decision Trees are essentially `If ... then ... else ...' statements, that can be captured by BTs as shown in Figure \ref{btsvsothers:fig:decisionTreeEq}.


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\columnwidth]{decisionTreeEq}
\caption{The basic building blocks of Decision Trees are `If ... then ... else ...' statements (left), and those can be created in BTs as illustrated above (right). }
\label{btsvsothers:fig:decisionTreeEq}
\end{center}
\end{figure}

Note that this observation opens possibilities of using the extensive literature on learning Decision Trees from human operators, see e.g.\ \cite{sammut20027}, to create BTs. These learned BTs can then be extended with safety or robustness  features, as described in Section~\ref{properties:sec:propDef}.




\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.45\columnwidth]{decisionTreeBTeq}
\caption{A BT that is equivalent to the Decision Tree in Figure  \ref{btsvsothers:fig:decisionTreeEx}. 
A compact version of the same tree can be found in Figure \ref{btsvsothers:fig:decisionTreeBTopt}.
}
\label{btsvsothers:fig:decisionTreeBTeq}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.45\columnwidth]{decisionTreeBTopt}
\caption{A compact formulation of the BT in Figure  \ref{btsvsothers:fig:decisionTreeBTeq}. }
\label{btsvsothers:fig:decisionTreeBTopt}
\end{center}
\end{figure}


We finish this section with an example of how BTs generalize Decision Trees.
Consider the Decision Tree in Figure \ref{btsvsothers:fig:decisionTreeEx}. Applying Lemma \ref{btsvsothers:lem:DTBT} we get the equivalent BT of Figure~\ref{btsvsothers:fig:decisionTreeBTeq}. However the direct mapping does not always take full advantage of  the features of BTs. Thus a more compact, and still equivalent, BT can be found in Figure~\ref{btsvsothers:fig:decisionTreeBTopt}, where again, we assume that all actions always return \emph{Running}.







\section{How BTs Generalize the Subsumption Architecture}
\label{btsvsothers:sec:analogySA}
In this section, we will see how the
 Subsumption Architecture, proposed by Brooks~\cite{brooks1986robust}, can be realized using a Fallback composition.
The basic idea in  \cite{brooks1986robust} was to have a number of controllers set up in parallel and each controller was allowed to output both actuator commands, and a binary value, signaling if it wanted to control the robot or not. The controllers were then ordered according to some priority, and the highest priority controller, out of the ones signaling for action, was allowed to control the robot. Thus, a higher level controller was able to \emph{subsume} the actions of a lower level one.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=6cm]{subsump}
\caption{The Subsumption Architecture. A higher level behavior can subsume (or suppress) a lower level one. }
\label{btsvsothers:fig:subsump}
\end{center}
\end{figure}

An example of a Subsumption architecture can be found in Figure  \ref{btsvsothers:fig:subsump}. Here, the basic level controller \emph{Do Other Tasks} is assumed to be controlling the robot for most of the time. However, when the battery level is low enough, the \emph{Recharge if Needed} controller will signal that it needs to command the robot, subsume the lower level controller, and guide the robot towards the recharging station. Similarly, if there is risk for overheating, the top level controller \emph{Stop if Overheated} will subsume both of the lower level ones, and stop the robot until it has cooled down.




\begin{lemma}
\label{btsvsothers:lem:sub}
Given a Subsumption architecture, we can create an equivalent BT by arranging the controllers as actions under a Fallback composition, in order from higher to lower priority. Furthermore, we let the return status of the actions be Failure if they do not need to execute, and Running if they do. They never return Success.
Formally, a subsumption architecture composition $S_i(x)=\mbox{Sub}(S_{i1}(x),S_{i2}(x))$ can be defined by
\begin{equation}
 \label{btsvsothers:eq:subEquiv}
S_i(x) = \begin{cases}
S_{i1}(x) & \mbox{if  $S_{i1}$ needs to execute} \\ 
S_{i2}(x) & \mbox{else} \\ 
\end{cases}
\end{equation}
Then we write an equivalent BT as follows
 \begin{equation}
 \bt_i=\mbox{Fallback}( \bt_{i1},\bt_{i2})
\end{equation}
where $ \bt_{ij}$ is defined by $f_{ij}(x)=S_{ij}(x)$ and
\begin{equation}
r_{ij}(x) = \begin{cases}
\mathcal{R} & \mbox{if  $S_{ij}$ needs to execute} \\ 
\mathcal{F} & \mbox{else}. \\ 
\end{cases}
\end{equation}

\end{lemma}
\begin{proof}
By the above arrangement, and Definition~\ref{bts:def.fallb} we have that
\begin{equation}
f_i(x) = \begin{cases}
f_{i1}(x) & \mbox{if  $S_{i1}$ needs to execute} \\ 
f_{i2}(x) & \mbox{else}, \\ 
\end{cases}
\end{equation}
which is equivalent to (\ref{btsvsothers:eq:subEquiv}) above.
In other words, actions will be checked in order of priority, until one that returns Running is found. 
\end{proof}

A BT version of the example in Figure  \ref{btsvsothers:fig:subsump} can be found in Figure  \ref{btsvsothers:fig:subsBT}. Table \ref{btsvsothers:subsumptionTable} illustrates how the two control structures are equivalent, listing all the $2^3$ possible return status combinations. Note that no action is executed if all actions return Failure.
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\columnwidth]{subsBT}
\caption{A BT version of the Subsumption example in Figure  \ref{btsvsothers:fig:subsump}. }
\label{btsvsothers:fig:subsBT}
\end{center}
\end{figure}

\begin{table}[htp]
%\scriptsize
\begin{center}
\begin{tabular}{|p{1.8cm} |p{1.6cm}|p{1.6cm}|p{2.5cm}|p{2.5cm}|}
\hline
 \bf{Stop if overheated} & \bf{Recharge if Needed} & \bf{Do Other Tasks} & \bf{Action Executed} \cr
\hline
Running & Running & Running & Stop ...  \cr
 \hline
 Running & Running & Failure & Stop ...  \cr
 \hline
 Running & Failure & Running & Stop ...  \cr
 \hline
 Running & Failure & Failure & Stop ...  \cr
 \hline
 Failure & Running & Running & Recharge ...  \cr
 \hline
 Failure & Running & Failure & Recharge ...  \cr
 \hline
 Failure & Failure & Running & Do other ...  \cr
 \hline
 Failure & Failure & Failure & -  \cr \hline
\end{tabular}
\end{center}
\caption{Possible outcomes of Subsumption-BT example.}
\label{btsvsothers:subsumptionTable}
\end{table}%



\section{How BTs Generalize Sequential Behavior Compositions}
\label{btsvsothers:sec:analogySBCs}


In this section, we will see how the Fallback composition, and Lemma \ref{properties:lem:robustnessSelector}, can also be used to implement the Sequential Behavior Compositions proposed in   \cite{burridge1999sequential}.

The basic idea proposed by  \cite{burridge1999sequential}
is to extend the region of attraction by using a family of controllers,
where the asymptotically stable equilibrium of each controller was either the goal state, or inside the region of attraction of another controller, positioned earlier in the sequence. 

%Burridge also notes that it is often the case that no available feedback control algorithm can successfully stabilize as large a range of initial conditions as desired.

 
 We will now describe the construction of   \cite{burridge1999sequential} in some detail, and then see how this concept is captured in the BT framework. Given a family of controllers $U=\{\Phi_i\}$, we say that $\Phi_i$ \emph{prepares} $\Phi_j$ if the goal $G(\Phi_i)$ is inside the domain $D(\Phi_j)$. Assume the overall goal is located at $G(\Phi_1)$. A set of execution regions $C(\Phi_i)$ for each controller was then calculated according to the following scheme:
 
 
\begin{enumerate}
 \item Let a Queue contain $\Phi_1$. Let $C(\Phi_1)=D(\Phi_1)$, $N=1$, $D_1=D(\Phi_1)$.
 \item Remove the first element of the queue and append all controllers that \emph{prepare} it to the back of the queue.
 \item Remove all elements in the queue that already has a defined $C(\Phi_i)$.
 \item Let $\Phi_j$ be the first element in the queue. Let $C(\Phi_j)=D(\Phi_j) \setminus D_N$, $D_{N+1}=D_N \cup D(\Phi_j)$ and $N \leftarrow N+1$.
 \item Repeat steps 2, 3 and 4 until the queue is empty.
\end{enumerate}
 
The combined controller is then executed by finding $j$ such that $x \in C(\Phi_j)$ and then  invoking controller $\Phi_j$.
 
Looking at the design of the Fallback operator in BTs, it turns out that it does exactly the job of the Burridge algorithm above, as long as the subtrees of the Fallback are ordered in the same fashion as the queue above. We formalize this in  Lemma \ref{btsvsothers:lem:seqBComp} below.



\begin{lemma}
\label{btsvsothers:lem:seqBComp}
Given a set of controllers $U=\{\Phi_i\}$ we define the corresponding regions $S_i=G(\Phi_i), R_i'=D(\Phi_i), F_i=\mbox{Complement}(D(\Phi_i))$, and consider the controllers as atomic BTs, $\bt_i=\Phi_i$.
Assume $S_1$ is the overall goal region.
 Iteratively create a larger BT $\bt_L$ as follows
\begin{itemize}
 \item[1. ] Let  $\bt_L=\bt_1$. 
 \item[2. ] Find a BT $\bt_*\in U$ such that $S_* \subset R_L'$
 \item[3. ] Let $\bt_L \leftarrow \mbox{Fallback}(\bt_L,\bt_*)$
 \item[4. ] Let $U \leftarrow U \setminus \bt_*$
 \item[5. ] Repeat steps 2, 3 and 4 until $U$ is empty.
\end{itemize}
%If all $\bt_i$ are \emph{safe} with respect to some obstacle region, $O \not \subset D(\Phi_i)$ then so is $\bt_L$.
If all $\bt_i$ are FTS, then so is $\bt_L$.
\end{lemma}
\begin{proof}
The statement is a direct consequence of iteratively applying Lemma \ref{properties:lem:robustnessSelector}.
\end{proof}

Thus, we see that BTs generalize the Sequential Behavior Compositions of \cite{burridge1999sequential},
with the execution region computations and controller switching replaced by the Fallback composition,
as long as the ordering is given by Lemma~\ref{btsvsothers:lem:seqBComp} above.



%\section{How BTs Generalize AND-OR Trees}
%\label{btsvsothers:sec:analogyAndOr}
%
%
%In this section we describe the analogy between And-Or-Trees and BTs. And-Or-Trees are used in heuristic problem solving \cite{pearl1984heuristics}, 
%and have two types of nodes, \emph{OR nodes} that combine subtrees representing \emph{alternative} ways of solving a problem,
%and \emph{AND nodes} which represent problem composition into independent subproblems, \emph{all of which} needs to be solved to solve 
%the original problem.
%
%It can be noted that And-Or-Trees have alternating levels of AND and OR nodes, and a solution $S$ to a And-Or-Search tree $T$
%is not a path, but a subtree, which contains the root node of $T$ and a sufficiently large set of the other nodes such
%that no contradiction occurs when all nodes in $S$ are True and all others are False. 
%Thus if a node in S is an AND node, all its children needs to also be in $S$, but if it is an OR node, only one of its children needs to be in $S$, \cite{marinescu2004and}.
%
%\begin{example}
%\label{btsvsothers:ex:andOrTree}
% Consider the And-Or-Tree in Figure \ref{btsvsothers:andOrTree}. The problem at hand is that of opening a door. The possible solutions to the problem are 1)   
% \emph{Door can be opened without keys} is true, or 
% 2) the combination of \emph{Keys can open door} and \emph{Keys are on table} is true, or
% 3) the combination of \emph{Keys can open door} and \emph{Keys are in drawer} is true. 
% The latter solution is represented by the subtree indicated by thicker edges in the figure.
%\end{example}
%
%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=0.4\columnwidth]{andOrTree}
%\caption{The door can be opened if the top node is true. This  happens when e.g., all conditions with thick edges are true, see Example~\ref{btsvsothers:ex:andOrTree}. }
%\label{btsvsothers:andOrTree}
%\end{center}
%\end{figure}
%
%The BT analogy of Example~\ref{btsvsothers:ex:andOrTree} can be found in Figure~\ref{btsvsothers:andOrBT}.
%There, the OR nodes are replaced by Fallbacks (requiring just one child to succeed) and the AND nodes are replaced by Sequences (requiring all children to succeed).
%If this is done, the BT works as an exact copy of the And-Or-Tree, as conditions never return Running.
%However, if
% the conditions are replaced by actions trying to make the corresponding conditions true,
%returning Running while trying, and returning \emph{Success} or \emph{Failure} after the action is completed,
%we get a rational feedback execution aiming towards completing  the overall task as described below.
%
%
%
%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=0.35\columnwidth]{andOrBT}
%\caption{The BT analogy of the And-Or-Tree in Figure~\ref{btsvsothers:andOrBT}. The door is successfully opened when the top node returns Success. This happens e.g., when all the nodes with thick edges return Success.}
%\label{btsvsothers:andOrBT}
%\end{center}
%\end{figure}
%
%Executing the BT in Figure~\ref{btsvsothers:andOrBT} on a robot would thus lead to the robot first trying to \emph{Open door without keys}.
%If this action succeeds, the robot is done. If the action fails the sequence is ticked, which in turn ticks the fallback, which in turn ticks 
% \emph{Find keys on table}. If this action succeeds, the robot continues to \emph{Open door with keys}. If  \emph{Find keys on table}
% fails on the other hand, the robot continues with  \emph{Find keys in drawer}. If both actions aimed at finding the keys fail, there is no need to
% try  \emph{Open door with keys}. Instead, the robot returns failure.
% 
% Thus, the And-Or-Tree of conditions was turned into a BT feedback execution plan,
% executing only actions that might lead to overall task completion.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{How BTs Generalize the Teleo-Reactive approach}
\label{btsvsothers:sec:analogyTRs}
In this section, we use the following 
Lemma to show how to create a BT with the same execution as a given Teleo-Reactive program. The lemma is illustrated by Example~\ref{btsvsothers:ex:goto} and Figure~\ref{btsvsothers:tr2bt}.

\begin{lemma}[Teleo-Reactive BT analogy]
\label{btsvsothers:lem:tr2bt}
 Given a TR in terms of conditions $c_i$ and actions $a_i$, an equivalent BT can be constructed as follows
\begin{equation}
 \bt_{TR}=\mbox{Fallback}(\mbox{Sequence}(c_1,a_1), \ldots, \mbox{Sequence}(c_m,a_m)),
\end{equation}
where we convert the True/False of the conditions to Success/Failure, and let the actions only return Running.
\end{lemma}
\begin{proof}
 It is straightforward to see that the BT above executes the exact same $a_i$ as the original TR would have, depending on the values of the conditions $c_i$, i.e. it finds the first condition $c_i$ that returns Success, and executes the corresponding $a_i$.
\end{proof}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.8\columnwidth]{tr2bt}
\caption{The BT that is analogous to a given TR.}
\label{btsvsothers:tr2bt}
\end{center}
\end{figure}

We will now illustrate the lemma with an example from Nilssons original paper~\cite{nilsson1994teleo}.

\begin{example}
\label{btsvsothers:ex:goto}
 The Teleo-Reactive program \emph{Goto(loc)} is described as follows, with conditions on the left and corresponding actions to the right:
\begin{eqnarray}
 \mbox{Equal(pos,loc)} &\rightarrow& \mbox{Idle} \\
 \mbox{Heading Towards (loc)} &\rightarrow& \mbox{Go Forwards} \\
 \mbox{(else)} &\rightarrow& \mbox{Rotate} 
\end{eqnarray}
where \emph{pos} is the current robot position and \emph{loc} is the current destination.

Executing this Teleo-Reactive program, we get the following behavior. If the robot is at the destination it does nothing. If it is heading the right way it moves forward, 
and else it rotates on the spot. In a perfect world without obstacles, this will get the robot to the goal, just as predicted in Lemma~\ref{btsvsothers:lem:TR}.
Applying Lemma~\ref{btsvsothers:lem:tr2bt}, the Teleo-Reactive program Goto is translated to a BT in Figure~\ref{btsvsothers:fig:goto}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.9\columnwidth]{goto}
\caption{The BT version of the Teleo-Reactive program Goto. }
\label{btsvsothers:fig:goto}
\end{center}
\end{figure}

The example continues in  \cite{nilsson1994teleo} with 
 a higher level recursive Teleo-Reactive program, called \emph{Amble(loc)}, designed to add a basic obstacle avoidance behavior
\begin{eqnarray}
 \mbox{Equal(pos,loc)} &\rightarrow& \mbox{Idle} \\
 \mbox{Clear Path(pos,loc)} &\rightarrow& \mbox{GoTo(loc)} \\
 \mbox{(else)} &\rightarrow& \mbox{Amble(new point(pos,loc))} 
\end{eqnarray}
where \emph{new point} picks a new random point in the vicinity of \emph{pos} and \emph{loc}.

Again,
if the robot is at the destination it does nothing. If the path to goal is clear it executes the Teleo-Reactive program Goto. 
Else it picks a new point relative to its current position and destination (loc) and recursively executes a new copy of Amble with that destination.
Applying Lemma~\ref{btsvsothers:lem:tr2bt}, the Amble TR is translated to a BT in Figure~\ref{btsvsothers:fig:amble}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.9\columnwidth]{amble}
\caption{The BT version of the TR Amble. }
\label{btsvsothers:fig:amble}
\end{center}
\end{figure}

\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Universal Teleo-Reactive programs and FTS BTs}
\label{btsvsothers:sec:analogyTRs2}
Using the functional form of BTs introduced in~\ref{bts:sec:funcBT} we can show that Lemma~\ref{properties:lem:robustnessSelector} is a richer version of Lemma \ref{btsvsothers:lem:TR} below, and also fix one of its assumptions. Lemma~\ref{properties:lem:robustnessSelector} includes execution time, but more importantly builds on a finite difference equation system model over a continuous state space.
Thus control theory concepts can be used to include phenomena such as imperfect sensing and actuation into the analysis, that was
removed in the strong assumptions of Lemma~\ref{btsvsothers:lem:TR}.
Thus, the BT analogy provides a powerful tool for analyzing Teleo-Reactive designs.

\begin{lemma}[Nilsson 1994]
\label{btsvsothers:lem:TR}
 If a Teleo-Reactive program is Universal, and there are no sensing and execution errors, then the execution of the program will lead to
 the satisfaction of $c_1$.
\end{lemma}
\begin{proof}
In \cite{nilsson1994teleo} it is stated that it is easy to see that this is the case.
\end{proof}

The idea of the proof is indeed straight forward, but as we will see when we compare it to the BT results in Section~\ref{btsvsothers:sec:analogyTRs2} below, the proof is incomplete.

In Lemma~\ref{properties:lem:robustnessSelector},  $S_i,R_i,F_i$ correspond to Success, Running and Failure regions and $R'$ denotes the region of attraction.

Lemma~\ref{properties:lem:robustnessSelector} shows under what conditions we can guarantee that the Success region $S_0$ is reached in finite time.
If we for illustrative purposes assume that the regions of attraction are identical to the running regions $R_i=R_i'$,
the lemma states that as long as the system starts in $R_0'= R_1' \cup R_2'$ it will reach $S_0=S_1$ in less than $\tau_0=\tau_1+\tau_2$
time units. The condition analogous to the \emph{regression property} is that $S_2 \subset  R_1'$, i.e. that the Success region of the second BT
is a subset of the region of attraction $R_1'$ of the first BT. The regions of attraction, $R_1'$ and $R_2'$ are very important,
but  there is no corresponding concept in Lemma  \ref{btsvsothers:lem:TR}. 
In fact, we can construct a counter example showing that Lemma  \ref{btsvsothers:lem:TR} does not hold.



\begin{example}[Counter Example]
 Assume that a Teleo-Reactive program is Universal in the sense described above. 
 Thus, the execution of action $a_i$ eventually leads to the satisfaction of $c_j$ where $j<i$ for all $i\neq 1$.
 However, assume it is also the case that the execution of $a_i$, on its way towards satisfying $c_j$ actually leads to a violation of $c_i$.
 This would lead to the first true condition being some $c_m$, with $m>i$ and the execution of the corresponding action $a_m$.
 Thus, the chain of decreasing condition numbers is broken, and the goal condition $a_1$ might never be reached.
\end{example}

The fix is however quite straightforward, and amounts to using the following definition with a stronger assumption.

\begin{definition}[Stronger Regression property]
 For each $c_i, i>1$ there is $c_j, j<i$ such that the execution of action $a_i$ leads to the satisfaction of $c_j$, \emph{without ever violating} $c_i$.
\end{definition}
