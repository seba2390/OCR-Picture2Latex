% !TEX root = ../BTBook.tex

\graphicspath{{properties/figures/}}

\chapter{Analysis of Efficiency, Safety, and Robustness}
\label{chap:properties}
\label{ch:properties}


Autonomous agents will need to be efficient, robust, and reliable in order to be used on a large scale. 
 In this chapter, we present a mathematical framework for analyzing  these properties for  a BT~(Section~\ref{bts:sec:funcBT}).
The analysis includes efficiency (Section~\ref{properties:sec:propDef}), in terms of execution time bounds; robustness (Section~\ref{properties:sec:propDef}), in terms of capability to operate in large domains; and safety (Section~\ref{properties:sec:safety}), in terms of avoiding some particular parts of the state space. 
Some of the results of this chapter were previously published in the journal paper \cite{colledanchise2017behavior}.




\section{Statespace  Formulation of BTs}
\label{bts:sec:funcBT}

In this section, we present a new formulation of BTs.
The new formulation is more formal, and will allow us to analyze how properties are preserved over modular compositions of BTs.
In the functional version, the \emph{tick} is replaced by a recursive function call that includes both the return status, the system dynamics and the system state.
%The details of the formulation are derived from  the pseudo code of Section~\ref{bts:sec:background}, above.




\begin{definition}[Behavior Tree]
\label{bts:thesis.thesis.def:BT}
A BT is a three-tuple 
\begin{equation}
 \bt_i=\{f_i,r_i, \Delta t\}, 
\end{equation}
where $i\in \mathbb{N}$ is the index of the tree, $f_i: \mathbb{R}^n \rightarrow  \mathbb{R}^n$ is the right hand side of an ordinary difference equation, $\Delta t$ is a time step and 
$r_i: \mathbb{R}^n \rightarrow  \{\mathcal{R},\mathcal{S},\mathcal{F}\}$ is the return status that can be equal to either 
\emph{Running} ($\mathcal{R}$),
\emph{Success} ($\mathcal{S}$), or
\emph{Failure} ($\mathcal{F}$).
Let the Running/Activation region ($R_i$),
Success region ($S_i$) and
Failure region ($F_i$) correspond to a partitioning of the state space,  defined as follows:
\begin{eqnarray}
 R_i&=&\{x: r_i(x)=\mathcal{R} \} \\
 S_i&=&\{x: r_i(x)=\mathcal{S} \} \\
 F_i&=&\{x: r_i(x)=\mathcal{F} \}. 
\end{eqnarray}
Finally,  let $x_k=x(t_k)$ be the system state at time $t_k$, then the execution of a BT $\bt_i$ is a standard ordinary difference equation
\begin{eqnarray}
 x_{k+1}&=&f_i( x_{k}),  \label{bts:eq:executionOfBT}\\
 t_{k+1}&=&t_{k}+\Delta t.
\end{eqnarray}
 \end{definition}
The return status $r_i$ will be used when combining BTs recursively, as explained below.

\begin{assumption}
\label{bts:ass:same}
 From now on we will assume that all BTs evolve 
in the same continuous space $\mathbb{R}^n$ using
 the same time step $\Delta t$. 
\end{assumption}
 
 
\begin{remark}
\label{bts:rem:differentStatespace}
It is often the case, that different BTs, controlling different vehicle subsystems evolving in different state spaces, need to be 
 combined into a single BT. Such cases can be accommodated in the assumption above by letting all systems evolve in a larger state space, that is the Cartesian product of the smaller state spaces.
\end{remark}

%The five node types of Table \ref{bts:nodeTable} are given functional representations as follows.
%BTs that satisfy Definition \ref{bts:thesis.thesis.def:BT} directly, without calling other subtrees, are  called  Actions
%and Conditions, with the later ones never returning Running. The three composition nodes, corresponding to Algorithms 1-3 are defined below.





\begin{definition}[Sequence compositions of BTs]
\label{bts:def.seq}
 Two or more BTs  can be composed into a more complex BT using a Sequence operator,
 $$\bt_0=\mbox{Sequence}(\bt_1,\bt_2).$$ 
 Then $r_0,f_0$ are defined as follows
\begin{eqnarray}
   \mbox{If }x_k\in S_1&& \\
   r_0(x_k) &=&  r_2(x_k) \\
   f_0(x_k) &=&  f_2(x_k) \label{bts:eq:seq1}\\ 
   \mbox{ else }&& \nonumber \\
   r_0(x_k) &=&  r_1(x_k) \\
   f_0(x_k) &=&  f_1(x_k). \label{bts:eq:seq2}
 \end{eqnarray}
\end{definition}
$\bt_1$ and $\bt_2$ are called children of $\bt_0$. Note that when executing the new BT, $\bt_0$ first keeps executing its first child $\bt_1$ as long as it returns Running or Failure.  
The second child is executed only when the first returns Success, and $\bt_0$ returns Success only when all children have succeeded, hence the name Sequence,
just as the classical definition of Sequences in Algorithm~\ref{bts:alg:sequence} of Section~\ref{sec:classicalBT}.

For notational convenience, we write
\begin{equation}
 \mbox{Sequence}(\bt_1, \mbox{Sequence}(\bt_2,\bt_3))= \mbox{Sequence}(\bt_1,\bt_2, \bt_3),
\end{equation}
and similarly for arbitrarily long compositions.



\begin{definition}[Fallback compositions of BTs]
\label{bts:def.fallb}
 Two or more BTs  can be composed into a more complex BT using a Fallback operator,
 $$\bt_0=\mbox{Fallback}(\bt_1,\bt_2).$$ 
 Then $r_0,f_0$ are defined as follows
\begin{eqnarray}
   \mbox{If }x_k\in {F}_1&& \\
   r_0(x_k) &=&  r_2(x_k) \\
   f_0(x_k) &=&  f_2(x_k) \\ 
   \mbox{ else }&&\nonumber \\
   r_0(x_k) &=&  r_1(x_k) \\
   f_0(x_k) &=&  f_1(x_k).
 \end{eqnarray}
\end{definition}


Note that when executing the new BT, $\bt_0$  first keeps executing its first child $\bt_1$ as long as it returns Running or Success. 
The second child is executed only when the first returns Failure, and $\bt_0$ returns Failure only when all children have tried, but failed, hence the name Fallback,
just as the classical definition of Fallbacks in Algorithm~\ref{bts:alg:fallback} of Section~\ref{sec:classicalBT}. 
 
 
 For notational convenience, we write
\begin{equation}
 \mbox{Fallback}(\bt_1, \mbox{Fallback}(\bt_2,\bt_3))= \mbox{Fallback}(\bt_1,\bt_2, \bt_3),
\end{equation}
and similarly for arbitrarily long compositions.

Parallel compositions only make sense if the BTs to be composed control separate parts of the state space, thus we make the following assumption.
\begin{assumption}
\label{bts:ass:parallel}
 Whenever two BTs $\bt_1,\bt_2$ are composed in parallel, we assume that there is a partition of the state space $x=(x_1,x_2)$ such that $f_1(x)=(f_{11}(x),f_{12}(x))$ implies $f_{12}(x)=x$ and $f_2(x)=(f_{21}(x),f_{22}(x))$
implies $f_{21}(x)=x$ (i.e. the two BTs control different parts of the system). 
\end{assumption}


 
 \begin{definition}[Parallel compositions of BTs]
 \label{bts:def:parallel}
 Two or more BTs  can be composed into a more complex BT using a Parallel operator,
 $$\bt_0=\mbox{Parallel}(\bt_1,\bt_2).$$ 
 Let $x=(x_1,x_2)$ be the partitioning of the state space described in Assumption~\ref{bts:ass:parallel},
 then $f_0(x)=(f_{11}(x),f_{22}(x))$ and $r_0$ is defined as follows
\begin{eqnarray}
   \mbox{If } M=1&&\nonumber \\
   r_0(x) &=&  \mathcal{S}  \mbox{ If } r_1(x)=\mathcal{S} \vee r_2(x)=\mathcal{S}\\
   r_0(x) &=&  \mathcal{F}  \mbox{ If } r_1(x)=\mathcal{F} \wedge r_2(x)=\mathcal{F}\\
   r_0(x) &=&  \mathcal{R}  \mbox{ else } \\
   \mbox{If } M=2&&\nonumber \\
   r_0(x) &=&  \mathcal{S}  \mbox{ If } r_1(x)=\mathcal{S} \wedge r_2(x)=\mathcal{S}\\
   r_0(x) &=&  \mathcal{F}  \mbox{ If } r_1(x)=\mathcal{F} \vee r_2(x)=\mathcal{F}\\
   r_0(x) &=&  \mathcal{R}  \mbox{ else } 
 \end{eqnarray}
\end{definition}

% 
% \begin{remark}
% Note that we do not include the parallel node in the functional representation.
% The reason is that the parallel node is often used when different subsystems, evolving in different statespaces, needs to be run in parallel.
% As noted in Remark \ref{bts:rem:differentStatespace}
% this can be addressed by creating a cartesian product of the statespaces.
% However, this makes the notation of a functional parallel node somewhat messy, 
% and since we will not use it in the analysis below, we choose not to include it.
% \end{remark}


\section{Efficiency and Robustness }
\label{properties:sec:propDef}


In this section we will show how some aspects of time efficiency and robustness

carry across modular compositions of BTs. This result will then enable us to conclude, that if two BTs are efficient, then their composition will also be \emph{efficient}, if the right conditions are satisfied.
We also show how the Fallback composition can be used to increase the region of attraction of a BT, thereby making it more robust to uncertainties in the initial configuration.

Note that, as in \cite{burridge1999sequential}, by robustness we mean large regions of attraction. We do not investigate e.g.\ disturbance rejection, or other forms of robustness\footnote{Both meanings of robustness are  aligned with the IEEE standard glossary of software engineering terminology:
``The degree to which a system or component can function correctly in the presence of invalid inputs or stressful environmental conditions."}


Many control problems, in particular in robotics, can be formulated in terms of achieving a given goal configuration in a way that is  time efficient and robust with respect to the initial configuration. Since all BTs return either Success, Failure, or Running, the definitions below will include a finite time, at which Success must be returned.

In order to formalize the discussion above, we  say that
 \emph{efficiency} can be measured by the size of a time bound $\tau$ in Definition~\ref{properties:def:FTS} and
 \emph{robustness} can be measured by the size of the region of attraction $R'$ in the same definition.
% a BT is \emph{efficient} if it satisfies Definition~\ref{properties:def:FTS} with a small $\tau$ and \emph{robust} if it satisfies the same definition with a large region of attraction $R'$.


\begin{definition}[Finite Time Successful]
\label{properties:def:FTS}
 A BT is Finite Time Successful (FTS) with region of attraction $R'$, if for all starting points $x(0)\in R'\subset R$, there is a time $\tau$, and a time $\tau'(x(0))$ such that $\tau'(x)\leq \tau$ for all starting points, and
 %$x(\tau')\in S$ for some $\tau'\leq \tau$ and 
 $x(t)\in R'  $ for
 all $t\in [0,\tau')$ 
 and $x(t)\in S$ for
  $t = \tau'$
\end{definition}
As noted in the following lemma, exponential stability implies FTS, given the right choices of the sets $S,F,R$.
\begin{lemma}[Exponential stability and FTS]
 A BT for which $x_s$ is a globally exponentially stable equilibrium of the execution (\ref{bts:eq:executionOfBT}),
 and $S \supset \{x: ||x-x_s||\leq \epsilon\}$, $\epsilon>0$, $F=\emptyset$,  $R=\mathbb{R}^n \setminus S$, is FTS.
\end{lemma}
\begin{proof}
Global exponential stability implies that there exists  $a>0$ such that $||x(k)-x_s|| \leq e^{-ak}$ for all $k$.
Then, for each $\epsilon$ there is a time $\tau$ such that $||x(k)-x_s|| \leq e^{-a\tau}<\epsilon$, which implies that there is a $\tau'<\tau$ such that $x(\tau')\in S$ and the BT is FTS.
\end{proof}



We are now ready to look at how these properties extend across compositions of BTs.


\begin{lemma}
\label{properties:lem:robustnessSequence}
\emph{(Robustness and Efficiency of Sequence Compositions)}
If $\bt_1,\bt_2$ are FTS, with $S_1=R_2' \cup S_2 $,
then $\bt_0=\mbox{Sequence}(\bt_1,\bt_2)$ is FTS with 
$\tau_0 = \tau_1+\tau_2$, 
$R_0'= R_1' \cup R_2'$ and 
$S_0=S_1 \cap S_2 = S_2$.
\end{lemma}
\begin{proof}
 First we consider the case when $x(0)\in R_1'$. Then, as $\bt_1$ is FTS, the state will reach $S_1$ in a time   $k_1 <\tau_1$, without leaving $R_1'$.
 Then $\bt_2$ starts executing, and will keep the state inside $S_1$, since $S_1=R_2' \cup S_2$.
 $\bt_2$ will then bring the state into $S_2$, in a time $k_2 <\tau_2$, and $\bt_0$ will return Success.
 Thus we have the combined time $k_1+k_2 <\tau_1+\tau_1$.
 
 If $x(0)\in R_2'$, $\bt_1$ immediately returns Success, and $\bt_2$ starts executing as above.
\end{proof}

The lemma above is illustrated in Figure \ref{properties:fig:seq1rob}, 
and  Example~\ref{properties:ex:seq}
 below.


\begin{figure}[h]
\begin{center}
\includegraphics[width=4cm]{sequence}
\caption{
A Sequence is used to to create an \emph{Enter Through Front Door} BT.
Passing the door  is only tried if the opening action succeeds.
Sequences are denoted by a white box with an arrow.}
\label{properties:fig:recipe}
\end{center}
\end{figure}


 \begin{figure}[h]
\begin{center}
\includegraphics[width=0.8\columnwidth]{seqComp}
\caption{The sets $R_1', S_1, R_2', S_2$ of Example \ref{properties:ex:seq} and Lemma \ref{properties:lem:robustnessSequence}. }
\label{properties:fig:seq1rob}
\end{center}
\end{figure}

\begin{example}
\label{properties:ex:seq}
Consider the BT in Figure \ref{properties:fig:recipe}.
If we know that \emph{Open Front Door} is FTS and will finish in less than $\tau_1$ seconds, and that \emph{Pass through Door} is FTS and will finish in less than $\tau_2$ seconds. Then, as long as $S_1=R_2' \cup S_2$,
Lemma \ref{properties:lem:robustnessSequence} states that the combined BT in Figure  \ref{properties:fig:recipe} is also FTS, with an upper bound on the execution time of $\tau_1+\tau_2$.
Note that the condition $S_1=R_2' \cup S_2$ implies that
 the action  \emph{Pass through Door} will not make the system leave $S_1$, by e.g. accidentally colliding with the door and thereby closing it without having passed through it.
\end{example}



The result for Fallback compositions is related, but with a slightly different condition on $S_i$ and $R_j'$. 
Note that this is the theoretical underpinning of the design principle \emph{Implicit Sequences} described in Section~\ref{sec:implicit_sequences}.


\begin{lemma}
\label{properties:lem:robustnessSelector}
\emph{(Robustness and Efficiency of Fallback Compositions)}
If $\bt_1,\bt_2$ are FTS, with $S_2 \subset  R_1'$ and $R_1«=R_1$,
then $\bt_0=\mbox{Fallback}(\bt_1,\bt_2)$ is FTS with 
$\tau_0 = \tau_1+\tau_2$, 
$R_0'= R_1' \cup R_2'$ and 
$S_0=S_1$.
\end{lemma}
\begin{proof}
 First we consider the case when $x(0)\in R_1'$. Then, as $\bt_1$ is FTS, the state will reach $S_1$ before $k=\tau_1<\tau_0$, without leaving $R_1'$.
 If $x(0)\in R_2'\setminus R_1'$, $\bt_2$ will execute, and the state will progress towards $S_2$.  But as $S_2 \subset R_1'$, $x(k_1)\in R_1'$ at some time $k_1<\tau_2$. Then, we have the case above, reaching $x(k_2) \in S_1$ in a total time of $k_2<\tau_1+k_1<\tau_1+\tau_2$.
\end{proof}

The Lemma above is illustrated in Figure \ref{properties:fig:sel1}, and Example~\ref{properties:ex:sel}
 below.

 \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{vennDias_sel1}
\caption{The sets $S_1, F_1, R_1$ (solid boundaries) and $S_2, F_2, R_2$ (dashed boundaries) of Example \ref{properties:ex:sel} and Lemma \ref{properties:lem:robustnessSelector}. }
\label{properties:fig:sel1}
\end{center}
\end{figure}
 \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.4\columnwidth]{implicit}
\caption{An Implicit Sequence created  using a Fallback, as described in Example
 \ref{properties:ex:sel} and Lemma \ref{properties:lem:robustnessSelector}. }
\label{properties:fig:implicit}
\end{center}
\end{figure}

\begin{remark}
 As can be noted, the necessary conditions in Lemma \ref{properties:lem:robustnessSequence},
including~$S_1=R_2' \cup S_2 $ might be harder to satisfy than the conditions of 
Lemma \ref{properties:lem:robustnessSelector}, including~$S_2 \subset  R_1'$.
Therefore,  Lemma \ref{properties:lem:robustnessSelector} is often preferable from a practical point of view,
e.g. using implicit sequences as shown below.
\end{remark}

\begin{example}
\label{properties:ex:sel}
This example will illustrate the design principle \emph{Implicit sequences} of Section~\ref{sec:implicit_sequences}.
Consider the BT in Figure \ref{properties:fig:implicit}. During execution, if  the door is closed, then \emph{Pass through Door} will fail and \emph{Open Front Door} will start to execute. Now, right before \emph{Open Front Door} returns Success, the first action  \emph{Pass through Door} (with higher priority) will realize that the state of the world has now changed enough to enable a possible success and starts to execute, i.e.\ return Running instead of Failure. The combined action of this BT will thus make the robot open the door (if necessary) and then pass through if.

Thus, even though a Fallback composition is used, the result   is sometimes a sequential execution of the children in reverse order (from right to left). Hence the name Implicit sequence.
\end{example}

The example above illustrates how we can increase the robustness of a BT.
If we want to be able to handle more diverse situations, such as a closed door, we do not have to make the door passing action more complex, instead we combine it with another BT that can handle the situation and move the system into a part of the statespace that the first BT can handle.
The sets $S_0, F_0, R_0$ and $f_0$ of the combined BT are shown in Figure~\ref{properties:fig:sel2}, together with the  vector field $f_0(x)-x$.
As can be seen, the combined BT can now move a larger set of initial conditions to the desired region $S_0=S_1$.


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{vennDias_sel2}
\caption{The sets $S_0, F_0, R_0$ and the vector field $(f_0(x)-x)$ of Example~\ref{properties:ex:sel} and Lemma \ref{properties:lem:robustnessSelector}. }
\label{properties:fig:sel2}
\end{center}
\end{figure}



\begin{lemma}
\label{properties:lem:robustnessParallel}
\emph{(Robustness and Efficiency of Parallel Compositions)}
If $\bt_1,\bt_2$ are FTS,
then $\bt_0=\mbox{Parallel}(\bt_1,\bt_2)$ is FTS with 

\begin{eqnarray}
   \mbox{If } M=1&&\nonumber \\
	R_0' &=& \{R_1' \cup R_2'\} \setminus \{S_1 \cup S_2\}   \\ 
	S_0 &=& S_1 \cup S_2  \\ 		
	\tau_0 &=& \min(\tau_1,\tau_2) \\
   \mbox{If } M=2&&\nonumber \\
	R_0' &=&  \{R_1' \cap R_2'\} \setminus \{S_1 \cap S_2\}  \\ 
	S_0 &=& S_1 \cap S_2  \\ 
	\tau_0 &=& \max(\tau_1,\tau_2)
 \end{eqnarray}
\end{lemma}
\begin{proof}
The Parallel composition executes $\bt_1$ and $\bt_2$ independently. If $M = 1$ the Parallel composition returns Success if either  $\bt_1$ or $\bt_2$ returns Success, thus $\tau_0 = \min(\tau_1,\tau_2)$. It returns Running if either  $\bt_1$ or $\bt_2$ returns Running and the other does not return Success. If $M = 2$ the Parallel composition returns Success if and only if both  $\bt_1$ and $\bt_2$ return Success, thus $\tau_0 = \max(\tau_1,\tau_2)$.
It returns Running if either  $\bt_1$ or $\bt_2$ returns Running and the other does not return Failure.
\end{proof}


%
%%%
%The second result regarding robustness, is a variation on the elegant
% funnel argument of  Burridge et al  \cite{burridge1999sequential}.
% There, they showed how the region of attraction could be extended using a family of controllers, as long as the asymptotically stable equilibrium of each controller was either the goal state, or inside the region of attraction of another controller, positioned earlier in the sequence. 
% 
% We will now describe the construction of  Burridge et al \cite{burridge1999sequential} in some detail, and then see how this concept is captures in the BT framework. Given a family of controllers $U=\{\Phi_i\}$, we say that $\Phi_i$ \emph{prepares} $\Phi_j$ if the goal $G(\Phi_i)$ is inside the domain $D(\Phi_j)$. Assume the overall goal is located at $G(\Phi_1)$. A set of execution regions $C(\Phi_i)$ for each controller was then calculated according to the following scheme:
% 
% 
%\begin{enumerate}
% \item Let the queue contain $\Phi_1$. Let $C(\Phi_1)=D(\Phi_1)$, $N=1$, $D_1=D(\Phi_1)$.
% \item Remove the first element of the queue and append all controllers that \emph{prepare} it to the back of the queue.
% \item Remove all elements in the queue that already has a defined $C(\Phi_i)$.
% \item Let $\Phi_j$ be the first element in the queue. Let $C(\Phi_j)=D(\Phi_j) \setminus D_N$, $D_{N+1}=D_N \cup D(\Phi_j)$ and $N \leftarrow N+1$.
% \item Repeat steps 2,3 and 4 until the queue is empty.
%\end{enumerate}
% 
%The combined controller is then executed by finding $j$ such that $x \in C(\Phi_j)$ and then  invoking controller $\Phi_j$.
% 
%Looking at the design of the Selector operator in BTs, it turns out that it does exactly the job of the Burridge algorithm above, as long as the subtrees of the Selector are ordered in the same fashion as the queue above. We formalize this in the following Lemma.
%%%
%%%%%%%%%%%%%%%%%%
%\newpage
\section{Safety }
\label{properties:sec:safety}
In this section we will show how some aspects of safety carry across modular compositions of BTs. The results will enable us to design a BT to handle safety guarantees and a BT to handle the task execution separately.

In order to formalize the discussion above, we say that \emph{safety} can be measured by the ability to avoid a particular part of the statespace, which we for simplicity  denote the \emph{Obstacle Region}. 


\begin{definition}[Safe]
\label{properties:def:Safe}
 A BT is safe, with respect to the obstacle region $O \subset \mathbb{R}^n$, and the initialization region $I \subset R$,
 if for all starting points $x(0)\in I$, we have that $x(t) \not \in O$, for all $t \geq 0$.
 \end{definition}

In order to make statements about the safety of composite BTs we also need the following definition.

\begin{definition}[Safeguarding]
\label{properties:def:Safeguarding}
 A BT is safeguarding, with respect to the step length $d$, the obstacle region $O \subset \mathbb{R}^n$, and the initialization region $I \subset R$,
 if it is safe, and FTS with region of attraction $R' \supset I$ and a success region $S$, such that $I$ surrounds $S$ in the following sense:
\begin{equation}
  \{x\in X \subset \mathbb{R}^n: \inf_{s\in S} || x-s  || \leq d \} \subset I,
\end{equation}
where $X$ is the reachable part of the state space $\mathbb{R}^n$. 
  \end{definition}
This implies that the system, under the control of another BT with maximal statespace steplength $d$, cannot leave $S$ without entering $I$, and thus avoiding $O$,  see Lemma~\ref{properties:lem:safety} below.



\begin{example}
\label{properties:ex:safe}
To illustrate how safety can be improved using a Sequence composition, we  consider the UAV control BT 
 in Figure~\ref{properties:fig:uav}.
The sets $S_i, F_i, R_i$ are shown in Figure~\ref{properties:fig:seq1}. As $\bt_1$ is \emph{Guarrantee altitude above 1000 ft}, its failure region $F_1$ is a small part of the state space (corresponding to a crash) surrounded by the running region $R_1$ that is supposed to move the UAV away from the ground, guaranteeing a minimum altitude of 1000 ft. The success region $S_1$ is large, every state sufficiently distant from $F_1$. The BT that performs the mission, $\bt_2$, has a smaller success region $S_2$, surrounded by a very large running region $R_2$, containing a small failure region $F_2$. The 
function $f_0$ is governed by Equations (\ref{bts:eq:seq1}) and (\ref{bts:eq:seq2}) and is depicted in form of the  vector field $(f_0(x)-x)$  in Figure~\ref{properties:fig:seq2}.
\end{example}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4cm]{uav}
\caption{The Safety of the UAV control BT is Guaranteed by the first Action.  }
\label{properties:fig:uav}
\end{center}
\end{figure}

 \begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.8\columnwidth]{vennDias_seq1}
\caption{The sets $S_1, F_1, R_1$ (solid boundaries) and $S_2, F_2, R_2$ (dashed boundaries) of Example \ref{properties:ex:safe} and Lemma \ref{properties:lem:safety}. }
\label{properties:fig:seq1}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.8\columnwidth]{vennDias_seq2}
\caption{The sets $S_0, F_0, R_0$ and  the vector field $(f_0(x)-x)$ of Example~\ref{properties:ex:safe} and Lemma \ref{properties:lem:safety}. }
\label{properties:fig:seq2}
\end{center}
\end{figure}

The discussion above is formalized in Lemma \ref{properties:lem:safety} below.







\begin{lemma}[Safety of Sequence Compositions]
\label{properties:lem:safety}
If $\bt_1$ is safeguarding, with respect to the obstacle $O_1$ initial region $I_1$, and margin $d$, and
 $\bt_2$ is an arbitrary BT with $\max_x ||x-f_2(x)||<d$,
then the composition $\bt_0=\mbox{Sequence}(\bt_1,\bt_2)$ is safe with respect to  $O_1$ and $I_1$.
\end{lemma}
\begin{proof}
 $\bt_1$ is safeguarding, which implies that $\bt_1$ is safe and thus any trajectory starting in $I_1$ will stay out of $O_1$ as long as $\bt_1$ is executing. But if the trajectory reaches $S_1$, $\bt_2$ will  execute until the trajectory leaves $S_1$. We must now show that the trajectory cannot reach $O_1$ without first entering $I_1$. But any trajectory leaving $S_1$ must immediately enter $I_1$, as the first state outside $S_1$ 
 must lie in the set $\{x\in \mathbb{R}^n: \inf_{s\in S_1} || x-s  || \leq d \} \subset I_1$ due to the fact that for $\bt_2$, $||x(k)-x(k+1) ||=||x(k)-f_2(x(k)) ||<d$.
\end{proof}

%This Lemma is also illustrated in Example \ref{properties:ex:seq} and Figures \ref{properties:fig:seq1} and \ref{properties:fig:seq2} above.


We conclude this section with a discussion about undesired chattering in switching systems.

The issue of undesired chattering, i.e., switching back and fourth between different subcontrollers,
is always an important concern when designing switched control systems, and BTs are no exception. 
As is suggested by the right part of Figure \ref{properties:fig:seq2}, chattering can be a problem when  vector fields meet at a switching surface. 

Although the efficiency of some compositions can be computed using Lemma \ref{properties:lem:robustnessSequence} and \ref{properties:lem:robustnessSelector}  above, chattering can significantly reduce the efficiency of others.
Inspired by \cite{filippov1988differential} the following result can give an indication of when chattering is to be expected.

Let $R_i$ and $R_j$ be  the running region of  $\bt_i$ and $\bt_j$ respectively. 
We want to study the behavior of the system when a composition of $\bt_i$ and $\bt_j$ is applied. In some cases the execution of a BT will lead to the running region of the other BT and vice-versa. Then, both BTs are alternatively executed and the state trajectory chatters on the boundary between $R_i$ and $R_j$. 
We formalize this discussion in  the following lemma.
 
  
\begin{lemma}
 Given a composition $\bt_0=\mbox{Sequence}(\bt_1,\bt_2)$, where $f_i$ depend on $\Delta t$ such
 that $||f_i(x)-x|| \to 0$ when $\Delta t \to 0$.
 Let  $s:\mathbb{R}^n\to \mathbb{R}$ be such that 
  $s(x)=0$ if $x\in \delta S_1 \cap R_2$,
$s(x)<0$ if $x\in \mbox{interior}( S_1 )\cap R_2$,
 $s(x)>0$ if $x\in \mbox{interior}(  \mathbb{R}^n \setminus S_1 ) \cap R_2$,
 and let 
 $$
 \lambda_i(x)=(\frac{\partial s}{\partial x})^T(f_i(x)-x).
 $$
 Then, $x \in \delta S_1$ is chatter free, i.e., avoids switching between $\bt_1$ and $\bt_2$ at every timestep, for small enough $\Delta t$, if $\lambda_1(x)<0$ or $\lambda_2(x)>0$.
\end{lemma}
 
\begin{proof}
When the condition holds, the vector field is pointing outwards on at least one side of the switching boundary.
\end{proof}




Note that this condition is not satisfied on the right hand side of Figure~\ref{properties:fig:seq2}.
This concludes our analysis of BT compositions.


\section{Examples}
\label{properties:sec:example}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
In this section, we show some BTs of example and we analyze their properties.

Section~\ref{properties:sec:example:robeff} Illustrates how to analyze robustness and efficiency of a robot executing a generic task. Section~\ref{properties:sec:safety} illustrates to compute safety using the functional representation of Section~\ref{bts:sec:funcBT}. Section~\ref{properties:sec:example:reliability} illustrate how to compute the performance estimate of a given BT. Finally, Section~\ref{properties:sec:example:huge}  illustrate the properties above of a complex BT .

All BTs were implemented using the ROS BT library.\footnote{library available at \url{http://wiki.ros.org/behavior_tree}.}
A video showing the executions of the BTs used in Sections~\ref{properties:sec:example:safety}-\ref{properties:sec:example:robeff} is publicly available. \footnote{\url{https://youtu.be/fH7jx4ZsTG8}}
%To illustrate the modularity, the leaf nodes are a mix of behaviors from the NAO Software Development Kit, such as \emph{Stand Up}, \emph{Sit Down}, and \emph{Lie Down} and behaviors we developed ourselves, such as \emph{Approach Ball}, \emph{Grasp Ball}, and \emph{Throw Ball}, see below.


\subsection{Robustness and Efficiency}
\label{properties:sec:example:robeff}
To illustrate Lemma \ref{properties:lem:robustnessSelector} we look at the BT of Figure~\ref{properties:fig:robust3} controlling a humanoids robot.
The BT has three subtrees \emph{Walk Home}, which is first tried,
if that fails (the robot cannot walk if it is not standing up) it tries the subtree \emph{Sit to Stand},
and if that fails, it tries \emph{Lie down to Sit Up}.
Thus, each fallback action brings the system into the running region of the action to its left,
e.g., the result of \emph{Sit to Stand} is to enable the execution of  \emph{Walk Home}.

\begin{example}
\label{properties:ex:rob}
Let  $x=(x_{1},x_{2})\in \mathbb{R}^2$, where $x_{1}\in [0,0.5]$ is the horizontal position of the robot head and
$x_{2}\in [0,0.55]$ is vertical position  (height above the floor) of the robot head.
The objective of the robot is to get to the destination at $(0,0.48)$. 

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.4 \columnwidth]{core/ACCfigs/robust3}
\caption{The combination $\bt_3$=Fallback($\bt_4,\bt_5,\bt_6$) increases robustness by increasing the region of attraction. }
\label{properties:fig:robust3}
\end{center}
\end{figure}
\end{example}

First we describe the sets $S_i, F_i, R_i$ and the corresponding vector fields of the functional representation.
Then we apply Lemma~\ref{properties:lem:robustnessSelector} to see that the combination does indeed improve robustness. For this example $\Delta t=1s$.

For \emph{Walk Home}, $\bt_4$, we have that 
\begin{align}
S_4 &= \{x: x_1 \leq 0 \}  \label{properties:eq:startRobust} \\
R_4 &= \{x: x_1 \neq 0, x_2\geq 0.48 \}\\
F_4 &= \{x: x_1 \neq 0, x_2 < 0.48 \} \\
 f_4(x)&=\begin{pmatrix}
x_1-0.1 \\
x_2
\end{pmatrix}
\end{align}
that is, it runs as long as the vertical position of the robot head, $x_2$, is at least $0.48m$ above the floor, and moves towards the origin with a speed of $0.1m/s$. If the robot is not standing up $x_2<0.48m$ it returns Failure. A phase portrait of $f_4(x)-x$ is shown in Figure~\ref{properties:fig:goback}.
 Note that $\bt_4$ is FTS with the completion time bound $\tau_4 =0.5/0.1=10$ and region of attraction $R_4'=R_4$.


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{core/matlab/goback}
\caption{The Action \emph{Walk Home}, keeps the head around $x_2=0.5$ and moves it towards the destination $x_1=0$.}
\label{properties:fig:goback}
\end{center}
\end{figure}



For \emph{Sit to Stand}, $\bt_5$, we have that 
\begin{align}
S_5 &= \{x: 0.48 \leq x_2 \}\\
R_5 &= \{x: 0.3 \leq x_2 <  0.48 \}\\
F_5 &= \{x: x_2 < 0.3 \} \\
 f_5(x)&=\begin{pmatrix}
x_1 \\
x_2+0.05
\end{pmatrix}
\end{align}
that is, it runs as long as the vertical position of the robot head, $x_2$, is in between $0.3m$ and $0.48m$ above the floor.
If $0.48 \leq x_2$ the robot is standing up, and it returns Success.
If $x_2 \leq 0.3$ the robot is lying down, and it returns Failure.
 A phase portrait of $f_5(x)-x$ is shown in Figure~\ref{properties:fig:standup}.
 Note that $\bt_5$ is FTS with the completion time bound $\tau_5 = \mbox{ceil}(0.18/0.05)=\mbox{ceil}(3.6)=4$ and region of attraction $R_5'=R_5$


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{core/matlab/standup}
\caption{The Action \emph{Sit to Stand} moves the head upwards in the vertical direction towards standing. }
\label{properties:fig:standup}
\end{center}
\end{figure}

For \emph{Lie down to Sit Up}, $\bt_6$, we have that 
\begin{align}
S_6 &= \{x: 0.3 \leq x_2 \}\\
R_6 &= \{x: 0 \leq x_2 <  0.3 \}\\
F_6 &= \emptyset \\
 f_6(x)&=\begin{pmatrix}
x_1 \\
x_2+0.03
\end{pmatrix} \label{properties:eq:endRobust}
\end{align}
that is, it runs as long as the vertical position of the robot head, $x_2$, is below $0.3m$  above the floor.
If $0.3 \leq x_2$ the robot is sitting up (or standing up), and it returns Success.
If $x_2 < 0.3$ the robot is lying down, and it returns Running.
 A phase portrait of $f_6(x)-x$ is shown in Figure~\ref{properties:fig:situp}.
 Note that $\bt_6$ is FTS with the completion time bound $\tau_6 =0.3/0.03=10$ and region of attraction $R_6'=R_6$


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{core/matlab/situp}
\caption{The Action \emph{Lie down to Sit Up} moves the head upwards in the vertical direction towards sitting. }
\label{properties:fig:situp}
\end{center}
\end{figure}

Informally, we can look at the phase portrait in Figure~\ref{properties:fig:getback} to get a feeling for what is going on.
As can be seen the Fallbacks make sure that the robot gets on its feet and walks back,
independently of where it started in $\{x:0< x_1 \leq 0.5, 0\leq x_2 \leq 0.55\}$.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{core/matlab/getback}
\caption{The combination Fallback($\bt_4,\bt_5,\bt_6$) first gets up, and then walks home.}
\label{properties:fig:getback}
\end{center}
\end{figure}

Formally, we can use Lemma \ref{properties:lem:robustnessSelector} to compute 
robustness in terms of the region of attraction $R_3'$,  and efficiency in terms of bounds on completion time $\tau_3$.
The results are described in the following Lemma.


\begin{lemma}
\label{properties:lem:robustExample}
 Given $\bt_4,\bt_5,\bt_6$ defined in Equations (\ref{properties:eq:startRobust})-(\ref{properties:eq:endRobust}).
 
 The combined BT $\bt_3=\mbox{Fallback}(\bt_4,\bt_5,\bt_6)$ is FTS, with 
  region of attraction $R_3'=\{x:0< x_1 \leq 0.5, 0\leq x_2 \leq 0.55\}$,
 completion time bound $\tau_3 =24$.
\end{lemma}
\begin{proof}
We note that $\bt_4,\bt_5,\bt_6$ are FTS with
$\tau_4 =10$, $\tau_5 =4$, $\tau_6 =10$
and regions of attractions equal to the running regions $R_i'=R_i$.
Thus we have that 
$S_6 \subset R_5=R_5'$ and
$S_5 \subset R_4=R_4'$.
Applying Lemma \ref{properties:lem:robustnessSelector} twice now gives the desired results,
$R_3'=R_4' \cup R_5'\cup R_6'=\{x:0\leq x_1 \leq 0.5, 0\leq x_2 \leq 0.55\}$ and
$\tau_3 = \tau_4+\tau_5+\tau_6=10+4+10=24$.
\end{proof}

%\subsection{Large Example}


\subsection{Safety}
\label{properties:sec:example:safety}
 
 
To illustrate Lemma~\ref{properties:lem:safety} we choose the BT of Figure \ref{properties:fig:safe3}. %, which is actually a compact version of the BT of Figure \ref{properties:condition}.
The idea is that the first subtree in the Sequence (named \emph{Guarantee Power Supply}) is to guarantee that the combination does not run out of power,
under very general assumptions about what is going on in the second BT.

First we describe the sets $S_i, F_i, R_i$ and the corresponding vector fields of the functional representation.
Then we apply Lemma~\ref{properties:lem:safety} to see that the combination does indeed guarantee against running out of batteries.
\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.4 \columnwidth]{core/ACCfigs/safe3}
\caption{A BT where the first action guarantees that the combination does not run out of battery. }
\label{properties:fig:safe3}
\end{center}
\end{figure}


\begin{example}

Let $\bt_1$ be \emph{Guarantee Power Supply} and $\bt_2$ be \emph{Do other tasks}.
Let furthermore $x=(x_{1},x_{2})\in \mathbb{R}^2$, where $x_{1}\in [0,100]$ is the distance from the current position to the recharging station
 and
$x_{2}\in [0,100]$ is the battery level. For this example $\Delta t=10s$.

For \emph{Guarantee Power Supply}, $\bt_1$, we have that 
\begin{align}
S_1 &= \{x:  100 \leq x_2 \mbox{ or } (0.1 \leq x_1, 20 < x_2) \} \label{properties:bt1Start} \\
R_1 &= \{x: x_2 \leq 20 \mbox{ or } (x_2 < 100  \mbox{ and }   x_1 < 0.1) \}\\
F_1 &= \emptyset \\
 f_1(x)&=\begin{pmatrix}
x_1 \\
x_2+1
\end{pmatrix}  \mbox{if } x_1<0.1, x_2<100\\
&=\begin{pmatrix}
x_1-1 \\
x_2-0.1
\end{pmatrix}  \mbox{else} \label{properties:bt1End}
\end{align}
that is, when running, the robot moves  to $x_1<0.1$ and recharges. While moving, the battery level decreases and while charging the battery level increases.
If at the recharge position, it returns Success only after reaching $x_2 \geq 100$.
Outside of the recharge area, it returns Success as long as the battery level is above 20\%.
 A phase portrait of $f_1(x)-x$ is shown in Figure~\ref{properties:fig:rechargeR}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{core/matlab/rechargeR}
\caption{The \emph{Guarantee Power Supply} Action }
\label{properties:fig:rechargeR}
\end{center}
\end{figure}


For \emph{Do Other Task}, $\bt_2$, we have that 
\begin{align}
S_2 &=  \emptyset \\
R_2 &= \mathbb{R}^2 \\
F_2 &= \emptyset \\
 f_2(x)&=\begin{pmatrix}
x_1 + (50-x_1)/50\\
x_2-0.1
\end{pmatrix} 
\end{align}
that is, when running, the robot moves towards $x_1=50$ and does some important task,
while the  battery  level keeps on decreasing. 
 A phase portrait of $f_2(x)-x$ is shown in Figure~\ref{properties:fig:rechargeR}.


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{core/matlab/rechargeDo}
\caption{The \emph{Do Other Task} Action  }
\label{properties:fig:rechargeDo}
\end{center}
\end{figure}
\end{example}

Given $\bt_1$ and $\bt_2$, the composition $\bt_0$=Sequence($\bt_1,\bt_2$) is created to improve the safety of $\bt_2$, as described below.

Informally, we can look at the phase portrait in Figure~\ref{properties:fig:rechargeTot} to get a feeling for what is going on.
The obstacle to be avoided is the Empty Battery state $O=\{x: x_2=0 \}$, and
$\bt_0$ makes sure that this state is never reached, since the \emph{Guarantee Power Supply} action
starts executing as soon as \emph{Do Other Task} brings the battery level below 20\%.
The remaining battery level is also enough for the robot to move back to the recharging station,
given that the robot position is limited by the reachable space, i.e., $x_{1k}\in [0,100]$.


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{core/matlab/rechargeTot}
\caption{Phase portrait of $\bt_0$=Sequence($\bt_1,\bt_2$). Note that $\bt_1$ guarantees that the combination does not run out of battery. 
The dashed line is a simulated execution, starting at $(80,50)$.}
\label{properties:fig:rechargeTot}
\end{center}
\end{figure}

Formally, we state the following Lemma

%start by confirming that $\bt_1$ is safe, when we note that it is safeguarding, and finally conclude that the combination 
%Sequence($\bt_1,\bt_2$) is also Safe. We do this in the following Lemma
%
\begin{lemma}
\label{properties:lem:recharge}
 Let the obstacle region be $O=\{x: x_2=0 \}$ and the initialization region be $I=\{x: x_1 \in [0,100], x_2\geq 15 \}$. 
 
 
 Furthermore, let $\bt_1$ be given by (\ref{properties:bt1Start})-(\ref{properties:bt1End}) and $\bt_2$ be an arbitrary BT satisfying $\max_x ||x-f_2(x)||<d=5$, then  $\bt_0$=Sequence($\bt_1,\bt_2$) is safe 
 with respect to $I$ and $O$, i.e. if $x(0)\in I$, then $x(t) \not \in O$, for all $t > 0$. 
\end{lemma}
\begin{proof}
 First we see that $\bt_1$ is safe with respect to $O$ and $I$.
 Then we notice that $\bt_1$ is safeguarding with margin $d=10$ for the reachable set $X=\{x: x_1 \in [0,100], x_2 \in [0,100] \}$.
 Finally we conclude that $\bt_0$ is Safe, according to Lemma~\ref{properties:lem:safety}.
\end{proof}
Note that if we did not constraint the robot to move in some reachable set $X=\{x: x_1 \in [0,100], x_2 \in [0,100] \}$, it would be able to 
move so far away from the recharging station that the battery would not be sufficient to bring it back again before reaching $x_2=0$.


%The sets $S_i, F_i, R_i$ are shown in Figure~\ref{properties:fig:seq1}. As $\bt_1$ is \emph{Guarrantee altitude above 1000 ft}, its failure region $F_1$ is a small part of the state space (corresponding to a crash) surrounded by the running region $R_1$ that is supposed to move the UAV away from the ground, guaranteeing a minimum altitude of 1000 ft. The success region $S_1$ is large, every state sufficiently distant from $F_1$. The BT that performs the mission, $\bt_2$, has a smaller success region $S_2$, surrounded by a very large running region $R_2$, containing a small failure region $F_2$. The 
%function $f_0$ governed by Equations (\ref{properties:eq:seq1}) and (\ref{properties:eq:seq2}) and is depicted together with the  vector field $(f_0(x)-x)$  in Figure~\ref{properties:fig:seq2}.












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%BIG BT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\subsection{A More Complex BT}
\label{properties:sec:example:huge}
Below we will use a larger BT to illustrate modularity, as well as the applicability of the proposed analysis tools to more complex problems.

 

\begin{figure*}[t]
  \includegraphics[width=\textwidth]{properties/figures/hugeBT}
  \caption{A BT that combines some capabilities  of the humanoid robot in an interactive and modular way. Note how atomic actions can easily be replaced by more complex sub-BTs.}
  \label{properties:fig:hugeExample}
\end{figure*}
\begin{example}

The BT in Figure~\ref{properties:fig:hugeExample} is 
designed for controlling a humanoid robot in an interactive capability demo,
and includes the BTs of Figures~\ref{properties:fig:safe3} and \ref{properties:fig:robust3} as subtrees, as discussed below.

The top left part of the tree includes some exception handling, in terms of battery management, and backing up and complaining in case  the toe bumpers are pressed.
The top right part of the tree is a Parallel node, listening for new user commands, along with a request for such commands if none are given and an execution of the corresponding activities if a command has been received. 

The subtree \emph{Perform Activities} is composed of  checking of
what activity to do, and execution of the corresponding command.
Since the activities are mutually exclusive, we let the Current Activity hold only the latest command and no ambiguities of control commands will occur.

The subtree \emph{Play Ball Game} runs the ball tracker, in parallel with moving closer to the ball, grasping it, and throwing it. 

As can be seen, the design is quite modular. A HDS implementation of the same functionality would need an extensive amount of transition arrows going in between the different actions.  

We will now apply the analysis tools of the paper to the example, initially assuming that all atomic actions are FTS, as described in Definition~\ref{properties:def:FTS}.

Comparing Figures~\ref{properties:fig:safe3} and \ref{properties:fig:hugeExample} we see that they are identical, if we let \emph{Do Other Task} correspond to the whole right part of the larger BT. Thus, according to Lemma \ref{properties:lem:recharge}, the complete BT is safe, i.e.\ it will not run out of batteries, as long as the reachable state space is bounded by 100 distance units from the recharging station and the time steps are small enough so that $\max_x ||x-f_2(x)||<d=5$, i.e.\ the battery does not decrease more than  5\%  in a single time step.

The design of the right subtree in \emph{Play Ball Game} is made to satisfy Lemma~\ref{properties:lem:robustnessSequence},
with the condition $S_1=  R_2'\cup S_2$. Let 
$\bt_1=\mbox{Fallback(Ball Close?, Approach Ball)}$, 
$\bt_2=\mbox{Fallback(Ball Grasped?, Grasp Ball)}$,
$\bt_3=\mbox{Throw Ball}$.
Note that the use of condition-action pairs makes the success regions explicit. 
Thus $S_1=  R_2'\cup S_2$, i.e.\ Ball Close is designed to describe the Region of Attraction of Grasp Ball, and
$S_2=  R_3'\cup S_3$, i.e.\ Ball Grasped is designed to describe the Region of Attraction of Throw Ball.
Finally, applying Lemma~\ref{properties:lem:robustnessSequence} twice
we conclude that the right part of \emph{Play Ball Game} is FTS with completion time bound $\tau_1+\tau_2+\tau_3$,
region of attraction $R_1'\cup R_2'\cup R_3'$ and success region $S_1 \cap S_2 \cap S_3$.

The Parallel composition at the top of 
\emph{Play Ball Game}  combines \emph{Ball Tracker} which always returns Running, with the subtree discussed above.
The Parallel node has $M=1$, 
i.e.\ it only needs the Success of one child to return Success.
Thus, it is clear from Definition~\ref{bts:def:parallel} that the whole BT \emph{Play Ball Game} has the same
properties regarding FTS as the right subtree.




Finally, we note that  \emph{Play Ball Game} fails if the robot is not standing up.
Therefore, we improve the robustness of that subtree in a way similar to 
  Example~\ref{properties:ex:rob}  in  Figure~\ref{properties:fig:robust3}.
Thus we create the composition Fallback(Play Ball Game, $\bt_5$, $\bt_6$),
with 
$\bt_5=\mbox{Sit to Stand}$, 
$\bt_6=\mbox{Lie Down to Sit Up}$.

Assuming that that high dimensional dynamics of  \emph{Play Ball Game}
is somehow captured in the $x_1$ dimension we can apply an argument similar to 
Lemma~\ref{properties:lem:robustExample} to conclude that the combined BT is indeed also FTS
with 
completion time bound $\tau_1+\tau_2+\tau_3+\tau_5+\tau_6$,
region of attraction $R_1'\cup R_2'\cup R_3' \cup R_5' \cup R_6'$
and success region $S_1 \cap S_2 \cap S_3$.

The rest of the BT concerns user interaction and is thus not suitable for doing performance analysis.
\end{example}

Note that the assumption on all atomic actions being FTS is fairly strong. For example, the humanoid's grasping capabilities are somewhat unreliable. 
A deterministic analysis such as this one
is still  useful for making good design choices, but 
in order to capture the stochastic properties of a BT, we need the tools of Chapter~\ref{ch:stochastic}.

But first we will use the tools developed in this chapter to formally investigate how BTs relate to other control architectures. 
%\todo{add performance analysis}%An analysis using a  stochastic approach, modeling the probabilities of success and failure,  is also conceivable, but outside the scope of this paper.



