%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Init
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\ARTICLEtrue
%\renewcommand{\thefigure}{\arabic{figure}}
%\renewcommand{\thetable}{\arabic{table}}
\graphicspath{{bts/figures/}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Structure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \nocite{}

% !TEX root = ../CRCBook.tex


\section*{Quotes on Behavior Trees}
\thispagestyle{empty}



\say{I'm often asked why I chose to build the SDK with behavior trees instead of finite state machines. The answer is that behavior trees are a far more expressive tool to model behavior and control flow of autonomous agents.}
\footnote{\url{https://developers.jibo.com/blog/the-jibo-sdk-} \url{reaching-out-beyond-the-screen}}

\begin{flushright}
Jonathan Ross \\Head of Jibo SDK 
\end{flushright}


\say{There are a lot of different ways to create AI's, and I feel like I've tried pretty much all of them at one point or another, but ever since I started using behavior trees, I wouldn't want to do it any other way. I wish I could go back in time with this information and do some things differently.}
\footnote{\url{http://www.gamasutra.com/blogs/ChrisSimpson/20140717/221339/Behavior_trees_for_AI_How_they_work.php}}

\begin{flushright}
Mike Weldon \\Disney, Pixar  
\end{flushright}



\say{[...]. Sure you could build the very same behaviors with a finite state machine (FSM). But anyone who has worked with this kind of technology in industry knows how fragile such logic gets as it grows. A finely tuned hierarchical FSM before a game ships is often a temperamental work of art not to be messed with!}
\footnote{\url{http://aigamedev.com/open/article/fsm-age-is-over/}}

\begin{flushright}
Alex J. Champandard \\Editor in Chief  \& Founder AiGameDev.com, \\Senior AI Programmer Rockstar Games
\end{flushright}

\say{Behavior trees offer a good balance of supporting goal-oriented behaviors and reactivity.}
\footnote{\url{https://forums.unrealengine.com/showthread.php?6016-Behavior-Trees-What-and-Why}}

\begin{flushright}
Daniel Broder \\Unreal Engine developer
\end{flushright}

 \say{The main advantage [of Behavior Trees] is that individual behaviors can easily be reused in the context of another higher-level behavior, without needing to specify how they relate to subsequent behaviors}, \cite{Bagnell2012b}.
\begin{flushright}
Andrew Bagnell et al. \\ Carnegie Mellon University.
\end{flushright}


\chapter{What are Behavior Trees?}
\label{chap:bts}
%\epigraph{I have always found that plans are useless, but planning is indispensable.}{\textit{Dwight D. Eisenhower}}


A Behavior Tree (BT) is a way to structure the switching between different tasks\footnote{assuming that an activity can somehow be broken down into reusable sub-activities called \emph{tasks} sometimes also denoted \emph{actions} or \emph{control modes}}  in an autonomous agent, such as a robot or a virtual entity 
in a computer game. An example of a BT performing a pick and place task can be seen in Fig.~\ref{introduction.fig.BTsmall}. 
As will be explained, BTs are a very efficient way of creating complex systems that are both \emph{modular} and \emph{reactive}.
These properties are crucial in many applications, which has led to the spread of BT
 from computer game programming to many branches of AI and Robotics.


\begin{figure}[ht!]
    \centering

    \begin{subfigure}[t]{\columnwidth}
        \centering
\includegraphics[width = 0.7\columnwidth]{BTIntroExample}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{A high level BT carrying out a task consisting of first finding, then picking and finally placing a ball.  }
   \label{introduction.fig.BTsmall}
    \end{subfigure}
    \vspace*{0.5cm}
    
    
      \begin{subfigure}[t]{\columnwidth}
        \centering
\includegraphics[width = 0.7\columnwidth]{BTIntroExampleExpansion}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{The Action Pick Ball from the BT in Fig.~\ref{introduction.fig.BTsmall} is expanded into a sub-BT. The Ball is approached until it is considered close, and then the Action grasp is executed until the ball is securely grasped.}
      \label{introduction.fig.BTextended}
    \end{subfigure}
    \vspace{1em}
    \caption{Illustrations of a BT carrying out a pick and place task with different degrees of detail. The execution of a BT will be described in Section~\ref{sec:classicalBT}.}
    \label{introduction.fig.BT}
\end{figure}


%\newpage


In this book, we will first give an introduction to BTs, in the present chapter. Then, in Chapter~\ref{ch:earlier_ideas} we describe how BTs relate to, and in many cases generalize, earlier switching structures, or control architectures as they are often called. These ideas are then used as a foundation for a set of efficient and easy to use design principles described in Chapter~\ref{ch:design_principles}.
Then, in Chapter~\ref{ch:extensions} we describe a set of important extensions to BTs.
Properties such as safety, robustness, and efficiency are important for an autonomous system, and in Chapter~\ref{ch:properties} we describe a set of tools for formally analyzing these using a state space formulation of BTs. 
With the new analysis tools, we can formalize the descriptions of how BTs generalize earlier approaches in Chapter~\ref{ch:btsvsothers}.
Then, we see how BTs can be automatically generated using planning, in Chapter~\ref{ch:planning} and learning, in Chapter~\ref{ch:learning}.  
Finally, we describe an extended set of tools to capture the behavior of Stochastic BTs, where the outcomes of actions are described by probabilities, in Chapter~\ref{ch:stochastic}. These tools enable the computation of both success probabilities and time to completion.

In this chapter, we will first tell a brief history of BTs in Section~\ref{sec:history}, 
and explain the core benefits of BTs,  in Section~\ref{sec:modularity},
then in Section~\ref{sec:classicalBT} we will describe how a BT works.
Then, we will create a simple BT for the computer game Pac-Man in Section~\ref{sec:pacman} and a more sophisticated BT for a mobile manipulator in Section~\ref{sec:youbot}. We finally describe the usage of BT in a number of applications in Section~\ref{sec:use_of_BTs}.


\section{A Short History and Motivation of BTs}
\label{sec:history}
BTs were developed in the computer game industry, as a tool to increase
modularity in the control structures of Non-Player Characters (NPCs)\label{definition:NPC}
\cite{isla2005handling,champandard2007understanding,mateas2002abl,isla2008halo,millington2009artificial,rabin2014gameAiPro}.
In this billion-dollar industry, modularity is a key property that enables reuse of code, incremental design of functionality, and efficient testing.

In games, the control structures of NPCs were often formulated in terms of Finite State Machines (FSMs). However, just as Petri Nets \cite{murata1989petri} provide an alternative to FSMs that supports design of \emph{concurrent} systems, BTs provide an alternative view of FSMs that supports design of \emph{modular} systems.

Following the development in the industry, BTs have now also started to receive attention in academia \cite{lim2010evolving,Nicolau2016,shoulson2011parameterizing,bojic2011extending,ogren,Marzinotto14,Bagnell2012b,klockner2013,Colledanchise14, bart,hu2015ablation,guerin2015manufacturing}.

At Carnegie Mellon University, BTs have been used extensively to do robotic manipulation \cite{Bagnell2012b, bart}. 
The fact that modularity is the key reason for using BTs is clear from the following quote from~\cite{Bagnell2012b}:
 \say{The main advantage is that individual behaviors can easily be reused in the context of another higher-level behavior, without needing to specify how they relate to subsequent behaviors}.

BTs have also been used to enable non-experts to do robot programming of pick and place operations,
due to their \say{modular, adaptable representation of a robotic task}
\cite{guerin2015manufacturing} and allowed \say{end-users to visually create programs
with the same amount of complexity and power as traditionally-written programs}~\cite{paxton2016costar}. Furthermore, BTs have been proposed as a key component in brain surgery robotics due to their \say{flexibility, reusability, and simple syntax} \cite{hu2015ablation}.


%The advantages of BTs as compared to FSMs was the reason for extending the so-called \emph{JADE agent Behavior Model} with BTs in \cite{bojic2011extending}, and  the benefits of using BTs to control complex multi mission UAVs was described in \cite{ogren}.
%
%The modularity of BTs was used to address the formal verification of mission plans
%in \cite{klockner2013} while the execution time of stochastic BTs was analyzed in \cite{Colledanchise14}.
%BTs have also been studied in machine learning applications
%\cite{lim2010evolving,Nicolau2016} and details regarding efficient parameter passing were investigated in \cite{shoulson2011parameterizing}.
%Finally, a Modelica implementation of BTs was presented in \cite{klockner2014}.
%



\section{What is wrong with FSMs? The Need for Reactiveness and Modularity}
\label{sec:modularity}

Many autonomous agents need to be both reactive and modular.
By reactive we mean the ability to quickly and efficiently react to changes.
We want a robot to slow down and avoid a collision if a human enters into its planned trajectory and we want a virtual game character to hide, flee, or fight, if made aware of an approaching enemy.
By modular, we mean the degree to which a system's components may be separated into building blocks, and recombined \cite{gershenson2003product}. 
We want the agent to be modular, to enable components to be developed, tested, and reused independently of one another. Since complexity grows with size, it is  beneficial to be able to work with components one at a time, rather than the combined system.

FSMs have long been the standard choice when designing a task switching structure \cite{powers2012sting,montemerlo2008junior}, and
 will be discussed in detail in Chapter~\ref{sec:FSM}, but here we make a short description of the unfortunate tradeoff between reactivity and modularity that is inherent in FSMs.
This tradeoff can be understood in terms of the classical Goto-statement that was used in early programming languages.
The Goto statement is an example of a so-called
\emph{one-way control transfer}, where the execution of a program jumps to another part of the code and continue executing from there.
Instead of \emph{one-way control transfers}, modern programming languages tend to rely on 
\emph{two-way control transfers} embodied in e.g. function calls. Here, execution jumps to a particular part of the code, executes it, and then returns to where the function call was made. The drawbacks of \emph{one-way control transfers} were made explicit by 
 Edsgar Dijkstra in his paper \emph{Goto statement considered harmful} \cite{Dijkstra:1968:LEG:362929.362947}, where he states that
``The Goto statement as it stands is just too primitive; it is too much an invitation to make a mess of one's program".
Looking back at the state transitions in  FSMs, we note that they  are indeed \emph{one-way control transfers}. 
This is where the tradeoff between reactivity and modularity is created.
For the system to be reactive, there needs to be many transitions between components, and many transitions means many  \emph{one-way control transfers}
which, just as Dijkstra noted, harms modularity by being an ``invitation to make a mess of one's program". 
If, for example, one component is removed, every transition to that component needs to be revised.
As will be seen, BTs use \emph{two-way control transfers}, governed by the internal nodes of the trees.



 Using BTs instead of FSMs 
to implement the task switching, allows us to describe the desired behavior in modules as depicted in Figure~\ref{introduction.fig.BTsmall}. 
Note that in the next section we will describe how BTs work in detail, so these figures are just meant to give a first glimpse of BTs, rather than the whole picture.

 A behavior is often composed of a sequence of sub-behaviors that are task independent, meaning that while creating one sub-behavior the designer does not need to know which sub-behavior will be performed next. Sub-behaviors can be designed recursively, adding more details as in Figure~\ref{introduction.fig.BTextended}. BTs are executed in a particular way, which will be described in the following section, that allows the behavior to be carried out reactively. For example, the BT in Figure~\ref{introduction.fig.BT} executes the sub-behavior \emph{Place Ball}, but also verifies that the ball is still at a known location and securely grasped. If, due to an external event, the ball slips out out of the grasp, then the robot will abort the sub-behavior \emph{Place Ball} and will re-execute the sub-behavior \emph{Pick Ball} or \emph{Find Ball} according to the current situation. 
%\todo{Add description of drawbacks of FSM in terms of Modularity and Reactiveness}


\section{Classical Formulation of BTs}
\label{sec:classicalBT}

At the core, BTs are built from a small set of simple components, just as many other powerful concepts, but throughout this book, we will see how this simple formalism can be used to create very rich structures, in terms of both applications and theory.

Formally speaking, a BT is a directed rooted tree where the internal nodes  are called \emph{control flow nodes} and leaf nodes are called \emph{execution nodes}. For each connected node we use the common terminology of  \emph{parent} and \emph{child}. The root is the node without parents; all other nodes have one parent. The control flow nodes have at least one child. Graphically, the children of a node are placed below it, as shown in Figures~\ref{bts.fig.seq}-\ref{bts.fig.par}.

A BT starts its execution from the root node that generates signals that allow the execution of a node called \emph{ticks} with a given frequency, which are sent to its children. A node is executed if and only if it receives ticks. The child immediately returns \emph{Running} to the parent,   if its execution is under way, \emph{Success} if it has achieved its goal, or \emph{Failure} otherwise.

In the classical formulation, there exist four categories of control flow nodes (Sequence, Fallback, Parallel, and Decorator) and two categories of execution nodes (Action and Condition). They  are all explained below and summarized in Table~\ref{bts:tab:nodeTable}.



%\paragraph*{Sequence}
The Sequence node executes Algorithm \ref{bts:alg:sequence},
which corresponds to routing the ticks to its children from the left until it finds a child that returns either \emph{Failure} or \emph{Running}, then it returns \emph{Failure} or \emph{Running} accordingly to its own parent. It returns \emph{Success} if and only if all its children return \emph{Success}. Note that when a child returns \emph{Running} or \emph{Failure}, the Sequence node does not route the ticks to the next child (if any). The symbol of the Sequence node is a box containing the label \say{$\rightarrow$}, shown in Figure~\ref{bts.fig.seq}.
\begin{figure}[h]
\centering
\includegraphics[width=0.6\columnwidth]{IntroSeq.pdf}
\caption{Graphical representation of a Sequence node with $N$ children.}
\label{bts.fig.seq}
\end{figure}

\begin{algorithm2e}[h]
  \For{$i \gets 1$ \KwSty{to} $N$}
  {
    \ArgSty{childStatus} $\gets$ \FuncSty{Tick(\ArgSty{child($i$)})}\\
    \uIf{\ArgSty{childStatus} $=$ \ArgSty{Running}}
    {
      \Return{Running}
    }
    \ElseIf{\ArgSty{childStatus} $=$ \ArgSty{Failure}}
    {
      \Return{Failure}
    }
  }
  \Return{Success}
  \caption{Pseudocode of a Sequence node with $N$ children}
  \label{bts:alg:sequence}
\end{algorithm2e}


%\paragraph*{Fallback}
The Fallback node\footnote{Fallback nodes are sometimes also called \emph{selector} or \emph{priority selector} nodes.} executes Algorithm \ref{bts:alg:fallback},
which corresponds to routing the ticks to its children from the left until it finds a child that returns either \emph{Success} or \emph{Running}, then it returns \emph{Success} or \emph{Running} accordingly to its own parent. It returns \emph{Failure} if and only if all its children return \emph{Failure}. Note that when a child returns \emph{Running} or \emph{Success}, the Fallback node does not route the ticks to the next child (if any).
The symbol of the the Fallback node is a box containing the label \say{$?$}, shown in Figure~\ref{bts.fig.sel}.
\begin{figure}[h]
\centering
\includegraphics[width=0.6\columnwidth]{IntroSel.pdf}
\caption{Graphical representation of a Fallback node with $N$ children.}
\label{bts.fig.sel}
\end{figure}

\begin{algorithm2e}[h]
  \For{$i \gets 1$ \KwSty{to} $N$}
  {
    \ArgSty{childStatus} $\gets$ \FuncSty{Tick(\ArgSty{child($i$)})}\\
    \uIf{\ArgSty{childStatus} $=$ \ArgSty{Running}}
    {
      \Return{Running}
    }
    \ElseIf{\ArgSty{childStatus} $=$ \ArgSty{Success}}
    {
      \Return{Success}
    }
  }
  \Return{Failure}
  \caption{Pseudocode of a Fallback node with $N$ children}
    \label{bts:alg:fallback}
\end{algorithm2e}


%\paragraph*{Parallel}
The Parallel node executes Algorithm \ref{bts:alg:parallel},
which corresponds to routing the ticks to all its children and it returns \emph{Success} if $M$ children return \emph{Success}, it returns \emph{Failure} if $N-M+1$ children return \emph{Failure}, and it returns \emph{Running} otherwise, where $N$ is the number of children and $M\leq N$ is a user defined threshold.
The symbol of the the Parallel node is  a box containing the label \say{$\rightrightarrows$}, shown in Figure~\ref{bts.fig.par}.
\begin{figure}[h]
\centering
\includegraphics[width=0.6\columnwidth]{IntroPar.pdf}
\caption{Graphical representation of a Parallel node with $N$ children.}
\label{bts.fig.par}
\end{figure}

\begin{algorithm2e}[h]
  \For{$i \gets 1$ \KwSty{to} $N$}
  {
    \ArgSty{childStatus}(i) $\gets$ \FuncSty{Tick(\ArgSty{child($i$)})}\\
    }
    \uIf{$\Sigma_{i: \ArgSty{childStatus}(i)=Success}1\geq M$}
    {
      \Return{Success}
    }
    \ElseIf{$\Sigma_{i: \ArgSty{childStatus}(i)=Failure}1 > N-M$}
    {
      \Return{Failure}
    
  }
  \Return{Running}
    \caption{Pseudocode of a Parallel node with $N$ children and success threshold $M$}
  \label{bts:alg:parallel}
\end{algorithm2e}




\begin{figure}[h]
        \centering
        \begin{subfigure}[b]{0.3\columnwidth}
                \centering
                \includegraphics[width=0.4\columnwidth]{IntroAct}
                \caption{Action node. The label describes the action performed.}
                \label{bts.fig.act}              
        \end{subfigure}
        ~
                \begin{subfigure}[b]{0.3\columnwidth}
                \centering
                \includegraphics[width=0.7\columnwidth]{IntroCon}
                \caption{Condition node. The label describes the condition verified.}
                \label{bts.fig.cond}
        \end{subfigure}
        ~
         \begin{subfigure}[b]{0.3\columnwidth}
                \centering
                \includegraphics[width=0.5\columnwidth]{IntroDec}
                \caption{Decorator node. The label describes the user defined policy.}
                \label{bts.fig.dec}
        \end{subfigure}%
        \caption{Graphical representation of  Action (a), Condition (b), and Decorator (c) node.}
\end{figure}



%\paragraph*{Action}
When it receives ticks, an Action node executes a command. It returns \emph{Success} if the action is correctly completed or \emph{Failure} if the action has failed. While the action is ongoing it returns \emph{Running}. An Action node is shown in Figure~\ref{bts.fig.act}.

%\paragraph*{Condition}
When it receives ticks, a Condition node checks a proposition. It returns \emph{Success} or \emph{Failure} depending on if the proposition holds or not. Note that a Condition node never returns a status of \emph{Running}. A Condition node is shown in Figure~\ref{bts.fig.cond}.

%\paragraph*{Decorator} 
The Decorator node is a control flow node with a single child that manipulates the return status of its child according to a user-defined rule and also selectively ticks the child according to some predefined rule. For example, an \emph{invert} decorator inverts the \emph{Success}/\emph{Failure} status of the child; a \emph{max-N-tries} decorator only lets its child fail $N$ times, then always returns \emph{Failure} without ticking the child; a \emph{max-T-sec} decorator lets the child run for $T$ seconds then, if the child is still Running, the Decorator returns \emph{Failure} without ticking the child. The symbol of the Decorator is a rhombus, as in Figure~\ref{bts.fig.dec}.

%
%
\begin{table*}[htp]
\scriptsize
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
 \bf{Node type} & \bf{Symbol}& \bf{Succeeds} & \bf{Fails} & \bf{Running} \cr

\hline
 Fallback  &\fbox{?} & If one child succeeds & If all children fail &If one child returns Running \cr
\hline
Sequence &\fbox{$\rightarrow$} &If all children succeed & If one child fails &If one child returns Running \cr
\hline
Parallel &\fbox{$\rightrightarrows$} & If $\geq M$ children succeed & If $>N-M$ children fail &else \cr
\hline
Action & \fbox{text}& Upon completion & If impossible to complete & During completion \cr
\hline
\cornersize{.9} 
Condition &\ovalbox{text} & If true & If false & Never  \cr
 \hline
Decorator & $\Diamond$& Custom  & Custom & Custom \cr
\hline
\end{tabular}
\end{center}
\caption{The node types of a BT.}
\label{bts:tab:nodeTable}
\end{table*}%


%A BT is defined as a directed rooted tree where nodes are grouped into control flow nodes,  execution nodes, and a root node. In a pair of connected nodes we use the common definition of \emph{parent} and \emph{child} node. 
%Then, the root node has no parents and only one child, 
% the control flow nodes have one parent and at least one child, and
% the execution nodes are the leaves of the tree (i.e. they have no children and one parent).
% Graphically, the children of a control flow node are sorted from its bottom left to its bottom right, as depicted in Figures~\ref{bts.fig.sel}-\ref{bts.fig.par}.
%The execution of a BT starts from the root node. It sends \emph{ticks}~\footnote{A tick is a signal that enables the execution of a child.} to its child. When a generic node in a BT receives a tick from its parent,  its execution starts and it returns to its parent a status \emph{Running} if its execution has not finished yet, \emph{success} if its execution is accomplished (i.e. the execution ends without Failures), or \emph{failure} otherwise.\\ 
%Here we draw a distinction between three types of control flow nodes (selector, sequence, and parallel) and between two types of execution nodes (action and condition). Their execution is explained below.
%\subsection{Fallback (also known as Selector)}
%When the execution of a selector node starts (i.e. the node receives a tick from its parent), then the node's children are executed in succession from left to right, 
%until a child returning success or Running is found. Then this message is returned to the parent of the selector.
% It returns failure only when all the children return a status failure.
%The purpose of the selector node is to robustly carry out a task that can be performed using several different approaches (e.g. a motion tracking task can be made using either a 3D camera or a 2D camera) by performing each of them in succession until one succeeds.
%The graphical representation of a selector node is a box with a ``?", as in Fig.~\ref{bts.fig.sel}. \\ A finite number of BTs $\bt_1,\bt_2,\ldots,\bt_N$ can be composed into a more complex BT, with them as children, using the selector composition: $\bt_0=\mbox{Selector}(\bt_1,\bt_2,\ldots,\bt_N)$.
%\begin{figure}[h]
%\centering
%\includegraphics[width=0.6\columnwidth]{IntroSel-crop.pdf}
%\caption{Graphical representation of a selector node with $N$ children.}
%\label{bts.fig.sel}
%\end{figure}
%\subsection{Sequence}
%When the execution of a sequence node starts, then the node's children are executed in succession from left to right, returning to its parent a status failure (Running) as soon as the a child that returns failure (Running) is found. It returns success only when all the children return success.
%The purpose of the sequence node is to carry out the tasks that are defined by a strict sequence of subtasks, in which all have to succeed (e.g. a mobile robot that has to move to a region ``A" and then to a region ``B"). 
%The graphical representation of a sequence node is a box with a ``$\rightarrow$", as in Fig.~\ref{bts.fig.seq}.\\ A finite number of BTs $\bt_1,\bt_2,\ldots,\bt_N$ can be composed into a more complex BT, with them as children, using the sequence composition: $\bt_0=\mbox{Sequence}(\bt_1,\bt_2,\ldots,\bt_N)$.
%\begin{figure}[h]
%\centering
%\includegraphics[width=0.6\columnwidth]{IntroSeq-crop.pdf}
%\caption{Graphical representation of a sequence node with $N$ children.}
%\label{bts.fig.seq}
%\end{figure}
%\subsection{Parallel} 
%When the execution of a parallel node starts, then the node's children are executed in succession from left to right without waiting for a return status from any child before ticking the next one. It returns success if a given number of children $M\in \mathbb{N}$ return success, it returns failure when the children that return Running and success are not enough to reach the given number, even if they would all   return success. It returns Running otherwise. The purpose of the parallel node is to model those tasks separable in independent subtasks performing non-conflicting actions (e.g. a multi object tracking can be performed using several cameras).
%The parallel node is graphically represented by a box with ``$\rightrightarrows$" with the number $M$ on top left, as in Fig.~\ref{bts.fig.par}. 
%A finite number of BTs $\bt_1,\bt_2,\ldots,\bt_N$ can be composed into a more complex BT, with them as children, using the parallel composition: $\bt_0=\mbox{Parallel}(\bt_1,\bt_2,\ldots,\bt_N,M)$.
%
%\begin{figure}[h]
%\centering
%\includegraphics[width=0.6\columnwidth]{IntroPar-crop.pdf}
%\caption{Graphical representation of a parallel node with $N$ children.}
%\label{bts.fig.par}
%\end{figure}
%\begin{figure}[b]
%        \centering
%        \begin{subfigure}[b]{0.3\columnwidth}
%                \centering
%                \includegraphics[width=0.5\columnwidth]{IntroDec-crop}
%                \caption{Decorator node. The label describes the user defined policy.}
%                \label{bts.fig.dec}
%        \end{subfigure}%
%       ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
%          %(or a blank line to force the subfigure onto a new line)
%        \begin{subfigure}[b]{0.3\columnwidth}
%                \centering
%                \includegraphics[width=0.3\columnwidth]{IntroAct-crop}
%                \caption{Action node. The label describes the action performed}
%                \label{bts.fig.act}              
%        \end{subfigure}
%        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
%          %(or a blank line to force the subfigure onto a new line)
%        \begin{subfigure}[b]{0.3\columnwidth}
%                \centering
%                \includegraphics[width=0.5\columnwidth]{IntroCon-crop}
%                \caption{Condition node. The label describes the condition verified}
%                \label{bts.fig.cond}
%        \end{subfigure}
%        \caption{Graphical representation of a decorator, action, and condition node.}
%\end{figure}
%\subsection{Decorator} 
%A decorator is a particular node that has only one child. It changes its child's return status according to a user defined arbitrarily policy (e.g. it might return failure if the child does not succeeds in a given time). The decorator is graphically represented in Fig.~\ref{bts.fig.dec}.
%\subsection{Action}
%When an action node starts its execution, then it returns
% success if the action is completed and failure if the action cannot be completed. Otherwise it returns
% Running. The action node is represented in Fig.~\ref{bts.fig.act} 
%\subsection{Condition}
%The condition node checks if a condition is satisfied or not. The return status is success or failure accordingly and it is never Running. The condition node is represented in Fig.~\ref{bts.fig.cond}. 
%\subsection{Root}
%The root node is the node that generates ticks. It is graphically represented by a box labeled with ``$\varnothing$''.



\subsection{Execution Example of a BT}
\label{bts.ee}
Consider the BT in Figure~\ref{bts.fig.btmot} 
designed to make an agent look for a ball, approach it, grasp it, proceed to a bin, and place the ball in the bin.
This example will illustrate the execution of the BT, including the reactivity when another (external) agent takes the ball from the first agent, 
making it switch to looking for the ball and approaching it again.
When the execution starts, the ticks traverse the BT reaching the condition node \emph{Ball Found}. The agent does not know the ball position hence the condition node returns  \emph{Failure} and the ticks reach the Action \emph{Find Ball}, which returns  \emph{Running} (see Figure~\ref{bts.fig.btmot1}). While executing this action, the agent  sees the ball with the camera.  In this new situation the agent knows the ball position. Hence the condition node \emph{Ball Found} now returns  \emph{Success} resulting in the ticks no longer reaching the Action node \emph{Find Ball} and the action is preempted. The ticks continue exploring the tree, and reach the condition node \emph{Ball Close}, which returns \emph{Failure} (the ball is far away) and then reach the Action node \emph{Approach Ball}, which returns  \emph{Running} (see Figure~\ref{bts.fig.btmot2}). Then the agent eventually reaches the ball, picks it up and goes towards the bin (see Figure~\ref{bts.fig.btmot3}). When an external agent moves the ball from the hand of the first agent to the floor (where the ball is visible), the condition node \emph{Ball Found} returns  \emph{Success} while the condition node \emph{Ball Close} returns  \emph{Failure}. In this situation the ticks no longer reach the Action \emph{Approach Bin} (which is preempted) and they instead reach the Action \emph{Approach Ball} (see Figure~\ref{bts.fig.btmot4}).  


%\begin{remark}
%In this example, actions are durative as in a TR program (See Section~\ref{architectures.tr}). In a BT actions can be either durative or discrete.
%\end{remark}

\begin{figure}[h!]
\centering
\includegraphics[width=\columnwidth]{BTExample1}
\caption{BT encoding the behavior of Example~\ref{Introduction.ex.motivating}.}
\label{bts.fig.btmot}
\end{figure}

\begin{figure}[h!]
\centering
\begin{subfigure}[b]{\columnwidth}
\includegraphics[width=\columnwidth]{BTExample1Tick1}
\caption{Ticks' traversal when the robot is searching the ball.}
\label{bts.fig.btmot1}
\end{subfigure}

\begin{subfigure}[b]{\columnwidth}
\includegraphics[width=\columnwidth]{BTExample1Tick2}
\caption{Ticks'  traversal while the robot is approaching the ball.}
\label{bts.fig.btmot2}
\end{subfigure}

\begin{subfigure}[b]{\columnwidth}
\includegraphics[width=\columnwidth]{BTExample1Tick3}
\caption{Ticks'  traversal while the robot is approaching the bin.}
\label{bts.fig.btmot3}
\end{subfigure}

\begin{subfigure}[b]{\columnwidth}
\includegraphics[width=\columnwidth]{BTExample1Tick2}
\caption{Ticks'  traversal while the robot is approaching the ball again (because it was removed from the hand).}
\label{bts.fig.btmot4}
\end{subfigure}
\caption{Visualization of the ticks' traversal in the different situations, as explained in Section~\ref{bts.ee}.}
\label{bts.fig.btmot1to4}
\end{figure}
%\section{BT FSM}
%\red{TBD}




\subsection{Control Flow Nodes with Memory}
\label{bt:sec:mem}
As seen in the example above, to provide reactivity
the control flow nodes Sequence and Fallback keep sending ticks to the children to the left of a running child, in order to verify whether a child has to be re-executed and the current one has to be preempted. 
However, sometimes the user knows that a child, once executed, does not need to be re-executed.

Nodes with memory~\cite{millington2009artificial} have been introduced to enable the designer to avoid the unwanted re-execution of some nodes. Control flow nodes with memory always remember whether a child has returned  \emph{Success} or \emph{Failure}, avoiding the re-execution of the child until the whole Sequence or Fallback finishes in either \emph{Success} or \emph{Failure}. In this book, nodes with memory are graphically represented with the addition of the symbol  \say{$*$} (e.g. a Sequence node with memory is graphically represented by a box with a \say{$\rightarrow^*$}).
The memory is cleared when the parent node returns either  \emph{Success} or \emph{Failure}, so that at the next activation all children are considered. Note however that every execution of a control flow node with memory can be obtained with a non-memory BT using some auxiliary conditions as shown in Figure~\ref{bts.fig.mem}. Hence nodes with memory can be considered to be syntactic sugar.

\begin{figure}[h]
        %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
          
          
        \begin{subfigure}[b]{0.3\columnwidth}
                \centering
                \includegraphics[width=\columnwidth]{BTstarNONreactive}
                \caption{Sequence composition with memory.}
                \label{bts.fig.starnonreac}
        \end{subfigure}          
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.6\columnwidth}
                \centering
                \includegraphics[width=\columnwidth]{BTstarreactive}
                \caption{BT that emulates the execution of the Sequence composition with memory using nodes without memory.}
                \label{bts.fig.starreac}              
        \end{subfigure}
        \caption{Relation between memory and memory-less BT nodes.}
                        \label{bts.fig.mem}              
\end{figure}

\begin{remark}
 Some BT implementations, such as the one described in~\cite{millington2009artificial},  do not include the \emph{Running} return status. Instead, they let each Action run until it returns \emph{Failure} or \emph{Success}. We denote these BTs as  \emph{non-reactive}, since they do not allow  actions other than the currently active one to react to changes. This is a significant limitation on non-reactive BTs, which was also noted in \cite{millington2009artificial}. A non-reactive BT can be seen as a BT with only memory nodes.
 
As reactivity is one of the key strengths of BTs, the non-reactive BTs are of limited use. 
\end{remark}


%\section{Behavior Trees as Closed Loop task execution framework}
%As seen in Section~\ref{bts.ee}, BTs allows a compact description of a reactive task execution. Now let ask ourselves why we need a reactive execution.
%In Example~\ref{Introduction.ex.motivating} we have seen two problems: the environment was not modeled correctly, the action failure is unpredictable. In a control theory perspective these can be seen as a uncertainty in the plant model and disturbance. Uncertainty describes the impossibility to model the environment and actions outcome with absolute accuracy, and the disturbance as the influence of an external actor. In control theory, they solved this problem adding a feedback loop, that is the controller sends signals to the plant according to the current output. BT implements a similar strategy to react to change in the environment and model uncertainty, it keeps reading the return statuses of actions and conditions preempting the execution of some nodes whenever needed.
%
%
%\begin{figure}[b]
%        %add desired spacing between images, e. g. ~, \quad, \qquad etc.
%          %(or a blank line to force the subfigure onto a new line)
%        \begin{subfigure}[b]{0.5\columnwidth}
%                \centering
%                \includegraphics[width=\columnwidth]{feedforwardControl}
%                \caption{Feed-forward control scheme.}
%                \label{bts.fig.FF}              
%        \end{subfigure}
%        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
%          %(or a blank line to force the subfigure onto a new line)
%        \begin{subfigure}[b]{0.5\columnwidth}
%                \centering
%                \includegraphics[width=\columnwidth]{feedbackControl}
%                \caption{Feed-back control scheme.}
%                \label{bts.fig.FB}
%        \end{subfigure}
%        \caption{Control schemes for low level controllers.}
%\end{figure}




\newpage	
\section{Creating a BT for Pac-Man from Scratch}
\label{sec:pacman}
In this section we create a set of BTs of increasing complexity for playing the game Pac-Man.
The source code of all the examples is publicly available and editable.\footnote{\url{https://btirai.github.io/}}
We use  a clone of the Namco's Pac-Man computer game depicted in Figure~\ref{bts.fig.ScenarioPacMan}\footnote{The software was developed at UC Berkeley for educational purposes. More information available at: \url{http://ai.berkeley.edu/project_overview.html}}.    

In the testbed, a BT controls the agent, Pac-Man, through a maze containing two ghosts, a large number of  pills, including two so-called power pills. 
The goal of the game is to consume all the pills, without being eaten by the ghosts. The power pills are such that, if eaten, Pac-Man receives temporary super powers, and is able to eat the ghosts. After a given time the effect of the power pill wears off, and the ghosts can again eat Pac-Man.
 When a ghost is eaten, it returns to the center box where it is regenerated and becomes dangerous again. Edible ghosts change color, and then flash to signal when they are about to become dangerous again.
\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{scenario_pacman.png}
\caption{The game Pac-Man for which we will design a BT. There exists maps of different complexity.}
\label{bts.fig.ScenarioPacMan}
\end{figure}
%\subsection{Simplest Behavior: Greedy approach}

The simplest behavior is to let Pac-Man ignore the ghosts and just focus on eating pills.
This is done using a greedy action
 \emph{Eat Pills} as in Figure~\ref{bts.fig.greedy}.

\begin{figure}[h]
\centering
\includegraphics[width=0.2\columnwidth]{pacman_1}
\caption{BT for the simplest non-random behavior, \emph{Eat Pills}, which maximizes the number of pills eaten in the next time step.}
\label{bts.fig.greedy}
\end{figure}

%\subsection{Safe Behavior: Avoid being eaten}  
The simple behavior described above ignores the ghosts. 
To take them into account,  we can extend the previous behavior by adding an \emph{Avoid Ghosts} Action to be executed whenever the condition \emph{Ghost Close} is true. This Action will 
greedily maximize the distance to all ghosts.
The new Action and condition can be added to the BT as depicted in 
 Fig.~\ref{bts.fig.avoid}.
The resulting BT will switch between Eat Pills and Avoid Ghost depending on whether Ghost Close returns Success or Failure.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\columnwidth]{pacman_2}
\caption{If a Ghost is Close, the BT will execute the Action Avoid Ghost, else it will run Eat Pills.}
\label{bts.fig.avoid}
\end{figure}

The next extension we make is to take the power pills into account.
When Pac-Man eats a Power pill, the ghosts are edible, and we would like to chase them, instead of avoiding them.
To do this we add the condition \emph{Ghost  Scared} and the Action \emph{Chase Ghost} to the BT, as shown in Fig.~\ref{bts.fig.eat}.
\emph{Chase Ghost} greedily minimizes the distance to the closest edible ghost.
Note that we only start chasing the ghost if it is close, otherwise we continue eating pills.
Note also that all extensions are modular, without the need to rewire the previous BT.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\columnwidth]{pacman_3}
\caption{BT for the Combative Behavior}
\label{bts.fig.eat}
\end{figure}

With this incremental design, we have created a basic AI for playing Pac-Man, but what if we want to make a world class Pac-Man AI?
You could add additional nodes to the BT, such as moving towards the Power pills when being chased, and stop chasing ghosts when they are blinking and soon
will transform into normal ghosts. However, much of the fine details of Pac-Man lies in considerations of the Maze geometry, choosing paths that avoid dead ends and 
possible capture by multiple ghosts.
Such spatial analysis is probably best done inside the actions, e.g., making Avoid Ghosts take dead ends and ghost positions into account.
The question of what functionality to address in the BT structure, and what to take care of inside the actions is open, and must be decided on a case to case basis,
as discussed in Section~\ref{design:sec:granularity}.


%
%(change this text and decide how to extend the BT)
%The behavior we have now can handle edible and non-edible ghosts, and can eat dots using a very simple heuristic. We may want improve this behavior by using a better heuristic to find a path to eat the dots. This will result in editing solely the action node \emph{Move To Dot}.
%Moreover we observe that there are some situations in which the \emph{Escape} action could let the Pac-Man run into a ghost: Remembering that the escape action will move to a state that maximizes the distance from all the ghosts, there could be the situation where the only legal actions will move further away from one ghost but will move close to another as in Figure~\ref{bts.fig.bts.fig.fail}. In such situation is it preferable if Pac-Man moves away from the closest ghost. Hence we can can extend the previous behavior by adding an \emph{emergency escape} action whenever a \emph{non edible ghost is very close}. The emergency escape action will move to a state that maximizes the distance from the closest ghost. We incorporate the emergency escape behavior as in Figure~\ref{bts.fig.edit}
%
%\begin{figure}[h]
%\centering
%\includegraphics[width=\columnwidth]{scenario_pacman_fail.png}
%\caption{Situation in which the escape action could let Pac-Man run into a ghost. Both action \emph{Move Left} and \emph{Move Right} will lead to a state where the sum of the this distance from the ghosts is $4$. However, if Pac-Man moves left, it runs into a ghost.}
%\label{bts.fig.bts.fig.fail}
%\end{figure}
%
%
%\begin{figure}[h]
%\centering
%\includegraphics[width=\columnwidth]{PacmanFinal}
%\caption{Final BT}
%\label{bts.fig.edit}
%\end{figure}

\section{Creating a BT for a Mobile Manipulator Robot}
\label{sec:youbot}
\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{scenario_youbot.jpg}
\caption{The Mobile Manipulator for which we will design a BT.}
\label{bts.fig.ScenarioYouBot}
\end{figure}

In this section, we create a set of BTs of increasing complexity for controlling a mobile manipulator.
The source code of all the examples is publicly available and editable.\footnote{\url{https://btirai.github.io/}}
We use a custom-made testbed created in the V-REP robot simulator depicted in Figure~\ref{bts.fig.ScenarioYouBot}. 


In the testbed, a BT controls a mobile manipulator robot, a youBot, on a flat surface. In the scenario, several colored cubes are lying on a flat surface. The goal is to move the green cube to the goal area while avoiding the other cubes. The youBot's grippers are such that the robot is able to pick and place the cubes if the robot is close enough.

The simplest possible BT is to check the goal condition \emph{Green Cube on Goal}. If this condition is satisfied (i.e. the cube is on the goal) the task is done, if it is not satisfied the robot needs to \emph{place the cube} onto the goal area. To correctly execute the Action \emph{Place Cube}, two conditions need to hold: the robot \emph{is holding the green cube} and the robot \emph{is close to the goal area}. The behavior described so far can be encoded in the BT in Figure~\ref{bts.fig.youbotsimple}. This BT is able to 
place the green cube on the goal area if and only if the robot is close to the goal area with the green cube grasped.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\columnwidth]{BT_youbot_book}
\caption{BT for the simple Scenario.}
\label{bts.fig.youbotsimple}
\end{figure}



Now, thanks to the modularity of BTs, we can separately design the BTs needed to satisfy the two lower conditions in Fig.~\ref{bts.fig.youbotsimple}, i.e., the BT needed to grasp the green cube and the BT needed to reach the goal area. To grasp the green cube, the robot needs to have the \emph{hand free} and be \emph{close to the cube}. If it is not close, it approaches as long as a collision free trajectory exists. This behavior is encoded in the BT in Figure~\ref{bts.fig.youbotpick}. To reach the goal area we let the robot simply \emph{Move To the Goal}  as long as a \emph{collision free trajectory exists}. This behavior is encoded in the BT in Figure~\ref{bts.fig.youbotmove}.

\begin{figure}[ht!]
    \centering

    \begin{subfigure}[t]{\columnwidth}
        \centering
\includegraphics[width = 0.45\columnwidth]{BT_youbot_book_pick}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{A BT that picks the green cube. }
   \label{bts.fig.youbotpick}
    \end{subfigure}
    
      \begin{subfigure}[t]{\columnwidth}
        \centering
\includegraphics[width = 0.45\columnwidth]{BT_youbot_book_goal}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{A BT that reaches the goal region.}
      \label{bts.fig.youbotmove}
    \end{subfigure}
    \vspace{1em}
    \caption{Illustrations of a BT carrying out the subtasks of picking the green cube and reaching the goal area}
    \label{bts.fig.youbotpickmove}
\end{figure}


Now we can extend the simple BT in Fig.~\ref{bts.fig.youbotsimple} above by replacing the two lower conditions in Fig.~\ref{bts.fig.youbotsimple}
with the two BTs in Fig.~\ref{bts.fig.youbotpickmove}.
The result can be seen  in Fig.~\ref{bts.fig.youbotfinal}. Using this design, the robot is able to place the green cube in the goal area as long as there exists a collision free trajectory to the green cube and to the goal area. 


\begin{figure}[h]
\centering
\includegraphics[width=0.7\columnwidth]{BT_youbot_book_final}
\caption{Final BT resulting from the aggregation of the BTs in Figs.~\ref{bts.fig.youbotsimple}-\ref{bts.fig.youbotpickmove}}
\label{bts.fig.youbotfinal}
\end{figure}



We can continue to incrementally build the BT in this way to handle more situations, for instance removing obstructing objects to ensure that a \emph{collision free trajectory exists}, and dropping things in the hand to be able to pick the green cube up. 

%\clearpage
\section{Use of BTs in Robotics and AI}
\label{sec:use_of_BTs}
In this section we describe the use  of BTs in a set of real robot applications and projects, spanning from autonomous driving to industrial robotics. 
%We review some projects that have chosen BT as their Control Architecture.

\subsection{BTs in autonomous vehicles}

There is no standard control architecture for autonomous vehicles, however reviewing the architectures used to address the DARPA Grand Challenge, a competition for autonomous vehicles, we note that most teams employed FSMs  designed and developed exactly for that challenge \cite{urmson2008autonomous, urmson2007tartan}. Some of them used a HFSM\cite{montemerlo2008junior} decomposing the mission task in multiple subtasks in a  hierarchy. %However, a real autonomous vehicle has to be fully functional in the urban areas, which precludes any hard-coded design.
%\todo{remove it? just a single example is not enough}
As discussed in Section~\ref{sec:modularity} there is reason to believe that using BTs instead of FSMs would be beneficial for autonomous driving applications.




\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{iQmatic}
\caption[Trucks running the Scania iQmatic's software.]{Trucks running the Scania iQmatic's software.\footnotemark}
\label{bts.fig.iQmatic}
\end{figure}
%\newpage
%\paragraph*{iQmatic\\}

iQmatic is a Scania-led project that aims at developing a fully autonomous heavy truck for goods transport, mining, and other industrial applications. The vehicle's software has to be reusable, maintainable and easy to develop. For these reasons, the iQmatic's developers chose BTs as the  control architecture  for the project. BTs are appreciated in iQmatic for their human readability,  supporting the design and development of early prototypes; and their maintainability,  making the editing task easier. Figure~\ref{bts.fig.iQmatic} shows two trucks used in the iQmatic project.\footnotetext{Picture courtesy of \url{Scania.com}}



\subsection{BTs in industrial robotics}
Industrial robots usually operate in structured environments and their  control architecture  is designed for a single specific task. Hence classical architectures such as FSMs or Petri Nets~\cite{murata1989petri} have found successful applications in the last decades. However, future generations of collaborative industrial robots, so-called cobots, will operate in less structured environments and  collaborate closely with humans. Several research projects explore this research direction. 

%\paragraph*{CoSTAR\\}
\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{CoSTAR}
\caption[Experimental platform of the CoSTAR project.]{Experimental platform of the CoSTAR project.\footnotemark}
\label{bts.fig.CoSTAR}
\end{figure}

CoSTAR~\cite{paxton2016costar} is a project that aims at developing a software framework that contains tools for  industrial applications that involve human cooperation.\footnotetext{Picture courtesy of \url{http://cpaxton.github.io/}} The use cases include non trained operators composing task plans, and training 
 robots  to perform complex behaviors.
BTs have found successful applications in this project as they simplify the composition of subtasks. The order in which the subtasks are executed is independent from the subtask implementation; this enables  easy composition of trees and the iterative composition of larger and larger trees. Figure~\ref{bts.fig.CoSTAR} shows one of the robotic platforms of the project.


%\paragraph*{SARAFun\\}

SARAFun\footnote{\url{http://sarafun.eu}} is a project that aims at developing a robot-programming framework that enables a non-expert user to program an assembly task from scratch on a robot in less than a day. It takes advantages of state of the art techniques in sensory and cognitive abilities, robot control, and planning.
\begin{figure}[h]
\centering
\includegraphics[trim={0 2cm 0 15cm},clip,width=\columnwidth]{SARAFun}% trim={<left> <lower> <right> <upper>}

\caption[Experimental platform of the SARAFun projectE.]{Experimental platform of the SARAFun project.\footnotemark}
\label{bts.fig.SARAFun}
\end{figure}

BTs are used to execute the generic actions learned or planned. For the purpose of this project, the  control architecture  must be human readable, enable code reuse, and modular.
 BTs have  created advantages also during the  development stage, when the code written by different partners had to be integrated. Figure~\ref{bts.fig.SARAFun} shows an ABB Yumi robot used in the SARAFun testbed.\footnotetext{Setup located at CERTH, Thessaloniki, Greece. Picture courtesy of Angeliki Topalidou-Kyniazopoulou.} 



%\newpage

%\paragraph*{BTs at Rethink Robotics \\}

\begin{figure}[h]
  \includegraphics[width=0.9\textwidth]{intera5}
  \caption[Intera's BT (left) and simulation environment (right).]{Intera's BT (left) and simulation environment (right).\footnotemark}
  \label{intera}
\end{figure}
  \footnotetext{Picture courtesy of \url{http://www.rethinkrobotics.com/intera/}}


Rethink Robotics released its software platform Intera in 2017, with
BTs  at the \say{heart of the design}. Intera claims to be a \say{first-of-its-kind software platform that connects everything from a single robot controller, extending the smart, flexible power of Rethink Robotics' Sawyer to the entire work cell and simplifying automation with unparalleled ease of deployment.}\footnote{\url{http://www.rethinkrobotics.com/news-item/rethink-robotics-releases-} \url{intera-5-new-approach-automation/}} It is designed with the goal of creating the world's fastest-to-deploy robot and fundamentally changing the concepts of integration, making it drastically easier and affordable. 


%Intera allows robots to respond quickly to changes in the workflow. This makes robots much more attractive for those businesses that still have little automation due to their less-structured assembly lines.  An example can be taken from the German magnet manufacturer \emph{MS Schramberg}\footnote{\url{http://www.magnete.de/}}. With less than a day of training, an MS Schramberg's engineer is able to deploy and train the robots in just an hour. The robots now run 24 hours per day, 6 days per week, and can easily configure complex logic tasks, minimizing the need for human interaction and freeing up employees for more complex tasks.


Intera's BT defines the Sequence of tasks the robot will perform. The tree can be created manually or trained by demonstration. Users can inspect any portion of the BT and make adjustments. The Intera interface (see Figure~\ref{intera}) also includes a simulated robot, so a user can run simulations while  the program executes the BT. BTs are appreciated in this context because the train-by-demonstration framework builds a BT that is easily inspectable and modifiable.\footnote{\url{http://twimage.net/rodney-brooks-743452002}}



\subsection{BTs in the Amazon Picking Challenge}

\begin{figure}[h!]
\centering
  \includegraphics[width=0.9\textwidth]{amazon}
  \caption{The KTH entry in the Amazon Picking Challenge at ICRA 2015.}
  \label{amazon}
\end{figure}

The Amazon Picking Challenge (APC) is an international robot competition. Robots need to autonomously retrieve a wide range of products from a shelf and put them into a container. The challenge was conceived with the purpose of strengthening the ties between  industrial and academic robotic research, promoting shared solutions to some open problems in unstructured automation. Over thirty companies and research laboratories from different continents competed in the APC's preliminary phases. The best performing teams earned the right to compete at the finals and the source codes of the finalists were made publicly available. \footnote{\url{https://github.com/amazon-picking-challenge}}

The KTH entry in the final challenge used BTs in both  2015 and 2016. BTs were appreciated for their modularity and code reusability, which allowed the integration of different functionalities developed by programmers with different background and coding styles. In  2015, the KTH entry got the best result out of the four teams competing with PR2 robots.

\subsection{BTs inside the social robot JIBO}
JIBO is a social robot that can recognize faces and voices, tell jokes, play games, and share information.
It is intended to be used in homes, providing the functionality of a tablet, but with an interface relying on speech and video instead of a touch screen. JIBO has been featured in Time Magazine's Best Inventions of 2017.\footnote{\url{http://time.com/5023212/best-inventions-of-2017/}} BTs are a fundamental part of the software architecture of JIBO\footnote{\url{https://developers.jibo.com/docs/behavior-trees.html}},
including an open SDK inviting external contributors to develop new skills for the robot.

\begin{figure}[ht]
\centering
  \includegraphics[width=0.9\textwidth]{jibo}
  \caption{The JIBO social robot has an SDK based on BTs.}
  \label{jibo}
\end{figure}



%
%10 Reasons the Age of Finite State Machines is Over
%Alex J. Champandard on December 28, 2007
%
%They're Unorthodox
%They're Low-Level
%Their Logic is Limited
%They Require Custom Extensions
%They Are Hard to Standardize
%They Are Not Deliberative
%They Have Concurrency Nightmares
%They Scale Poorly
%They Are Labor Intensive
%Industry is Moving On

\chapter{How Behavior Trees Generalize and Relate to Earlier Ideas}
\label{ch:earlier_ideas}
%\todo{if we keep this as a separate chapter, add an intro }

In this chapter, we describe how BTs relate to, and often generalize, a number of well known control architectures including FSMs (Section~\ref{sec:FSM}),
the Subsumption Architecture (Section~\ref{sec:SA}), the Teleo-Reactive Approach (Section~\ref{sec:TR}) and Decision Trees (Section~\ref{sec:DT}). We also present advantages and disadvantages of each approach.
Finally, we list a set of advantages and disadvantages of BTs % properties of a control architecture and compare the alternatives with respect to these properties 
(\ref{btasca.sec.properties}).
Some of the results of this chapter were previously published in the journal paper \cite{colledanchise2017behavior}.

%\section{Common Robot Control Architecture (remove)}
\label{btasca.sec.ca}
%In this section, we overview a set of Control Architectures that have found successful applications in robotics and we analyze their advantages and disadvantages. 
%To allow formal analysis, robotics (and more generally computer science) needs to have formal models of its subject matters. Indeed, various task execution models exist, each abstracting away some of the properties of the real computation and modeling others.

\section{Finite State Machines}
\label{sec:FSM}
A FSM is one of the most basic mathematical models of computation.
The FSM consists of a set of states, transitions and events, as illustrated in Fig.~\ref{Arch.fig.FSM} showing an example of a FSM designed to carry out a grab-and-throw task. 
Note that the discussion here is valid for all  control architectures  based on FSMs, including Mealy~\cite{moore1956gedanken} and Moore~\cite{mealy1955method} machines.
\begin{figure}[h]
\centering
\includegraphics[width = \columnwidth]{FSMexample} 
   \caption{Graphical representation of a FSM designed to carry out a simple grab-and-throw task. The initial state has a thicker border, and events names are given next to the corresponding transition arrows.}
    \label{Arch.fig.FSM}
\end{figure}

% Loosely following XXXCITESOMETHINGRANDOM, a FSM is defined as a quintuple $(\Sigma, S, s_0, \delta, F)$ where:
%\begin{itemize}
%\item $\Sigma$ is the input alphabet (a finite, non-empty set of symbols).
%\item $S$ is a finite, non-empty set of states.
%\item $s_0$ is an initial state, an element of $S$.
%\item $\delta$ is the state-transition function: $\delta: S \times \Sigma \rightarrow S$.
%\item $F$ is the set of final states, a (possibly empty) subset of $S$.
%\end{itemize}


\subsection{Advantages and disadvantages}
FSMs are widely used due to their three main advantages:

\begin{itemize}
\item Very common structure, used in many different parts of computer science.
\item  Intuitive and easy to understand.
\item Easy to implement. 
\end{itemize}

However, the drawbacks of FSMs gives rise to problems when the system modelled grows in complexity and number of states, as described briefly in Section~\ref{sec:modularity}.
In particular we have the following drawbacks

\begin{itemize}
\item Reactivity/Modularity tradeoff.
A reactive system needs many transitions, and every transition corresponds to a Goto statement, see Section~\ref{sec:modularity}. In particular, the transitions give rise to the problems below:
\begin{itemize}
\item Maintainability: Adding or removing states requires the re-evaluation a potentially large number of transitions and internal states of the FSM. This makes FSMs highly susceptible to human design errors and 
impractical from an automated design perspective.
%makes them inefficient to be used and generated by computer programs.
\item Scalability: FSMs with many states and many transitions between them are hard to modify, for both humans and computers.
\item Reusability: The transitions between states may depend on internal variables, making it unpractical to reuse the same sub-FSM  in multiple projects.
\end{itemize}
\end{itemize}



\section{Hierarchical Finite State Machines}
Hierarchical FSMs (HFSMs)\label{definition:HFSM}, also known as State Charts~\cite{Harel87statecharts}, where developed to alleviate some of the disadvantages of FSMs. In a HFSM, a state can in turn contain one or more substates. A state containing two or more states is called a \emph{superstate}. In a HFSM, a \emph{generalized transition} is a transition between superstates. Generalized transitions can reduce the number of transitions by connecting two superstates rather than connecting a larger number of substates individually. 
Each superstate has one substate identified as the starting state, executing whenever a transition to the superstate occurs.
Figure~\ref{Arch.fig.HFSM} shows an example of a HFSM for a computer game character.


\begin{figure}[h]
\centering
\includegraphics[width = \columnwidth]{HFSM} 
   \caption{Example of a HFSM controlling a NPC of a combat game. \emph{Patrol}, \emph{Use Rifle}, and \emph{Use Handgun} are superstates.}
    \label{Arch.fig.HFSM}
\end{figure}


\subsection{Advantages and disadvantages}



The main advantages of HFSMs are:

\begin{itemize}
\item Increased Modularity: it is possible to separate the tasks in subtasks. However these subtasks often still depend on each other through state-dependent transitions.
\item Behavior inheritance: The state nesting in HFSMs allows so-called \emph{behavior inheritance}. Behavior inheritance allows substates to inherit behaviors from the superstate; for example,  in the HFSM depicted in Figure~\ref{Arch.fig.HFSM}, while in the substates inside \emph{Use Handgun}, the character holds the weapon using one hand whereas while in the substates inside \emph{Use Rifle}, the character holds the weapon using two hands. Thus, there is no need for the sub states to specify this property, instead, it is inherited from the superstate.
\end{itemize}
The main disadvantages of HFSMs are:
\begin{itemize}
\item Maintainability: Adding or removing states is still hard. A long sequence of actions, with the possibility of going back in the sequence and re-execute a task that was undone by external agents (e.g. the environment), still requires a fully connected subgraph.
\item Manually created hierarchy: Although HFSMs were conceived as a hierarchical version of FSMs, the hierarchy has to be user defined and editing such a hierarchy  can be difficult. The hierarchy resolves some problems, but a reactive HFSM still results in some sub graphs being fully connected with many possible transitions, see Fig.~\ref{fig:hugeHFSM}.
\end{itemize}

%FSMs are very flexible  and intuitive Control Architectures used in robotics. 
From a theoretical standpoint, every execution described by a BT can be described by a FSM and vice-versa~\cite{ogren,Marzinotto14}. However, due to the number of transitions, using a FSM as a  control architecture  is unpractical for some applications as shown in Chapter~\ref{chap:bts}. Moreover, 
a potential problem is that
a FSM does not assume that the conditions triggering the outgoing transitions from the same state are mutually exclusive. When implemented, the conditions are checked regularly in discrete time, hence there exists a non-zero probability that two or more conditions hold simultaneously after one cycle. To solve this problem we need to redefine some transitions, as done in the FSM in Figure~\ref{Introduction.fig.FSMreactive}, making the propositions of the outgoing transitions mutually exclusive. A FSM of this format is impractical to design for both humans and computers. Manually adding and removing behaviors  is prone to errors. After adding a new state, each existing transition must be re-evaluated (possibly removed or replaced) and new transitions from/to the new state must be evaluated as well. A high number of transitions make any automated process to analyze or synthesize FSMs computationally expensive.  

HFSMs is the most similar  control architecture  to BTs in terms of purpose and use. To compare BTs with HFSMs we use the following complex example. Consider the HFSM shown in Figure~\ref{fig:hugeHFSM} describing the behavior of a humanoid robot. We can describe the same functionality using the BT shown in Figure~\ref{fig:hugeBT}. Note that we have used the standard notation~\cite{Harel87statecharts} of HFSMs to denote two activities running in parallel with a dashed line as separation. One important difference is that, in HFSMs, each layer in the hierarchy needs to be added explicitly, whereas in BTs every subtree can be seen as a module of its own, with the same interface as an atomic action.

In the HFSM shown in Figure~\ref{fig:hugeHFSM}, a proposition needs to be given for each transition, and to improve readability we have numbered these propositions from $C1$ to $C10$.
In the top layer of the HFSM we have the sub-HFSMs of \emph{Self Protection} and  \emph{Perform Activites}.
Inside the latter we have two parallel sub-HFSMs. One is handling the user interaction, while the larger one contains 
a complete directed graph handling the switching between the different activities. Finally, \emph{Play Ball Game} is yet another  sub-HFSM with the 
ball tracking running in parallel with another complete directed graph, handling the reactive switching between  \emph{Approach Ball}, \emph{Grasp Ball}, and \emph{Throw Ball}. 

It is clear from the two figures how modularity is handled by the HFSM. 
The explicitly defined sub-HFSM encapsulates  \emph{Self Protection},  \emph{Perform Activities} and  \emph{Play Ball Game}.
However, inside these sub-HFSMs, the transition structure is a complete directed graph, with $n(n-1)$ transitions that need to be maintained ($n$ being the number of nodes). 


\begin{landscape}
 \begin{figure}
 \centering
  \includegraphics[width=\textwidth]{hugeFSM}
  \caption{A HFSM description of the BT in Figure \ref{fig:hugeBT}. The transition conditions are shown at the end of each arrow to indicate the direction of the transition. Note how the complexity of the transitions \emph{within} each layer of the HFSM grows with the number of nodes. The conditions labels are: $C1= \mbox {Bumper Pressed}$, $C2= \mbox {Activity Ball Game}  $, $C3= \mbox {Activity Sit} $, $C4=\mbox {Not Know What to Do} $, $C5= \mbox {Activity Stand Up} $, $C6= \mbox {Activity Sleep} $, $C7=\mbox {Say Goodbye} $, $C8= \mbox {Ball Close} $, $C9= \mbox {Ball Grasped}$, $C10= \mbox {New User Suggestion}$. }
  %(start nodes at first execution, then continue doing what was done last time)
  \label{fig:hugeHFSM}
 \end{figure}
\end{landscape}


\begin{landscape}
 \begin{figure}\centering
  \includegraphics[width=\textwidth]{hugeBT}
  \caption{A BT that combines some capabilities  of a humanoid robot in an interactive and modular way. Note how atomic actions can easily be replaced by more complex sub-BTs.}
  %(start nodes at first execution, then continue doing what was done last time)
  \label{fig:hugeBT}
 \end{figure}
\end{landscape}
%Passing of variables is not handled explicitly by either FSMs or BTs. A natural solution is however the use of a shared memory, e.g. a blackboard, as is done in \cite{guerin2015manufacturing}.

%Looking at the available software for designing and executing FSMs and BTs, we note that the tools on the FSM side,
%such as IBM Rhapsody\footnote{http://www-03.ibm.com/software/products/sv/ratirhapfami} and Stateflow\footnote{http://se.mathworks.com/products/stateflow/?refresh=true} are much more mature. Still, 
%many computer game development platforms, such as Unity3d\footnote{http://forum.unity3d.com/threads/behavior-designer-behavior-trees-for-everyone.227497/} and  Unreal Engine\footnote{https://docs.unrealengine.com/latest/INT/Engine/AI/BehaviorTrees/QuickStart/} now have tools for working with BTs.
%For those who wish to implement their own framework, we note that standard FSM implementation is quite straightforward,
%whereas both HFSMs and BTs require more consideration. However open source implementations are available for both.\footnote{http://michelecolledanchise.com/github/ (BTs)}\footnote{http://qfsm.sourceforge.net (FSMs)}

\newpage
\subsection{Creating a FSM that works like a BTs }
\label{btsvsothers:sec:FSMandBTs}


As described in Chapter~\ref{chap:bts}, each BT returns \emph{Success}, \emph{Running} or \emph{Failure}.
Imagine we have a state in a FSM that has 3 transitions, corresponding to these 3 return statements.
Adding a Tick source that collect the return transitions and transfer the execution back into the state, as depicted in Figure \ref{btsvsothers:FSMticksource}, we have a structure that resembles a BT.

 \begin{figure}[h]
\begin{center}
\includegraphics[width=5cm]{btsvsothers/figures/FSMticksource}
\caption{An FSM behaving like a BT, made up of a single normal state, three out transitions Success (S), Running (R) and Failure (F), and a Tick source. }
\label{btsvsothers:FSMticksource}
\end{center}
\end{figure}




We can now compose such FSM states using both Fallback and Sequence constructs. The FSM corresponding to the Fallback example in Figure~\ref{btsvsothers:subsumption} would then look like the one shown in Figure \ref{btsvsothers:FSMfallback}.

\begin{figure}[h]
\begin{center}
\includegraphics[width=3.5cm]{btsvsothers/figures/fallback}
\caption{
A Fallback is used to create an \emph{Enter Building} BT.
The back door option is only tried if the front door option fails. }
\label{btsvsothers:subsumption}
\end{center}
\end{figure}


 \begin{figure}[h]
\begin{center}
\centering
\includegraphics[width=0.8\columnwidth]{btsvsothers/figures/FSMfallback}
\caption{A FSM corresponding to the Fallback BT in Figure~\ref{btsvsothers:subsumption}.
Note how the second state is only executed if the first fails.}
\label{btsvsothers:FSMfallback}
\end{center}
\end{figure}

Similarly, the FSM corresponding to the sequence example in Figure~\ref{btsvsothers:recipe} would then look like the one shown in Figure \ref{btsvsothers:FSMsequence}, and a two level BT, such as the one in  Figure~\ref{btsvsothers:comb1} would look like Figure~\ref{btsvsothers:FSMcombo}.



\begin{figure}[h]
\begin{center}
\includegraphics[width=3.5cm]{btsvsothers/figures/sequence}
\caption{
A Sequence is used to to create an \emph{Enter Through Front Door} BT.
Passing the door  is only tried if the opening action succeeds.}
\label{btsvsothers:recipe}
\end{center}
\end{figure}



 \begin{figure}[h]
\begin{center}
\centering
\includegraphics[width=0.8\columnwidth]{btsvsothers/figures/FSMsequence}
\caption{An FSM corresponding to the Sequence BT in Figure~\ref{btsvsothers:recipe}.  
Note how the second state is only executed if the first succeeds.
}
\label{btsvsothers:FSMsequence}
\end{center}
\end{figure}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=6cm]{btsvsothers/figures/compSeqFallback}
\caption{The two BTs in Figures \ref{btsvsothers:subsumption}
 and \ref{btsvsothers:recipe} are combined to larger BT. If e.g. the robot opens the front door, but does not manage to pass through it, it will try the back door.}
\label{btsvsothers:comb1}
\end{center}
\end{figure}



 \begin{figure*}[htbp]
\begin{center}
\includegraphics[width=\columnwidth]{btsvsothers/figures/FSMcombo}
\caption{An FSM corresponding to the BT in Figure~\ref{btsvsothers:comb1}. 
 }
\label{btsvsothers:FSMcombo}
\end{center}
\end{figure*}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=7cm]{btsvsothers/figures/comp2}
\caption{Combining the BTs above and some additional Actions, we get a flexible BT for entering a building and performing some task.}
\label{btsvsothers:comb2}
\end{center}
\end{figure}


A few observations can be made from the above examples.
First, it is perfectly possible to design FSMs with a structure taken from BTs.
Second, considering that a BT with 2 levels corresponds to the FSM in Figure~\ref{btsvsothers:FSMcombo}, a BT with 5 levels, such as the one in Figure~\ref{btsvsothers:comb2} would correspond to a somewhat complex FSM. 

Third, and more importantly, the \emph{modularity} of the BT construct is illustrated 
in  Figures~\ref{btsvsothers:FSMticksource}-\ref{btsvsothers:FSMcombo}. 
Figure~\ref{btsvsothers:FSMcombo} might be complex, but that complexity is encapsulated in a box with a single in-transition and three out-transitions, just as the box in Figure~\ref{btsvsothers:FSMticksource}.

Fourth, as was mentioned in Section~\ref{sec:modularity}, the decision of what to do after a given sub-BT returns is always decided on the parent level of that BT. The sub-BT is ticked, and returns \emph{Success}, \emph{Running} or \emph{Failure} and the parent level decides whether to tick the next child, or return something to its own parent. Thus, the BT ticking and returning of a sub-BT is similar to a \emph{function call} in a piece of source code, just as described in Section~\ref{sec:modularity}. A function call in Java, C++, or Python moves execution to another piece of the source code, but then returns the execution to the line right below the function call. What to do next is decided by the piece of code that made the function call, not the function itself.
As discussed, this is quite different from standard FSMs where the decision of what to do next is decided by the  state being transitioned to, in a way that resembles the Goto statement.

%\newpage

\subsection{Creating a BT that works like a FSM }
\label{btsvsothers:sec:FSMandBTs_part2}

If you have a FSM design and want to convert it to a BT, the most straight forward way is to create a \emph{State Variable} available to all parts of the BT and then
list all the states of the FSM and their corresponding transitions and actions as shown in Figure~\ref{Arch.fig.FSMasBT}.


\begin{figure}[h!]
\centering
\includegraphics[width = 0.7\columnwidth]{FSMasBT} 
   \caption{Example of a straightforward translation of a FSM to a BT using a global \emph{State Variable}.}
    \label{Arch.fig.FSMasBT}
\end{figure}



\section{Subsumption Architecture}
\label{sec:SA}
The Subsumption Architecture~\cite{brooks1986robust} is heavily associated with the behavior-based robotic architecture, which was very popular in the late 1980s and 90s. 
This architecture has been widely influential in autonomous robotics and elsewhere in real-time AI and  has found a number of successful applications~\cite{brooks1990elephants}.
The basic idea of the Subsumpion Architecture is to have several controllers, each one implementing a task, running in parallel. Each controller is allowed to output both its actuation commands and a binary value that signifies if it wants to control the robot or not. The controllers are ordered according to some priority (usually user defined), and the highest priority controller, out of the ones that want to control the robot, is given access to the actuators. Thus, a controller with a higher priority is able to subsume a lower level one. Figure~\ref{Arch.fig.subsump} shows an example of a Subsumption Architecture.





\begin{figure}[h]
\centering
\includegraphics[width = 0.7\columnwidth]{subsumption} 
   \caption{Example of Subsumption Architecture composed by three controllers. The controller \emph{Stop if Overheated} subsumes the controller \emph{Recharge if Needed}, which subsumes the controller \emph{Do Other Tasks}.}
    \label{Arch.fig.subsump}
\end{figure}



\subsection{Advantages and disadvantages}

The Subsumption Architecture has many practical advantages, in particular:

\begin{itemize}
\item Easy development: The Subsumption Architecture is naturally well suited for iterative development and testing.
\item Modularity: The Subsumption Architecture connects limited, task-specific actions.
\item Hierarchy: The controllers are hierarchically ordered, which makes it possible to define high priority behaviors (e.g. safety guarantees) that override others.
%\item Parallel execution: The emphasis on independed execution smooths the integration of the perception, control, and action systems.
\end{itemize}
The main disadvantages of the Subsumption Architecture are:
\begin{itemize}
\item Scalability:  Designing complex action selection through a distributed system of inhibition and suppression can be hard.
\item Maintainability: Due to the lack of structure, the consequences of adding or removing controllers can be hard to estimate. 
%\item Lack of planning modules: There is no well established tool for planning tasks using this architecture.
%\item Lack of mathematical representation: This becomes a real disadvantage when a Subsumption Architecture has to be synthesized by computer programs (e.g. planning or learning algorithm).
\end{itemize}

\subsection{How BTs Generalize the Subsumption Architecture}
There is a straightforward mapping from a Subsumption Architecture design to a BT using a Fallback node.
If each controller in the Subsumption Architecture is turned into a BT Action, returning running if the binary output indicates that it wants to run and Failure the rest of the time, 
a standard Fallback composition will create an equivalent BT.
As an example we see that the structure in Fig.~\ref{Arch.fig.subsump} is represented by the BT in Fig.~\ref{btsvsothers:fig:subsBT_v2}. A more formal argument using a state space representation of BTs will be given in Section \ref{btsvsothers:sec:analogySA}.

%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=6cm]{btsvsothers/figures/subsump}
%\caption{The Subsumption architecture. A higher level behavior can subsume (or suppress) a lower level one. }
%\label{btsvsothers:fig:subsump_v2}
%\end{center}
%\end{figure}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=6cm]{btsvsothers/figures/subsBT}
\caption{A BT version of the subsumption example in Figure  \ref{Arch.fig.subsump}. }
\label{btsvsothers:fig:subsBT_v2}
\end{center}
\end{figure}



%\section{Sequential Behavior Composition}
%The basic idea of the Sequential Behavior Composition~\cite{burridge1999sequential} is to expand the domain of a controller by using several other controllers where the asymptotically stable equilibrium of each controller is either the goal state, or it is inside the region of attraction of the next controller. Since each controller moves the state to its own local goal, the state crosses the domains of the different controllers. This process is repeated until the state reaches the domain of the final controller, which is the one that drives the state to the final goal. Graphically, if we represent the Lyapunov function of each controller as a funnel, the bottom of a funnel must then be inside the funnel of the next controller. Figure~\ref{Arch.fig.funnel} shows this method of combining controllers. 
%\begin{figure}[h]
%\centering
%\includegraphics[width = 0.4\columnwidth]{sequential} 
%   \caption{Example of Sequential Behavior Composition of three controllers where each of them has a Lyapunov function represented as a funnel. Each controller is active if the state is outside the domains of lower controllers (solid lines). The lowest controller stabilizes the system so that it reaches the goal state.}
%    \label{Arch.fig.funnel}
%\end{figure}
%
%
%\subsubsection{Advantages and disadvantages}
%
%The main advantages of a Sequential Behavior Composition are:
%\begin{itemize}
%\item Execution analysis: With the Sequential Behavior Composition it is easy to analyze if the execution of a subtask impedes the execution of another subtask.
%\item Modularity: subtasks can be developed separately as long the local goal of one controller is in the domain of the next one.
%\item Robustness: subtasks can be added to increase the domain of operation.
%\end{itemize}
%The main disadvantages of a Sequential Behavior Composition are:
%
%\begin{itemize}
%\item Maintainability: Adding or removing controllers can be demanding as their region of attraction and goal states are tightly related. 
%\item Reusability: The local goal states depend on the low level controllers, making the code written in a Sequential Behavior Composition unpractical to reuse.
%\item Human readability: It is hard to visualize a Sequential Behavior Composition in a arbitrary N-dimensional state space.
%\end{itemize}






\section{Teleo-Reactive programs}
\label{sec:TR}
\label{architectures.tr}
Teleo-Reactive\label{definition:TR} (TR) programs were introduced by Nils Nilsson~\cite{nilsson1994teleo} at Stanford University in 1994 to allow engineers to define the behavior of a robotics system that had to achieve specific goals while being responsive to changes in the environment. A TR program is composed of a set of prioritized condition-action rules that directs the agent towards a goal state (hence the term \emph{teleo}) while monitoring the environmental changes (hence the term \emph{reactive}). In its simplest form, a TR program is described by a list of condition-action rules as the following:
\begin{eqnarray*}
c_1 &\rightarrow& a_1 \\
 c_2  &\rightarrow& a_2 \\
 &\cdots \\
  c_m  &\rightarrow& a_m
\end{eqnarray*}
where the $c_i$ are conditions and $a_i$ are actions. The condition-action rules list is scanned from the top until it finds a condition that holds, then the corresponding action is executed. In a TR program, actions are usually \emph{durative} rather than discrete. A durative action is one that continues indefinitely in time, e.g. the Action \emph{move forwards} is a durative action, whereas the action \emph{take one step} is discrete. In a TR program, a durative action is executed as long as its corresponding condition remains the one with the highest priority among the ones that hold. When the highest priority condition that holds changes, the action executed changes accordingly. Thus, the conditions must be evaluated continuously so that the action associated with the current highest priority condition that holds, is always the one
being executed. A running action terminates when its corresponding condition ceases to hold or when another condition with higher priority takes precedence. Figure~\ref{Arch.fig.tr} shows an example of a TR program for navigating in a obstacle free environment.


\begin{figure}[h]
\centering
\begin{eqnarray*}
 \mbox{Equal(pos,goal)} &\rightarrow& \mbox{Idle} \\
 \mbox{Heading Towards (goal)} &\rightarrow& \mbox{Go Forwards} \\
 \mbox{(else)} &\rightarrow& \mbox{Rotate} 
\end{eqnarray*}
   \caption{Example of teleoreactive program carrying out a navigation task. If the robot is in the goal position, the action performed is \emph{Idle} (no actions executed). Otherwise if it is heading towards the goal, the action performed is \emph{Go Forwards}. Otherwise, the robot performs the action \emph{Rotate}.}
    \label{Arch.fig.tr}
\end{figure}
 
TR programs have been extended in several directions, including integrating TR programs with automatic planning and machine learning~\cite{benson1993reacting,vargas2008solving}, removing redundant parts of a TR program~\cite{mousavi2003simplification}, and using TR programs to play
robot soccer~\cite{gubisch2008teleo}.


\subsection{Advantages and disadvantages}
The main advantages of a TR program are:
\begin{itemize}
\item Reactive execution: TR programs enable  reactive executions by continually monitoring the conditions and aborting actions when needed.
\item Intuitive structure: The list of condition-action rules is intuitive to design for small problems.
\end{itemize}
The main disadvantages of a TR program are:
\begin{itemize}
\item Maintainability: Due to its structure (a long list of rules), adding or removing condition-action rules is prone to cause errors when a TR program has to encode a complex system. In those cases, a TR program takes the shape of a long list.
\item Failure handling: To enable failure handling, a TR program needs to have a condition that checks if an action fails.%, making a TR program unnecessarily complicated.
\end{itemize}

\subsection{How BTs Generalize Teleo-Reactive Programs}
\label{sec:BT_generalize_TR}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.8\columnwidth]{btsvsothers/figures/tr2bt}
\caption{The BT that is analogous to a given TR.}
\label{btsvsothers:tr2bt_v2}
\end{center}
\end{figure}


The core idea of continuously checking conditions and applying the corresponding rules can be captured using a Fallback node and pairs of conditions and actions. Thus, a general TR program can be represented in the BT of Fig.~\ref{btsvsothers:tr2bt_v2}.
A more formal argument using a state space representation of BTs will be given in Section~\ref{btsvsothers:sec:analogyTRs}.




\section{Decision Trees}
\label{sec:DT}
A Decision Tree is a directed tree that represents a list of nested if-then clauses used to derive decisions~\cite{sammut20027}. Leaf nodes describe decisions, conclusions, or actions to be carried out, whereas non-leaf nodes describe predicates to be evaluated. Figure~\ref{Arch.fig.dt} shows a Decision Tree where according to some conditions, a robot will decide what to do.




\begin{figure}[h]
\centering
\includegraphics[width = 0.8\columnwidth]{DT} 
   \caption{Example of a Decision Tree executing a generic robotic task. The predicate are evaluated traversing the tree in a top-down fashion.}
    \label{Arch.fig.dt}
\end{figure}


\subsection{Advantages and disadvantages}

The main advantages of a Decision Tree are:
\begin{itemize}
\item Modularity: The Decision Tree structure is modular, in the sense that a subtree can be developed independently from the rest of the Decision Tree, and added where suitable.
\item Hierarchy: Decision Tree's structure is hierarchical, in the sense that predicates are evaluated in a top-down fashion.
\item Intuitive structure: It is straightforward to design and understand Decision Trees.
\end{itemize}
The main disadvantages of a Decision Tree are:
\begin{itemize}
\item No information flow out from the nodes, making failure handling very difficult
%\item Repetitions: To describe a reactive behavior, a given predicate must be reevaluated at different depths of the tree resulting in a Decision Tree with many repetitions. 
%\item Maintainability:  Due to repetitions, if the number of outgoing arcs from a predicate should change, this will affect the entire tree where such predicates appears.

\end{itemize}

\subsection{How BTs Generalize Decision Trees}
\label{sec:BT_generalize_DT}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\columnwidth]{btsvsothers/figures/decisionTreeEq}
\caption{The basic building blocks of Decision Trees are `If ... then ... else ...' statements (left), and those can be created in BTs as illustrated above (right). }
\label{btsvsothers:fig:decisionTreeEq_v2}
\end{center}
\end{figure}


%\begin{figure}[htbp]
%\begin{center}
%\includegraphics[width=6cm]{btsvsothers/figures/decisionTreeEx}
%\caption{The Decision Tree of a robot control system. The decisions are interior nodes, and the actions are leaves. }
%\label{btsvsothers:fig:decisionTreeEx_v2}
%\end{center}
%\end{figure}




\begin{figure}[htbp]
\begin{center}
\includegraphics[width=0.6\columnwidth]{btsvsothers/figures/decisionTreeBTeq}
\caption{A BT that is equivalent to the Decision Tree in Figure  \ref{Arch.fig.dt}. 
}
\label{btsvsothers:fig:decisionTreeBTeq_v2}
\end{center}
\end{figure}

A general Decision Tree can be converted into a BT using the mapping shown in Fig.~\ref{btsvsothers:fig:decisionTreeEq_v2}. By converting the predicate to a condition, letting the leaves be Action nodes always returning Running, we can map each decision node of the Decision Tree to a small BT. Applying the mapping to the Decision Tree of Fig.~\ref{Arch.fig.dt} we get the BT of Fig.~\ref{btsvsothers:fig:decisionTreeBTeq_v2}.
A more formal argument using a state space representation of BTs will be given in Section \ref{btsvsothers:sec:analogyDTs}.
Note that this structure requires actions always returning Running, reflecting the drawback of Decision Trees that no information flows out of the actions.


\section{Advantages and Disadvantages of Behavior Trees}
\label{btasca.sec.properties} 
Having looked at how BTs relate to a set of existing control architectures we will now take a step back and list a number of advantages and disadvantages 
of BTs. 


\subsection{Advantages}

As described in Section~\ref{sec:modularity} many advantages stem from BTs being both modular and reactive.
Below we list a set of advantages of BTs.
% that are desirable for a control architecture in general, and discuss the corresponding aspects of BTs.


%In real robot applications, it is often advantageous to choose a Control Architecture that allows hierarchically organized deliberation as well as continual planning and deliberation~\cite{nau2015blended}. On a more practical side, it is preferable if the Control Architecture allows code reusability, modular design, heterogeneity of code developers' expertise, and (possibly) human readability~\cite{ferrati2016walk,Kortenkamp2016}. Moreover a Control Architecture for robots should be sufficiently expressive~\cite{arkin1998behavior}; suitable for automatic synthesis (planning and learning); and suitable for analysis.
%In detail, a list of design principles include:

\begin{description}
\item[Modular:] 
By modular, we mean the degree to which a system's components may be separated into building blocks, and recombined \cite{gershenson2003product}. 
A modular system can be designed, implemented, tested and reused one module at a time.
The benefits of modularity thus increases, the more complex a system is, by 
enabling a divide and conquer approach when designing, implementing and testing.

BTs are modular, since each subtree of a BT can be seen as a module in the above sense, with a standard interface given by the return statuses. 
Thus,  BTs are modular on all scales ranging from the topmost subtrees to all the leaves of the tree.

%Modular design is an approach that subdivides a system into smaller parts or modules, that can be independently created and then used in different systems. A modular system can be characterized by functional partitioning into discrete and scalable modules. A modular design is loosely connected with code reusability and it can allow an heterogeneity  of code developers' expertise.


\item[Hierarchical organization:] 
%An autonomous robot needs to plan and execute its tasks hierarchically. Some tasks may need to perform some other operations (e.g. data gathering, online planning, etc.) in a specified hierarchy.
If a control architecture contains several levels of decision making it is hierarchical.
The possibility of designing and analyzing structures on different hierarchical levels
 is important for both humans and computers, as it enables e.g., iterative refinement and extensions of a plan, see Section~\ref{design:sec:back_chaining}. BTs are hierarchical, since each level of a BT automatically defines a  level in the hierarchy.

 \item[Reusable code:] 
Having reusable code is very important in any large, complex, long-term project. The ability to reuse designs relies  on the ability to build larger things from smaller parts, and on the independence of the input and output of those parts from their use in the project. 
 To enable reuse of code, each module must interface the  control architecture  in a clear and well-defined fashion.

BTs enable  reusable code, since given the proper implementation, any subtree can be reused in multiple places of a BT.
Furthermore, when writing the code of a leaf node, the developer needs to just take care of returning the correct return status which is universally predefined as either \emph{Running}, \emph{Success}, or \emph{Failure}. Unlike FSMs and HFSMs, where the outgoing transitions require  knowledge about the next state, in BTs leaf nodes are developed disregarding which node is going to be executed next. Hence, the BT logic is independent from the leaf node executions and viceversa. 


\item[Reactivity:] By reactive we mean the ability to quickly and efficiently react to changes.
 For unstructured environments, where outcomes of actions are not certain and the state of the world is constantly changed by external actors,
 plans that were created offline and then executed in an open loop fashion are often likely to fail.

BTs are reactive, since
the continual generation of ticks and their tree traversal result in a closed loop execution. Actions are executed and aborted according to the ticks' traversal, which depends on the leaf nodes' return statuses. Leaf nodes are tightly connected with the environment (e.g. condition nodes evaluate the overall system properties and Action nodes return  \emph{Failure}/\emph{Success} if the action failed/succeeded). 
Thus, BTs are highly responsive to changes in the environment.



\item[Human readable:] A readable structure is desirable for reducing the cost of development and debugging, especially when the task is human designed. The structure should remain readable even for large systems. Human readability requires a coherent and compact structure.

BTs are human readable due to their tree structure and modularity.

\item[Expressive:] A control architecture must be sufficiently expressive to encode a large variety of behaviors.

BTs are at least as expressive as FSMs, see Section~\ref{sec:FSM}, the Subsumption Architecture, see Section~\ref{sec:SA}, Teleo-Reactive programs, see Section~\ref{sec:TR}, and Decision Trees, see Section~\ref{sec:DT}.


\item[Suitable for analysis:] Safety critical robot applications often require an analysis of qualitative and quantitative system properties. These properties include: safety, in the sense of avoiding irreversible undesired behaviors;  robustness, in the sense of a large domain of operation; efficiency, in the sense of time to completion; reliability, in the sense of success probability; and composability, in the sense of analyzing whether properties are preserved over compositions of subtasks. 

BTs have tools available to evaluate such system properties, see Chapters \ref{ch:properties} and \ref{ch:stochastic}.

\item[Suitable for automatic synthesis:] In some problem instances, it is preferable that the action ordering of a task, or a policy, is automatically synthesized using task-planning or machine learning techniques. The  control architecture  can influence the efficiency of such synthesis techniques (e.g. a FSM with a large number of transitions can drastically deteriorate the speed of an algorithm that has to consider all the possible paths in the FSMs).

BTs are suitable for automatic synthesis in terms of both planning, see Section~\ref{design:sec:back_chaining} and in more detail Chapter~\ref{ch:planning} and learning, see Chapter~\ref{ch:learning}.

\end{description}






To  illustrate the advantages listed above, we consider the following simple example. %\todo{for comparison we should have a BT of this example}

\begin{example}
\label{Introduction.ex.motivating}
A robot is tasked to find a ball, pick it up, and place it into a bin. If the robot fails to complete the task, it should go to a safe position and wait for a human operator. After picking up the ball (Figure~\ref{IN.fig.FSMEx1}), the robot moves towards the bin (Figure~\ref{IN.fig.FSMEx2}). While moving towards the bin, an external entity takes the ball from the robot's gripper (Figure~\ref{IN.fig.FSMEx3}) and immediately throws it in front of the robot, where it can be seen (Figure~\ref{IN.fig.FSMEx4}). The robot aborts the execution of moving and it starts to approach the ball again.  
\end{example}





\begin{figure}[h!]
    \centering
    \begin{subfigure}[t]{0.45\columnwidth}
        \centering
\includegraphics[width = \columnwidth, trim={18cm 1cm 8cm 14cm},clip]{introExample2} % trim={<left> <lower> <right> <upper>}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{The robot is picking up the ball.}
       \label{IN.fig.FSMEx1}
    \end{subfigure}
    ~  \begin{subfigure}[t]{0.45\columnwidth}
        \centering
\includegraphics[width = \columnwidth, trim={18cm 1cm 8cm 14cm},clip]{introExample3} % trim={<left> <lower> <right> <upper>}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{The robot moves toward the bin (far away from the robot) with the ball in the hand.}
       \label{IN.fig.FSMEx2}
    \end{subfigure}
    
    
        \begin{subfigure}[b]{0.45\columnwidth}
        \centering
\includegraphics[width = \columnwidth, trim={19cm 2cm 7cm 13cm},clip]{introExample4} % trim={<left> <lower> <right> <upper>}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{An external entity (a human) takes the ball from the robot gripper.}
       \label{IN.fig.FSMEx3}
    \end{subfigure}
    ~  \begin{subfigure}[b]{0.45\columnwidth}
        \centering
\includegraphics[width = \columnwidth, trim={18cm 1cm 8cm 14cm},clip]{introExample5} % trim={<left> <lower> <right> <upper>}
        %\caption{The nominal plan is: \emph{MoveTo(S)$\to$Push(S)$\to$MoveTo(C)} 
        %\emph{$\to$Pick(C)$\to$MoveTo(G)$\to$Drop()}. The sphere moves  away from the goal before the robot is able to push it. The execution of \emph{ MoveTo(S)} and \emph{Push(S)} is no longer required.}
   \caption{The robot approaches the ball in the new location.}
       \label{IN.fig.FSMEx4}
    \end{subfigure}
    \caption{Execution stages of Example~\ref{Introduction.ex.motivating}.}
    \label{IN.fig.FSMEx}
\end{figure}

%Research on Automated Planning (AP) has led to numerous impressive results to automate complex tasks that cannot be easily conveived by a human operator. However, as stressed in~\cite{nau2015blended}, the AP research community has focused mostly in offline planning. Unfortunately this type of AP is rarely useful in practice. The solutions provided are usually not scalable to the size of real problems and their applications cn mostrly be found in proof-of-concepts examples. Is it naive to hope that higher computational power will make such solutions scalable, as more and more complex applications will be found. The authors of~\cite{nau2015blended} advocates for a unified hierarchical representation of tasks and actions that can be used for both planning and acting. In particular they advocate for:
%
%\begin{itemize}
%\item \say{Hierarchically organized deliberation. This principle goes beyond existing hierarchical planning techniques; its requirements and scope are significantly different. The actor performs its deliberation online}
%
%\item \say{Continual planning and deliberation. The actor monitors, refines, extends, updates, changes and repairs its plans throughout the acting process, using both descriptive and operational models of actions.}
%\end{itemize}
%Similarly, the recent book \emph{Automated Planning and Acting} \cite{ghallab2016automated} describes the need for an autonomous system that can \say{react to events and extends, updates, and repairs its plan on the basis of its perception.} 
\begin{landscape}
 \begin{figure}
\includegraphics[width = \columnwidth]{FSMreactive} 
   \caption{FSM modeling the robot's behavior in Example~\ref{Introduction.ex.motivating}. The initial state has a thicker border.}
    \label{Introduction.fig.FSMreactive}
 \end{figure}
\end{landscape}
In this example, the robot does not simply execute a pick-and-place task. It \emph{continually} monitors the progress of the actions, stops whenever needed, skips planned actions, decides the actions to execute, and responds to exogenous events. In order to execute some actions, the robot might need to inject new actions into the plan (e.g. the robot might need to empty the bin before placing the ball). Hence the task requires a  control architecture  suitable for extensions. These extensions might be human made (e.g. the robot asks the operator to update the current action policy) requiring an architecture to be \emph{human readable}, or automated (e.g. using model-based reasoning) requiring an architecture to be \emph{suitable for automatic synthesis}. In either case, to be able to easily extend and modify the action policy, its representation must be \emph{modular}. In addition, new actions may subsume existing ones whenever needed (e.g. \emph{empty the bin if it is full} must be executed before \emph{place the ball)}. This requires a \emph{hierarchical} representation of the policy. Moreover there might be multiple different ways of carrying out a task (e.g. picking the ball using the left hand or the right hand). The robot must be able to decide which option is the best, requiring the architecture to be \emph{suitable for analysis}. Finally, once the policy is designed, it is desirable that it can be \emph{reused} in other contexts.  %and be \emph{expressive}.


Most  control architectures lack one or more of   the properties described above. Take as an example a FSM modeling the behavior of the robot in Example~\ref{Introduction.ex.motivating}, depicted in Figure~\ref{Introduction.fig.FSMreactive}. As can be seen, even for this simple example the FSM gets fairly complex with many transitions. 


%
%\subsection{Properties of Other Control Architectures}
%
%As mentioned in Section~\ref{btasca.sec.properties}, we may consider a set of different design principles when choosing a Control Architecture. 
%Below we discuss each design principle for each Control Architecture reviewed in this chapter. Table~\ref{Architectures.tab.summary} summarizes the discussion.
%
%\begin{table}[t!]
%\centering
%\begin{tabular}{|m{6em}|l|c|c|c|c|c|c|}
%\cline{2-7}\multicolumn{1}{c |}{} & FSM & HFSM & Sub. Arc & Seq Com. & TR prog  & DTs\\ \hline
% Hierarchial organization & \emph{hard} & \emph{easy} & \emph{easy} & \emph{hard} & \emph{hard} & \emph{easy} \\[2ex] \hline
% Closed-loop execution &  \emph{hard} & \emph{hard} & \emph{easy} & \emph{hard} & \emph{easy} & \emph{hard} \\[2ex] \hline
%  \parbox{1cm}{Reusable \\  code\vspace*{0.5em}} &  \emph{hard} & \emph{hard} & \emph{easy} & \emph{hard} & \emph{easy} & \emph{hard} \\[2ex] \hline
%    \parbox{1cm}{Modular \\  design\vspace{0.3em}}  &  \emph{hard} & \emph{easy} & \emph{hard} & \emph{hard} & \emph{hard} & \emph{easy} \\[2ex] \hline
%  \parbox{1cm}{Human \\  readable\vspace{0.5em}} & \emph{hard} & \emph{hard} & \emph{hard} & \emph{hard} & \emph{hard} & \emph{easy} \\[2ex] \hline
%  \parbox{1cm}{Sufficiently \\expressive } & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} \\[2ex] \hline
%  \parbox{1cm}{Suitable for \\analysis} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} \\[2ex] \hline
%  \parbox{1cm}{Suitable for \\synthesis} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} & \emph{easy} \\[2ex] \hline
%\cline{1-7}
%\end{tabular}
%\caption{Comparison of Control Architectures.}
%\label{Architectures.tab.summary}
%\end {table}
%




%This issue usually rise in late stages of robot's development when is generally too late for taking remedial actions. In real robot applications we must choose a Control Architecture that allows~\cite{nau2015blended}: hierarchically organized deliberation, and continual planning and deliberation. On a more practical side, a Control Architecture must allow~\cite{ferrati2016walk,Kortenkamp2016}: code reusability, modular design, heterogeneity of expertise of code developers, and (possibly) human readability. We will now analyze in details those design principles.

%\begin{description}
%
%\item[Hierarchical organization:] The Subsumption Architecture allows a hierarchical heterogeneous composition of different tasks. HFSMs and DTs show the most primitive hierarchical organization which has to be user defined and is difficult to modify. The other Control Architectures reviewed here do not have this property. 
%
%
%\item[Continual closed-loop execution:] TR programs were conceived precisely for this purpose. In a FSM, the monitoring will have to be done in the current Running state (or superstate in a HFSM),  increasing the complexity. In the Subsumption Architecture, each controller keeps reading the sensory input in a closed-loop fashion. The other Control Architectures reviewed here do not show this property. 
%
%
%\item[Reusable code:] In a Subsumption Architecture, the input and output commands of each controller are independent from the overall task. This makes the implementation of each controller reusable for different designs. A similar argument applies to TR programs, where the implementation of each condition-action predicate is independent from the program itself. The other Control Architectures reviewed here do not have this property. 
%
%
%
%\item[Modular design:] HFSMs have a quite primitive modular design. In a HFSM, the execution inside each super state can be independently designed with the hard constraint that implementation must be compliant with the outgoing and incoming generalized transitions. DTs allow a modular design due to their tree structure. The other Control Architectures reviewed here do not have this property. 
%
%\item[Human readable:] DTs, due to their tree structure, remain readable independently from their size.  The other Control Architectures discussed do not have this property unless in fairly small systems. 
%
%\item[Sufficiently expressive: ] To a certain degree, all the Control Architectures above are sufficiently expressive to encode a large variety of tasks.
%\item[Suitable for analysis: ] The Sequential Behavior Composition was conceived for analysis purposes. Analytical tools are available for all the Control Architectures above. Some tools are more used than others. 
%\item[Suitable for automatic synthesis: ] Many planning and learning techniques can be found in the state of the art, some more popular than others.
%
%\end{description}



\subsection{Disadvantages}
In this section we describe some disadvantages of BTs. 

\begin{description}
\item [The BT engine can be complex to implement.] The implementation of the BT engine can get complicated using single threaded sequential programming. To guarantee the full functionality of BTs, the tick's generation and traversal should be executed in parallel with the action execution. However the
BT engine only needs to be implemented once, it can be reused, and several BT engines are available as off the shelf software libraries.\footnote{C++ library: \url{https://github.com/miccol/Behavior-Tree} \\ ROS library: \url{http://wiki.ros.org/behavior_tree} \\ 
python library: \url{https://github.com/futureneer/beetree}}
\item [Checking all the conditions can be expensive.] A BT needs to check several conditions to implement the closed-loop task execution. In some applications this checking is expensive or even infeasible. In those cases a closed-loop execution (using any architecture) presents more costs than advantages. However, it is still possible to design an open-loop task execution using BTs with memory nodes, see Section~\ref{bt:sec:mem}. 
\item [Sometimes a feed-forward execution is just fine.] In  applications where the robot operates in a very structured environment, predictable in space and time, BTs do not have any advantages over simpler architectures.
\item [BTs are different from FSMs.] BTs, despite being easy to understand, require a new mindset when designing a solution. The execution of BTs is not focused on states but on conditions and the switching is not event driven but tick driven. 
The ideas presented in this book, and in particular the design principles of Chapter~\ref{ch:design_principles}, are intended to support the design of efficient BTs.
%At least some of the design principles described in Chapter~\ref{ch:design_principles} needs to be learned and applied.
\item [BT tools are less mature.] Although there is software for developing BTs, it is still far behind the amount and maturity of the software available for e.g. FSMs.
\end{description}
