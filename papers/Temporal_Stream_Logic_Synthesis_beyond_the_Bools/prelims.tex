We assume time to be discrete and denote it by the set $ \dtime $ of
positive integers.  A value is an arbitrary object of arbitrary
type. $ \values $ denotes the set of all values.  The Boolean values
are denoted by $ \bool \subseteq \values $.  A
stream~$ \signal \from \dtime \to \values $ is a function fixing
values at each point in time.
An $ n $-ary function~$ f \from \values^{n} \to \values $ determines
new values from $ n $ given values, where the set of all functions (of
arbitrary arity) is given by~$ \functions $. Constants are functions
of arity 0. Every constant is a value, i.e., is an element of
$ \functions \cap \values $. An $ n $-ary
predicate~$ p \from \values^{n} \to \bool $ checks a property
over~$ n $ values.  The set of all predicates (of arbitrary arity) is
given by~$ \predicates $, where $ \predicates \subseteq \functions $.
We use $ \fspace{\hspace{-1pt}A}{B} $ to denote the set of all total functions with
domain~$ A $ and image~$ B $.

In the classical synthesis setting, inputs and outputs are vectors of
Booleans, where the standard abstraction treats inputs and outputs as
atomic propositions $ \mathcal{I} \cup \mathcal{O} $, while their
Boolean combinations form an
alphabet~\mbox{$ \Sigma = 2^{\mathcal{I} \cup \mathcal{O}}
  $}. Behavior then is described through infinite sequences
$ \alpha = \alpha(0)\alpha(1)\alpha(2) \ldots \in \Sigma^{\omega} $.
A \textit{specification} describes a relation between input
sequences~\mbox{$ \alpha \in (2^{\mathcal{I}})^{\omega} $} and output
sequences~\mbox{$ \beta \in (2^{\mathcal{O}})^{\omega} $}. Usually,
this relation is not given by explicit sequences, but by a fomula in a
temporal logic.  The most popular such logic is Linear Temporal Logic
(LTL)~\cite{Pnueli:1977}, which uses Boolean connectives to specify
behavior at specific points in time, and temporal connectives, to
relate sub-specifications over time. The realizability and synthesis
problems for LTL are 2\textsc{ExpTime}-complete~\cite{PnueliR89}.

An implementation describes a realizing strategy, formalized via infinite trees. A $ \Phi $-labeled
and \mbox{$ \Upsilon $-}branching tree is a
function~$ \sigma \from \Upsilon^{*} \to \Phi $, where $ \Upsilon $
denotes the set of branching directions along a tree. Every node of
the tree is given by a finite prefix $ v \in \Upsilon^{*} $, which
fixes the path to reach a node from the root. Every node is labeled
by an element of $ \Phi $. For infinite
paths~$ \nu \in \Upsilon^{\omega} $, the
branch~$ \branch{\sigma}{\nu} $ denotes the sequence of labels that appear
on $ \nu $, i.e.,
$ \forall t \in \nats. \ (\branch{\sigma}{\nu})(t) =
\sigma(\nu(0) \ldots \nu(t-1)) $.
