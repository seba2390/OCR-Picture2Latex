In order to synthesize programs from TSL specifications, we give an overview of the first part of our synthesis process, as shown in \cref{fig:system}.
First we show how to approximate the semantics of TSL through a reduction to LTL.
However, due to the approximation, finding a realizable strategy immediately may fail.
Our solution is a CEGAR loop that improves the approximation.
This CEGAR loop is necessary, because the realizability problem of TSL is undecidable in general.

\medskip

\noindent \textit{Approximating TSL with LTL} We approximate TSL
formulas with weaker LTL formulas.  The approximation reinterprets the
syntactic elements, $\pterms$ and $\uterms$, as atomic propositions
for LTL. This strips away the semantic meaning of the function
application and assignment in TSL, which we reconstruct by later
adding assumptions lazily to the LTL formula.

Formally, let $ \pterms $ and $ \uterms $ be the finite sets of
predicate terms and updates, which appear in
$ \varphi_{\textit{TSL}} $, respectively. For every assigned signal, we
partition $ \uterms $ into
$ \biguplus_{\name{s}_{\name{o}} \in \onames \cup \cells}
\uterms^{\hspace{0.5pt}\name{s}_{\name{o}}} $. For every
$ \name{c} \in \cells $ let \mbox{$\utermsp^{\hspace{0.5pt}\name{c}} =
  \uterms^{\hspace{0.5pt}\name{c}} \cup \set{ \upd{\name{c}}{\name{c}}
  } $}, for $ \name{o} \in \onames $ let
$ \utermsp^{\hspace{0.5pt}\name{o}} = \uterms^{\hspace{0.5pt}\name{o}}
$, and let
$ \utermsp = \bigcup_{\name{s}_{\name{o}} \in \onames \cup \cells}
\utermsp^{\hspace{0.5pt}\name{s}_{\name{o}}} $.  We construct the LTL
formula~$ \varphi_{\textit{LTL}} $ over the input
propositions~$ \pterms $ and output propositions $ \utermsp $ as
follows:
%
\begin{equation*}
  \varphi_{\textit{LTL}} \, = \;
  \LTLglobally \Big ( \bigwedge_{\name{s}_{\name{o}} \in \onames \cup \cells} \,
  \bigvee_{\term \in \utermsp^{\hspace{0.5pt}\name{s}_{\name{o}}}}
  \big( \term \; \wedge \bigwedge_{\term' \in
    \utermsp^{\hspace{0.5pt}\name{s}_{\name{o}}} \setminus
    \set{ \term }} \neg \, \term' \big)  \Big) \ \wedge \
  \textsc{SyntacticConversion}\big(\varphi_{\textit{TSL}}\big)
\end{equation*}
%
Intuitively, the first part of the equation partially reconstructs the semantic meaning of updates by ensuring that a signal is not updated with multiple values at a time.
The second part extracts the reactive constraints of the TSL formula without the semantic meaning of functions and updates.
%
\begin{theorem}
  \label{thm:tsl2ltl} If $ \varphi_{\textit{LTL}} $ is realizable, then $ \varphi_{\textit{TSL}} $ is realizable.
\end{theorem}
%
\noindent The proof of \cref{thm:tsl2ltl} is given in \cref{proof:tsl2ltl}.
Note that unrealizability of $\varphi_{\textit{LTL}} $ does not imply that $ \varphi_{\textit{TSL}}$ is unrealizable.
It may be that we have not added sufficiently many environment assumptions to the approximation in order for the system to produce a realizing strategy.

\medskip

\label{ex:asLTL}

\begin{figure*}[t]
    \centering
    \begin{subfigure}[t]{0.28\textwidth}
      \centering
      $ \begin{array}{c}
          \\[-0.5em]
          \LTLglobally \; (\upd{\name{y}}{\name{y}} \, \vee \, \upd{\name{y}}{\name{x}}) \\[0.2em]
          \wedge \ \LTLeventually \, \name{p} \ \name{x} \, \impl \,
          \LTLeventually \, \name{p}\ \name{y} \\[-0.5em]
          \
        \end{array} $
        \caption{TSL specification}
\label{eq:tslSimple}
    \end{subfigure}%
    ~ ~
    \begin{subfigure}[t]{0.30\textwidth}
      \centering
      $ \begin{array}{c}
          \LTLglobally \; \neg ( \name{y\_to\_y} \, \wedge \, \name{x\_to\_y}) \\[0.2em]
          \wedge \ \LTLglobally \; (\name{y\_to\_y} \, \vee \, \name{x\_to\_y}) \\[0.2em]
          \wedge \ \LTLeventually \, \name{p\_x} \, \impl \
          \LTLeventually \, \name{p\_y}
        \end{array} $
\caption{initial approximation}
\label{eq:ltlSimple}
    \end{subfigure}%
    ~\;
    \begin{subfigure}[t]{0.35\textwidth}
      \centering
      \vspace{-1em}
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,initial text=]
    \tikzstyle{every state}=[fill=blue!20,draw,text=white,minimum size=1.5em]
    \node[initial,state] (A)                    {};
    \path (A) edge [loop right] node {$\name{p\_x} \; \wedge \; \neg \, \name{p\_y}$} (A);
  \end{tikzpicture}
  \vspace{1.1em}
\caption{spurious counter-strategy}
\label{eq:tslSimpleSoln}
    \end{subfigure}
    \caption{
      A TSL specification~(a) with input~\name{x} and cell~\name{y} that is realizable. A winning strategy is to save~\name{x} to \name{y} as soon as $ \name{p}(\name{x}) $ is satisfied. However, the initial approximation~(b), that is passed to an LTL synthesis solver, is unrealizable, as proven through the counter-strategy~(c) returned by the LTL solver.}
    \label{fig:approx}
\end{figure*}

\noindent \textit{Example} As an example, we present a simple TSL specification in \cref{eq:tslSimple}.
The specification asserts that the environment provides an input~\name{x} for which the predicate~$ \name{p}~\name{x} $ will be satisfied eventually. The system must guarantee that eventually $ \name{p}~\name{y} $ holds.
According to the semantics of TSL the formula is realizable. The system can take the value of $ \name{x} $ when $ \name{p}~\name{x} $ is true and save it to $ \name{y} $, thus guaranteeing that $ \name{p}~\name{y} $ is satisfied eventually.
This is in contrast to LTL, which has no semantics for pure functions - taking the evaluation of $ \name{p}~\name{y} $ as an environmentally controlled value that does not need to obey the consistency of a pure function.

\medskip

\noindent \textit{Refining the LTL Approximation} It is possible that the LTL solver returns a counter-strategy for the environment although the original TSL specification is realizable.
We call such a counter-strategy \textit{spurious} as it exploits the additional freedom of LTL to violate the purity of predicates as made possible by the underapproximation.
Formally, a counter-strategy is an infinite tree $ \pi \from \comps^{*} \to 2^{\pterms} $, which provides predicate evaluations in response to possible update assignments of function terms~$ \fterm \in \fterms $ to outputs~$ \name{o} \in \onames $.
W.l.o.g.\ we can assume that $ \onames $, $ \fterms $ and $ \pterms $ are finite, as they can always be restricted to the outputs and terms that appear in the formula.
A counter-strategy is spurious, iff there is a branch~$ \branch{\pi}{\comp} $ for some computation~$ \comp \in \comps^{\omega} $, for which the strategy chooses an inconsistent evaluation of two equal predicate terms at different points in time, i.e.,
%
\begin{equation*}
  \begin{array}{l}
    \exists \comp \in \comps^{\omega}. \ \exists t, t' \in \dtime. \ \exists \pterm \in \pterms. \\[0.2em]
    \qquad \pterm \in \pi(\comp(0)\comp(1)\ldots\comp(t-1)) \, \wedge \, \pterm \notin \pi(\comp(0)\comp(1)\ldots\comp(t'-1)) \ \wedge \\[0.2em]
    \qquad \forall \assign{\cdot} \from \fnames \to \functions. \ \eval(\comp, \branch{\pi}{\comp}, t, \pterm) \, = \, \eval(\comp, \branch{\pi}{\comp}, t', \pterm).
  \end{array}
\end{equation*}
%
Note that a non-spurious strategy can be inconsistent along multiple
branches. Due to the definition of realizability
the environment can choose function and
predicate assignments differently against every system strategy
accordingly.

By purity of predicates in TSL the environment is forced to
always return the same value for predicate evaluations on equal
values. However, this semantic property cannot be enforced implicitly
in LTL.  To resolve this issue we use the returned counter-strategy to
identify spurious behavior in order to strengthen the LTL
underapproximation with additional environment assumptions.
After adding the derived assumptions, we re-execute the LTL synthesizer to check whether the
added assumptions are sufficient in order to obtain a winning strategy
for the system.  If the solver still returns a spurious strategy, we
continue the loop in a CEGAR fashion until the set of added
assumptions is sufficiently complete.  However, if a non-spurious strategy is
returned, we have found a proof that the given
TSL specification is indeed unrealizable and terminate.

\goodbreak

\begin{algorithm}[t]
  \small
  \caption{Check-Spuriousness} \label{alg:spurious}
  \begin{algorithmic}[1]
    \Require{bound~$ b $, counter-strategy~$ \pi \from \comps^{*}\!\! \to \! 2^{\pterms} $ (finitely represented using $ m $ states)}

    \vspace{0.3em}

    \ForAll{$ v \in \comps^{m \cdot b},\, \pterm \in \pterms, \, t,t' \in \set{ 0,1,\ldots,m\cdot b - 1} $}
      \If{$ \evalid(v,\iota_{\name{id}},t,\pterm) \equiv \evalid(v,\iota_{\name{id}},t',\pterm) \wedge \mbox{\qquad} \qquad \qquad \qquad \qquad \qquad \qquad \qquad $ $ \mbox{\ }\hspace{2.5em} \pterm \in \pi(v_{0}\ldots v_{t-1}) \wedge \pterm \notin \pi(v_{0}\ldots v_{t'-1}) $}
      \State \quad $ w \gets \texttt{reduce}\,(v,\pterm,t,t') $
      \State \quad {\textbf{return} \ $ \LTLglobally \big(\! \bigwedge_{i=0}^{t-1} \LTLnext^{i}\! w_{i} \, \wedge \, \bigwedge_{i = 0}^{t'-1} \LTLnext^{i}\! w_{i} \,\rightarrow\, (\LTLnext^{t}\! \pterm \leftrightarrow \LTLnext^{t'} \!\! \pterm) \big) $}
      \EndIf
    \EndFor
    \State {\textbf{return} \ \texttt{``non-spurious''}}
  \end{algorithmic}
  \vspace{-0.2em}
\end{algorithm}

\cref{alg:spurious} shows how a returned counter-strategy~$ \pi $ is
checked for being spurious. To this end, it is sufficient to
check~$ \pi $ against system strategies bounded by the given
bound~$ b $, as we use bounded
synthesis~\cite{Schewe:2013}. Furthermore, we can assume w.l.o.g.\
that~$ \pi $ is given by a finite state representation, which is
always possible due to the finite model guarantees of LTL. Also note
that~$ \pi $, as it is returned by the LTL synthesizer, responses to
sequences of sets of updates~$ (2^{\utermsp})^{*} $. However, in our
case $ (2^{\utermsp})^{*} $ is an alternative
representation~of~$ \comps^{*} $, due to the additional constraints
added during the construction~of~$ \varphi_{\textit{LTL}} $.

The algorithm iterates over all possible
responses~$ v \in \comps^{m \cdot b} $ of the system up to depth
$ m \cdot b $. This is sufficient, since any deeper exploration would
result in a state repetition of the cross-product of the finite state
representation of~$ \pi $ and any system strategy bounded by~$ b
$. Hence, the same behaviour could also be generated by a smaller
sequence. At the same time, the algorithm iterates over
predicates~$ \pterm \in \pterms $ appearing in
$ \varphi_{\textit{TSL}} $ and times $ t $ and $ t' $ smaller
than~$ m \cdot b $. For each of these elements, spuriousness is
checked by comparing the output of~$ \pi $ for the evaluation of
$ \pterm $ at times~$ t $ and $ t' $, which should only
differ, if the inputs to the predicates are different as well. This
can only happen, if the passed input terms have been constructed
differently over the past. We check it by using the evaluation
function~$ \eta $ equipped with the identity assignment
$ \assign{\cdot}_{\texttt{id}} \from \fnames \to \fnames $, with
$ \assign{\name{f}}_{\texttt{id}} = \name{f} $ for all
$ \name{f} \in \fnames $, and the input sequence
$ \iota_{\texttt{id}} $, with
$ \iota_{\texttt{id}}(t)(\name{i}) = (t,\name{i}) $ for all
$ t \in \dtime$ and $ \name{i} \in \inames $, that always generates a
fresh input. Syntactic inequality of
$ \evalid(v,\iota_{\name{id}},t,\pterm) $ \linebreak and
$ \evalid(v,\iota_{\name{id}},t',\pterm) $ then is a sufficient
condition for the existence of an assignment
$ \assign{\cdot} \from \fterms \to \functions $, for which $ \pterm $
evaluates differently at times $ t $ and~$ t' $.

If spurious behaviour of~$ \pi $ could be found, then the revealing
response~$ v \in \comps^{*} $ is first simplified using
$ \texttt{reduce} $, which turns $ v $ back to a sequence of sets of
updates~$ w \in (2^{\utermsp})^{*} $ and removes updates that do not
affect the behavior of $ \pterm $ at the times $ t $ and $ t' $ to
accelerate the termination of the CEGAR loop. Afterwards, the
sequence~$ w $ is turned into a new assumption that prohibits the found
spurious behavior and, thus, further refines the LTL
underapproximation.

As an example of this process, reconsider the spurious
counter-strategy of \cref{eq:tslSimpleSoln}. Already after the first
system response~$ \upd{\name{y}}{\name{x}} $, the environment produces
an inconsistency by evaluating~$ \name{p} \ \name{x} $ and
$ \name{p} \ \name{y} $ differently. This is inconsistent, as the
cell~$ \name{y} $ holds the same value at time~$ t = 1 $ as the
input~$ \name{x} $ at time~$ t = 0 $. Using \cref{alg:spurious} we generate
the new
assumption~$ \LTLglobally (\upd{\name{y}}{\name{x}} \impl (\name{p} \
\name{x} \leftrightarrow \LTLnext \name{p} \ \name{y})) $. After adding this
strengthening the LTL synthesizer returns a realizability result.

\medskip

\goodbreak

\noindent \textit{Undecidability}
Although we can approximate the semantics of TSL with LTL, there are
TSL formulas that cannot be expressed as LTL formulas of finite
size.
%
\begin{theorem}\label{thm:decidability}
  The realizability problem of $ \TSL $ is undecidable.
\end{theorem}
%
\begin{proof}
  We reduce an instance of the Post Correspondence
  Problem~(PCP)~\cite{post1946}, consisting of an alphabet~$ \Sigma $
  and sequences
  $ w_{0}w_{1}\ldots w_{n}, v_{0}v_{1}\ldots v_{n} \in \Sigma^{*} $,
  to the realizability of a $ \TSL $ formula~$ \varphi $. To this end,
  we fix some unary predicate~$ \name{p} \in \pnames $, a~unary
  function $ \name{f} \in \fnames $ for every alphabet symbol
  $ f \in \Sigma $, and some $ 0 $-nary
  function~$ \name{X} \in \fnames $. The system has no
  inputs~$ \inames $, but two outputs $ \name{A} \in \onames $ and
  $ \name{B} \in \onames $.

  Initially, we assign the signals $ \name{A} $ and $ \name{B} $ the
  constant value~$ \name{X} $. From then on, we non-deterministically
  pick pairs $ (w_{j},v_{j}) $ in every time step, as provided by the
  PCP instance, where every $ w_{j} $ and $ v_{j} $ is represented as
  a stacked composition of the corresponding alphabet functions. Our
  choice is stored in the signals~$ \name{A} $ and $ \name{B} $ for
  $ w_{j} $ and $ v_{j} $, respectively. Finally, we check that the
  sequences of function applications, constructed over time, are equal
  at some point, using the eventually operator~$ \LTLfinally $ and the
  universally quantified predicate~$ \name{p} $ to check for equality.
\end{proof}
%
\noindent A more detailed version of the proof can be found in
\cref{proof:decidability}. Also note that no inputs are used by
the proof, which additionally shows that the \mbox{``satisfiability''} problem of
\TSL is undecidable as well.
