To evaluate our synthesis procedure we implemented a tool that follows
the structure of \cref{fig:system}.  Our tool first encodes the given
\TSL specification in LTL and then refines it until an LTL solver
either produces a realizability result or returns a counter-strategy
that is non-spurious. For LTL synthesis we use the bounded synthesis
tool BoSy~\cite{bosy}. As soon as we get a realizing strategy, given
as a circuit, it is translated to a corresponding CFM. Then, we
generate the FRP program structure. Finally, after providing function
and predicate implementations the resulting program is compiled into
an executable.

\begin{table}[htbp]
\centering
\caption{Number of cells~$ |\cells_{\cfm}| $ and
  vertices~$ |V_{\cfm}|$ of the resulting CFM~$ \cfm $ and
  synthesis times for a collection of \TSL specifications~$ \varphi
  $. A * indicates that the benchmark additionally has an initial
  condition as part of the specification.}
\label{table:results}
\begin{tabular}{|l||c|c|c|c|c||c|c|c|c|}
\hline
\multicolumn{1}{|c||}{\multirow{2}{*}{\textsc{Benchmark} $ (\varphi) $}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\ \,$| \varphi |$\ \,}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\ \,$| \inames |$\ \,}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\ \,$| \onames |$\ \,}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\ \,$| \pnames |$\ \,}}
  & \multicolumn{1}{c||}{\multirow{2}{*}{\ \,$| \fnames |$\ \,}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\ $| \cells_{\cfm} |$\ }}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\ $| V_{\cfm} |$\ }}
  & \multicolumn{1}{c|}{\raisebox{-2pt}{\ \textsc{Synthesis}\ }}
  \\
&&&&&&&&\raisebox{0pt}{\textsc{Time (s)}}\\
\hline \hline
\textbf{Button} &&&&&&&& \\
\ \ \ default & 7 & 1 & 2 & 1 &  3 & 3 & 8 & 0.364 \\
\hline
\textbf{Music App} &&&&&&&& \\
\ \ \ simple & 91 & 3 & 1 & 4 & 7 & 2 & 25 & 0.77 \\ % music
\ \ \ system feedback & 103 & 3 & 1 & 5 & 8 & 2 & 31 & 0.572 \\ % music2
\ \ \ motivating example \mbox{\quad\ \,} & 87 & 3 & 1 & 5 & 8 & 2 & 70 & 1.783 \\ % music3
\hline
\textbf{FRPZoo} &&&&&&&& \\
\ \ \ scenario\hspace{0.5pt}$_{0} $ & 54 & 1 & 3 & 2 & 8 & 4 & 36 & 1.876 \\ % zoo0
\ \ \ scenario\hspace{0.5pt}$_{5} $ & 50 & 1 & 3 & 2 & 7 & 4 & 32 & 1.196 \\ % zoo5
\ \ \ scenario\hspace{0.5pt}$_{10} $ & 48 & 1 & 3 & 2 & 7 & 4 & 32 & 1.161 \\ % zoo10
\hline
\textbf{Escalator} &&&&&&&& \\
\ \ \ non-reactive & 8 & 0 & 1 & 0 & 1 & 2 & 4 & 0.370 \\ % escalator0
\ \ \ non-counting & 15 & 2 & 1 & 2 & 4 & 2 & 19 & 0.304 \\ % escalator1
\ \ \ counting & 34 & 2 & 2 & 3 & 7 & 3 & 23 & 0.527 \\ % escalator2
\ \ \ counting* & 43 & 2 & 2 & 3 & 8 & 4 & 43 & 0.621 \\ % escalator2init
\ \ \ bidirectional & 111 & 2 & 2 & 5 & 10 & 3 & 214 & 4.555 \\ % escalator3
\ \ \ bidirectional* &\,124\,& 2 & 2 & 5 & 11 & 4 & 287 & 16.213 \\ % escalator3init
\ \ \ smart & 45 & 2 & 1 & 2 & 4 & 4 & 159 & 24.016 \\ % escalator4
\hline
\textbf{Slider} &&&&&&&& \\
\ \ \ default & 50 & 1 &  1 & 2 & 4 & 2 & 15 & 0.664 \\ % slider0
\ \ \ scored & 67 & 1 & 3 & 4 & 8 & 4 & 62 & 3.965 \\ % slider1
\ \ \ delayed & 71 & 1 & 3 & 4 & 8 & 5 & 159 & 7.194 \\ % slider2
\hline
  \textbf{Haskell-TORCS}  &&&&&&&& \\
\ \ \ simple & 40 & 5 & 3 & 2 & 16 & 4 & 37 & 0.680 \\
\ \ \ \textbf{advanced} &&&&&&&& \\[-0.2em]
\ \ \ \ \ \ gearing & 23 & 4 & 1 & 1 & 3 & 2 & 7 & 0.403 \\
\ \ \ \ \ \ accelerating & 15 & 2 & 2 & 2 & 6 & 3 & 11 & 0.391 \\
\ \ \ \ \ \ \textbf{steering} &&&&&&&& \\[-0.2em]
\ \ \ \ \ \ \ \ \ simple & 45 & 2 & 1 & 4 & 6 & 2 & 31 & 0.459 \\
\ \ \ \ \ \ \ \ \ improved & 100 & 2 & 2 & 4 & 10 & 3 & 26 & 1.347 \\
\ \ \ \ \ \ \ \ \ smart & 76 & 3 & 2 & 4 & 8 & 5 & 227 & 3.375 \\
\hline
\end{tabular}
\end{table}

\begin{table}[htbp]
\centering
\caption{Set of programs that use purity to keep one or two counters
  in range. Synthesis needs multiple refinements of the specification
  to proof realizability.}
\label{table:results2}
\begin{tabular}{|l||c|c|c|c|c||c|c|c|c|}
\hline
  \multicolumn{1}{|c||}{\multirow{2}{*}{\ \textsc{Benchmark} $ (\varphi) $\ }}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\;$| \varphi |$\;}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\;$| \inames |$\;}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\;$| \onames |$\;}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\;$| \pnames |$\;}}
  & \multicolumn{1}{c||}{\multirow{2}{*}{\;$| \fnames |$\;}}

  & \multicolumn{1}{c|}{\multirow{2}{*}{\,$| \cells_{\cfm} |$\,}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\,$| V_{\cfm} |$\,}}
  & \multicolumn{1}{c|}{\multirow{2}{*}{\textsc{Refinements}}}
  & \multicolumn{1}{c|}{\raisebox{-2pt}{\;\textsc{Synthesis}\;}}
  \\
&&&&&&&&&\raisebox{0pt}{\textsc{Time (s)}}\\
\hline \hline
\ inrange-single  & 23 & 2  & 1 & 2 & 4 & 2 & 21 & 3 & 0.690 \\ %
\ inrange-two  & 51 & 3 &  3 & 4 & 7 & 4 & 440 & 6 & 173.132 \\ %
\ graphical-single  & 55 & 2 & 3 & 2 & 6 & 4 & 343 & 9 & 1767.948 \\ %
\ graphical-two  & 113 & 3 &  5 & 4 & 9 & -  & - & - & >\,10000 \\ %
\hline
\end{tabular}
\end{table}


To demonstrate the effectiveness of synthesizing \TSL, we applied our
tool to a collection of benchmarks from different application domains,
listed in \cref{table:results}.  Every benchmark class consists of
multiple specifications, addressing different features of \TSL.  We
created all specifications from scratch, where we took care that they
either relate to existing textual specifications, or real world
scenarios. A short description of each benchmark class is given in
\cref{apx:benchmarks}.

For every benchmark, we report the synthesis time and the size of the
synthesized CFM, split into the number of cells
($ | \cells_{\cfm} | $) and vertices ($ | V_{\cfm} | $) used.
The synthesized CFM may use more cells than the original TSL
specification if synthesis requires more memory in order to realize a
correct control flow.
%
The synthesis was executed on a quad-core Intel Xeon processor
(E3-1271 v3, 3.6GHz, 32 GB RAM, PC1600, ECC), running
Ubuntu 64bit LTS 16.04.

The experiments of \cref{table:results} show that TSL successfully lifts the applicability of
synthesis from the Boolean data domain to arbitrary data domains,
which allows for new applications that can utilize every level of
required abstraction. For the benchmarks, we could always find a
realizable system within a reasonable amount of time, where the
solutions found often required synthesized cells to realize
the underlying control flow behavior.

We also considered a preliminary set of benchmarks that require
multiple refinement steps to be synthesizable. An overview of the
results is given in \mbox{\cref{table:results2}}. The benchmarks are inspired
by examples of the Reactive Banana FRP library~\cite{reactivebanana}.
Here, purity of function and predicate applications must be utilized
by the system to ensure that the value of one or two counters never
goes out of range. Thereby, the system not only needs purity to verify
this condition, but also to take the correct decisions in the
resulting implementation to be synthesized.
