Our synthesis framework provides a modular refinement process
to synthesize executables from $ \TSL $ specifications, as depicted
in \cref{fig:system}. The user initially provides a
$ \TSL $ specification over predicate and function terms.  At the end
of the procedure, the user receives an executable to control a
reactive system.

The first step of our method answers the synthesis question of TSL: if
the specification is realizable, then a control flow model is
returned.  To this end, an intermediate translation to LTL is used,
utilizing an LTL synthesis solver that produces circuits in the AIGER
format. If the specification is realizable, the resulting control flow
model is turned into Haskell code, which is implemented as an
independent Haskell module. The user has the choice between two
different targets: a module built on Arrows, which is compatible with
any Arrowized FRP library, or a module built on Applicative, which
supports Applicative FRP \mbox{libraries}. Our procedure generates a single
Haskell module per TSL specification. This makes naturally decomposing
a project according to individual tasks possible. Each module provides
a single component, which is parameterized by their initial state and
the pure function and predicate transformations. As soon as these are
provided as part of the surrounding project context, a final
executable can be generated by compiling the Haskell code.

An important feature of our synthesis approach is that implementations
for the terms used in the specification are only required after
synthesis.  This allows the user to explore several possible
specifications before deciding on any term implementations.

\paragraph{Control Flow Model} The first step of our approach is the
synthesis of a \textit{Control Flow Model}~$ \cfm $ (CFM) from the
given $ \TSL $ specification~$ \varphi $, which provides us with a
uniform representation of the control flow structure of our final
program.

\noindent Formally, a CFM~$ \cfm $ is a tuple
$ \cfm = (\inames, \onames, \cells, \vertices, \labeling,
\dependencies), $ where $ \inames $ is a finite set of inputs,
$ \onames $ is a finite set of outputs, $ \cells $ is a finite set of
cells, $ \vertices $ is a finite set of vertices,
$ \labeling \from \vertices \to \fnames $ assigns a
vertex a function~$ \name{f} \in \fnames $ or a
predicate~$ \name{p} \in \pnames $, and
%
\begin{equation*}
  \dependencies \from (\onames \cup \cells \cup \vertices) \times
  \nats \to (\inames \cup \cells \cup \vertices \cup \set{ \bot })
\end{equation*}
%
is a dependency relation that relates every output, cell, and
vertex of the CFM with $ n \in \nats $ arguments, which are either
inputs, cells, or vertices. Outputs and
cells~$ \name{s} \in \onames \cup \cells $ always have only a single
argument, i.e., $ \delta(s, 0) \not\equiv \bot $ and
\mbox{$ \forall m > 0 .\ \delta(\name{s}, m) \equiv \bot $}, while for
vertices~$ x \in \vertices $ the number of arguments $ n \in \nats $
align with the arity of the assigned function or predicate
$ \labeling(x) $, i.e.,
$ \forall m \in \nats .\ \delta(s, m) \equiv \bot \leftrightarrow m >
n $. A CFM is valid if it does not contain circular dependencies,
i.e., on every cycle induced by $ \delta $ there must lie at least a
single cell. We only consider valid CFMs.

\input{musicFRP}

An example CFM for our music player of \cref{sec:motiv} is depicted in
\cref{fig:cfmexample}. Inputs~$ \inames $ come from the left
and outputs~$ \onames $ leave on the right. The example
contains a single cell~$ \name{c} \in \cells $, which holds the
stateful memory~\name{Cell}, introduced during synthesis for the
module. The green, arrow shaped boxes depict vertices~$ \vertices $,
which are labeled with functions and predicates names, according
to~$ \labeling $. For the Boolean decisions that define $\delta$, we use circuit symbols for
conjunction, disjunction, and negation. Boolean decisions are piped to
a multiplexer gate that selects the respective
update streams. This allows each update stream to be passed to an output stream if and only if the
respective Boolean trigger evaluates positively, while
our construction ensures mutual exclusion on the Boolean triggers. For
code generation, the logic gates are implemented using the corresponding dedicated Boolean functions.
After building a control structure, we assign semantics to functions
and predicates by providing implementations.  To this end, we use
Functional Reactive Programming (FRP).  Prior work has established
Causal Commutative Arrows (CCA) as an FRP language pattern equivalent
of a CFM~\cite{jfp/LiuCH11,liu2007plugging,yallop2016causal}.  CCAs
are an abstraction subsumed by other functional reactive programming
abstractions, such as Monads, Applicative and
Arrows~\cite{jfp/LiuCH11,lindley2011idioms}.
There are many FRP libraries using
Monads~\cite{elm,hudakFRAN,ploeg2015frpnow},
Applicative~\cite{reactivebanana,clash2015,helbling2016juniper,Reflex},
or Arrows~\cite{courtney2003yampa,murphy2016livefrp,perez2016yampa,UISF},
and since every Monad is also an Applicative and Applicative/Arrows both are universal design patterns, we can give uniform
translations to all of these libraries using translations to just Applicative
and Arrows. Both translations are possible due to the flexible notion of a CFM.

In the last step, the synthesized FRP program is compiled into an
executable, using the provided function and predicate
implementations. This step is not fixed to a single
compiler implementation, but in fact can use any FRP compiler (or
library) that supports a language abstraction at least as expressive as CCA.
For example, instead of creating an Android music player app, we could
target an FRP web interface~\cite{Reflex} to create an online music
player, or an embedded FRP library~\cite{helbling2016juniper} that
allows us to directly instantiate the player on a computationally more
restricted device. By using the strong core of CCA, we even can go
down the whole chain and directly implement the player in hardware,
which is for example possible with the C$ \lambda $aSH  compiler~\cite{clash2015}.
Note that we still need to give separate implementations for the functions and
predicates for each target. However, our specification and the
synthesized CFM always stay the same.
