In reactive synthesis, we automatically translate a formal specification, typically
given in a temporal logic, into a controller that is guaranteed to
satisfy the specification. Over the past two decades there has been
much progress on reactive synthesis, both in terms of algorithms,
notably with techniques like GR(1)-synthesis~\cite{bloem2012synthesis} and bounded synthesis~\cite{Schewe:2013},
and in terms of tools, as showcased, for example, in the annual
{\sc syntcomp} competition~\cite{SYNTCOMP2017}.

In practice however, reactive synthesis has seen limited success.
One of the largest published success stories~\cite{Khalimov2014ParameterizedSynthesisCaseStudyAMBA} is the synthesis of
the AMBA bus
protocol. To push synthesis even further, automatically synthesizing a controller for an autonomous system has been recognized to be of critical importance~\cite{wongpiromsarn2013synthesis}.
Despite
many years of experience with synthesis tools, our own attempts to
synthesize such controllers with existing tools have been unsuccessful. The reason is that the tools are unable to
handle the data complexity of the controllers. The controller only
needs to switch between a small number of behaviors, like steering
during a bend, or shifting gears on high rpm. The number of control
states in a typical controller (cf. \cite{SCAV2017}) is thus not much
different from the arbiter in the AMBA case study. However, in order to correctly initiate transitions between \mbox{control states}, the driving
controller must continuously process data from more than 20 sensors.

If this data is included (even as a rough discretization) in the state
space of the controller, then the synthesis problem is much too large
to be handled by any available tools. It seems clear then, that a scalable synthesis approach must separate
control and data. If we assume that the data processing is handled by
some other approach (such as deductive synthesis~\cite{Manna:1980:DAP:357084.357090} or manual programming), is it
then possible to solve the remaining reactive synthesis problem?

In this paper, we show scalable reactive synthesis is indeed possible. Separating
data and control has allowed us to synthesize reactive systems, including an
autonomous driving controller and a music player app, that
had been impossible to synthesize with previously available tools. However, the
separation of data and control implies some fundamental changes to
reactive synthesis, which we describe in the rest of the paper. The
changes also imply that the reactive synthesis problem is no
longer, in general, decidable. We thus trade theoretical
decidability for practical scalability, which is, at least with regard to the goal of synthesizing realistic systems, definitely an attractive trade-off.

We introduce Temporal Stream Logic (\TSL), a new temporal logic that includes
\emph{updates}, such as $\upd{\name{y}}{\name{f}~\name{x}}$, and
predicates over arbitrary function terms. The update $\upd{\name{y}}{\name{f}~\name{x}}$ indicates
that the result of applying function~$ \name{f} $ to variable~$ \name{x} $ is assigned
to $\name{y}$. The implementation of predicates and functions is
not part of the synthesis problem. Instead, we look for a
system that satisfies the \TSL specification \emph{for all
possible interpretations of the functions and predicates}.

This implicit quantification over all possible interpretations provides a useful
abstraction: it allows us to \emph{independently} implement the data
processing part. On the other hand, this quantification is also the
reason for the undecidability of the synthesis problem. If a predicate
is applied to the same term \emph{twice}, it must (independently of the interpretation)
return the \emph{same} truth value. The synthesis must then implicitly
maintain a (potentially infinite) set of terms to which the predicate
has previously been applied. As we show later, this set of terms can
be used to encode PCP~\cite{post1946} for a proof of undecidability.

We present a practical synthesis approach for \TSL specifications, which is based
on bounded synthesis~\cite{Schewe:2013} and counterexample-guided abstraction refinement (CEGAR)~\cite{DBLP:journals/jacm/ClarkeGJLV03}.
We use bounded synthesis to search for an implementation up to a (iteratively growing)
bound on the number of states. This approach underapproximates the actual \TSL synthesis
problem by leaving the interpretation of the predicates to the environment.
The underapproximation allows for inconsistent behaviors: the environment might assign different
truth values to the same predicate when evaluated at different points in time,
even if the predicate is applied to the same term.
However, if we find an implementation in this underapproximation, then the CEGAR loop terminates and we have a correct implementation for the original \TSL specification. If we do not find an implementation in the underapproximation,
we compute a counter strategy for the environment. Because bounded synthesis reduces the synthesis problem to a safety game, the counter strategy is a reachability strategy that can be represented as a finite tree. We check whether the counter strategy is spurious by searching for a pair of positions in the strategy where some predicate results in different truth values when applied to the same term.
If the counter strategy is not spurious, then no implementation exists for the considered bound, and we increase the bound.
If the counter strategy is spurious, then we introduce a constraint
into the specification that eliminates the incorrect interpretation
of the predicate, and continue with the refined specification.

\input{system}

A general overview of this procedure is shown in \cref{fig:system}.
The top half of the figure depicts the bounded search for an
implementation that realizes a TSL specification using the CEGAR loop to
refine the specification. If the specification is realizable, we
proceed in the bottom half of the process, where a synthesized
implementation is converted to a control flow model (CFM) determining
the control of the system. We then specialize the CFM to Functional
Reactive Programming (FRP), which is a popular and expressive
programming paradigm for building reactive programs using functional
programming languages~\cite{hudakFRAN}. Our framework supports any FRP
library using the \textit{Arrow} or \textit{Applicative} design patterns, which covers
most of the existing FRP libraries
(e.g.~\cite{reactivebanana,clash2015,courtney2003yampa,perez2016yampa}).
Finally, the synthesized control flow is embedded into a project
context, where it is equipped with function and predicate
implementations and then compiled to an executable program.

Our experience with synthesizing systems based on \TSL specifications has been extremely positive. The synthesis works
for a broad range of benchmarks, ranging from classic reactive synthesis
problems (like escalator control), through programming exercises
from functional reactive programming, to novel
case studies like our music player app and the autonomous driving
controller for a vehicle in the Open Race Car Simulator (TORCS).
