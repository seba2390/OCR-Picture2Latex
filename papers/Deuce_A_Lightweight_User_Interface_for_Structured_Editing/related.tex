\section{Related Work}
\label{sec:discussion-related}

We describe the most closely related ideas in structured
editing and refactoring.
\citet{Barista}, \citet{DNDRefactoring}, and \citet{HazelnutSNAPL}
provide more thorough introductions.
%% to the rich literature on these topics.


%% \subsection{User Interfaces for Structured Transformations}
\subsection{User Interfaces for Structured Editing}

%% Perhaps the simplest way to expose automated tools for structured
%% transformations is with a toolbar of menus. Several alternative
%% user interface features have been proposed to integrate structured

Compared to traditional text-selection and menus, several alternative user
interface features have been proposed to integrate structured editing more
seamlessly within the text-editing workflow.


\parahead{Text Selection}

%% could add multi-source to DNDR, though it's not clear how widely used
%% textual multi select is. and there's still the difficulty of text
%% selecting large expressions and expressions located far apart.

\citet{Murphy-Hill-ICSE2008} identify that text selection-based refactoring is
prone to error, particularly for statements that span multiple lines and that
have irregular formatting.
They propose two prototype user interface mechanisms, called
Selection Assist and Box View, to help.
With Selection Assist, the user positions the cursor at the start of a statement, and
the entire statement is highlighted green to show what must be
selected (using normal text-selection).
With Box View, the editor draws a separate panel (next to the code editor) that
shows the tree structure of the program with nested boxes. When selecting text
in the editor, the nested boxes are colored according to which code items are
completely selected. Similarly, the user can select a nested box in the Box View
to select the corresponding text in the code.

%% Compared to both of the above, our structural selection polygons are drawn
In contrast, our structural selection polygons are drawn
directly atop the code, at once helping to identify (like Box View) and select (like
Selection Assist), which aims to mitigate the context switching
overhead of Box View identified by \citet{Murphy-Hill-ICSE2008}.

%% our isSubsetRange test can be thought of as a variation of Selection Assist
%% where (a) the user positions a partial text selection inside the statement and
%% (b) the entire statement is selected automatically.
%% 
%% box view (authors identify the context switching overhead)
%% 
%% want an interface that integrates textual and structural
%% representations more seamlessly
%% 
%% this
%% paper also made three recommendations for future tools that help with selection:
%% 
%% \begin{itemize}
%% \item lightweight
%% \item help with unfamiliar or unusual code formatting
%% \item be task specific
%% \end{itemize}
%% 
%% our interface satisfies the first two, but not the third (for now, at least; in
%% the future, would help to have more context-sensitive colors, arrows, etc.)

%% we think a fourth criterion is important
%% 
%% 4. multi-selection
%% 
%% some text editors support this...
%% 
%% Eclipse has block selection, but it's for a single rectangular region, not for
%% multiple spans




%% \parahead{\dndrLong{}}
\parahead{Drag-and-Drop Refactoring}
\label{sec:discussion-related-dndr}

%% Regarding the user interface challenges for invoking refactorings
%% Regarding the user interface challenges for identifying, invoking,
%% and configuring refactorings
%% (\cf{}~\autoref{sec:intro}),
\citet{DNDRefactoring} propose a tool called \dndr{} that eliminates the use
of menus altogether. They demonstrate how many common Eclipse
refactorings can be unambiguously invoked with a drag-and-drop gesture
without the need for any additional configuration.
This is a compelling workflow for situations
in which the user can (a) readily \emph{identify} an intended
refactoring based on a preconceived notion (\eg{} its name), (b)
unambiguously \emph{invoke} the intended refactoring by a single-source,
single-target drag-and-drop gesture, and (c) accept the \emph{default configuration}
of the refactoring.
It would be useful to add drag-and-drop gestures to \deuce{}
for transformations that satisfy these three conditions.
%% apply to a single source item and single target position,
%
However, our user interface supports situations when one or more
of these three conditions fails to hold.

\begin{comment}
For identification, our menu displays
potential transformations that the user may not already know by name
(\eg{} \codeTool{Make Equal}) or may not realize is an option (\eg{} inverting
dependencies to \codeTool{Move Definitions} safely).
%% have already
%% identified (\eg{} Move Definition) or ones that do not already appear
%% widely in existing tools (\eg{} Make Equal).
For invocation, our user
interface allows gestures that require additional selection
information (\eg{} \codeTool{Make Equal} takes an arbitrary number of source
items and no explicit target, because it is automatically
computed). Furthermore, our menu helps quickly choose between multiple
potential transformations (and configuration options) triggered by the same user action
(several transformations in \autoref{fig:transformations-1} are active
based on the same selection state).
%% And for configuration, our menu
%% helps integrate this within a lightweight way for transformations that
%% require some extra information (\eg{} a name for Rename, the desired
%% variable or expression for Make Equal, or the desired secondary edit
%% when Move Definition detects a dependency violation).
Our approach---context-sensitive menus that appear near the selected
elements---attempts to strike a middle-ground between the
``heavyweight'' menu-based approach in Eclipse and the no-menu
approach of \dndr{}, providing structured transformations within the
typical workflow of a text-editing environment.
\end{comment}


%% \parahead{Block-Based and Hybrid Editors}

%% Several studies (\eg{}~\cite{GreenfootCost}) show how syntax errors
%% and whitespace formatting lead to many errors, which particularly
%% difficult for beginners.
%% A variety of alternative, block-based representation formats for programs
%% have been proposed to help mitigate these challenges.

%% Structured editors---such as
%% Scratch~\cite{Scratch:2009,Scratch:2010},
%% Blockly~(\url{https://developers.google.com/blockly/}),
%% GP~\cite{Monig:2015},
%% Visual Haskell~\cite{VisualHaskell},
%% Subtext~(\url{http://www.subtext-lang.org/}), and
%% Lambdu~(\url{http://www.lamdu.org/})---provide a variety
%% of alternative program representations that
%% make heavy use of graphical elements to reduce the amount of
%% unstructured text as much as possible.

\parahead{Hybrid Editors}

Compared to ``fully'' structured editors, several \emph{hybrid editor}
approaches augment text-based programs with additional information.
%% to help with development, maintenance, and understanding.
Barista~\cite{Barista} is a hybrid Java editor where
\emph{structure views} can be implemented to present
alternate representations of structural items instead of text. For
example, an arithmetic expression may be rendered with mathematical
symbols, a method may be accompanied by
%% symbols instead of ASCII, a method may be accompanied by
interactive documentation with input-output examples, and structures
may be selectively collapsed, expanded, or zoomed.
%% Barista uses an incremental parsing algorithm~\cite{Wagner:1998}
%% to help keep the lexical and structural representations synchronized
%% as much as possible.
\citet{ActiveCodeCompletion} introduce a similar notion to
structure views, called \emph{palettes}, where custom displays can be
incorporated based on the type of a subexpression. For example, a
color palette can provide visual previews of different candidate color
values, and a regular expression palette can show input-output examples
for different candidate regular expressions.
In Greenfoot~\cite{Greenfoot}, program text is separated into
structural regions called \emph{frames}, which are created and
manipulated with text- and mouse-based operations that are orthogonal
to the text-edits within a frame.
Code Bubbles~\cite{CodeBubbles1} allows text fragments to
be organized into \emph{working sets}, which are collections of code,
documentation, and notes from multiple files that can be organized in
a flexible way.
%% a flexible way as needed for the task at hand.
Outside of the views, palettes, frames, and working sets in the
above hybrid editors, the user has access to normal text-editing tools.

Our approach is complementary to all of the above: in places where
code fragments---regardless of their granularity and their
relationship to alternative or additional pieces of information---are
represented in plain text, we aim for a lightweight user interface to
structurally manipulate it.

\parahead{Refactoring with Synthesis}

In contrast to direct manipulation in \dndr{} and \deuce{},
\citet{RefactoringWithSynthesis} propose a
workflow where the user starts a refactoring with
text-edits---providing some of the changes after the refactoring---and
then asks the tool to synthesize a
sequence of refactorings that complete the task.
This text-based interface and the mouse-based interfaces of \dndr{}
and \deuce{} are complementary.


%% It may be useful
%% to consider how direct manipulation interactions can augment
%% the synthesis approach of \citet{RefactoringWithSynthesis}. User
%% studies like the ones performed by \citet{DNDRefactoring} would help
%% to identify what direct manipulation features would be best to expose
%% different kinds of transformations.



%% \subsection{Transformations Supported in Structured Editors}
%% \subsection{Refactorings and Other Structured Transformations}
%% \subsection{Refactorings and Other Transformations}
\subsection{Program Transformations}

%% Automated support for
%% refactoring~\cite{GriswoldThesis,Fowler1999,SmalltalkRefactoring} has
%% been aimed primarily at programs written in class-based,
%% object-oriented languages, with relatively
%% ``coarse-grained'' transformations (\eg{} Extract Class and Extract Method
%% work at the granularity of classes and methods, respectively).
%% As we have described, our current implementation of \deuce{} is in the
%% context of a functional language, and the set of transformations
%% includes several ``fine-grained'' transformations that arise during
%% various phases of the development process.

Automated support for
refactoring~\cite{GriswoldThesis,Fowler1999,SmalltalkRefactoring} has been aimed
primarily at programs written in class-based, object-oriented languages.

%% Our current implementation of \deuce{} is set in the context of a functional
%% language, and some of the transformations are designed to help with prototyping
%% and repair tasks in addition to refactoring.


%% \parahead{\hareLong{}}
\parahead{Refactoring for Functional Languages}

\hare{}~\cite{Thompson2013,HaReThesis1,HaReThesis2}
is a refactoring tool for functional languages, such as Haskell,
where features---including first-class functions
(\ie{} lambdas), local bindings, tuples, algebraic datatypes, and type
polymorphism---lead to editing tasks that are different from those
supported in most typical refactoring tools for object-oriented programs.
Our user interface could be incorporated by \hare{} to expose the
supported transformations with lightweight direct manipulation.
\hare{} provides a larger catalog of transformations than our
current implementation of \deuce{}. However, the details of our \codeTool{Move
Definitions} and \codeTool{Make Equal} transformations are, to the best of our
knowledge, not found in existing tools.

%% Furthermore, to support prototyping and repairing
%% phases of development, our intention is to also support
%% transformations that do not preserve semantics, such as Make Equal.
%% That is, our idea is to create a direct manipulation environment for
%% useful structured transformations that are not necessarily
%% refactorings. Indeed, our user interface makes it easy to instantiate
%% with whatever set of domain-specific transformations are relevant for
%% the setting.



%% \input{deuce-sns}


%% \subsection{Direct Manipulation of Trace and Output Information}
%%
%% In contrast to \deuce{} and all of the work discussed above, several
%% interactive programming environments augment the program text with
%% information about the execution of the program. In
%% \sns{}~\cite{sns-pldi,sns-uist}, the user interface provides direct
%% manipulation tools for (1) drawing shapes, (2) declaring intended
%% relationships between shapes, (3) grouping and abstracting shapes, and
%% (4) changing shape properties such as position, size, and colors. For
%% each of these direct manipulation features, \sns{} automatically
%% transforms the program text to match the user action.
%% Other systems augment code with
%% explanatory prose~\cite{VanWyk:1987},
%% documentation~\cite{Codelets},
%% and information from prior executions such as run-time
%% values (Sean McDirmid's live programming environments
%% (\url{https://www.youtube.com/watch?v=YLrdhFEAiqo}),
%% Carbide~(\url{http://alpha.trycarbide.com/}), and
%% Eve~(\url{http://witheve.com/})).
%% All of these features are orthogonal to the goals of providing
%% automated support for structured transformations directly in terms
%% of the code itself.
