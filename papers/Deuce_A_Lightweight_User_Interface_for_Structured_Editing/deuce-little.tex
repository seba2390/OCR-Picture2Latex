\parahead{\little{}}

\noindent
To make the discussion of our design concrete, we choose to work with
a small functional language called \little{}, defined in \autoref{fig:syntax}.
A \little{} program is a sequence of top-level definitions, the last of which is
called \verb+main+. Notice that all (sub)expressions, (sub)patterns, definitions
(both at the top-level and locally via \verb+let+), and branches of \verb+case+
expressions are surrounded in the abstract syntax by orange boxes; these denote
\emph{code items} that will be exposed for selection and deselection in the user
interface. In addition, there are \emph{target positions}, denoted by blue
dots, before and after every definition, expression, and pattern in the program. Target
positions are ``abstract whitespace'' between items in the abstract syntax tree,
which will also be exposed for selection.

\input{fig-syntax}

\parahead{Code Tool Interface}

\input{fig-code-tool-interface}

\input{fig-whitespace-polygons} %% HACK: here instead of deuce-ui.tex
                                %% to get this on page 4

Each code tool must implement the interface in \autoref{fig:code-tool-interface}.
A tool has access to the \verb+EditorState+, which contains a
\verb+Program+ and the \verb+Set+ of structural \verb+Selection+s within it.
Based on the \verb+EditorState+, the \verb+active+ predicate specifies
whether the tool is
\verb+Active+ (ready to run and produce \verb+Result+ options),
\verb+NotYetActive+ (could be \verb+Active+ if given more valid selections), or
\verb+Inactive+ (invalid based on the selections).
For example, \codeTool{Move Definitions} is \verb+NotYetActive+ if the user has
selected one or more definitions but no target position.
%
When invoked via \verb+run+, a tool has access to the \verb+EditorState+ and
configuration \verb+Options+, namely, an optional \verb+String+. This strategy
supports the ubiquitous \codeTool{Rename} tool. A more full-featured interface
may allow a more general set of configuration parameters; the challenge would be
to expose them using a lightweight user interface. In our implementation, all
transformations besides \codeTool{Rename} require \verb+NoOptions+. Each
\verb+Result+ is a new \verb+Program+ and a \verb+description+ of the changes.

This API between the user interface and code tool implementations is
shallow, in the sense that a code tool implementation can do whatever it
wants with the selection information. A framework for defining notions of
transformation correctness would be a useful line of work, but is beyond the scope of
this paper. Currently, code tools must be implemented inside the
\deuce{} implementation. Designing a domain-specific language for writing
transformations would be useful, but is also beyond the scope of this paper.
