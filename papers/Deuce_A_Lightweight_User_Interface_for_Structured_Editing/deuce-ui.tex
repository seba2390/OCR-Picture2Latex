\subsection{User Interface}
\label{sec:user-interface}

The goals of our user interface are, first, to expose \emph{structural
\maybecode{} selection widgets}---corresponding to the code items and target
positions in a \little{} program---and, second, to display an interactive menu
of active transformations based on the set of selections.

So that the additional features provided by \deuce{} do not intrude on
the text-editing workflow, we display structural selection widgets when hovering
over the code box only when the user is holding down the Shift key.
Hitting the Escape key at any time deselects all widgets
and clears any menus, returning the editor to text-editing mode.
This allows the user to quickly toggle between editing modes during
sustained periods in either mode.
When not using the Shift modifier key, the editor is a standard,
monospace code editor with familiar, unrestricted access to
general-purpose text-editing features.


\subsubsection{Structural \maybeCode{} Selection}

The primary innovation in our design is the ability to \emph{structurally
select} concrete source text corresponding to code items and target positions
from the abstract syntax tree of a program.

\parahead{Code Items}

Our
current %% TODO HACK, ugh, _removing_ this word creates spills...
implementation draws an invisible ``bounding polygon'' around the
source text of each expression, which tightly wraps the expression
even when stretched across multiple lines. These polygons serve as mouse
hover regions for selection, with the polygons of larger
expressions drawn behind the (smaller) polygons for the
subexpressions such that all polygons for child expressions partially
occlude those of their parents. Because complex expressions in
\little{} are fully parenthesized, it is always unambiguous
exactly where to start and end each polygon, and there are always
character positions that can be used to select an arbitrary
subexpression in the tree. Similarly, we create bounding polygons for
all patterns and definitions.

When hovering over an invisible selection polygon, 
\deuce{} colors the polygon to indicate that it has become the focus. Its
transparency and style is designed to resemble what might
otherwise be expected for text selection (\cf{} the screenshots in
\autoref{sec:overview}). Clicking a polygon selects the code item, making it visible even
after hovering away. Hovering the mouse back to the polygon and clicking it
again deselects the code item.


\parahead{Target Positions}

The user interface also draws polygons for the whitespace between code items for
selecting target positions.
%
\autoref{fig:whitespace-polygons}~(left) shows how our implementation draws
whitespace polygons slightly to the left of the beginning of a line, and until
the end of a line even if there are no characters on that line.
\autoref{fig:whitespace-polygons}~(center) shows whitespace polygons with
non-zero width even when there are no whitespace characters between adjacent code
items.

\begin{comment}
We make several design decisions to help with these concerns. First, when the
lines in have a program have different lengths, we ``pad'' whitespace polygons at the end
of each line to span to the maximum column width. For example, for the
whitespace polygon above \verb+redSquare+ in \autoref{fig:whitespace-polygons}~(left),
notice how the polygon on line 1 spans to the length of line 4 (the
longest line in the program) even though that line 1 has zero characters. Second, for
whitespace polygons that end at column 0, we begin the polygon slightly to the
left of column 0 (\eg{} the polygons on lines 1, 2, and 4 of
\autoref{fig:whitespace-polygons}~(left)). Third, when there is exactly one newline in
the whitespace, we draw a line from the end of the first line to the beginning
of the second so that the polygon is connected (\eg{} the polygon that spans lines
3 and 4 of \autoref{fig:whitespace-polygons}~(left).
Fourth, when there is no whitespace between
adjacent items, we draw a slim polygon rather than one with zero width.
To demonstrate, \autoref{fig:whitespace-polygons}~(center) shows all of the
0-character whitespace polygons in a selected state.
\end{comment}

Another concern is that many target positions in the abstract syntax from
\autoref{fig:syntax} describe the \emph{same} space between code items. For
example, the expression
\expListTwo{\targetsAround{\mathtt{50}}}{\targetsAround{\mathtt{70}}}
on line 3 of
\autoref{fig:whitespace-polygons} contains both an after-\verb+50+ and before-\verb+70+
position. Because such target positions between adjacent items are redundant,
our implementation draws only one whitespace polygon. (This polygon is not
selected in any of the screenshots.)

A more interesting case is for the code items
\expTopDefNoBox
  {\targetsAround{{\varPat}}}
  {\targetsAround{{\varExp}}} and
\expLetNoBox
  {\targetsAround{{\varPat}}}
  {\targetsAround{{\varExp}}}
  {\cdots};
there is both an after-\varPat{} target and a before-\varExp{} target.
To allocate the whitespace between \varPat{} and \varExp{},
we take the following approach.
The space up to the first newline, if any, is dedicated to
after-\varPat{}; the remaining is for before-\varExp{}. If there is no
newline, then we do not expose any selection widget for before-\varExp{}.
For comparison, notice how the whitespace from the
end of line 2 to beginning of line 3 in
\autoref{fig:whitespace-polygons}~(right) is split into two polygons,
but the whitespace from the end of line 3 to the beginning of line 4 in
the \autoref{fig:whitespace-polygons}~(left) is not.
In other settings, it may be worthwhile to consider alternative approaches
to the design decisions above.


\subsubsection{Displaying Active Code Tools}

Several program transformations may be \verb+Active+ based on the items and
targets that are selected.
We design and implement a lightweight user interface for identifying, invoking,
and configuring \verb+Active+ transformations.


\parahead{Pop-up Panel}

When the user has entered structured editing mode (by pressing Shift) and selected at least one
item, we automatically display a menu near the selected items. The user
has already pressed a key to enter this mode, so our design does not require a
right-click to display the menu.
The user can drag the pop-up panel if it is obstructing relevant code.
We often manually re-positioned pop-up menus to make the screenshots
in \autoref{sec:overview} fit better in the paper.

\parahead{Hover Previews}

Each tool in the menu
has a list of \verb+Result+s, which appear
in a second-level menu when hovering the tool \verb+name+. Each second-level
menu item displays the \verb+description+ of the change, and hovering
over it previews the new \verb+code+ in the editor.
Clicking the item confirms the choice and clears all \deuce{} selections.
%
When there are few \verb+Result+s (\ie{} configuration options),
this preview menu provides a quick way to consider the options,
rather than going through a separate Configuration Wizard.
For tools that require multiple and non-trivial configurations,
however, the editor could fall back on separate, tool-specific
Configuration Wizards; our current implementation of \deuce{} does not support
this.
