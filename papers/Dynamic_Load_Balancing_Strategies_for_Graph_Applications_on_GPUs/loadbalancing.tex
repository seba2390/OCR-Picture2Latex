\documentclass[conference,10pt]{IEEEtran}
%\documentclass[conference]{/home/satish/papers/style/hipc/IEEEtran}

\IEEEoverridecommandlockouts

\usepackage{setspace}
\usepackage{enumerate}
\usepackage{cite}
\usepackage{times}
\usepackage{url}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{amsmath}
\usepackage{color}
\usepackage[ruled,figure,linesnumbered]{algorithm2e}
\usepackage{multirow}
\usepackage{array}
\usepackage{wrapfig}
%\usepackage[ruled,figure,linesnumbered]{/home/satish/papers/style/algorithm2e/tex/algorithm2e}
% \usepackage{algpseudocode}

\newcommand{\todo}[1]{\textrm{\color{blue} #1}}
\newcommand{\REM}[1]{}

\begin{document}
\title{Dynamic Load Balancing Strategies for Graph Applications on GPUs}
\author{}
%\REM {
\author{
\IEEEauthorblockN{
$^1$Ananya Raval,
$^2$Rupesh Nasre,
$^1$Vivek Kumar,
$^1$Vasudevan R,
$^1$Sathish Vadhiyar,
$^3$,$^4$Keshav Pingali
}
\IEEEauthorblockA{
$^1$Department of Computational and Data Sciences, Indian Institute of Science, Bangalore, India \\
$^2$Department of Computer Science and Engineering, Indian Institute of Technology, Madras, India \\
$^3$Institute for Computational Engineering and Sciences, University of Texas at Austin, USA \\
$^4$Department of Computer Science, University of Texas at Austin, USA \\
ananya.raval@gmail.com, rupesh@cse.iitm.ac.in, vivekkumar1987@gmail.com, \\vasudevan@ssl.serc.iisc.in, vss@serc.iisc.in, pingali@cs.utexas.edu
}
}
%}
\maketitle

\begin{abstract}
Acceleration of graph applications on GPUs has found large interest due to the ubiquitous use of graph processing in various domains. The inherent \textit{irregularity} in graph applications leads to several challenges for parallelization. A key challenge, which we address in this paper, is that of load-imbalance. If the work-assignment to threads uses node-based graph partitioning, it can result in skewed task-distribution, leading to poor load-balance. In contrast, if the work-assignment uses edge-based graph partitioning, the load-balancing is better, but the memory requirement is relatively higher. This makes it unsuitable for large graphs. In this work, we propose three techniques for improved load-balancing of graph applications on GPUs. Each technique brings in unique advantages, and a user may have to employ a specific technique based on the requirement. Using Breadth First Search and Single Source Shortest Paths as our processing kernels, we illustrate the effectiveness of each of the proposed techniques in comparison to the existing node-based and edge-based mechanisms.
\end{abstract}

\input{intro}
\input{motivation}

\section{Proposed Load Balancing Strategies}
\label{strategies}
We propose three load balancing strategies: \textit{workload decomposition}, \textit{node splitting} and \textit{hierarchical processing} which we discuss in the following subsections.  
All our strategies implement data-driven GPU executions~\cite{nasre-datavstoplogy-ipdps2013} in which only the \textit{active} elements are processed using a worklist.
%In contrast to a \textit{topology-driven} execution in which all the elements are processed in each iteration, a data-driven execution has been shown to be work-efficient as well as performance-efficient~\cite{merrill-scalablegputraversal-ppopp2012,davidson-sssp-ipdps2014}.

\input{wd}
\input{ns}
\input{hp}

\input{expt}
\input{related}

\section{Conclusions and Future Work}
\label{con_fut}

In this paper, we had evaluated four load balancing strategies for BFS and SSSP applications for different graphs. We found that the edge-based processing method performs the best giving about 10\% better performance than the baseline for BFS, and about 60-80\% better performance than the baseline for SSSP. Among the node-based strategies, the workload decomposition method performs the best for graphs with small diameters while the node splitting method performs the best for graphs with large diameters. While the node-based strategies gave worse performance than the baseline in BFS, all our load balancing strategies gave significantly better results (at least 20\% better) than the baseline for SSSP. This shows that load balancing becomes very essential for computationally-intensive graph applications especially for large graphs.
For very large graphs in which some of our load balancing strategies cannot be executed due to memory constraints, our novel hierarchical processing method proposed in this work gives 48-75\% reduction in execution time compared to the baseline.
In future, we plan to explore our strategies for other graph applications including minimum spanning tree and betweenness centrality applications. We also plan to explore dynamic parallelism offered by modern GPU architectures for load balancing graphs. Finally, we plan to build data reorganization strategies for improved coalescing.

\bibliographystyle{IEEEtran}
\bibliography{loadbalancing,others}

\end{document}
