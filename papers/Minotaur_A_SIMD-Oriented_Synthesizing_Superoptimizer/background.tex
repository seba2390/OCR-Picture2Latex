\section{Background}
\label{sec:background}

\subsection{Vectors in LLVM}

LLVM uses a typed, SSA-based intermediate representation (IR).
%
It supports a derived \emph{vector type}; for example, a vector with
eight lanes, where each element is a 64-bit integer, would have type
\texttt{<8 x i64>}.
%
Many LLVM instructions, such as arithmetic operations, logical operations,
and pointer arithmetic, can operate on vectors as well as scalars.
%
IR-level vectors are target-independent; backends attempt to lower
vector operations to native SIMD instructions, if available.


Beyond the vertical ALU instructions that are element-wise vector
versions of scalar instructions, LLVM supports a variety of horizontal
vector reduction intrinsics and an assortment of memory intrinsics
such as vector load and store, strided load and store, and
scatter/gather.
%
Additionally, there are three vector-specific data movement
instructions:
%
\textit{extractelement} retrieves the element at a specified index from
a vector,
%
\textit{insertelement} non-destructively creates a new vector where
one element of an old vector has been replaced with a specified value,
%
and \textit{shufflevector} returns a new vector that is a permutation
of two input vectors using elements whose indices are specified by a
constant mask vector.
%
Finally, to provide direct access to platform-specific vector
instructions, LLVM provides numerous intrinsic functions such as
\texttt{@llvm.x86.avx512.mask.cvttps2dq.512}, aka ``convert with
truncation packed single-precision floating-point values to packed
signed doubleword integer values.''


\iffalse
An omnipresent semantic complication at the LLVM IR level is undefined
behavior in the form of \emph{poison} values, the \emph{undef} value,
and immediate undefined behavior~\cite{taming}.
%
For example, the LLVM language reference manual specifies that for the
shufflevector instruction:
%
\begin{quote}
If the shuffle mask is undefined, the result vector is undefined. If
the shuffle mask selects an undefined element from one of the input
vectors, the resulting element is undefined. An undefined element in
the mask vector specifies that the resulting element is undefined. An
undefined element in the mask vector prevents a poisoned vector
element from propagating.
\end{quote}
%
These rules can have counterintuitive effects on vector optimizations.
\fi


\subsection{Alive2}

Alive2~\cite{alive2} is an open-source, solver-based tool that takes a
pair of functions in LLVM IR and attempts to either prove that the
second one refines the first, or else provides a counterexample
showing that a refinement relation does not hold.
%
When refinement holds in both directions, two functions are equivalent.
%
However, an equivalence checker is unsuitable for translation
validation of LLVM optimizations: non-trivial
refinements---transformations that are legal in one direction, but
that cannot be soundly reversed---are very common.


\subsection{LLVM-MCA}

Predicting throughput of code running on modern microprocessors is not
straightforward.
%
To help developers improve performance-critical code, the LLVM Machine
Code Analyzer (LLVM-MCA)~\cite{llvmmca} was created.
%
It is an interactive tool that emits a graphical depiction of pipeline
behavior, but its functionality can also be accessed programmatically,
and this is what \tool{} does.
%
A problem with LLVM-MCA (and all similar tools that we are aware of)
is that it is imperfect: in some cases it either over- or
under-estimates the cost of certain code sequences~\cite{ithemal}.
%
This is a limitation that we simply live with.
