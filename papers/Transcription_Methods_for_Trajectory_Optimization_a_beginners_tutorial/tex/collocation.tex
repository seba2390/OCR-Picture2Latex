\section{Collocation Methods}

Collocation methods are based representing the optimal trajectory as a polynomial. Polynomials are nice because they can accurately represent nearly any smooth function, and their derivatives and integrals are easy to compute. This is useful because we can match the derivative of the polynomial approximation of the solution with the system dynamics at points along the trajectory. If they are identical, then the trajectory is feasible (at least as far as the dynamics are concerned). This is convenient, because it is often faster than running simulations, particularly if the dynamics are expensive to compute. Collocation can also be more accurate, assuming that the underlying solution is smooth and continuous. In addition, if orthogonal polynomials are used properly, the Jacobian of these derivative matching constraints is sparse.

\subsection{A more technical description}

 Let's assume that the system dynamics are given by:

\begin{equation} \label{eq:SystemDynamics}
\dot{\mathbf{x}} = f\left( t,\mathbf{x} \right)
\end{equation}

Now let's suppose that you represent the solution (soon to be optimal trajectory) as a $n^{th}$ order polynomial:

\begin{equation} \label{eq:PolynomialFunction}
\mathbf{x} = \mathbf{p}(t)
\end{equation}

In multiple shooting, the feasibility of the trajectory was ensured by breaking it up into many segments. Each trajectory was then stitched together using defect constraints that compared the state at the end of one segment to the state at the start of the next. This required running a simulation of each trajectory segments. In collocation, there is no simulation step. Rather, the system dynamics are satisfied by a constraint on the derivative of the solution at special grid points $t_i$:

\begin{equation} \label{eq:collocationDefects}
\mathbf{0} = \dot{\mathbf{p}}(t_i) - f\left( t_i,\mathbf{p}(t_i)  \right)
\end{equation}

If $\mathbf{p}$ is a $n^{th}$-order polynomial, then there are $n+1$ special grid points, whose spacing is determined by which class of orthogonal polynomial is being used\footnote{Using orthogonal polynomials is not required. The methods described in the following section are technically {\em orthogonal collocation methods}.}. For a Chebyshev polynomial \footnotemark{, these points are given by Equation \ref{eq:chebyshevPoints}, assuming that the domain of the trajectory has been scaled to the domain $[-1,1]$.

\begin{equation} \label{eq:chebyshevPoints}
t_i = \cos(i\pi/n), \quad i=0\dots n
\end{equation}

\footnotetext{There are similar equations for other orthogonal polynomials, but for simplicity, the following discussion will use the example of Chebyshev Polynomials, relying largely on the book: {\em ``Approximation Theory and Approximation Practice''} by Lloyd N. Tregethen \ADDREF{Trefethen}. }

The whole collocation method is based on representing polynomials using their values at each of these `special points'. Interestingly, this representation is analogous to representing a signal in the frequency domain (ie. taking its Fourier Transform), hence the alternate name for these techniques: {\em pseudo-spectral methods}. This makes it easy for the optimization algorithm to move around each point independently of the rest (the Jacobian of the constraints is sparse).

\par One nice property of storing a polynomial in this way is that its derivative is is easily calculated at each of these points. This makes calculating equation \ref{eq:collocationDefects} quite fast. A related property is that taking the integral of an orthogonal polynomial is incredibly easy - it is just a weighted sum of each coefficient (the polynomial's value at the special points). This is particularily useful for accurately computing integral cost functions, such as total work done by a motor.

\par Each special point has a basis function associated with it. The polynomial's value at an arbitrary point in the domain is calculated by taking a weighted average of these basis functions. This is called Barycentric Interpolation, and is shown in Equation \ref{eq:BarycentricInterpolation}. Note that $\lambda_i$ is pre-calculated based on the type of orthogonal polynomial.

\begin{equation} \label{eq:BarycentricInterpolation}
\mathbf{p}(\mathbf{x}) = \frac{
\sum_{i=0}^{n} \frac{\lambda_j \mathbf{p_j}}{\mathbf{x}-\mathbf{x}_j}
}{
\sum_{i=0}^{n} \frac{\lambda_j}{\mathbf{x}-\mathbf{x}_j}
}
\end{equation}

\subsection{Extensions of Collocation}

One of the limitations to the collocation methods described above is that they only work if the true solution is well-approximated by a polynomial. This is a good approximation for smooth dynamical systems, but once constraints are added, it is likely that the true solution will be discontinuous. One trivial example is swinging up a simple pendulum using a motor with restrictive torque limits. The optimal solution (by some cost functions) is to alternate between maximum torque in each direction. This solution is poorly captured by even a high-order polynomial.

\par The solution to this problem is to break up the trajectory into segments, in a similar manner to multiple shooting. The methods are very similar, except that the collocation version uses the same derivative matching constraints as above within each trajectory segment, where as the multiple shooting version uses a simulation. The trajectory segments are stitched together for the state variables (using defects like multiple shooting), but the control variable is allowed to be discontinuous.

\par The above fix is pretty good, but it has a problem: where to put the breaks between segments? As a first guess, the user can run multiple iterations of the algorithm with different spacings, but this is tedious and prone to error. A better method has been developed by Rao et al \cite{PattersonHagerRao}, which automatically breaks up the trajectory into the correct number of segments. Their method is called a {\em ``hp-adaptive''} scheme. It runs several iterations of the solver, and adaptively re-meshes the trajectory after each run. The breakpoints between trajectory segments are adjusted, as well as the order of the polynomial within each segment. Their full transcription algorithm is commercially available, under the name GPOPS II \cite{Rao_GPOPS_II} which will be discussed in a later section.


