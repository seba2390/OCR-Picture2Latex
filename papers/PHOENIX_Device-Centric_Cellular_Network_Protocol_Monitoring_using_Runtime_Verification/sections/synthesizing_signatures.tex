\section{Automated Vulnerability signature Synthesis}\label{atk-syn}
We now discuss the design of the optional \system component called \signatureSynthesizer.

\subsection{Potential Application of the Signature Synthesizer}
For using the \system system, we want to emphasize it is not mandatory to have the
signature synthesizer component; a cellular network security expert will suffice for
generating signatures. Despite that, an automatic signature synthesizer can be useful to the expert
in the following three scenarios.

First, when a cellular network security expert knows the root cause of an attack but does not
know how to represent it one of the forms, then it can use the signature synthesizer to generate
a candidate signature. DFA and MM signatures can be particularly complex.
Please see Figure \ref{fig:aka_bypass_dfa} in the Appendix
for the DFA signature of the AKA bypass attack \cite{kim_ltefuzz_sp19}.
Second, when an expert neither knows the root cause of a newly discovered attack nor knows the signature representation, the
signature synthesizer, especially the PLTL synthesizer because of its ability to generate succinct signatures,
can be particularly helpful for not only
identifying the root cause but also to synthesize the signature in the appropriate representation.
Finally, the runtime and space overheads of monitors, especially the PLTL-based monitor, are proportional
to the length of the signature. As the PLTL signature synthesizer is guaranteed to generate the minimum length
signature, it induces an efficient monitor. \emph{We envision a more collaborative process between
the automatic signature synthesizer and a human expert; instead of completely bypassing the expert and only using
the synthesizer in a standalone fashion. In this envisioned process,
the human expert asks the synthesizer to
generate multiple candidate signatures and then chooses the one she finds more appropriate.}
Such a collaborative interaction reliefs the human expert to be also an expert of formal logic like PLTL.



\subsection{The Problem of Signature Synthesis}
The signature synthesis problem is
an instance of the \emph{language learning from the informant} problem \cite{informant_learning}.
In this problem, for a fixed alphabet $\mathcal{A}$,
an \emph{informed learning sample (i.e., training dataset)} \calc{D} is given which
comprises of two disjoint sets of strings
\calc{P} and \calc{N}, such that $\calc{P}\cap \calc{N}=\emptyset$.
The aim is to learn an \emph{observationally
consistent}  language $\mathcal{L}$ that accepts all strings in \calc{P} and rejects all strings in \calc{N}.
In our setting, without the loss of generality,
for a given vulnerability \textbf{v} the set \calc{N} are vulnerable execution traces in which \textbf{v} happens
and the set \calc{P} are (benign) traces in which \textbf{v} does not happen. Then the
learned observationally consistent
language $\mathcal{L}$ represents the vulnerability signature for \textbf{v}.

% Note that, we do not discuss signature synthesis
% for the LSTM representation as it boils down to training the LSTM following
% the strategy of Du et al. ~\cite{deeplog}.



\subsection{Regular Language Signature Synthesis}
\label{sec:regular_languages}
%For regular language signatures,
The observationally consistent language $\mathcal{L}$ is considered to be
regular and
we used variations of the
%For both DFA and Mealy machine based signatures, we take
%advantage of the
RPNI (Regular Positive and Negative Inference) algorithm \cite{rpni}
to learn both DFA and Mealy machine based vulnerability signatures.
The complexity time of RPNI is the
following: $\bigO(l\cdot\vert\Sigma\vert\cdot k^4)$, where $l$ is the total
number of states in the negative traces, $\vert\Sigma\vert$ is the total size
of the alphabet, and $k$ is the number of unique prefixes \cite{rpni}.
%passive automata learning.
Below we discuss how to prepare \calc{P} and \calc{N} that are
required inputs to the RPNI algorithm.

%The only difference is how we prepare the traces for the learning
% procedure which we discuss below.

\paragraph{DFA Signature Synthesis.} For a given vulnerability $v$,
we are given two sets of traces $\Sigma_+$ (i.e., $v$ does not happen in these traces)
and $\Sigma_{-}$ (i.e., $v$ happens in these traces) such that
$\Sigma_+ \cap \Sigma_{-} = \emptyset$. For each  positive trace $\sigma_+\in\Sigma_+$,
we add $\sigma_+$ and all its prefixes to \calc{P}. We set $\calc{N}=\Sigma_{-}$.
We then invoke the RPNI \cite{rpni} algorithm for obtaining a DFA signature for $v$.

\paragraph{Mealy Machine Signature Synthesis.} We are given a
set of vulnerabilities $V.$ For each such vulnerability $v_i\in V$,
we are given two sets of traces $\Sigma^i_+$ (i.e., $v_i$ does not happen in these traces)
and $\Sigma^i_{-}$ (i.e., $v_i$ happens in these traces) such that
$\Sigma^i_+ \cap \Sigma^i_{-} = \emptyset$. For each positive trace $\sigma_+\in\Sigma_+$,
we add $\sigma_+$ to \calc{P} and assign the output label \texttt{benign}.
We add each negative trace $\sigma_{-}\in\Sigma_{-}$ to \calc{N} with output label
$\mathrm{\texttt{vulnerability}}_i$ and then invoke the RPNI algorithm for obtaining a combined
Mealy machine signature for all vulnerabilities in $V.$
%



\subsection{\pltl Signature Synthesis}
\label{sec:pltl_synthesis}
%In this setting, the observationally consistent language $\mathcal{L}$ is represented
%as an \pltl formula. For \pltl signature synthesis, we propose a new syntax-guided
%synthesis algorithm inspired by the work of Neider and Gavran \cite{learning_ltl} for learning
%future-only LTL formulas from infinite traces.
A \pltl formula represents the observationally consistent language $\fml{L}$ that constitutes a vulnerability signature.
For synthesizing \pltl signatures, we propose a syntax-guided synthesis algorithm that extends Neider and Gavran \cite{learning_ltl} to
learn PLTL formulas using only finite length traces.
%
The proposed algorithm reduces the signature synthesis problem to a Boolean satisfaction problem (SAT) and
then solve it using an off-the-shelf SAT solver. In this setting, any satisfiable assignment (or, \emph{a model}) of that SAT
problem instance is used to derive observationally consistent \pltl signature.
%Minimal signature tends to better generalize than overfit.
We aim to learn minimal consistent signatures as
they can  capture a concise
% tend to learn the
% intended behavior of attack
vulnerability behavior
even from a smaller training dataset and are also intellectually
manageable (readable).
%
This feature is inherent to this algorithm in contrast to other representations (i.e., DFA and
Mealy machine).
%This is a unique feature not offered by DFA and Mealy Machine.
Precisely, a formula $\Phi$ is minimally consistent with $\fml{D}$ if and only if $\Phi$ is consistent
with $\fml{D}$ and for every other \pltl formula $\Psi$ such that $|\Psi|<|\Phi|$, $\Psi$  is
inconsistent. Here $|\cdot|$ is a function that takes
a \pltl formula as input and returns the number of its sub-formulas.
%
Also, this algorithm can provide different candidate signatures for a given sample \calc{D}
by enumerating different models of the SAT problem. Thus, it provides the user with more
flexibility to select the most desirable signature among the suggested candidates.

%
\begin{algorithm}
\caption{\pltl Syntax-Guided Synthesis Algorithm}\label{algo1}
\hspace*{\algorithmicindent} \textbf{Input: }{Training dataset $\mathcal{D=(P,N)}$
and alphabet $\mathcal{A}$}\\
  %, where  $\mathcal{P,N}\subseteq (2^{\mathcal{P}})^{*}$} \\
\hspace*{\algorithmicindent} \textbf{Output: }{Minimally consistent signature $\Phi_\ell$ of size $\ell\in\mathbb{N}$}
\begin{algorithmic}[1]
%
\State $\ell \gets \text{1}$ %\text{//Compute Signature of size $>=$ 1}
%
%
\While{$\ell \leq \Delta$} //$\Delta$ is a constant threshold
\State $\varphi_\ell \gets \text{encode}(\mathcal{D}, \ell)$% \text{//Encoding LTL Syntax \& Semantic rules implying Traces}
\State $m \gets \textsf{SAT}(\varphi_{\ell})$
\If {$m \neq \emptyset$}
    \State $\Phi_{\ell} \gets \text{decode(m)}$ %\text{//Decode Formula from Model}
    \State \Return $\Phi_\ell$
\Else
    \State $\ell \gets \ell +1$ %\text{//Increment bound to continue searching the signature}
%        \State $\varphi_n \gets \text{encode}(\mathcal{D}, n)$
\EndIf
\EndWhile
\end{algorithmic}
%\label{algo1}
\end{algorithm}
%
\paragraph{Algorithm.}
For a given training dataset \calc{D} and alphabet \calc{A} (i.e., a set of
propositional variables), our learning algorithm (Algorithm \ref{algo1})
iterates over the depth of the \pltl formula
abstract syntax tree (AST) in ascending order.
For a given depth of the formula AST $\ell$,
the algorithm has two main steps: \ding{182} Generate all possible \pltl formulas
whose AST depth is exactly $\ell$; \ding{183} Check whether one of the generated
formulas is consistent with $\mathcal{D}$. Although logically the algorithm has two steps,
one can use a SAT solver to perform both searches simultaneously.
The advantage of such an approach is that the constraints capturing the
restrictions in step \ding{183} can rule out formulas from search at step
\ding{182}. We now, at a high-level, describe
how both steps are encoded as a SAT formula.
% whose satisfiable assignment will yield
%  a consistent \pltl signature.

The first set of constraints
% represented as propositional logic formulas
are regarding the syntax of the \pltl formula. These constraints are conjunctions
of the following:
(1) constraints for generating all  ASTs of depth $\ell$;
(2) constraints for assigning labels (i.e., propositions and operators) to the
% different
AST nodes. Example constraints in the label assignment
include operators cannot be assigned to leaf nodes,  and binary operators can only be
assigned to nodes having two children. These
constraints are required to be strong enough to ensure that
only syntactically well-formed \pltl formulas are considered~\cite{mc03}.
Based on \pltl semantics, the second set of constraints capture that the synthesized formula should satisfy
all traces in \calc{P} while rejecting all traces in \calc{N}.
% This is
% done with respect to the semantics of \pltl.

The encode function in the algorithm, given the AST depth $\ell$  and the training dataset
$\mathcal{D}$, generates a propositional formula $\varphi_\ell$ that capture these constraints.
% with a guarantee that
% %
% $\varphi_\ell $ is satisfiable if and only if there exists a \pltl formula
% $\Phi_\ell$ of size $\ell\in\mathbb{N}$ that is consistent with the training data set
% $\mathcal{D}$.
%
The algorithm then uses an off-the-shelf SAT solver to search for a model of $\varphi_\ell$.
%
If a model  $m$ is found, it is decoded to obtain an \pltl formula
$\Phi_\ell$ that represents the consistent vulnerability signature. If no model is found,
the algorithm increments the bound size (i.e., $\ell$) and the search procedure continues
until a satisfying assignment is found or the bound threshold  is exceeded (i.e., $\ell > \Delta$).
% The search procedure for finding a
% signature is
% % always complete ... bounded (operate in a finite search space)
% quite similar to bounded model checking~\cite{mc03}.
