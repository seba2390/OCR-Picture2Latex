\section{Implementation of \system}
%We now present the implementation details of \system.
We instantiate \system in two settings: a full-fledged defense as part of the
baseband processor and also as an Android app serving as warning system.
To study the overhead of \system when
running inside a baseband processor, we implement \system by modifying srsUE distributed as part of
srsLTE open-source protocol stack \cite{gomez2016srslte}. To analyze the effectiveness of \system as a warning
system, we implement the message extractor and the monitor in an Android
application on different devices. The optional \signatureSynthesizer component of
\system is developed as a standalone program.

\subsection{\system Implementation With srsUE}
\label{sec:baseband_implementation}
To simulate \system{}'s integration into the baseband
processor, we extend srsUE \cite{gomez2016srslte} so that it can
% analyze messages in an on-going session and
detect an
undesired behavior. As a baseband processor (similarly, srsUE) parses a message,
\system does not need to parse messages
and instead need to focus on the monitor component. For this instantiation,
we used the PLTL-based monitor because it is the
most effective monitor instantiation according to our evaluation in Section \ref{sec:evaluation_of_phoenix}.
% We will now discuss more details on the implementation of
% the monitor component of \system in srsUE.

\textbf{PLTL monitor.} In order to achieve a highly efficient implementation,
both when considering memory and computational overhead, we leverage the work
by Rosu et al. \cite{rosu2001synthesizing} to synthesize dynamic programming
algorithm-based PLTL monitors in C++. The runtime and memory requirements of these
monitors are constant with respect to the signature size.

\textbf{Monitor integration.}
Depending on the information required to evaluate a signature,
the monitors are integrated in either the RRC or NAS namespace
files, which are responsible for the handling (and sending)
messages of each layer.
In each such message handling/sending function, prior to processing
or sending a message, the entry point of \system is invoked with the label of the
new event. In order to empower \system to drop messages or
close the connection altogether, \system returns a Boolean value
representing whether or not at least one signature was violated, in order
to let the function either proceed with the handling (or sending) process or drop
the connection to prevent a vulnerability.

\subsection{\system Implementation as an Android App}
When implemented as an Android app, we instantiated \system
with DFA-, MM-, and PLTL-based monitors. We now discuss the
major component implementations.

\textbf{Message Extractor.} The message extractor first reads events from the baseband processor.
For efficiently parsing protocol packets, we %extend and enhance the
%MobileInsight~\cite{mobile_insight} application. In particular, we
modified MobileInsight~\cite{mobile_insight} application's traffic
dissector to efficiently capture NAS and RRC layers' traffic. We then apply
any required propositions and forward the message to the \monitor.
Note that since we modified MobileInsight to implement the message extractor,
\system requires root privileges to function. These types of apps require root access since normal
applications do not have access to the virtual device where the modem information
is exposed \cite{mobile_insight}.

\textbf{Monitor Component.}
Since MobileInsight is written with Python and compiled into an Android App using Python for Android~\cite{python_for_android},
we implement our monitors in the same fashion.
We now discuss the implementation details of the monitors for each of the attack signature representations.


\textit{DFA.} For an attack signature,
our %python implementation of
DFA-based \monitor
stores the set of transitions, list of accepting states,
current state, and the alphabet in memory. The transition relation in our
implementation is just a dictionary lookup. A transition to a non-accepting state
is considered an attack.

\textit{MM.} Mealy machine-based \monitor is similar to the one for DFA with one
exception. Since Mealy-machine does not have any accepting and non-accepting states,
the output symbol of the transition indicates which particular attack has occurred.



\textit{PLTL.} We implemented the dynamic programming  algorithm \cite{rosu2001synthesizing} for monitoring \pltl formulas in Python.
Our implementation stores a single bit for each sub-formulas truth value and uses bitwise operations to identify the truth values.



\subsection{Signature Synthesizer} The implementation details of the
optional \signatureSynthesizer component is as follows.


\textbf{DFA.} For learning DFA signatures, we use the RPNI passive automata learning algorithm implemented in LearnLib~\cite{learnlib}.
We provide the attack traces as well as non-attack traces and all their prefixes as input. We also include empty string ($\epsilon$) as part of the positive
sample because without it the initial state of the synthesized DFA is marked as non-accepting.


\textbf{Mealy Machine.} Similar to DFA, we invoke the RPNI algorithm of LearnLib \cite{learnlib} to serve as the \signatureSynthesizer for
Mealy Machine. Each message in the trace is also mapped with its corresponding output (i.e., $\mathsf{benign}$ or $\mathsf{vulnerability}_i$).

Note that, since Mealy Machine is a monitoring mechanism capable of detecting multiple attacks at the same time, the training set
contains all the traces for that corresponding layer.

\textbf{PLTL.} To instantiate our \pltl \signatureSynthesizer, we implement the algorithm  in Section~\ref{sec:pltl_synthesis}.
Our implementation uses PySMT, a Python-based solver-agnostic library
built on top of SMT-LIB~\cite{smtlib}. %This allows us to leverage different solvers without any modification.
By leveraging our \pltl \signatureSynthesizer's capability of
generating different candidate signatures, we create 5
candidate signatures
for each attack with 80\% of the training data. We then evaluate the candidate
signatures on the remaining 20\% of training data to pick the best one.
In case of a tie, we choose the smallest signature.
