\section{Vulnerability Signatures and Monitors}
\label{sec:approaches}
% Previously, we only abstractly discussed the notions of signatures and monitors.
In this section, we discuss the possible vulnerability signature representations and their monitors that we consider.

\subsection{Insight on Vulnerability Signatures}
After analyzing existing control-plane attacks on 4G LTE \cite{lteinspector, TORPEDO, privacy_ndss16, kim_ltefuzz_sp19,
5Gformal_authentication_basin, 5g_reasoner, lte_redirection, how_not_to_break_crypto}, we observed that
a substantial amount of these attacks have very specific behavioral signatures
when considering protocol messages, their payloads, and predicates over them.
Precisely, considering the relative ordering of events often are sufficient
to synthesize a discernible and precise vulnerability signature. For instance,
in the running example described in Section \ref{sec:running_example},
not seeing both the \securityModeCommand and \securityModeComplete
messages prior to the \rlfReport being exposed,
can serve as a confident indicator for such vulnerability.


\subsection{Vulnerability Signature Representations}
To precisely capture the behavioral signatures of cellular network vulnerabilities,
we consider regular languages and \pltl as two possible representations.
% : Regular language;
% Past-Time Propositional Linear Temporal Logic (\pltl).
These formalisms are chosen
due to their effectiveness in capturing relative temporal ordering of events
as well as being efficiently monitorable at real-time. In addition, there is one
more representational question we have to address: \emph{Does one keep per-vulnerability`
signatures or one giant signature capturing all of the considered vulnerabilities}? These
design choices induce the following
% possible attack
signature representations.


\textbf{Signatures as Regular Languages.}
In this scheme, let us consider \calc{U} to be all finite protocol execution
traces. Let us denote all the finite protocol executions in which a given vulnerability $v$
occurs as a regular language \lang. Then the behavioral vulnerability signature we consider
is the language $\lang^* = \calc{U}-\lang$ which is the complement of \lang and accepts all finite protocol
execution traces where $v$  does not happen (See Figure \ref{fig:universe_of_traces}). This signifies that
$\lang^*$ will only reject traces in which $v$ happens. For representing $\lang^*$,
we consider the protocol message types, their payloads, and predicates over them
as the alphabet. For a given vulnerability whose behavioral
signature is denoted by $\lang^*$, we represent its signature as a deterministic
finite automata (DFA). For the case of having one giant signature for all vulnerabilities,
we use a Mealy Machine whose outputs in the transitions indicates whether a certain
execution is benign (labeled with output \texttt{benign}) or vulnerable in which case the output label identifies the vulnerability.
% particular attack in question.

\begin{figure}[t]
  \centering
	\includegraphics[width=.8\columnwidth]{figures/trace_universe.pdf}
	\caption{Universe of finite protocol executions separated into two regular languages,
  depending on if the undesired behavior
  \textbf{v} occurred or not (resp., $\lang$ and $\lang^*$).}
	\label{fig:universe_of_traces}
\end{figure}



\textbf{Signatures as \pltl formulas.}
\pltl has been shown to be a natural candidate for succinctly representing the
temporal ordering of events of the past. We use message types, their payloads,
and predicates over them as propositions of the logic.
In this scheme, we keep one behavioral
signature as a \pltl formula for each vulnerability that rejects only those finite
traces in which the vulnerability in question occurs. We do not keep a giant \pltl
formula for all vulnerabilities as it would not allow us to identify the particular vulnerability
that occurs, impairing us to provide vulnerability-specific remedies and severity.



\subsection{Vulnerability Monitors}
We now discuss how we monitor vulnerability signatures based on their
representations.

\paragraph{Monitoring Regular Language Signatures.}
For monitoring a signature represented as a DFA, we need to store the DFA
along with the current state in the memory. When a new packet and its associated
information arrives to the \monitor, we try to take a transition in DFA. If the
transition lands us on a non-accepting state that means a vulnerability has been observed
in which case we raise an alarm and provide vulnerability-specific information (e.g.,
name of the vulnerability, severity, and remedies). In case of a benign scenario, we
just take the transition and update the current state. The monitoring with respect
to a Mealy Machine is very similar with the one difference is that the output
label of the transition indicates whether a vulnerability has been observed, and if so
which particular vulnerability was observed.


\paragraph{Monitoring \pltl Signatures.}
For monitoring \pltl formulas, we consider a standard dynamic programming (DP) based approach
from the literature of runtime verification \cite{d2005efficient, basin2010monitoring, basin2010policy,
 monpoly, bauer2011runtime, rosu2001synthesizing}.

In this approach,
to monitor a \pltl formula $\Phi$, the \monitor requires one bit of information
for each sub-formula of $\Phi$. This bit signifies whether the associated formula
holds true in the current state. If the truth value bit of $\Phi$ is true
in the current state, then there is no vulnerability.
%If the truth value bit of $\Phi$ is true in the current
%state it signifies that $\Phi$ is true in the current state and there is no attack.
For a given \pltl formula $\Phi$, let us assume
that $\llbracket\Phi\rrbracket^i$ represents the truth value bit of formula $\Phi$
at position $i$ of the trace. Adhering to the \pltl semantics,
the DP algorithm constructs
$\llbracket\Phi\rrbracket^i$ from $\llbracket\Phi\rrbracket^{(i-1)}$ and the current
state $\sigma_i$ in the following way. Note that, we just need to store $\llbracket\Phi\rrbracket^{(i-1)}$
to calculate $\llbracket\Phi\rrbracket^{(i)}$.
The current state $\sigma_i$ in our presentation is a total map which maps
each propositional variable in the alphabet \calc{A} to either true or false.
%\fa{PLTL operator not displaying correctly.}
% Comment addressed.
\begin{align*}
\llbracket p \rrbracket^i  &=  \sigma_i(p)\\
\llbracket\neg\Phi\rrbracket^i &= \neg\llbracket\Phi\rrbracket^{i}\\
\llbracket\Phi\wedge\Psi\rrbracket^i &= \llbracket\Phi\rrbracket^{i} \wedge \llbracket\Psi\rrbracket^{i}\\
\llbracket\yesterday\Phi\rrbracket^i &= i>0 \wedge  \llbracket\Phi\rrbracket^{(i-1)}\\
\llbracket\Phi\since\Psi\rrbracket^i &= \llbracket\Psi\rrbracket^{i} \vee (\llbracket\Phi\since\Psi\rrbracket^{(i-1)}\wedge \llbracket\Phi\rrbracket^{i})
\end{align*}
\label{sec:pltl_description}
