\section{Related Work}
\label{sec:related}

We put our work into context and discuss other approaches to cache-oblivious methods. We also discuss previous works on tiling and code generation. 

\subsection{Empirical Study of Cache-Oblivious Methods}
The most closely related work is by Yotov et al.~\cite{yotov2007experimental} that explored answers to the question ``what is the cost of cache obliviousness?'' Their study is primarily on matrix multiplication and is only about sequential execution.  Our work extends the study to a broader range of programs and to parallel executions. We also provide variability of both speed and cache behavior with respect to tile size.

Some prior work on code generators for various types of tiling have empirically compared iteration space tiling and cache-oblivious methods~\cite{Bandishti12, lifflander2017cache, autogen-ppopp16, strzodka2010cache, zou2015rajopadhye}. The objective of these experiments are slightly different from ours; the main target of evaluation is the code generation tools. Our interest is in understanding the difference due to the tile execution order. The reported performance difference in these experiments mostly come from differences in other aspects that influence the performance (e.g., copy optimization and other low-level optimizations), which we carefully checked that codes from all tools have similar behavior in our work. This explains the apparent inconsistency with earlier results.

\subsection{Cache Oblivious Code Generation}
Prokop~\cite{prokop-thesis99, frigo-etal-focs99} introduced the cache-oblivious algorithms. Later, Frigo and Strumpen proposed the serial~\cite{frigo-strumpen-ics05} and the parallel~\cite{frigo2006cache} divide and conquer implementations of stencil programs.  Strzodka et al. ~\cite{strzodka2010cache} proposed cache oblivious parallelograms method (CORALS) which is similar to the time-skewed wavefront parallelization of iterative stencil computations. CORALS takes advantage of the regular dependence patterns of stencil computations and applies oblique cuts in both space and time dimensions simultaneously. They use a load-balancing scheme to evenly distribute all the threads amongst the tiles.  Their technique benefits from data locality, parallelism and vectorization simultaneously.  

Pochoir~\cite{Tang2011} is a domain specific compiler for stencil programs. It generates a divide and conquer implementation of the program based on trapezoidal decompositions using hyperspace cuts.  Pochoir generates efficient code, but the code generated for the hyper-trapezoidal tile shape is very complex and that the base case sizes are fixed at compile time.  Pochoir, also, cannot handle dependences along the time dimension.  The dependence should be always from a previous time step. Therefore, Gauss-Seidel-like dependences cannot be handled. Pochoir can generate the divide and conquer code for periodic stencils.  Periodic stencils can be handled by our COT code
generator after the smashing transformation ~\cite{sanjay-lcpc08,
uday-pact2014}.  Pochoir is capable of applying oblique cuts whereas we make canonic cuts.

Serial and parallel implementations of recursive divide and conquer algorithms with optimal cache complexity have been developed and evaluated for a specific dynamic programming algorithm such as Longest Common Subsequence ~\cite{rezaul-thesis, Chowdhury-2006-CDP}, global pairwise sequence alignment problem in bioinformatics ~\cite{Chowdhury-2010soda}, Gaussian Elimination Paradigm ~\cite{Chowdhury2010GEP}, etc. Tithi et al.~\cite{tithi-ipdps2015} described a way to obtain divide and conquer algorithms manually for a class of dynamic programming problems. The base cases of these programs are similar to matrix multiplication computations. The code is hand optimized with the non-trivial Z-Morton matrix conversions.  Unlike the work of ~\cite{tithi-ipdps2015}, Autogen does not use Z-Morton matrices. The derived cache-oblivious implementation is parameterized by a single base value for all the dimensions which limits the tile shape to a hypercube.  Autogen is mostly applicable to dynamic programming problems where the fractal property is often available.

Tang et al.~\cite{Tang-COW} proposed the Cache-Oblivious-Wavefront (COW) technique, that improves the parallelism of the cache-oblivious algorithms, which also preserves locality. They use classic divide and conquer strategy to partition the iteration space and schedule the execution of tasks across different levels of the recursion as soon as the data dependency constraints are satisfied. The execution pattern of the COW algorithm is conceptually similar to classic wavefront schedules. However, the implementation is done by hand and their technique can handle only dynamic programming algorithms.

Autogen~\cite{autogen-ppopp16} executes an iterative implementation of the input program using very small problem sizes to determine the access patterns (dependences).  It then determines a recursive decomposition (called fractal property) that can be used to derive a divide and conquer implementation. The structure of the recursive function is automatically generated but the body of the base case is hand implemented.  

Bellmania~\cite{itzhaky-oopsla2016} is an interactive system, based on solver-aided tactics, that re-writes the rules and generates provably correct divide and conquer implementations of dynamic programs.  The dependences are statically analyzed, however, the derivation of the recursive algorithm is not automatic.

The COT code generator presented in this paper takes the base case tile sizes as input, therefore, the tile shape can be hyper-rectangular; and supports more general class of programs, i.e. all polyhedral programs.

\subsection{Tiled Code Generation}
Tiling~\cite{Wol87,irigoin-popl88} is a classic iteration space partitioning technique which combines a set of points into tiles, where each tile can be executed atomically.  Tiling comes in handy for exploiting data locality~\cite{Wolf91tiling, kamil2010, liu2009}, minimizing communication ~\cite{Andonov2001,xue-jpdc97} and maximizing parallelism ~\citep{Bandishti12}.  

Time skewing ~\cite{wonnacott-time-skewing-tr99a} enables time tiling which increases the temporal reuse, especially in stencils.  Bondhugula et al. ~\cite{uday-pldi08} developed PLuTo, a system for tiling imperfectly nested affine loops with fixed sized tiles.  The PLuTo algorithm obtains tiling hyperplanes that minimizes communication across fixed size hyper-parallelopiped tiles. Bandishti et al. ~\cite{Bandishti12} proposed a diamond tiling technique that enables the concurrent start of tiles and eliminates the pipeline fill and flush cost of classic wavefront tiling. Many other tiling techniques ~\cite{Hartono-DynTile, grosser2014hybrid, TJin-Hybrid-Tech, Krishnamoorthy07, Henretty2013SIMDStencil, Holewinski2012Overtile} also propose ways to eliminate pipeline start-up cost in a similar fashion.  

However, in all of the above, the generated code has fixed sized tiles and does not guarantee optimal usage of caches.  Parametric tile sizes enable efficient auto-tuning and performance portability. Techniques ~\cite{Hartono2009prime, baskaran-etal-cgo10, Kim2010, lakshmi-thesis, sanjay-kim-dtilingTR-2010, darte2014parametric}  have been thus developed to allow parametric tiling. More studies on parametric tiling such as D-Tiling ~\cite{sanjay-lcpc2009, sanjay-kim-dtilingTR-2010}, P-Tiling~\cite{baskaran-etal-cgo10} and Mono-parametric tiling~\cite{iooss:hal2015} are conducted where the latter is a polyhedral transformation.  

Our COT code generator produces code with parametric base tile sizes and the point loops can be generated using any of the aforementioned parametric tiled code generators.



% Local Variables: ***
% TeX-master: "PACT17.tex" ***
% fill-column: 78 ***
% End: ***
