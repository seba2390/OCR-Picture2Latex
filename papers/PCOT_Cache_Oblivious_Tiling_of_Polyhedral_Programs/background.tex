\section{Background}
\label{sec:background}

In this section, we present necessary background on tiling, cache oblivious
divide-and-conquer execution, and define the terminology used in this paper.

\subsection{Tiling}
Tiling is a well-known loop transformation for partitioning computations into
smaller, atomic (all inputs to a tile can be computed before its execution),
units called tiles~\cite{irigoin-popl88, Wolf91tiling}. The partitioning into
tiles improves data locality by altering the execution order of the operations.
Tiling also exposes coarse-grained parallelism making it the core transformation
for polyhedral automatic parallelizers such as Pluto~\cite{uday-pldi08}.

 The natural legality condition of tiling is that the dependences across tiles do not
create a cycle.  In compilers, this condition is typically expressed as fully
permutability (i.e., dependences are non-negative direction vectors), which is
a sufficient condition. In the rest of this paper, we assume that the programs
have been transformed to expose loop nests that satisfy this condition.  For
polyhedral programs, scheduling techniques to expose such loop nests are
available~\cite{uday-pldi08}.

\subsection{Cache Oblivious Tiling}
Cache oblivious algorithms~\cite{prokop-thesis99, frigo-etal-focs99} are based
on recursive formulation into smaller subproblems (divide-and-conquer). The
main argument is that as the problem sizes are recursively made smaller, a
subproblem is going to fit on some level of the memory hierarchy that may be
caches, main memory, etc. This class of algorithms is expected to take
advantage of all memory hierarchies through this strategy.

Cache Oblivious Tiling is a specialization of such algorithms based on tiling.
Tiles after a level of tiling can be tiled again with smaller tile
sizes to realize the divide-and-conquer execution pattern. COT may be viewed as
hierarchical tiling, except that the number of tiling levels are determined at
run-time through divide-and-conquer~\cite{carter1995hierarchical}. 

The key effect of multi-level tiling is to change the execution order of the
tiles. As illustrated in Figure~\ref{fig:tile-order}, the grouping of smaller
tiles; forming larger tiles increasing intra-tile reuse; is what accounts for
better cache utilization.


\begin{figure}
\centering
  \begin{subfigure}{0.2\textwidth}
    \includegraphics[width=\columnwidth]{wavefront-tile-order}
    \caption{Single-Level Tiling \label{fig:wavefront-tile-order}}
  \end{subfigure}
  \begin{subfigure}{0.2\textwidth}
    \includegraphics[width=\columnwidth]{cot-tile-order}
    \caption{Two-Level Tiling \label{fig:cot-tile-order}}
  \end{subfigure}
  \caption{\label{fig:tile-order}Execution order of the smallest tiles under single- and two-level
tiling. Two-level tiling may be viewed as Cache Oblivious Tiling where the
recursion reached the base case after one recursive step. With hierarchical tiling,
neighboring tiles form a larger tile that increase intra-tile reuse.
\vspace{-0.2cm}
}
\end{figure}


\subsection{Terminology}\label{sec:terminology}
We introduce a few terms, in addition to COT in the above.
%, that are used throughout this paper.

\paragraph{Single-Level Tiling} SLT is when loop tiling is applied once to
improve data locality with respect to a level of cache. The reason we restrict
to SLT is because SLT and COT expose the same number of tuning parameters. It
is known that even cache oblivious algorithms require the performance of the
leaf subproblems to be tuned to have good performance. The tuning effort
required is similar to SLT with the same number of tuning parameters, which
would not be the case if you apply multi-level tiling that multiplies the
number of tuning parameters.  

\paragraph{Tile Size} We use tile size interchangeably with the base case
threshold (and leaf tile size) in COT. Whenever tile sizes are discussed for
COT, it refers to the size of the leaf tile sizes, which is its tuning parameter. 

\paragraph{Off-Chip Accesses} OCA are all load accesses that read from the main
memory.  This includes the accesses due to Last-Level Cache misses due to load
operations, as well as those arising from prefetching instructions.

%\subsection{Benefits of Cache Oblivious Tiling}
%For compute-bound programs, the performance (speed) of SLT and COT is expected
%be similar.  As demonstrated by Zou and Rajopadhye~\cite{zou2015rajopadhye}
%for compute-bound stencil computations, reducing the amount of off-chip memory
%accesses (reduced Last Level Cache misses) does not always translate to
%performance. The latency penalty for LLC misses are mostly hidden by the
%computation, and thus further reducing the penalty have little impact on
%speed.
%
%%\FIXME{I am contradicting the
%%TurboTiling paper here - I think what happens is that for TurboTiling the
%%performance gains are not from reduced LLC misses, but more optimized execution
%%of tiles due to larger tiles. We should check this.}
%
%Therefore, the execution times of recursively tiled programs are not expected
%to be any better than those with just a single level of tiling if the tile sizes are
%well-tuned. In fact, we expect that the recursion to introduce overhead of
%various forms, such as functional call overhead, increased register pressure,
%increased difficulty for the compiler as the recursive functions cannot be
%inlined.
%
%However, the increased intra-tile data reuse improves the data locality with
%respect to lower levels of the memory hierarchy. In effect, what can be
%expected for COT with compute-bound programs is \emph{reduced off-chip memory
%accesses with similar performance as SLT, without the need to explicitly tune
%for LLC}. This what we validate in our experiments presented in
%Section~\ref{sec:experiments}.
%
%The two scenarios where COT is useful are memory-bound computations and energy
%efficient computing. When the program is memory-bound to the extent latency
%hiding is not possible, then improved data locality in all levels are expected
%to translate to speed improvements. Another important benefit of reduced LLC
%misses\footnote{In fact, COT reduces L2 cache misses as well, but we focus on
%LLC misses that are associated with the more costly off-chip memory accesses.}
%is energy. Energy consumption due to off-chip memory accesses is a
%non-negligible component of the total energy consumption of a computing
%platform, and significant reduction on off-chip memory accesses can be
%beneficial for energy~\cite{zou2015rajopadhye,mikami2011evaluation}.
%

%\input{approach}		  %THis file has high level approach

%\FIXME{Following subsections should move to code gen section.}
%
%\subsection{Parametric Tiling}
%In this paper, we use parametric tile sizes for both Single-Level Tiling and
%Cache Oblivious Tiling. Existing techniques for parametric
%tiling~\cite{sanjay-lcpc2009, baskaran-etal-cgo10} have demonstrated that the
%parameterization does not incur significant performance overhead when compared
%to tiling by compile-time constants. 
%
%
%\subsection{Bounding Box of Tilable Band}
%For a given loop nest, tilable band specifies band of loops which are tilable
%or permutable. Usually, the band is specified by the start loop depth and end
%loop depth.  Bounding box is a cuboid (or hyper-rectangle) containing the
%iteration space of the tilable band.  There can be infinitely many bounding
%boxes for a given tilable band, but we chose the tightest bounding box among
%all the possibilities. Since there are outer loops surrounding the tilable
%band of loops, the bounding box is parameterised by outer loop iterators. In
%other words, there is a bounding box for each instance of outer loops. 
%


%In this section, we introduce the necessary background of our work. We first
%give a brief description of the polyhedral representation of programs, and the
%general flow of a polyhedral compiler.  Then, we discuss the legality of
%tiling, which is related to the input of our code generator.
%
%\begin{figure*}[tb]
%  \centering %\vspace*{6cm}
%  \includegraphics[scale=0.6]{figures/PolyCompiler}
%  \caption{\small{Polyhedral Compilation: the Polyhedral Reduced Dependence
%      (hyper) Graph (PRDG) serves as the intermediate representation.
%      Piecewise Quasi-Affine Functions (PQAFs) describe transformations.}}
%  \label{fig:compiler}
%\end{figure*}
%
%\subsection{Polyhedral Compilation and Representation}
%
%Figure~\ref{fig:compiler} shows the flow of polyhedral compilation.  First,
%dependence analysis of an input program (or a ``polyhedral section'' thereof)
%produces an intermediate representation (IR) in the form of~\cite{DRV-sched00}
%a \emph{Polyhedral Reduced Dependence (hyper) Graph} (PRDG).  Various analyses
%are performed on the PRDG to choose a number of mappings in the form of
%\emph{Piecewise Quasi-Affine Functions} (PQAFs) that specify the schedule as a
%set of \emph{multi-dimensional} vectors.  The PQAFs come with annotations to
%indicate whether each dimension is sequential or parallel, and also whether it
%is part of a \emph{tilable band}, i.e., whether tiling this band of dimensions
%is legal.  The transformations may be applied to the PRDG iteratively, and
%(eventually) the PRDG and QLAF are provided to a code-generator that produces
%code for various targets.
%
%One of the strengths of the polyhedral model is that a parametric program may
%be concisely represented with a PRDG with finite number of nodes (statements)
%and edges (dependences).  The potentially unbounded sets of instances of a
%statement are represented in abstract forms of integer sets, called
%\emph{domains}, and dependences between them as affine functions (or
%relations, which are viewed as a set-valued function) over these statement
%domains.  Indeed, every edge, $e$ from node $v$ to $w$, in the PRDG is
%annotated with two objects: (i) a domain, $D_e$ specifying the (subset of) the
%domain, $D_v$ of its source node, where the dependence occurs, and (ii) the
%affine function, $f$, such that for any point $z\in D_e$, the (set of)
%point(s) in $D_w$ on which it depends is given by $f(z)$.  $D_e$ is called the
%context of the edge, and $f$ is its dependence function.  We also use the
%notation $f(D_e)$ to denote the set valued image of $D_e$ by $f$.
%
%An affine function $\mathbb{Z}^n \rightarrow \mathbb{Z}^m$ may be expressed as
%$f(x) = A\vec{x} + \vec{b}$, where $\vec{x}$, function domain, is an integer
%vector of size $n$; $A$, linear part, is an $n\times m$ matrix; and $\vec{b}$,
%constant part, is an integer vector of size $m$.  A dependence is said to be
%uniform if the dependence function is only a constant offset, i.e., when the
%linear part $A$ is the identity.
%

%Why we do not expect execution time of COT to
%outperform wavefront tiling irrespective of lower LLC misses count.

% \begin{algorithm}[h]
%   \mbox{}

%   \begin{enumerate}
%   \item Extract Polyhedral Representation from C program
%   \item Determine per statement $s$ target mapping/schedule that specifies,
%     \begin{enumerate}
%     \item sequential dimensions
%     \item tilable band(s)
%     \end{enumerate}
%   \item Transform IR to above schedule
% 	\item Choose memory mappings
% 	\item Generate cache oblivious code
%   \end{enumerate}
%   \caption{PCOT: Polyhedral Cache Oblivious Tiling}
%   \label{alg:pcot}
% \end{algorithm}

% Local Variables: ***
% TeX-master: "PACT17.tex" ***
% fill-column: 78 ***
% End: ***
