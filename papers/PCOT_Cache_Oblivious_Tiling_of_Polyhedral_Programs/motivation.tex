\section{Motivations for Empirical Study}
\label{sec:motivations}
The key question that we try to answer is when and why we should use standard
iteration space tiling over cache oblivious tiling.  The two approaches
perform similar partitioning of the iteration space, but the schedules given
to the partitions are different.  Theoretically, cache oblivious code seems to
have advantages over iteration space tiling.  However, many factors complicate
the actual performance, which made our initial experiments difficult to
interpret.  In this section, we describe the obstacles between the theory and
practice we have identified.

We use Single-Level Tiling (SLT) for iteration space tiling, and Cache
Oblivious Tiling (COT) for cache oblivious techniques in this
paper, which are further described in Section~\ref{sec:background}.

\paragraph{Recursion Overhead} This is a well-known overhead of
COT~\cite{yotov2007experimental}.  The recursion introduces overheads, such as
function call overhead, and increased register pressure.  Furthemore, the
functions force inter-procedural analysis/optimization, known to be more
difficult for compilers well.  Thus, the leaf tiles must be ``sufficiently
large'' to avoid excessive overhead due to the recursion.

 \paragraph{Recursive Split Constraints the Tile Sizes} In typical cache
 oblivious algorithms, the problem is recursively split into halves in each
 dimension. This is in fact a rather coarse-grained exploration of the
 hierarchical partitioning of the iteration space. For instance, if the
 current problem size is $B^3$, then the next sub-problem would be
 $(\frac{B}{2})^3$.  If the best problem size for utilizing a level of cache
 is $(B-x)^3$ where $x\ll \frac{B}{2}$ then the subproblems due to
 divide-and-conquer will not match the best.  This is another factor that
 necessitates fine tuning of leaf tile sizes even for COT, since the utilization
 rate of L1 cache has strong impact on performance.  

%\paragraph{COT Leads to Imbalanced Tiles} Current COT tools recursively split
%the problem into halves in each dimension.  If the original bounds are not
%powers of two, every power-of-two leaf will be paired with a non-power-of-two
%leaf.  Since leaf tile sizes are often carefully tuned, thismeans that half
%the leaves will be suboptimal.  Our code generator incorporates a simple
%optimization that ensures that such suboptimal leaf nodes only occur at the
%boundaries of the iteration space.

\paragraph{COT has more Conflict Misses} The divide-and-conquer execution
order may negatively affect cache interference, especially with high
dimensional data.  This happens when the memory is allocated such that the
accesses are contiguous along some direction in the iteration space (typically
along innermost canonical axis).  With lexicographic order of execution, this
contiguity is largely preserved in the tiled execution.  However,
divide-and-conquer executes neighboring tiles in all dimensions, and many of
those tiles access some distant location in memory.  In contrast to accessing
contiguous regions of memory, accessing various segments of the memory
increases the chances of conflicts.

\paragraph{Hardware Prefetching}  Modern architectures are equipped with
hardware prefetchers that can bring data to the L1 cache. When
having sufficient locality at L2 or LLC makes the program compute-bound, then
the latency to L2/LLC can be hidden by the prefetcher. For such programs, it is
unnecessary to tile for the fastest cache, and larger tiles targeting slower
caches improve performance by maximizing prefetcher
effectiveness~\cite{mehta2016turbotiling}. When the primary objective is speed,
the leaf tiles for COT should also be large, which negates the benefit of
divide-and-conquer, as the leafs are already targeting slower caches.
Prefetching have little impact on parallel executions, since prefetching is
bandwidth limited. When multiple cores try to prefetch at the same time,
the bandwidth limit is quickly reached, and the latency hiding effect is
lost. Furthermore, smaller tile sizes are better for parallel execution for
load balancing  reasons.


These factors limit the effectiveness of COT in various ways and are also
closely tied to the characteristics of the computation. Our empirical study
illustrate the impact of these factors on polyhedral computations.

% Local Variables: ***
% TeX-master: "TACO2017.tex" ***
% fill-column: 78 ***
% End: ***
