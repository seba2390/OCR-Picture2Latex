CompCert Clight is a deterministic (up to system I/O) subset of C with
no side effects in expressions, and actual byte-level representation
of values. Clight has a realistic formal
semantics \cite{Blazy-Leroy-Clight-09,compcert-url} and tractable
enough to carry out the correctness proofs of our transformations
from \lamstar to C.
More importantly, Clight is the source language of the CompCert compiler
backend, which we can
thus leverage to preserve at least safety and functional correctness properties
of \lowstar programs down to assembly.\footnote{As a subset of C,
Clight can be compiled by any C compiler, but only CompCert provides
formal guarantees.}

Recall that we need to produce an event in the trace whenever a memory
location is read or written, and whenever a conditional branch is
taken, to account for memory accesses and statements in the semantics
of the generated Clight code for the purpose of our noninterference
security guarantees. However, the semantics of CompCert
Clight \emph{per se} produces no events on memory accesses; instead,
CompCert provides a syntactic program annotation mechanism using
no-op \emph{built-in calls}, whose only purpose is to add extra events
in the trace. Thus, we leverage this mechanism by prepending each
memory access and conditional statement in the Clight generated code
with one such built-in call producing the corresponding events.

The main two
differences between \cstar and Clight, which our translation deals
with as described below, are immutable local structures, and scope management
for local variables.

\paragraph{Immutable local structures}
\cstar handles immutable local structures as
first-class values, whereas Clight only supports non-compound
data (integers, floating-points or pointers) as values.

If we naively translate immutable local \cstar structures to C structures in
Clight, then CompCert will allocate them in memory.
This increases the number of memory accesses, which not only
introduces discrepancies in the security preservation proof from \cstar
to Clight, but also introduces significant performance
overhead compared to GCC, which optimizes away structures whose
addresses are never taken.

Instead, we split an immutable structure into the sequence of all its
non-compound fields, each of which is to be taken as a potentially
non-stack-allocated local variable,\footnote{Our benchmark without
this structure erasure runs 20\% slower than with structure erasure,
both with CompCert 2.7.
% on a 4-core Intel Core i7 1.70 GHz laptop.
% with 8 Gb RAM running Ubuntu 14.04.
Without structure erasure, code
generated with CompCert is 60\% slower than with
{\tt gcc -O1}. CompCert-generated code without structure erasure may even
segfault, due to stack overflow, which structure erasure successfully
overcomes.} except for functions that return structures, where, as
usual, we add, as an extra argument to the callee, a pointer to the
memory location written to by the callee and read by the caller.

\paragraph{Local variable hoisting}
Scoping rules for \cstar local arrays are not exactly the same as in
C, in particular for branches of conditional statements. So, it is
necessary to hoist all local variables to function-scope.  CompCert
2.7.1 does support such hoisting but as an unproven elaboration
step. While existing formal proofs (e.g., Dockins'
\cite[\S 9.3]{dockins-phd}) only prove functional
correctness, we also prove preservation of security guarantees, as
shown below.

\paragraph{Proof techniques}
Contrary to the \lamstar-to-\cstar transformation, our subsequent
passes modify the memory layout leading to differences in traces
between \cstar to Clight, due to pointer values. Thus, we need to
address security preservation separately from functional correctness.

   For each pass changing the memory layout, we split it into three
    passes. First, we \emph{reinterpret} the program by replacing each
    pointer value in event traces with the function name and recursion
    depth of its function call, the name of the corresponding local
    variable, and the array index and structure field name within this
    local variable. Then, we perform the actual transformation and
    prove that it exactly preserves traces in this new ``abstract''
    trace model. Finally, we reinterpret the generated code back to
    concrete pointer values.  We successfully used this technique to
    prove functional correctness and security preservation for
    variable hoisting.
    
  For each pass that adds new memory accesses, we split it into
    two passes. First, a reinterpretation pass produces new events
    corresponding to the provisional memory accesses (without actually
    performing those memory accesses). Then, this pass is followed by
    the actual trace-preserving transformation that goes back to the
    non-reinterpreted language but adds the actual memory accesses
    into the program.
    We successfully used this technique to prove functional
    correctness and security preservation for structure return, where
    we add new events and memory accesses whenever a \cstar function
    returns a structure value.

In both cases, we mean \emph{reinterpretation} as defining a new
language with the same syntax and small-step semantic rules except
that the produced traces are different, and relating executions of
the same program in the two languages. There, it is easy to prove
functional correctness, but for security preservation, we need to
prove an invariant on two small-step executions of the same program
with different secrets, to show that two equal pointer values in event
traces coming from those two different executions will actually turn
into two equal abstract pointer values in the reinterpreted language.

%% For reinterpretations, it is easy to prove functional correctness.
%% For security preservation, we prove an invariant on two small-step
%% executions of the same program with different secrets, so that they
%% produce the same trace in each of the two trace models before and
%% after reinterpretation.
%% For hoisting, reinterpretation replaces each pointer value in event
%% traces with the function name and recursion depth of its function
%% call, the name of the corresponding local variable, and the array
%% index and structure field name within this local variable.  For
%% structure return, reinterpretation produces new events corresponding
%% to the memory accesses that will be added by the actual
%% transformation, but without actually performing them at first in the
%% reinterpreted semantics.
Our detailed functional correctness and security preservation proofs
from \lamstar to Clight can be found in the appendix.

\paragraph{Towards verified assembly code}
We conjecture that our reinterpretation techniques can be generalized to most passes
of CompCert down to assembly. %% , since we believe that accesses to stack-allocated
%% variables are in most cases exactly preserved by compilation, and any
%% reordering, removal or addition of memory accesses (in the case of
%% register allocation and spilling, to constant offsets within the
%% stack) is made without introducing spurious tests, and thus in a
%% secret-independent way}
While we leave such generalization as future work, some guarantees
from C to assembly can be derived by instrumenting CompCert \cite{barthe-ccs2014}
and LLVM \cite{DBLP:conf/popl/ZhaoNMZ12,DBLP:conf/pldi/ZhaoNMZ13,almeida-usenix2016} 
and turning them into \emph{certifying} (rather than certified) compilers where
security guarantees are statically rechecked on the compiled code
through translation validation, thus re-establishing them
independently of source-level security proofs. In this case, rather
than being fully preserved down to the compiled code,
\lowstar-level proofs are still useful to \emph{practically} reduce the
risk of failures in translation validation.
%% By contrast, applying our
%% proof-preservation techniques to CompCert aims to avoid this further
%% compile-time check, eliminating the risk of compilation
%% failures.
\ch{Can we make this much shorter? it talks about applying
  something we didn't show at all to other layers.}
