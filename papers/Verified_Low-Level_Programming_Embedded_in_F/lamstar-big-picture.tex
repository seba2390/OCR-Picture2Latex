%% \jp{I feel like most of this has been said in the intro; what hasn't been said,
%% e.g. the precise specification of noninterference, perhaps is better suited to
%% the specific section.}

Figure~\ref{fig:bigpicture} on page~\pageref{fig:bigpicture} provides
an overview of our translation from \lowstar to CompCert Clight,
%
starting with \emf, a recently proposed model
of \fstar~\cite{dm4free}; then \lamstar, a formal core of \lowstar
after all erasure of ghost code and specifications; then \cstar, an
intermediate language that switches the calling convention closer to
C; and finally to Clight.
%
In the end, our theorems establish that: (a) the safety and functional
correctness properties verified at the \fstar level carry on to the
generated Clight code (via semantics preservation), and (b) \lowstar
programs that use the secrets parametrically enjoy the trace
equivalence property, at least until the Clight level, thereby
providing protection against side-channels.


%% , and show that
%% it preserves the functional behavior as well as the secret-independent
%% traces (\sref{to-clight}).  whose calling convention is close to that
%% of Clight

%% and show that erasing preserves verification. Then, following the
%% \emfST semantics of primitive state proposed
%% in~\cite{dm4free}, we present \lamstar, a formal core of \lowstar with
%% primitive stack-based allocation. We prove that \lamstar programs that
%% use secrets parametrically have secret-independent traces
%% (\sref{lamstar}). Next we present \cstar, an intermediate language
%% whose calling convention is close to that of Clight, but whose scoping
%% structure is closer to that of \lamstar. We translate \lamstar
%% to \cstar proving it a bisimulation
%% (\sref{lamstar-to-cstar}). Finally, we translate \cstar to CompCert
%% Clight, and show that it preserves the functional behavior as well as
%% the secret-independent traces (\sref{to-clight}).


\paragraph*{Prelude: Internal transformations in \emf}
We begin by briefly describing a few internal transformations on \emf,
focusing in the rest of this section on the pipeline from \lamstar to
Clight---the formal details are in the appendix. To express
computational irrelevance, we extend \emf with a primitive \kw{Ghost}
effect. An erasure transformation removes ghost subterms, and we prove
that this pass preserves semantics, via a logical relations
argument. Next, we rely on a prior result~\cite{dm4free} showing
that \emf programs in the \lst$ST$ monad can be safely reinterpreted
in \emfST, a calculus with primitive state. We obtain an instance
of \emfST suitable for \lowstar by instantiating its state type
with \lst$HyperStack.mem$. To facilitate the remainder of the
development, we transcribe \emfST to \lamstar, which is a restriction
of \emfST to first-order terms that only use stack memory, leaving the
heap out of \lamstar, since it is not a particularly interesting
aspect of the proof. This transcription step is essentially
straightforward, but is not backed by a specific proof. We plan to
fill this gap as we aim to mechanize our entire proof in the future.

%% and introduce
%% \lamstar, a formal core of \lowstar (\sref{lamstar}).
%% We have not yet formally proven
%% the simulation between \emf and \lamstar,


%% \paragraph{Primitive state} While the state effect in \emf is a
%% user-defined effect, parametric in the state, Ahman et
%% al.~\cite{dm4free} also present \emfST, a calculus with primitive
%% state, and prove a simulation between \emfST and
%% \emf. Relying on this result, we instantiate the
%% memory model of \emfST with stack-based memory,\ch{what's stack-based memory?
%%   you mean hyper-stacks? or you mean the hyper-stack part without the heap
%%   part ... this should be made explicit} and introduce
%% \lamstar, a formal core of \lowstar (\sref{lamstar}).
%% We have not yet formally proven
%% the simulation between \emf and \lamstar, but we conjecture that the
%% proof will be along similar lines as Ahman et al.
\nik{Mention non-termination here?}




%% The goal of our work is to provide users with a development and
%% verification environment consisting of a high-level language, \lowstar
%% (a subset of \fstar,) a compiler from \lowstar to C,
%% and \lowstar-level verification technology, such that their
%% combination establishes the following formal guarantees on the
%% extracted C code:
%% \begin{itemize}
%% \item \emph{safety:}
%% the extracted C program must not crash or reach any inconsistent state
%% leading to undefined behaviors. In particular, no out-of-bounds memory
%% accesses, or through dangling pointers, must ever occur (\emph{memory
%% safety}.)
%% \item \emph{functional correctness:}
%% the user should be able to specify, at the \lowstar level, whether the
%% extracted C program should diverge or terminate, and the return value
%% in the latter case, and the extracted C program must follow such
%% user-defined specification.
%% \item \emph{security:}
%% the extracted C program must be free of side channels. In this paper,
%% we focus on the following two sources of side channels:
%% \begin{itemize}
%% \item \emph{memory access noninterference:}
%% two executions of the same program starting from different secrets
%% perform the same sequence of memory accesses (although the actual
%% values stored in memory may differ), so that an attacker cannot
%% distinguish two such executions through memory cache-based side
%% channels.
%% \item \emph{control flow noninterference:}
%% two executions of the same program starting from different secrets
%% follow the same control flow. In the \emph{program counter model},
%% this property implies that two such executions will actually execute
%% the same sequence of instructions, so that an attacker cannot
%% distinguish them through time or energy-based side channels.
%% \end{itemize}
%% \end{itemize}

%% Our approach is to leverage \fstar's strong type system with dependent
%% types, so that any well-typed \lowstar program enjoys all of the above
%% safety, functional correctness and security properties. Then, we prove
%% that extraction from \lowstar to C preserves all those guarantees down
%% to the extracted C code.

%% \paragraph{Summary of passes}
%% \jp{This high-level overview has been mentioned in the intro\ldots what about
%% condensing it to: ``The following sections present \lowstar and erasure, then
%% \lamstar and the two translation steps to C and Clight''?}
%% In Section~\ref{sec:lowstar}, we define the \lowstar source
%% language, as a subset of \fstar, allowing the
%% user to augment their programs with specifications as \emph{ghost
%% code}.  Then, we describe how those specifications are erased in a
%% semantics-preserving and security-preserving way.

%% Then, in Section~\ref{sec:lamstar}, we formally define the \lamstar
%% language, and we describe how \lowstar programs obtained after
%% erasure, are reinterpreted in \lamstar. Then, we prove that
%% well-typed \lamstar programs make our security properties hold.

%% Then, in Section~\ref{sec:low-to-c}, we describe the \cstar language,
%% which we design as closely as possible to a subset of C, and we
%% present the transformation from \lamstar to \cstar and its proof.

%% Finally, in Section~\ref{sec:to-clight}, we transform \cstar programs
%% into C programs, with our correctness proof, where the target language
%% is actually the Clight \cite{} subset of C formally specified in CompCert \cite{}.
