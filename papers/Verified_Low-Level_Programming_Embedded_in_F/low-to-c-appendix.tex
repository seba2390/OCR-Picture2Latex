\section{Big-stepping a small-step semantics}

Actual observable behaviors will not account for the detailed
sequence of small-step transitions taken. Given an execution first
represented as the sequence of its transition steps from the initial
state, we follow CompCert to derive an observable behavior by only
characterizing termination or divergence and collecting the event
traces, thus erasing all remaining information about the execution
(number of transition steps, sequence of configurations, etc.)  by
\emph{big-stepping} the small-step semantics as shown in
Figure~\ref{fig:bigstep}.

\begin{figure}[!htbp]
  \begin{mathpar}
  \arraycolsep=1.4pt\def\arraystretch{3.2}

\inferrule*
{
  s_0 \stackrel{t_0}{\rightarrow} s_1 \stackrel{t_1}{\rightarrow} \dots \stackrel{t_{n-2}}{\rightarrow} s_{n-1}\stackrel{t_{n-1}}{\rightarrow} s_n \\
  s_0 ~ \text{initial} \\
  s_n ~ \text{final with return value} ~ r \\
  t = t_0 ; t_1 ; \dots ; t_{n-2} ; t_{n-1}
}
{
  \kw{Terminates}(t, r)
}

\\

\inferrule*
{
  s_0 \stackrel{t_0}{\rightarrow} s_1 \stackrel{t_1}{\rightarrow} \dots \\
  s_0 ~ \text{initial} \\
  T = t_0 ; t_1 ; \dots
}
{
  \kw{Diverges}(T)
}

\\

\inferrule*
{
  s_0 \stackrel{t_0}{\rightarrow} s_1 \stackrel{t_1}{\rightarrow} \dots \stackrel{t_{n-2}}{\rightarrow} s_{n-1}\stackrel{t_{n-1}}{\rightarrow} s_n \\
  s_0 ~ \text{initial} \\
  s_n ~ \text{not final} \\
  t = t_0 ; t_1 ; \dots ; t_{n-2} ; t_{n-1}
}
{
  \kw{GoesWrong}(t)
}
\end{mathpar}
\caption{Big-stepping a small-step semantics}
\label{fig:bigstep}
\end{figure}

\section{\cstar and \lamstar Definition}

Notations used in the document are summarized in Figure \ref{fig:notations}.
Function name $f$ and variable name $x$ are of different syntax classes. A term
is closed if it does not contain unbound variables (but can contain function
names). The grammar of \cstar and \lamstar are listed in Figure \ref{fig:cstar-syntax}
and \ref{fig:lowstar-syntax} respectively. \cstar syntax is defined in such a way
that \cstar expressions do not have side effects (but can fail to evaluate because
of e.g. referring to a nonexistent variable). Locations, which only appear during reduction, consist
of a block id, an offset and a list of field names (a ``field path''). The
``getting field address'' syntax $\eptrfd{e}{fd}$ is for constructing a pointer
to a field of a struct pointed to by pointer $e$.

In \lamstar syntax, buffer allocation, buffer write and function application (as well as mutable struct allocation, mutable struct write) are
distinctive syntax constructs (not special cases of let-binding). In this way we
force effectful operations to be in let-normal-form, to be aligned with \cstar (\cstar
does not allow effectfull expressions because of C's nondeterministic expression
evaluation order). Let-binding and anonymous let-binding are also distinctive
syntax constructs, because they need to be translated into different \cstar
constructs. Locations and $\epop\;le$ only appear during reduction.

The operational semantics of \cstar is listed in Figure \ref{fig:cstar-expr-eval}
and \ref{fig:cstar-stmts-reduction}. Because C expressions do not have a
deterministic evaluation order, in \cstar we use a mixed big-step/small-step
operational semantics, where \cstar expressions are evaluated with big-step
semantics defined by the evaluation function (interpreter) $\eval{e}{(p,V)}$,
while \cstar statements are evaluated with small-step semantics. Definitions used in
\cstar semantics are summarized in Figure \ref{fig:cstar-semantics-defs}. A \cstar
evaluation configuration $C$ consist of a stack $S$, a variable assignment $V$
and a statement list $ss$ to be reduced. A stack is a list of frames. A frame
$F$ includes frame memory $M$, variable assignment $V$ to be restored upon
function exit, and continuation $E$ to be restored upon function exit. Frame
memory $M$ is optional: when it is none, the frame is called a ``call frame'';
otherwise a ``block frame''. A frame memory is just a partial map from block ids
to value lists.

Both \cstar and \lamstar reductions generate traces that include memory read/write with
the address, and branching to true/false. Reduction steps that don't have these
effects are silent.

\begin{figure}[!htbp]
\begin{center}
  \begin{tabularx}{\columnwidth}{lRlR}
    $\ls{a}$ & list &
    $\option{a}$ & option $a$ \\
    $\None$ & None &
    $\Some{a}$ & Some a \\
    $n$ & integer &
    $x$ & variable name \\
    $f$ & function name &
    $fd$ & field name \\
    $a\sympartial b$ & partial map & $\{\}$ & empty map \\
    $\{x\mapsto a\}$ & singleton map & $m[x\mapsto a]$ & map update \\
    $[]$ & empty list & $a;b$ & list concat or cons \\
    $\subst{x}{a}{b}$ & substitute $a$ for $x$ in $b$ & & \\
  \end{tabularx}
\end{center}
\caption{Notations}
\label{fig:notations}
\end{figure}

\subsection{\cstar Definition}

The following are the definitions of the syntax and operational semantics of \cstar.

\begin{figure}[!htbp]
\begin{center}
  \begin{tabularx}{\columnwidth}{rlR}
    $p ::= $ & & program \\
      & $\ls d$                      & series of declarations \\[1.2mm]

    $d ::= $ & & declaration \\
      & $\ecfun fxtt{ss}$                & top-level function \\
    & $\evardecl txv$               & top-level value \\
    [1.2mm]

    $ss ::= $ & & statement lists \\
    & $\ls{s}$                  &  \\
    [1.2mm]

    $s ::= $ & & statements \\
    & $\evardecl txe$                  & immutable variable declaration \\
    & $\earray txn$                & array declaration \\
    & $\memset{e}{n}{e}$                & memory set \\
    & $\evardecl{t}{x}{\eapply fe}$    & application \\
    & $\evardecl{t}{x}{\eread e}$      & read \\
    & $\ewrite ee$               & write \\
    & $\eif{e}{ss}{ss}$ & conditional \\
    & \{\stmts\} &  block \\
    & e & expression \\
    & \ereturn e & return \\
    [1.2mm]

    $e ::= $ & & expressions \\
    & $n$    & integer constant \\
    & $()$ & unit value \\
      %% & $\ecifthenelse eee$           & conditional \\
      %% & $\esequence {\vec s}e$        & sequence \\
      %% & $\eapply fe$                  & application \\
      & $x$                           & variable \\
      & $e_1+e_2$                        & pointer add ($e_1$ is a pointer and $e_2$ is an $\kw{int}$) \\
    & $\{\ls{fd=e}\}$ & struct \\
    & $e.fd$ & struct field projection \\
    & $\eptrfd{e}{fd}$ & struct field address ($e$ is a pointer) \\
    & $loc$                        & location \\
    [1.2mm]

    $loc ::= $ & & locations \\
    & $(b, n, \ls{fd})$ &  \\

  \end{tabularx}
\end{center}
\caption{\cstar Syntax}
\label{fig:cstar-syntax}
\end{figure}


\begin{figure}[!htbp]
\begin{small}
\begin{center}
  \begin{tabularx}{\columnwidth}{rlR}

    $v ::= $ & & values \\
    & $n$    & constant \\
    & $()$ & unit value \\
    & $\{\ls{fd=v}\}$ & constant struct \\
    & $loc$                        & location \\
    [1.2mm]

    $E ::=$ & & evaluation ctx (plug expr to get stmts) \\
    & $\symhole; ss$ & discard returned value \\
    & $t\;x=\symhole; ss$ & receive returned value \\
    [1.2mm]

    $F ::=$ & & frames \\
    & $(\None, V, E)$ & call frame \\
    & $(\Some{M}, V, E)$ & block frame \\
    [1.2mm]

    $M ::=$ & & memory \\
    & $b\sympartial \ls{\option{v}}$ & map from block id to list of optional values \\
    [1.2mm]

    $V ::=$ & & variable assignments \\
    & $x\sympartial v$ & map from variable to value \\
    [1.2mm]

    $S ::=$ & & stack \\
    & $\ls{F}$ & list of frames \\
    [1.2mm]

    $C ::=$ & & configuration \\
    & $(S, V, ss)$ &  \\
    [1.2mm]

    $l ::=$ & & label \\
    & $\symread\;loc$ & read \\
    & $\symwrite\;loc$ & write \\
    & $\brt$ & branch true \\
    & $\brf$ & branch false \\

  \end{tabularx}
\end{center}
\end{small}
\caption{\cstar Semantics Definitions}
\label{fig:cstar-semantics-defs}
\end{figure}

\begin{figure*}[!htbp]
\begin{small}
\begin{flushleft}
\fbox{$\eval{e}{(p, V)}=v$}
\end{flushleft}
\begin{mathpar}

\inferrule* [Right=Var]
{
  V(x) = v
}
{
  \eval{x}{(p,V)}=v
}

\quad
\quad
\quad

\inferrule* [Right=PtrAdd]
{
  \eval{e_1}{(p,V)} = (b, n, []) \\
  \eval{e_2}{(p,V)} = n' \\
}
{
  \eval{e_1+e_2}{(p,V)}=(b, n+n', [])
}

\\

\inferrule* [Right=PtrFd]
{
  \eval{e}{(p,V)} = (b, n, \ls{fd}) \\
}
{
  \eval{\eptrfd{e}{fd}}{(p,V)}=(b, n, \ls{fd};fd)
}

\quad
\quad
\quad

\inferrule* [Right=GVar]
{
  x\not\in V \\
  p(x) = v
}
{
  \eval{x}{(p,V)}=v
}

\quad
\quad
\quad
\quad

\inferrule* [Right=NonMutStruct]
{
  \;
}
{
  \eval{\{\ls{fd=e}\}}{(p,V)}=\{\ls{fd=\eval{e}{(p,V)}}\}
}

\\

\inferrule* [Right=Proj]
{
  \eval{e}{(p,V)}=\{\ls{fd=v}\} \\
  \{\ls{fd=v}\}(fd')=v'
}
{
  \eval{e.fd'}{(p,V)}=v'
}

\quad
\quad
\quad
\quad

\inferrule*[Right=Val]
{
}{
  \eval{v}{(p,V)} = v
}
\end{mathpar}
\end{small}
\caption{\cstar Expression Evaluation}
\label{fig:cstar-expr-eval}
\end{figure*}


\begin{figure*}[!htbp]
\begin{small}
\begin{flushleft}
\fbox{$p \vdash C\step_l C'$}
\end{flushleft}
\begin{mathpar}
\inferrule* [Right=VarDecl]
{
  \eval{e}{(p,V)}=v
}
{
  p \vdash (S, V, t\;x=e; ss) \step (S, V[x\mapsto v], ss)
}

\quad
\quad
\quad
\quad
\quad
\quad

\inferrule* [Right=ArrDecl]
{
  S = S'; (M, V, E) \\
  b\not\in S
}
{
  p \vdash (S, V, t\;x[n]; ss) \step (S';(M[b\mapsto \None^n], V, E), V[x\mapsto (b, 0, [])], ss)
}

\\

\inferrule* [Right=Memset]
{
  \eval{e_1}{(p, V)} = (b, n, []) \\
  \eval{e_2}{(p, V)} = v \\
  \symset(S, (b, n, []), v^m) = S'
}
{
  p \vdash (S, V, \memset{e_1}{m}{e_2}; ss) \step_{\symwrite\;(b,n,[]), \dots, \symwrite\;(b,n+m-1,[])} (S', V, ss)
}

\\

\inferrule* [Right=Read]
{
  \eval{e}{(p, V)} = (b, n, \ls{fd}) \\
  \symget(S, (b, n, \ls{fd})) = v
}
{
  p \vdash (S, V, t\;x=*[e]; ss) \step_{\symread\;(b,n,\ls{fd})} (S, V[x\mapsto v], ss)
}

\quad
\quad
\quad
\quad

\\

\inferrule* [Right=Write]
{
  \eval{e_1}{(p, V)} = (b, n, \ls{fd}) \\
  \eval{e_2}{(p, V)} = v \\
  \symset(S, (b, n, \ls{fd}), v) = S'
}
{
  p \vdash (S, V, *e_1=e_2; ss) \step_{\symwrite\;(b,n,\ls{fd})} (S', V, ss)
}

\quad
\quad
\quad
\quad
\quad

\inferrule* [Right=Ret]
{
  \eval{e}{(p,V)}=v
}
{
  p \vdash (S;(\None, V',E), V, \ereturn\;e; ss) \step (S, V', \fplug{E}{v})
}

\\

\inferrule* [Right=Call]
{
  p(f)=\ecfuntwo{y}{t_1}{t_2}{ss_1} \\
  \eval{e}{(p,V)}=v
}
{
  p \vdash (S, V, t\;x=f\;e; ss) \step (S;(\None, V, t\;x=\symhole;ss), \{\}[y\mapsto v], ss_1)
}

\quad
\quad
\quad
\quad

\inferrule* [Right=RetBlk]
{
  \eval{e}{(p,V)}=v
}
{
  p \vdash (S;(M, V',E), V, \ereturn\;e; ss) \step (S, \{\}, \ereturn\;v)
}

\\

\inferrule* [Right=Expr]
{
  \eval{e}{(p,V)} = v
}
{
  p \vdash (S, V, e; ss) \step (S, V, ss)
}

\quad
\quad
\quad
\quad

\inferrule* [Right=Empty]
{
  \;
}
{
  p \vdash (S; (M, V', E), V, []) \step (S, V', \fplug{E}{()})
}

\\

\inferrule* [Right=Block]
{
  \;
}
{
  p \vdash (S, V, \{ss_1\};ss_2) \step (S;(\{\},V,\symhole;ss_2), V, ss_1)
}

\\

\inferrule* [Right=IfT]
{
  \eval{e}{(p,V)} = n \\
  n\not=0
}
{
  p \vdash (S, V, \eif{e}{ss_1}{ss_2};ss) \step_\brt (S, V, ss_1;ss)
}

\quad
\quad
\quad

\inferrule* [Right=IfF]
{
  \eval{e}{(p,V)} = n \\
  n=0
}
{
  lp \vdash (S, V, \eif{e}{ss_1}{ss_2};ss) \step_\brf (S, V, ss_2;ss)
}

\end{mathpar}
\end{small}
\caption{\cstar Configuration Reduction}
\label{fig:cstar-stmts-reduction}
\end{figure*}

\clearpage

\subsection{\lamstar Definition}

The following are the definitions of the syntax and operational semantics of \lamstar.

\begin{figure}[!htbp]
%% \begin{figure}[H]
\begin{center}
  \begin{tabularx}{\columnwidth}{rlR}
    $lp ::= $ & & program \\
      & $\ls{ld}$                      & series of declarations \\[1.2mm]

    $ld ::= $ & & declaration \\
      & $\etlet{x}{\lambda y:t.\;le:t}$                & top-level function \\
    & $\etlet{x:t}{v}$               & top-level value \\
    [1.2mm]

    $le ::= $ & & expressions \\
    & $n$    & constant \\
    & $()$ & unit value \\
    & $x$                           & variable \\
    & $\{\ls{fd=le}\}$ & struct as value \\
    & $le.fd$ & immutable struct field projection \\
    & $\estructfield{le}{fd}$           & sub-structure: mutable structure field projection \\
    & $\esubbuf{le}{le}$                & sub-buffer \\
    & $\eif {le}{le}{le}$            & conditional \\
    & $\elet{x:t}{le}{le}$                   & let-binding \\
    & $\elet{\_}{le}{le}$                   & anonymous let-binding \\
    & $\elet{x:t}{f\;le}{le}$                   & application \\
    & $\elet{x}{\enewbuf{n}{(le:t)}}{le}$                 & new buffer \\
    & $\elet{x:t}{\ereadbuf {le}{le}}{le}$  & read from buffer \\
    & $\elet{\_}{\ewritebuf{le}{le}{le}}{le}$              & write to buffer \\
    & $\elet{x}{\enewstruct{(le:t)}}{le}$                 & new mutable structure \\
    & $\elet{x:t}{\ereadstruct{le}}{le}$                & read from mutable structure \\
    & $\elet{\_}{\ewritestruct{le}}{le}$               & write to mutable structure \\
    & $\withframe\;le$ & with-frame \\
    & $\epop\;le$ & pop frame \\
    & $loc$                        & location \\
    [1.2mm]

  \end{tabularx}
\end{center}
\caption{\lamstar Syntax}
\label{fig:lowstar-syntax}
\end{figure}

\clearpage

\begin{figure}[!htbp]
  $$\begin{array}{rrcl}

    \multicolumn{4}{l}{\textrm{values}} \\
    & lv & ::= & n \mid () \mid \{\ls{fd=lv}\} \mid loc \\
    \\
    \multicolumn{4}{l}{\textrm{evaluation contexts}} \\
    & LE & ::= & \symhole \mid LE.fd \mid \estructfield{LE}{fd} \mid \{\ls{fd=lv};fd=LE;\ls{fd=le}\} \\
    & & \mid & \esubbuf{LE}{le} \mid \esubbuf{lv}{LE} \\
    & & \mid & \eif {LE}{le}{le} \\
    & & \mid & \elet{x:t}{LE}{le} \mid \elet{\_}{LE}{le} \\
    & & \mid & \elet{x:t}{f\;LE}{le} \\
    & & \mid & \elet{x}{\enewbuf{n}{(LE:t)}}{le} \\
    & & \mid & \elet{x:t}{\ereadbuf{LE}{le}}{le} \\
    & & \mid & \elet{x:t}{\ereadbuf{lv}{LE}}{le} \\
    & & \mid & \elet{\_}{\ewritebuf{LE}{le}{le}}{le} \\
    & & \mid & \elet{\_}{\ewritebuf{lv}{LE}{le}}{le} \\
    & & \mid & \elet{\_}{\ewritebuf{lv}{lv}{LE}}{le} \\
    & & \mid & \elet{x}{\enewstruct{(LE:t)}}{le} \\
    & & \mid & \elet{x:t}{\ereadstruct{LE}}{le} \\
    & & \mid & \elet{\_}{\ewritestruct{LE}{le}}{le} \\
    & & \mid & \elet{\_}{\ewritestruct{lv}{LE}}{le} \\
    & & \mid & \epop\;LE \\
    \\
    \multicolumn{4}{l}{\textrm{stack}} \\
    & H & ::= & \ls{h} \\
    \\
    \multicolumn{4}{l}{\textrm{stack frame}} \\
    & h & ::= & b\sympartial \ls{v} \\

\end{array}$$
\caption{\lamstar Semantics Definitions}
\label{fig:lowstar-semantics-defs}
\end{figure}

\clearpage

\begin{figure*}[!htbp]
\begin{scriptsize}
\begin{flushleft}
\fbox{$lp \vdash (H, le) \astep_l (H', le')$}\quad\text{and}\quad
\fbox{$lp \vdash (H, le) \step_l (H', le')$}
\end{flushleft}
\begin{mathpar}

\inferrule* [Right=ReadBuf]
{
  H(b, n+n', []) = lv
}
{
  lp \vdash (H, \elet{x}{\ereadbuf{(b,n,[])}{n'}}{le}) \astep_{\symread\;(b,n+n',[])} (H, \subst{x}{lv}{le})
}

\\


\inferrule* [Right=ReadStruct]
{
  H(b, n, \ls{fd}) = lv
}
{
  lp \vdash (H, \elet{x}{\ereadstruct{(b,n,\ls{fd})}}{le}) \astep_{\symread\;(b,n,\ls{fd})} (H, \subst{x}{lv}{le})
}

\\

\inferrule* [Right=App]
{
  lp(f)=\lambda y:t_1.\;le_1:t_2
}
{
  lp \vdash (H, \elet{x:t}{f\;v}{le}) \astep (H, \elet{x:t}{\subst{y}{v}{le_1}}{le})
}

\\

\inferrule* [Right=WriteBuf]
{
  (b,n+n',[])\in H
}
{
  lp \vdash (H, \elet{\_}{\ewritebuf{(b,n,[])}{n'}{lv}}{le}) \astep_{\symwrite\;(b,n+n',[])} (H[(b, n+n',[])\mapsto lv], le)
}

\\

\inferrule* [Right=WriteStruct]
{
  (b,n,\ls{fd})\in H
}
{
  lp \vdash (H, \elet{\_}{\ewritestruct{(b,n,\ls{fd})}{lv}}{le}) \astep_{\symwrite\;(b,n,\ls{fd})} (H[(b, n,\ls{fd})\mapsto lv], le)
}

\\

\inferrule* [Right=Subbuf]
{
  \;
}
{
  lp \vdash (H, \esubbuf{(b,n,[])}{n'}) \astep (H, (b, n+n',[]))
}


\\

\inferrule* [Right=StructField]
{
  \;
}
{
  lp \vdash (H, \estructfield{(b,n,\ls{fd})}{fd'}) \astep (H, (b, n, (\ls{fd}; fd')))
}

\\

\inferrule* [Right=Let]
{
  \;
}
{
  lp \vdash (H, \elet{x:t}{v}{le}) \astep (H, \subst{x}{v}{le})
}

\quad
\quad
\quad

\inferrule* [Right=ALet]
{
  \;
}
{
  lp \vdash (H, \elet{\_}{v}{le}) \astep (H, le)
}

\quad
\quad
\quad
\quad

\inferrule* [Right=Proj]
{
  \{\ls{fd=lv}\}(fd') = lv'
}
{
  lp \vdash (H, \{\ls{fd=lv}\}.fd') \astep (H, lv')
}

\\

\inferrule* [Right=IfT]
{
  n\not=0
}
{
  lp \vdash (H, \eif{n}{le_1}{le_2}) \astep_\brt (H, le_1)
}

\quad
\quad
\quad

\inferrule* [Right=IfF]
{
  n=0
}
{
  lp \vdash (H, \eif{n}{le_1}{le_2}) \astep_\brf (H, le_2)
}

\\

\inferrule* [Right=NewBuf]
{
  b\not\in H
}
{
  lp \vdash (H, \elet{x}{\enewbuf{n}{(lv:t)}}{le}) \astep_{\symwrite\;(b,0,[]),\dots,\symwrite\;(b,n-1,[])} (H[b\mapsto lv^n], \subst{x}{(b, 0,[])}{le})
}

\\

\inferrule* [Right=NewStruct]
{
  b\not\in H
}
{
  lp \vdash (H, \elet{x}{\enewstruct{(lv:t)}}{le}) \astep_{\symwrite\;(b,0,[])} (H[b\mapsto lv], \subst{x}{(b, 0,[])}{le})
}

\\

\inferrule* [Right=WF]
{
  \;
}
{
  lp \vdash (H, \withframe\;le) \astep (H;\{\}, \epop\;le)
}

\quad
\quad
\quad

\inferrule* [Right=Pop]
{
  \;
}
{
  lp \vdash (H;h, \epop\;lv) \astep (H, lv)
}


\\

\inferrule* [Right=Step]
{
  lp \vdash (H, le) \astep_l (H', le')
}
{
  lp \vdash (H, \fplug{LE}{le}) \step_l (H', \fplug{LE}{le'})
}

\end{mathpar}
\end{scriptsize}
\caption{\lamstar Atomic Reduction and Reduction}
\label{fig:lowstar-reduction}
\end{figure*}

\newpage

\section{\lamstar to \cstar Compilation}

The compilation procedure is defined in Figure \ref{fig:lowtoc} as inference rules, which should be read as a function defined by pattern-matching, with earlier rules shadowing later rules. The compilation is a partial function, encoding syntactic constraints on \lamstar programs that can be compiled. For example, compilable \lamstar top-level functions must be wrapped in a $\withframe$ construct.


\begin{figure*}[!htbp]
\begin{scriptsize}
\begin{flushleft}
\fbox{$\lowtoce{le}=e$}\quad\text{and}\quad
\fbox{$\lowtoc{le}=ss$}\quad\text{and}\quad
\fbox{$\lowtocd{ld}=d$}
\end{flushleft}
\begin{mathpar}
\inferrule*
{
  \;
}
{
  \lowtoce{n} = n
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \lowtoce{(b,n,[])} = (b,n,[])
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \lowtoce{\{\ls{fd=le}\}} = \{\ls{fd=\lowtoce{le}}\}
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \lowtoce{x} = x
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \lowtoce{\esubbuf{le_1}{le_2}} = \lowtoce{le_1} + \lowtoce{le_2}
}

\\

\inferrule*
{
  \;
}
{
  \lowtoce{\estructfield{le}{fd}} = \eptrfd{\lowtoce{le}}{fd}
}


\\

\inferrule*
{
  \lowtoce{le}=e \\
  \lowtoc{le_1}=ss
}
{
  \lowtoc{(\elet{x:t}{f\;le}{le_1})} = (t\;x=f(e); ss)
}

\quad
\quad

\inferrule*
{
  \lowtoce{le_i}=e_i \;(i=1,2) \\
  \lowtoc{le}=ss
}
{
  \lowtoc{\elet{x:t}{\ereadbuf{le_1}{le_2}}{le}} = (t\;x=\eread{e_1+e_2};ss)
}

\\

\inferrule*
{
  \lowtoce{le_i}=e_i \;(i=1) \\
  \lowtoc{le}=ss
}
{
  \lowtoc{\elet{x:t}{\ereadstruct{le_1}}{le}} = (t\;x=\eread{e_1};ss)
}

\\

\inferrule*
{
  \lowtoce{le_i}=e_i \;(i=1,2,3) \\
  \lowtoc{le}=ss
}
{
  \lowtoc{(\elet{\_}{\ewritebuf{le_1}{le_2}{le_3}}{le})} = (\ewrite{e_1+e_2}{e_3}; ss)
}

\\


\inferrule*
{
  \lowtoce{le_i}=e_i \;(i=1,2) \\
  \lowtoc{le}=ss
}
{
  \lowtoc{(\elet{\_}{\ewritestruct{le_1}{le_2}}{le})} = (\ewrite{e_1}{e_2}; ss)
}

\\

\inferrule*
{
  \lowtoce{le}=e \\
  \lowtoc{le_1}=ss
}
{
  \lowtoc{(\elet{x}{\enewbuf{n}{(le:t)}}{le_1})} = (\earray txn; \memset{x}{n}{e}; ss)
}

\\

\inferrule*
{
  \lowtoce{le}=e \\
  \lowtoc{le_1}=ss
}
{
  \lowtoc{(\elet{x}{\enewstruct{(le:t)}}{le_1})} = (\earray tx1; \memset{x}{1}{e}; ss)
}

\\

\inferrule*
{
  \;
}
{
  \lowtoc{(\withframe\;le)} = \{\lowtoc{le}\}
}

\quad
\quad

\inferrule*
{
  \lowtoce{le}=e \\
  \lowtoc{le_i}=ss_i \;(i=1,2)
}
{
  \lowtoc{(\eif{le}{le_1}{le_2})} = (\eif{e}{ss_1}{ss_2})
}

\\

\inferrule*
{
  \lowtoce{le}=e \\
  \lowtoc{le_1}=ss
}
{
  \lowtoc{(\elet{x:t}{le}{le_1})} = (t\;x=e; ss)
}

\quad
\quad

\inferrule*
{
  \lowtoce{le}=e \\
  \lowtoc{le_1}=ss
}
{
  \lowtoc{(\elet{\_}{le}{le_1})} = (e; ss)
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \lowtoc{le} = \lowtoce{le}
}

\\

\inferrule*
{
  \;
}
{
  \lowtocd{(\etlet{x:t}{lv})} = (t\;x=\lowtoce{lv})
}

\quad
\quad

\inferrule*
{
  \lowtoc{le}=ss;e
}
{
  \lowtocd{(\etlet{f}{\lambda x:t_1.\;\withframe\;le:t_2})} = \ecfun{f}{x}{t_1}{t_2}{ss; \ereturn{e}}
}

\end{mathpar}
\end{scriptsize}
\caption{\lamstar to \cstar compilation}
\label{fig:lowtoc}
\end{figure*}

\newpage

\section{Bisimulation Proof} \label{section-bisim}

The main results are Theorem \ref{thm-safety} and \ref{thm-bisim}, in terms of some notions defined before them in this section. The two theorems are proved by using the crucial Lemma \ref{lemma-reverse} to ``flip the diagram'', i.e., proving \cstar refines \lamstar by proving \lamstar refines \cstar. The flipping relies on the fact that \cstar is deterministic modulo renaming of block identifiers. An alternative way of determinization to renaming of block identifiers is to have the stream of random coins for choosing block identifiers as part of the configuration (state).

That \cstar semantics use
big-step semantics for \cstar expressions complicates the bisimulation
proof a bit because \lamstar and \cstar steps may go out-of-sync at
times. Within the proof we used a relaxed notion of simulation
(``quasi-refinement'') that allows this temporary discrepancy by some
stuttering, but still implies bisimulation.

The specific relation between a \lamstar configuration and its \cstar counterpart is defined in Definition \ref{def-R} as Relation $R$.  It is defined in terms of a \cstar-to-\lamstar back-translation, listed in Fig \ref{fig:ctolow}. We need a back-translation here instead of the \lamstar-to-\cstar forward-translation as defined before, because a \cstar configuration has a clear call-stack with each frame containing its own variable environment and continuation, while a \lamstar configuration contains one giant \lamstar expression which makes it impossible to recover the call-stack. Hence for relating two configurations in the middle of reduction, only the \cstar-to-\lamstar direction is possible.

\begin{definition}[(Labelled) Transition System] \label{def-trsys}
  A transition system is a 5-tuple $(\Sigma, L, \step, s_0, F)$, where $\Sigma$ is a set of states, L is a monoid which is the set of labels, $\step\;\subseteq\Sigma\times \kw{option}\;L\times \Sigma$ is the step relation, $s_0$ is the initial state, and $F$ is a set of designated final state.
\end{definition}

In the following text, we use $\epsilon$ to denote an empty label (the unit of the monoid $L$), $l$ to range over non-empty (non-$\epsilon$) labels and $\olabel$ to range over possibly empty labels. When the label is empty, we can omit it. The label of multiple steps is the combined label of each steps, using the addition operator of monoid $L$. We define $a\Downarrow_\olabel a'\defeq a\step^*_\olabel a'$ and $a'\in F$.

\begin{definition}[Safety] \label{def-safety}
  A transition system $A$ is safe iff for all $s$ so that $s_0\step^* s$, $s$ is unstuck, where $\unstuck(s)$ is defined as either $s\in F$ or there exists $s'$ so that $s\step s'$.
\end{definition}

\begin{definition}[Refinement] \label{def-refine}
  A transition system $A$ refines a transition system $B$ (with the same label set) by $R$ (or $R$ is a refinement for transition system $A$ of transition system $B$) iff
  \begin{enumerate}
  \item there exists a well-founded measure $|-|_b$ (indexed by a $B$-state $b$) defined on the set of $A$-states $\{a:\Sigma_A\;|\;a\;R\;b\}$;
  \item $a_0\;R\;b_0$, that is, the two initial states are in  relation $R$;
  \item for all $a:\Sigma_A$ and $b:\Sigma_B$ such that $a\;R\;b$,
    \begin{enumerate}
    \item if $a\step_\olabel a'$ for some $a':\Sigma_A$, then there exists $b':\Sigma_B$ and $n$ such that $b\step^n_\olabel b'$ and $a'\;R\;b'$ and that $n=0$ implies that $|a|_b>|a'|_b$;
    \item if $a\in F_A$, then there exists $b':\Sigma_B$ such that $b\Downarrow_\epsilon b'$ and $a\;R\;b'$.
    \end{enumerate}
  \end{enumerate}
  $A$ refines $B$ iff there exists $R$ so that $A$ refines $B$ by $R$.
\end{definition}

\begin{definition}[Bisimulation] \label{def-bisim}
  A transition system $A$ bisimulates a transition system $B$ iff $A$ refines $B$ and $B$ refines $A$.
\end{definition}

\begin{definition}[Transition System of \cstar and \lamstar] \label{def-trsys-cstar}
  %% \begin{itemize}
  %% \item
  $$\begin{array}{rcl}
    \sys_{\cstar}(p,V,ss)&\defeq&(C, \{\ls{l}\}, p\vdash\step, ([], V, ss), \{([], V', \ereturn{e})\}) \\
    \sys_{\lamstar}(lp,le)&\defeq&(\{(H,le)\}, \{\ls{l}\}, lp\vdash\step, ([], le), \{([], lv)\})
  \end{array}$$
  %% \end{itemize}
\end{definition}

In the following text, we treat label $\symread/\symwrite\;(b,n)$ and $\symread/\symwrite\;(b,n,[])$ as equal, and if we have a \lamstar value or substitution, we freely use it as a \cstar one because coercion from \lamstar value to \cstar value is straight-forward.

\begin{theorem}[Safety] \label{thm-safety}
  For all \lamstar program $lp$, closed expression $le$ and closing substitution $V$, if $\lowtocd{lp}=p$, $\lowtoc{le}=ss$ and $\sys_{\lamstar}(lp,V(le))$ is safe, then $\sys_{\cstar}(p, V, ss)$ is safe.
\end{theorem}
\begin{proof}
Appeal to Lemma \ref{lemma-reverse}, Lemma \ref{lemma-cstar-deter} and Lemma \ref{lemma-back-refine}.
\end{proof}

\begin{theorem}[Bisimulation] \label{thm-bisim}
  For all \lamstar program $lp$, closed expression $le$ and closing substitution $V$, if $\lowtocd{lp}=p$ and $\lowtoc{le}=ss$, then $\sys_{\cstar}(p, V, ss)$ bisimulates $\sys_{\lamstar}(lp,V(le))$.
\end{theorem}
\begin{proof}
Appeal to Corollary \ref{coro-reverse}, Lemma \ref{lemma-cstar-deter} and Lemma \ref{lemma-back-refine}.
\end{proof}

\begin{definition}[Determinism] \label{def-deter}
  A transition system $A$ is deterministic iff for all $s$ so that $s_0\step^* s$, $s\in F$ implies that $s$ cannot take any step, and $s\step_{o_1} s_1$ and $s\step_{o_2} s_2$ implies that $o_1 = o_2$ and $s_1 = s_2$.
\end{definition}

\begin{definition}[Quasi-Refinement] \label{def-quasi-refine}
  A transition system $A$ quasi-refines a transition system $B$ (with the same label set) by $R$ (or $R$ is a quasi-refinement for transition system $A$ of transition system $B$) iff
  \begin{enumerate}
  \item there exists a well-founded measure $|-|_b$ (indexed by a $B$-state $b$) defined on the set of $A$-states $\{a:\Sigma_A\;|\;a\;R\;b\}$;
  \item $a_0\;R\;b_0$, that is, the two initial states are in  relation $R$;
  \item for all $a:\Sigma_A$ and $b:\Sigma_B$ such that $a\;R\;b$,
    \begin{enumerate}
    \item if $a\step_\olabel a'$ for some $a':\Sigma_A$, then there exists $a'':\Sigma_A$, $b':\Sigma_B$ and $n$ such that $a'\step^*_\epsilon a''$ and $b\step^n_\olabel b'$ and $a''\;R\;b'$ and that $n=0$ implies that $|a|_b>|a'|_b$;
    \item if $a\in F_A$, then there exists $b':\Sigma_B$ such that $b\Downarrow_\epsilon b'$ and $a\;R\;b'$.
    \end{enumerate}
  \end{enumerate}
  $A$ quasi-refines $B$ iff there exists $R$ so that $A$ quasi-refines $B$ by $R$.
\end{definition}

\begin{lemma}[Quasi-refine-Refine] \label{lemma-quasi}
  If transition system $A$ is deterministic, then $A$ quasi-refines transition system $B$ implies that $A$ refines $B$.
\end{lemma}
\begin{proof}
  Let $R$ be the quasi-refinement for $A$ of $B$. \\
  Define $R'$ to be: $a\;R'\;b$ iff $\exists n.\;(\exists a'.\;a\step^n_\epsilon a' \eand a'\;R\;b).$ \\
  We are to show that $A$ refines $B$ by $R'$. Unfold Definition \ref{def-refine}. \\
  For Condition 1, define $|a|_b$ to be the minimal of the number $n$ in the definition of $R'$, which uniquely exists. \\
  For Condition 2, we are to show $a_0\;R'\;b_0$. We know that $a_0\;R\;b_0$, so it's obviously true. \\
  For Condition 3(a), we have $a\;R'\;b$ and $a\step_\olabel a'$. \\
  We are to exhibit $b'$ and $n$ so that $b\step^n_\olabel b'$ and $a'\;R'\;b'$ and that $n=0$ implies $|a|_b>|a'|_b$. \\
  From $a\;R'\;b$, we have $a\step^m_\epsilon a''$ and $a''\;R\;b$. \\
  If $m=0$, we know $a\;R\;b$. Because $A$ quasi-refines $B$ by $R$, we have $a'\step^*_\epsilon a_2$ and $b\step^n_\olabel b'$ and $a_2\;R\;b'$ and that $n=0$ implies $|a|_b>|a'|_b$. \\
  Pick $b'$ to be $b'$ and $n$ to be $n$. It suffices to show $a'\;R'\;b'$, which is true because $a'\step^*_\epsilon a_2$ and $a_2\;R\;b'$. \\
  If $m>0$, pick $b'$ to be $b$ and $n$ to be 0. Because $A$ is deterministic, we know $a'\;R'\;b$ with $m-1$ and $|a|_b=m$ and $|a'|_b=m-1$. \\
  For Condition 3(b), we have $a\;R'\;b$ and $a\in F_A$. \\
  We are to exhibit $b'$ such that $b\Downarrow_\epsilon b'$ and $a\;R'\;b'$. \\
  Because $A$ is deterministic and $a\in F_A$, we have $m=0$ and $a\;R\;b$. \\
  Because $A$ quasi-refines $B$ with $R$, we have $b\Downarrow_\epsilon b'$ and $a\;R\;b'$. \\
  Pick $b'$ to be $b'$. It suffices to show $a\;R'\;b'$, which is trivially true. \\
\end{proof}

\begin{lemma}[Refine-Safety] \label{lemma-refine-safety}
  If transition system $A$ refines transition system $B$ by $R$ and for any $a$ and $b$ we have $a\;R\;b$ implies $\unstuck(a)$, then $A$ is safe.
\end{lemma}
\begin{proof}
  From Definition \ref{def-refine} we know $(\exists b.\;a\;R\;b)$ is an invariant of $A$. Hence $\unstuck(a)$ is also an invariant of $A$.
\end{proof}

\begin{lemma}[Deterministic Reverse] \label{lemma-reverse}
  If transition system $A$ is deterministic and transition system $B$ is safe, then $B$ refines $A$ implies that $A$ refines $B$ and $A$ is safe.
\end{lemma}
\begin{proof}
  Appealing to Lemma \ref{lemma-refine-safety}, we will exhibit the refinement for $A$ of $B$ and show that it implies unstuckness. \\
  Let $R$ be the refinement for $B$ of $A$. Define $R'$ to be: \\
  $a\;R'\;b$ iff \\
  $b_0\step^*b\eand((\exists \olabel\;b'.\;b\step_\olabel b'\eand\exists n_1\;a_2\;a_3\;a_4.\;(a\step^*_\epsilon a_2\eor a_2\step^*_\epsilon a)\eand b\;R\;a_2\eand a_2\step^*_\olabel a_3\eand a\step^{n_1}_\olabel a_3\eand a_3\step^*_\epsilon a_4\eand b'\;R\;a_4)\eor(b\in F_B\eand \exists n_2\;a_2\;a_3.\;(a\step^*_\epsilon a_2\eor a_2\step^*_\epsilon a)\eand b\;R\;a_2\eand a_2\step^*_\epsilon a_3\eand a\step^{n_2}_\epsilon a_3\eand a_3\in F_A\eand b\;R\;a_3))$. \\
  Let's first prove the fact (Fact 1) that if $b_0\step^* b$ and $a\step^*_\epsilon a'$ and $b\;R\;a$, then $a\;R'\;b$. \\
  Because $B$ is safe, we know that either $b\step_\olabel b'$ or $b\in F_B$. \\
  In the first case, because $B$ refines $A$ by $R$, we have $a'\step^n_\olabel a''$ and $b\;R\;a''$. \\
  It's easy to show $a\;R'\;b$ by choosing the first disjunct and picking $\olabel,b',a_2, a_4$ to be $\olabel,b',a',a''$. $n_1$ and $a_3$ exist in this case. \\
  In the second case, because $B$ refines $A$ by $R$, we have $a'\Downarrow_\epsilon a''$ and $b\;R\;a''$. \\
  It's easy to show $a\;R'\;b$ by choosing the second disjunt and picking $a_2, a_3$ to be $a', a''$. $n_2$ obviously exists. \\
  \\
  Now we are to show $A$ refines $B$ by $R'$. Unfold Definition \ref{def-refine}. \\
  For Condition 1, define $|a|_b$ to be lexicographic order of two numbers. \\
  The first number is the minimal of the number $n_2$ in the definition of $R'$ if $b$ is a value, which uniquely exists; or 0 otherwise. \\
  The second number is the minimal of the number $n_1$ in the definition of $R'$ if $b$ can take a step, which uniquely exists; or 0 otherwise. \\
  For Condition 2, we are to show $a_0\;R'\;b_0$, which is true because of $b_0\;R\;a_0$ and Fact 1. \\
  For Condition 3(a), we have $a\;R'\;b$ and $a\step_\olabel a'$. \\
  We are to exhibit $b'$ and $n$ such that $b\step^n_\olabel b'$ and $a'\;R\;b'$ and that $n=0$ implies $|a|_b>|a'|_b$. \\
  Unfold $a\;R'\;b$, we have the two disjuncts. \\
  In case $\olabel=l$, only the first disjunt is possible, and we have $b\step_l b'$ and $a'\step^*_\epsilon a_4$ and $b'\;R\;a_4$. \\
  Pick $b',n$ to be $b',1$. From Fact 1, we know $a'\;R'\;b'$. \\
  In case $\olabel=\epsilon$, both disjuncts of $a\;R'\;b$ are possible. \\
  If $a\;R'\;b$ because of the first conjunct, we have $b\step_{\olabel'} b'\eand (a\step^*_\epsilon a_2\eor a_2\step^*_\epsilon a)\eand b\;R\;a_2\eand a_2\step^*_{\olabel'} a_3\eand a\step^{n_1}_{\olabel'} a_3\eand a_3\step^*_\epsilon a_4\eand b'\;R\;a_4$. \\
  %% Because $B$ is safe and $B$ refines $A$ by $R$, we can step on the $B$ side for finite steps to reach $b_2$ such that $b'\step^*_{\epsilon b_2$ and $b_2\;R\;a$ and either $b_2\in F_B$ or  \\
  We case-analyse on whether $\olabel'$ is $\epsilon$. \\
  \\
  If $\olabel'=l$, let the second component of $|a|_b$ (denoted by $|a|_b.2$) be $m$. We case-analyse on whether $m>1$. \\
  If $m>1$, pick $b',n$ to be $b, 0$ (i.e. do not move on the $B$ side). We need to show $a'\;R'\;b$ and $|a|_b>|a'|_b$. \\
  $a'\;R'\;b$ because according to $m>1$ and $a\step_\epsilon a'$, we know that $a'$ is still before the $l$-label step. \\
  $|a|_b>|a'|_b$ is true because according to $m>1$, it must be the case that $|a'|_b.2=|a|_b.2-1$; and as for $|a'|_b.1$, which represents the minimal number of steps to terminate (or 0 otherwise), taking one step will not increase it. \\
  If $m\leq 1$, we know that $a\step_l a''$ for some $a''$. But we also have $a\step_\epsilon a'$, so this case is impossible because of $A$'s determinism. \\
  \\
  If $\olabel'=\epsilon$, because $B$ is safe and $B$ refines $A$ by $R$, we can step on the $B$ side for finite steps to reach $b_2$ such that $b'\step^*_\epsilon b_2$ and $b_2\;R\;a$ and either $b_2\step_{\olabel''} b_3\eand a\step^+_{\olabel''}a''\eand b_3\;R\;a''$ or $b_2\in F_B\eand a\step^*_\epsilon a''\eand a''\in F_A\eand b_2\;R\;a''$. \\
  In the first case, because $A$ is deterministic, we have $a\step_\epsilon a'\step^*_{\olabel''}a''$. \\
  If $\olabel''=\epsilon$, pick $b'$ to be $b_3$. Because of $a'\step^*_\epsilon a''$ and $b_3\;R\;a''$ and Fact 1, we get $a'\;R'\;b_3$. \\
  If $\olabel''=l$, pick $b'$ to be $b_2$. Since $b\step_\epsilon b'\step^*_\epsilon b_2$, we just need to show that $a'\;R'\;b_2$, which is easy to show by choosing the first disjunct for $R'$ and picking $b',a_2,a_4$ to be $b_3, a, a''$. \\
  In the second case ($b_2\in F_B$), it must be case that $a\step_\epsilon a'\step^*_\epsilon a''\in F_A$. Pick $b'$ to be $b_2$, we need to show $a'\;R'\;b_2$, which is true because $a'\step^*_\epsilon a''$ and $a''\;R'\;b_2$. \\
  \\
  If $a\;R'\;b$ because of the second conjunct, we have $b\in F_B\eand (a\step^*_\epsilon a_2\eor a_2\step^*_\epsilon a)\eand b\;R\;a_2\eand a_2\step^*_\epsilon a_3\eand a\step^{n_2}_\epsilon a_3\eand a_3\in F_A\eand b\;R\;a_3$. \\
  Because $A$ is deterministic, it must be the case that $a\step_\epsilon a'\step^*_\epsilon a_3$. \\
  Pick $b',n$ to be $b,0$. We need to show $a'\;R'\;b$ and $|a|_b>|a'|_b$. $a'\;R'\;b$ because $a'\step^*_\epsilon a_3$ and $a_3\;R'\;b$. $|a|_b>|a'|_b$ because $|a|_b.1>|a'|_b.1$, which is true because $a'$ is one step closer to terminate. \\
  \\
  For Condition 3(b), we have $a\;R'\;b$ and $a\in F_A$. \\
  We are to exhibit $b'$ such that $b\Downarrow_\epsilon b'$ and $a\;R'\;b'$. \\
  If $a\;R'\;b$ because of the second disjunct, we have $b\in F_B\eand a\step^*_\epsilon a_3\eand b\;R\;a_3$. Because $a\in F_A$ and $A$ is deterministic, we know that $a_3=a$\\
  Pick $b'$ to be $b$. $a\;R'\;b$ is true because $b\;R\;a$ and Fact 1. \\
  If $a\;R'\;b$ because of the first disjunct, we have $b\step_\olabel b_2\eand a\step^*_\olabel a_4\eand b_2\;R\;a_4$. \\
  Because $a\in F_A$ and $A$ is deterministic, we know that $a_4=a$ and $\olabel=\epsilon$. \\
  If $b_2\in F_B$, pick $b'$ to be $b_2$. $a\;R'\;b_2$ is true with the same reasoning as before. \\
  Otherwise, because $B$ is safe and $B$ refines $A$ by $R$, we can step $b_2$ for finite steps (because $a$ cannot step and $|b|_a>|b_2|_a$) to have $b_2\step^*_\epsilon b_3\eand b_3\;R\;a$. \\
  Pick $b'$ to be $b_3$. $a\;R'\;b_3$ is true with the same reasoning as before. \\
  \\
  Now we prove that $a\;R'\;b$ implies $\unstuck(a)$ for any $a$ and $b$. \\
  Unfolding $a\;R'\;b$, in both disjuncts we have $a\step^na'$ and $b'\;R\;a'$ for some $b'$. \\
  If $n>0$, $\unstuck(a)$ is obviously true. \\
  If $n=0$, we have $b'\;R\;a$. Because $B$ is safe, we know that either $b'\step b''$ or $b'\in F_B$. \\
  In case $b'\in F_B$, we know $a\Downarrow_\epsilon a_2$. Because $A$ is deterministic, $\unstuck(a)$ is true. \\
  In case $b'\step b''$, because $B$ refines $A$ by $R$, we know $a\step^ka_2$ and $b''\;R\;a_2$ and that $k=0$ implies $|b'|_a>|b''|_a$. \\
  Thus $b'$ can step finite number of $k=0$ steps before hitting the $b'\in F_B$ case or the $k>0$ case, in both of which we have $\unstuck(a)$.
\end{proof}

\begin{corollary}[Deterministic Reverse] \label{coro-reverse}
  If transition system $A$ is deterministic and transition system $B$ is safe, then $B$ refines $A$ implies that $A$ bisimulates $B$ and $A$ is safe.
\end{corollary}

\begin{definition}[Relation $R$] \label{def-R}
  For any $p$ and $lp$, define relation $R_{p,lp}$ as: $(H, le)\;R_{p,lp}\;(S, V, ss)$ iff there exists a minimal $n$ such that $(H, le)\step_{lp}^n(H, le')$ and $(H, le')=\ctolowc{(S, V, ss)}$, where $\ctolowc{(S, V, ss)}\defeq(\mem(S), \unravel(S, V(\ctolow{(\normal{ss}{(p,V)})})))$ and $\mem(S)$ is all the memory parts of $S$ collected together (and requiring that there is no $\None$ in $S$'s memory parts). \\
  $\unravel(S, le)\defeq\foldl\;\unravelframe\;le\;S$ \\
  $\unravelframe((M, V, E), le)\defeq \\ \begin{cases}
    V(\fplug{(\ctolowE{E})}{le}) & \text{if }M=\None\\
    V(\fplug{(\ctolowE{E})}{\epop\;le}) & \text{if }M=\Some{\_}
  \end{cases}$.
\end{definition}

\begin{figure*}[!htbp]
\begin{small}
\begin{flushleft}
\fbox{$\normal{ss}{(p,V)}=ss$}
\end{flushleft}
\begin{mathpar}
\inferrule*
{
  \eval{e}{(p,V)}=v
}
{
  \normal{(t\;x=e;ss)}{(p,V)} = (t\;x=v;ss)
}

\quad
\quad

\inferrule*
{
  \eval{e}{(p,V)}=v
}
{
  \normal{(t\;x=f(e);ss)}{(p,V)} = (t\;x=f(v);ss)
}

\quad
\quad

\inferrule*
{
}
{
  \normal{(\earray{t}{x}{n};ss)}{(p,V)} = (\earray{t}{x}{n};ss)
}

\\

\inferrule*
{
  \eval{e}{(p,V)}=v
}
{
  \normal{(\ereturn{e};ss)}{(p,V)} = (\ereturn{v};ss)
}

\quad
\quad

\inferrule*
{
  \eval{e_i}{(p,V)}=v_i \;(i=1,2)
}
{
  \normal{(t\;x=\eread{e_1}{e_2};ss)}{(p,V)} = (t\;x=\eread{v_1}{v_2};ss)
}

\quad
\quad

\inferrule*
{
  \eval{e_i}{(p,V)}=v_i \;(i=1,2,3)
}
{
  \normal{(\ewrite{e_1+e_2}{e_3};ss)}{(p,V)} = (\ewrite{v_1+v_2}{v_3};ss)
}

\\

\inferrule*
{
  \eval{e}{(p,V)}=v
}
{
  \normal{(e;ss)}{(p,V)} = (v;ss)
}

\quad
\quad

\inferrule*
{
  \eval{e_i}{(p,V)}=v_i \;(i=1,2)
}
{
  \normal{(\memset{e_1}{n}{e_2};ss)}{(p,V)} = (\memset{v_1}{n}{v_2};ss)
}
\end{mathpar}
\end{small}
\caption{Normalize \cstar head expression}
\label{fig:normalize}
\end{figure*}

\clearpage

\begin{figure*}[!htbp]
\begin{scriptsize}
\begin{flushleft}
\fbox{$\ctolowe{e}=le$}\quad\text{and}\quad
\fbox{$\ctolow{ss}=le$}\quad\text{and}\quad
\fbox{$\ctolowd{d}=ld$}\quad\text{and}\quad
\fbox{$\ctolowE{E}=LE$}
\end{flushleft}
\begin{mathpar}
\inferrule*
{
  \;
}
{
  \ctolowe{n} = n
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \ctolowe{(b,n,[])} = (b,n,[])
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \ctolowe{\{\ls{fd=e}\}} = \{\ls{fd=\ctolowe{e}}\}
}

\quad
\quad

\inferrule*
{
}{
  \ctolowe{()} = ()
}

\\

\inferrule*
{
}{
  \ctolowe{x} = x
}

\quad
\quad

\inferrule*
{
  \ctolowe{le_i}=e_i \;(i=1,2)
}
{
  \ctolowe{(e_1+e_2)} = \esubbuf{le_1}{le_2}
}

\quad
\quad

\inferrule*
{
  \ctolowe{le_i}=e_i \;(i=1)
}
{
  \ctolowe{\eptrfd{e_1}{fd}} = \estructfield{le_1}{fd}
}

\\

\inferrule*
{
  \ctolowe{e}=le_1 \\
  \ctolow{ss} = le
}
{
  \ctolow{(t\;x=f(e);ss)} = (\elet{x:t}{f\;le_1}{le})
}

\quad
\quad

\inferrule*
{
  \ctolowe{e}=le_1 \\
  \ctolow{ss} = le
}
{
  \ctolow{(\earray{t}{x}{n};\memset{x}{n}{e};ss)} = (\elet{x}{\enewbuf{n}{(le_1:t)}}{le})
}

\\


\inferrule*
{
  \ctolowe{e}=le_1 \\
  \ctolow{ss} = le \\
  t ~ \text{is a struct type}
}
{
  \ctolow{(\earray{t}{x}{1};\memset{x}{1}{e};ss)} = (\elet{x}{\enewstruct{(le_1:t)}}{le})
}

\quad
\quad

\inferrule*
{
  \ctolowe{e}=le_1 \\
  \ctolow{ss} = le
}
{
  \ctolow{(t\;x=e;ss)} = (\elet{x:t}{le_1}{le})
}

\\

\inferrule*
{
  \ctolowe{e_i}=le_i \; (i=1,2) \\
  \ctolow{ss} = le
}
{
  \ctolow{(t\;x=\eread{e_1+e_2};ss)} = (\elet{\_}{\ereadbuf{le_1}{le_2}}{le})
}

\quad
\quad

\inferrule*
{
  \ctolowe{e_i}=le_i \; (i=1) \\
  \ctolow{ss} = le
}
{
  \ctolow{(t\;x=\eread{e_1};ss)} = (\elet{\_}{\ereadstruct{le_1}}{le})
}

\\

\inferrule*
{
  \ctolowe{e_i}=le_i \; (i=1,2,3) \\
  \ctolow{ss} = le
}
{
  \ctolow{(\ewrite{e_1+e_2}{e_3};ss)} = (\elet{\_}{\ewritebuf{le_1}{le_2}{le_3}}{le})
}

\quad
\quad

\inferrule*
{
  \ctolowe{e_i}=le_i \; (i=1,2) \\
  \ctolow{ss} = le
}
{
  \ctolow{(\ewrite{e_1}{e_2};ss)} = (\elet{\_}{\ewritestruct{le_1}{le_2}}{le})
}

\\

\inferrule*
{
  \ctolow{ss_1}=le_1 \\
  \ctolow{ss} = le
}
{
  \ctolow{(\{ss_1\};ss)} = (\elet{\_}{\withframe\;le_1}{le})
}

\quad
\quad

\inferrule*
{
  \ctolowe{e}=le_1 \\
  \ctolow{ss} = le
}
{
  \ctolow{(e;ss)} = (\elet{\_}{le_1}{le})
}

\\

\inferrule*
{
  \ctolowe{e}=le \\
  \ctolow{ss_i}=le_i \;(i=1,2,3)
}
{
  \ctolow{(\eif{e}{ss_1}{ss_2};ss_3)} = (\elet{\_}{\eif{le}{le_1}{le_2}}{le_3})
}

\quad
\quad

\inferrule*
{
  \ctolowe{e}=le
}
{
  \ctolow{[e]} = le
}

\quad
\quad

\inferrule*
{
  \;
}
{
  \ctolow{[]} = ()
}

\\

\inferrule*
{
  \;
}
{
  \ctolowd{(t\;x=v)} = (\etlet{x:t}{\ctolowe{v}})
}

\quad
\quad

\inferrule*
{
  \ctolow{(ss;e)}=le
}
{
  \ctolowd{(\ecfun{f}{x}{t_1}{t_2}{ss; \ereturn{e}})} = (\etlet{f}{\lambda x:t_1.\;\withframe\;le:t_2})
}

\\

\inferrule*
{
  \ctolow{ss} = le
}
{
  \ctolowE{(\symhole;ss)} = (\elet{\_}{\symhole}{le})
}

\quad
\quad

\inferrule*
{
  \ctolow{ss} = le
}
{
  \ctolowE{(t\;x=\symhole;ss)} = (\elet{x:t}{\symhole}{le})
}
\end{mathpar}
\end{scriptsize}
\caption{\cstar to \lamstar back-translation}
\label{fig:ctolow}
\end{figure*}

\clearpage

\begin{lemma}[\lamstar Refines \cstar] \label{lemma-back-refine}
  For all \lamstar program $lp$, closed expression $le$ and closing substitution $V$, if $\lowtocd{lp}=p$ and $\lowtoc{le}=ss$, then $\sys_{\lamstar}(lp,V(le))$ refines $\sys_{\cstar}(p, V, ss)$.
\end{lemma}
\begin{proof}
  We apply Lemma \ref{lemma-quasi} and \ref{lemma-lowstar-deter}, and prove that $\sys_{\lamstar}(lp,le)$ quasi-refines $\sys_{\cstar}(p, ss)$.
  We pick the relation $R_{p,lp}$ in Definition \ref{def-R} to be the simulation relation and prove $R_{p,lp}$ is a quasi-refinement for $\sys_{\lamstar}(lp,le)$ of $\sys_{\cstar}(p, ss)$. \\
  Unfold Definition \ref{def-quasi-refine}. \\
  For Condition 1, define the well-founded measure $|(H,le)|_{(S, V, ss)}$ (where $(H,le)\;R\;(S,V,ss)$) to be the minimal of the number $n$ in $R$'s definition. \\
  For condition 2, appeal to Lemma \ref{lemma-init}. \\
  Now prove Condition 3(a). Let $(H,le)$ be the \lamstar configuration and $C=(S,V,ss)$ be the \cstar configuration. \\
  We are to exhibit $(H'', le'')$ and $C'$ and $n$ such that $(H',le')\step^*(H'',le'')$ and $C\step^n C'$ and $(H'',le'')\;R\;C'$ and that $n=0$ implies $|(H,le)|_C > |(H',le')|_C$. \\
  For all the cases except \emph{Case Pop}, we pick $(H'', le'')$ to be $(H',le')$ (i.e. do not use the extra flexibility offered by Quasi-Refinement). \\
  Induction on $(H, le)\step(H', le')$. \\
  \\
  \emph{Case Let}: on case $(H, \fplug{LE}{\elet{x:t}{lv}{le}})\step(H, \fplug{LE}{\subst{x}{lv}{le}})$. \\
  We are to exhibit $C'$ such that $(S, V, ss)\step^+C'$ and \\
  $(H, \fplug{LE}{\subst{x}{lv}{le}})\;R\;C'$.\\
  Apply Lemma \ref{lemma-invert-let}. \\
  In the first case, we have $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$, where $v\defeq\eval{e}{(p,V)}$. \\
  The \cstar side runs with nonzero steps to $(S, V[x\mapsto v], ss')$. \\
  Pick $C'$ to be this configuration. \\
  It suffices to show that $(H, \fplug{LE}{\subst{x}{lv}{le}})\;R\;(S, V[x\mapsto v], ss')$. \\
  Appealing to Lemma \ref{lemma-eq-normal}, it suffices to show that $\fplug{LE}{\subst{x}{lv}{le}}=\unravel(S, V[x\mapsto v](\ctolow{ss'}))$, which is true. \\
  In the second case, the \cstar side runs with nonzero steps to $(S', V'[x\mapsto v], ss')$. The proof is the same as the first case. \\
  End of case. \\
  %% From now on, we omit the second case from each inversion lemma, since they just add a ``return'' step on top of the first case. \\
  \\
  \emph{Case ALet}: on case $(H, \fplug{LE}{\elet{\_}{lv}{le}})\step(H, \fplug{LE}{le})$. \\
  Appealing to Lemma \ref{lemma-invert-alet}, the proof is similar to the previous case. \\
  End of case. \\
  \\
  \emph{Case App}: on case $(H, \fplug{LE}{\elet{x:t}{f\;lv}{le}})\step(H, \fplug{LE}{\elet{x:t}{\subst{y}{lv}{le_1}}}{le})$ and $lp(f)=\lambda y:t_1.\;le_1:t_2$. \\
  Appealing to Lemma \ref{lemma-invert-app}, we have $ss=(t\;x=f(v);ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$. \\
  Because $\lowtocd{lp}=p$, we know $le_1=\withframe\;le_2$ and $\lowtoc{le_2}=ss_2;e$ and $p(f)=\ecfuntwo{y}{t_1}{t_2}{ss_1}$ and $ss_1=(ss_2;\ereturn\;e)$. \\
  Appealing to Lemma \ref{lemma-lowtoc-ctolow}, we know $\ctolow{ss_1}=le_2$ hence $\ctolow{\{ss_1\}}=le_1$. \\
  Pick $C'$ to be $(S;(\None, V, t\;x=\symhole;ss'), \{y\mapsto v\}, \{ss_1\})$. \\
  It suffices to show that \\
  $(H, \fplug{LE}{\elet{x:t}{\subst{v}{lv}{le_1}}{le}})\;R\;(S;(\None, V, t\;x=\symhole;ss'), \{y\mapsto v\}, \{ss_1\})$, which is true. \\
  End of case. \\
  \\
  \emph{Case Withframe}: \\
  on case $(H, \fplug{LE}{\withframe\;le})\step(H;\{\}, \fplug{LE}{\epop\;le})$. \\
  Appealing to Lemma \ref{lemma-invert-withframe}, we have $ss=\{ss_1\};ss_2$ and $le=V(\ctolow{ss_1})$ and $LE=\unravel(S, V(\ctolowE{(\symhole;ss_2)}))$. \\
  Pack $C'$ to be $(S;(\{\}, V, \symhole;ss_2), V, ss_1)$. \\
  It suffices to show that \\
  $(H;\{\}, \fplug{LE}{\epop\;le})\;R\;(S;(\{\}, V, \symhole;ss_2), V, ss_1)$, which is true. \\
  End of case. \\
  \\
  \emph{Case Newbuf}: on case $(H;h, \fplug{LE}{\elet{x}{\enewbuf{n}{(lv:t)}}{le}})\step_{\symwrite\;(b,0,[]),\dots,\symwrite\;(b,n-1,[])}(H;h[b\mapsto lv^n], \fplug{LE}{\subst{x}{(b,0,[])}{le}})$ and $b\not\in H;h$. \\
  We have $(H;h, \fplug{LE}{\elet{x}{\enewbuf{n}{(lv:t)}}{le}})\;R\;(S, V, ss)$. \\
  We are to exhibit $C'$ so that \\
  $(H;h[b\mapsto lv^n], \subst{x}{(b,0,[])}{le})\;R\;C'$ and $(S, V, ss)\step^+C'$. \\
  Appealing to Lemma \ref{lemma-invert-newbuf}, we have $ss=(\earray{t}{x}{n};\memset{x}{n}{v};ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$ and $S=S';(M, V', E)$. \\
  Pick $C'$ to be $(S';(M[b\mapsto v^n], V', E), V[x\mapsto(b,0, [])], ss')$. \\
  It suffices to show that $(H;h[b\mapsto lv^n], \fplug{LE}{\subst{x}{(b,0,[])}{le}})\;R\;(S';(M[b\mapsto v^n], V', E), V[x\mapsto(b,0,[])], ss')$, which is true. \\
  End of case. \\
  \\
  \emph{Case Newstruct}: on case $(H;h,\fplug{LE}{\elet{x}{\enewstruct{(lv:t)}}{le}})\step_{\symwrite\;(b,0,[])}(H;h[b\mapsto lv], \subst{x}{(b,0,[])}{le})$ and $b\not\in H;h$. \\
  We have $(H;h, \elet{x}{\enewstruct{(lv:t)}}{le})\;R\;(S, V, ss)$. \\
  We are to exhibit $C'$ so that \\
  $(H;h[b\mapsto lv], \fplug{LE}{\subst{x}{(b,0,[])}{le}})\;R\;C'$ and $(S, V, ss)\step^+C'$. \\
  Appealing to Lemma \ref{lemma-invert-newstruct}, we have $ss=(\earray{t}{x}{1};\memset{x}{1}{v};ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$ and $S=S';(M, V', E)$. \\
  Pick $C'$ to be $(S';(M[b\mapsto v], V', E), V[x\mapsto(b,0, [])], ss')$. \\
  It suffices to show that $(H;h[b\mapsto lv], \fplug{LE}{\subst{x}{(b,0,[])}{le}})\;R\;(S';(M[b\mapsto v], V', E), V[x\mapsto(b,0,[])], ss')$, which is true. \\
  End of case. \\
  \\
  \emph{Case Readbuf}: on case \\
  $(H, \fplug{LE}{\elet{x:t}{\ereadbuf{(b,n,[])}{n'}}{le}})\step_{\symread\;(b,n+n',[])}(H, \fplug{LE}{\subst{x}{lv}{le}})$ and $H(b,n+n',[])=lv$. \\
  Appealing to Lemma \ref{lemma-invert-readbuf}, we have $ss=(t\;x=(b,n,[])[n'];ss')$ and $le=V(\ctolow{ss'})$ and $LE=\unravel(S, \symhole)$. \\
  Pick $C'$ to be $(S, V[x\mapsto v], ss')$ where $v=\lowtoce{lv}$. \\
  We know $C\step^+_{\symread\;(b,n+n',[])}C'.$ \\
  It suffices to show that $(H, \fplug{LE}{\subst{x}{lv}{le}})\;R\;(S, V[x\mapsto v], ss')$, which is true because $\subst{x}{lv}{le}=V[x\mapsto v](\ctolow{ss'})$. \\
  End of case. \\
  \\
  \emph{Case Readstruct}: on case \\
  $(H, \fplug{LE}{\elet{x:t}{\ereadstruct{(b,n,\ls{fd})}}{le}})\step_{\symread\;(b,n,\ls{fd})}(H, \fplug{LE}{\subst{x}{lv}{le}})$ and $H(b,n,\ls{fd})=lv$. \\
  Appealing to Lemma \ref{lemma-invert-readstruct}, we have $ss=(t\;x=\eread{(b,n,\ls{fd})};ss')$ and $le=V(\ctolow{ss'})$ and $LE=\unravel(S, \symhole)$. \\
  Pick $C'$ to be $(S, V[x\mapsto v], ss')$ where $v=\lowtoce{lv}$. \\
  We know $C\step^+_{\symread\;(b,n,\ls{fd})}C'.$ \\
  It suffices to show that $(H, \fplug{LE}{\subst{x}{lv}{le}})\;R\;(S, V[x\mapsto v], ss')$, which is true because $\subst{x}{lv}{le}=V[x\mapsto v](\ctolow{ss'})$. \\
  End of case. \\
  \\
  \emph{Case Writebuf}: on case \\
  $(H, \fplug{LE}{\elet{\_}{\ewritebuf{(b,n,[])}{n'}{lv}}{le}})\step_{\symwrite\;(b,n+n',[])}(H[(b,n+n',[])\mapsto lv], \fplug{LE}{le})$ and $(b,n+n',[])\in H$. \\
  Appealing to Lemma \ref{lemma-invert-writebuf}, we have $ss=((b,n,[])[n']=v;ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$. \\
  Pick $C'$ to be $(S', V, ss')$ where $\symset(S, (b,n,[]), v) = S'$. \\
  We know $C\step^+_{\symwrite\;(b,n+n',[])}C'.$ \\
  It suffices to show that $(H[(b,n+n',[])\mapsto lv], \fplug{LE}{le})\;R\;(S', V, ss')$, which is true. \\
  End of case. \\
  \\
  \emph{Case Writestruct}: on case \\
  $(H, \fplug{LE}{\elet{\_}{\ewritestruct{(b,n,\ls{fd})}{lv}}{le}})\step_{\symwrite\;(b,n,\ls{fd})}(H[(b,n,\ls{fd})\mapsto lv], \fplug{LE}{le})$ and $(b,n,\ls{fd})\in H$. \\
  Appealing to Lemma \ref{lemma-invert-writestruct}, we have $ss=(\ewrite{(b,n,\ls{fd})}{v};ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$. \\
  Pick $C'$ to be $(S', V, ss')$ where $\symset(S, (b,n,\ls{fd}), v) = S'$. \\
  We know $C\step^+_{\symwrite\;(b,n,\ls{fd})}C'.$ \\
  It suffices to show that $(H[(b,n,\ls{fd})\mapsto lv], \fplug{LE}{le})\;R\;(S', V, ss')$, which is true. \\
  End of case. \\
  \\
  \emph{Case Subbuf}: on case $(H, \fplug{LE}{\esubbuf{(b,n,[])}{n'}})\step(H, \fplug{LE}{(b,n+n',[])})$. \\
  Pick $C'$ to be $(S, V, ss)$. \\
  Because $(H, \fplug{LE}{\esubbuf{(b,n,[])}{n'}})\;R\;C'$ with some $m$, it must be the case that $m\geq 1$ and $(H, \fplug{LE}{(b,n+n',[])})\;R\;C'$ with $m-1$. \\
  End of case. \\
  \\
  \emph{Case Structfield}: on case $(H, \fplug{LE}{\estructfield{(b,n,\ls{fd})}{fd'}})\step(H, \fplug{LE}{(b,n,(\ls{fd}; fd'))})$. \\
  Pick $C'$ to be $(S, V, ss)$. \\
  Because $(H, \fplug{LE}{\estructfield{(b,n,\ls{fd})}{fd'}})\;R\;C'$ with some $m$, it must be the case that $m\geq 1$ and $(H, \fplug{LE}{(b,n,(\ls{fd};fd'))})\;R\;C'$ with $m-1$. \\
  End of case. \\
  \\
  \emph{Case IfTrue}: on case $(H, \fplug{LE}{\eif{n}{le_1}{le_2}})\step_\brt (H, \fplug{LE}{le_1})$ and $n\not=0$. \\
  Appealing to Lemma \ref{lemma-invert-if}, we have $ss=\eif{e}{ss_1}{ss_2};ss'$ and $\eval{e}{(p,V)}=n$ and $le_i=V(\ctolow{ss_i})$ ($i=1,2$) and $LE=\unravel(S, V(\ctolowE{(\symhole;ss')}))$. \\
  Pick $C'$ to be $(S, V, ss_1;ss')$. \\
  We know $C\step^+_\brt C'.$ \\
  It suffices to show that $(H, \fplug{LE}{le_1})\;R\;(S, V, ss_1;ss')$, which is true. \\
  End of case. \\
  \\
  \emph{Case IfFalse}: on case $(H, \fplug{LE}{\eif{n}{le_1}{le_2}})\step_\brf (H, \fplug{LE}{le_2})$ and $n=0$. \\
  Similar to previous case. \\
  End of case. \\
  \\
  \emph{Case Proj}: on case $(H, \fplug{LE}{\{\ls{fd=lv}\}.fd'})\step(H, \fplug{LE}{lv'})$ and $\{\ls{fd=lv}\}(fd')=lv'$. \\
  Pick $C'$ to be $(S, V, ss)$. \\
  Because $(H, \fplug{LE}{\{\ls{fd=lv}\}.fd'})\;R\;C'$ with some $m$, it must be the case that $m\geq 1$ and $(H, \fplug{LE}{lv'})\;R\;C'$ with $m-1$. \\
  End of case. \\
  \\
  \emph{Case Pop}: on case $(H;h, \fplug{LE}{\epop\;lv})\step(H, \fplug{LE}{lv})$. \\
  Apply Lemma \ref{lemma-invert-pop}. \\
  In the first case, from $LE=\unravel(S', V'(\ctolowE{\symhole;ss'}))$ we know $LE=(\elet{\_}{\symhole}{le})$ and $le=\unravel(S',V'(ss'))$. \\
  pick $C'$ to be $(S',V',ss')$ and $(H'', le'')$ to be $(H, le)$. \\
  Obviously $(H, \fplug{LE}{lv})\step^*(H, le)$. It suffices to show that $(H,le)\;R\;(S',V',ss')$, which is true. \\
  In the second case, pick $C'$ to be $(S',V',\fplug{E}{v})$ and $(H'', le'')$ to be $(H, \fplug{LE}{lv})$. \\
  To suffices to show $(H, \fplug{LE}{lv})\;R\;(S', V', \fplug{E}{v})$, which follows from $LE=\unravel(S',V'(\ctolowE{E}))$. \\
  \\
  For Condition 3(b), because \lamstar and \cstar's values are almost the same (except that \cstar locations have a field-path component), every \lamstar value has an obvious corresponding \cstar value, so condition 3(b) is trivially true.
\end{proof}

\begin{lemma}[\cstar Deterministic] \label{lemma-cstar-deter}
  For all $p$ and $ss$, transition system $\sys_{\cstar}(p, ss)$ is deterministic, modulo renaming of block identifiers.
\end{lemma}

\begin{lemma}[\lamstar Deterministic] \label{lemma-lowstar-deter}
  For all $lp$ and $le$, transition system $\sys_{\lamstar}(lp, le)$ is deterministic, modulo renaming of block identifiers.
\end{lemma}

\begin{lemma}[Init] \label{lemma-init}
  For all \lamstar program $lp$, closed expression $le$ and closing substitution $V$, if $\lowtocd{lp}=p$ and $\lowtoc{le}=ss$, then $([],V(le))\;R_{p,lp}\;([],V,ss)$.
\end{lemma}
\begin{proof}
  Unfold $R$'s definition, it suffices to show: \\
  $([], V(le))\step^*([], V(\ctolow{(\normal{\lowtoc{le}}{(p, \{\})})}))$.
\end{proof}

\begin{lemma}[Equal-Normalize] \label{lemma-eq-normal}
  If $H=\mem(S)$ and $le=\unravel(S, V(\ctolow{ss}))$ and $\normal{ss}{(p,V)}=ss'$, then $(H, le)\step^*(H, \unravel(S, V(\ctolow{ss'})))$.
\end{lemma}


\begin{lemma}[Invert Let] \label{lemma-invert-let}
  If $(H, \fplug{LE}{\elet{x:t}{lv}{le}})\;R\;(S, V, ss)$, then either $ss=(t\;x=e;ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$, where $v\defeq\eval{e}{(p,V)}$ or $S=S';(\None, V', t\;x=\symhole;ss')$ and $ss=\ereturn{v}$ and $le=V'(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S', \symhole)$.
\end{lemma}

\begin{lemma}[Invert ALet] \label{lemma-invert-alet}
  If $(H, \fplug{LE}{\elet{\_}{lv}{le}})\;R\;(S, V, ss)$, then either $ss=(e;ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$, where $v\defeq\eval{e}{(p,V)}$ or $S=S';(\None, V', \symhole;ss')$ and $ss=\ereturn{v}$ and $le=V'(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S', \symhole)$.
\end{lemma}

\begin{lemma}[Invert Newbuf] \label{lemma-invert-newbuf}
  If $(H;h, \fplug{LE}{\elet{x}{\enewbuf{n}{(lv:t)}}{le}})\;R\;(S, V, ss)$, then $ss=(\earray{t}{x}{n};\memset{x}{n}{v};ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$ and $S=S';(M, V', E)$.
\end{lemma}

\begin{lemma}[Invert Newstruct] \label{lemma-invert-newstruct}
  If $(H;h, \fplug{LE}{\elet{x}{\enewstruct{(lv:t)}}{le}})\;R\;(S, V, ss)$, then $ss=(\earray{t}{x}{1};\memset{x}{1}{v};ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$ and $S=S';(M, V', E)$.
\end{lemma}

\begin{lemma}[Invert Readbuf] \label{lemma-invert-readbuf}
  If \\
  $(H;h, \fplug{LE}{\elet{x:t}{\ereadbuf{(b,n,[])}{n'}}{le}})\;R\;(S, V, ss)$, then $ss=(t\;x=(b,n,[])[n'];ss')$ and $le=V(\ctolow{ss'})$ and $LE=\unravel(S, \symhole)$.
\end{lemma}

\begin{lemma}[Invert Readstruct] \label{lemma-invert-readstruct}
  If \\
  $(H;h, \fplug{LE}{\elet{x:t}{\ereadstruct{(b,n,\ls{fd})}}{le}})\;R\;(S, V, ss)$, then $ss=(t\;x=\eread{(b,n,\ls{fd})};ss')$ and $le=V(\ctolow{ss'})$ and $LE=\unravel(S, \symhole)$.
\end{lemma}

\begin{lemma}[Invert Writebuf] \label{lemma-invert-writebuf}
  If \\
  $(H;h, \fplug{LE}{\elet{\_}{\ewritebuf{(b,n,[])}{n'}{lv}}{le}})\;R\;(S, V, ss)$, then $ss=((b,n,[])[n']=v;ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$.
\end{lemma}

\begin{lemma}[Invert Writestruct] \label{lemma-invert-writestruct}
  If \\
  $(H;h, \fplug{LE}{\elet{\_}{\ewritestruct{(b,n,\ls{fd})}{lv}}{le}})\;R\;(S, V, ss)$, then $ss=(\ewrite{(b,n,\ls{fd})}{v};ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$.
\end{lemma}

\begin{lemma}[Invert App] \label{lemma-invert-app}
  If $(H, \fplug{LE}{\elet{x:t}{f\;lv}{le}})\;R\;(S, V, ss)$, then $ss=(t\;x=f(v);ss')$ and $le=V(\ctolow{ss'})$ and $lv=\ctolowe{v}$ and $LE=\unravel(S, \symhole)$.
\end{lemma}

\begin{lemma}[Invert Withframe] \label{lemma-invert-withframe}
  If $(H, \fplug{LE}{\withframe\;le})\;R\;(S, V, ss)$, then $ss=\{ss_1\};ss_2$ and $le=V(\ctolow{ss_1})$ and $LE=\unravel(S, V(\ctolowE{(\symhole;ss_2)}))$.
\end{lemma}

\begin{lemma}[Invert If] \label{lemma-invert-if}
  If $(H, \fplug{LE}{\eif{n}{le_1}{le_2}})\;R\;(S, V, ss)$, then $ss=\eif{e}{ss_1}{ss_2};ss'$ and $\eval{e}{(p,V)}=n$ and $le_i=V(\ctolow{ss_i})$ ($i=1,2$) and $LE=\unravel(S, V(\ctolowE{(\symhole;ss')}))$.
\end{lemma}

\begin{lemma}[Invert Pop] \label{lemma-invert-pop}
  If $(H;h, \fplug{LE}{\epop\;lv})\;R\;(S, V, ss)$, then either $ss=e$ and $\eval{e}{(p,V)}=v$ and $\ctolowe{v}=lv$ and $S=S';(M, V', \symhole;ss')$ and $LE=\unravel(S', V'(\ctolowE{\symhole;ss'}))$, or $ss=\ereturn{e}$ and $\eval{e}{(p,V)}=v$ and $\ctolowe{v}=lv$ and $S=S';(M,V',E)$ and $LE=\unravel(S',V'(\ctolowE{E}))$.
\end{lemma}

\begin{lemma}[Low2C-C2Low] \label{lemma-lowtoc-ctolow}
  If $\lowtoc{le}=ss;e$, then $\ctolow{(ss;\ereturn\;e)}=le$.
\end{lemma}


