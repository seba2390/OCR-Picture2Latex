We move from \lamstar to Clight in two steps. The \cstar intermediate
language retains \lamstar's explicit scoping structure, but switches
the calling convention to maintain an explicit call-stack of
continuations (separate from the stack memory regions). \cstar also
switches to a more C-like syntax, separates side effect-free
expressions from effectful statements.
    
%% \paragraph{The \cstar language}
%%     \cstar is a reinterpretation of \lamstar which separates side
%%     effect-free expressions from effectful statements, reflecting this
%%     split as a C-style syntax and a small-step semantics for
%%     statements as opposed to a big-step semantics for expression
%%     evaluation. \cstar introduces a block-scoped notion of local
%%     arrays; however, contrary to C and similarly to \lamstar, block
%%     scopes are not required for branches of a conditional statement,
%%     so that any local variable or local array declared in a
%%     conditional branch, if not enclosed by a further block, is still
%%     live after the conditional statement.
% \begin{figure}[h]
\vspace{-.7em}
\[
  \begin{array}{rl}
    \cp & ::= \ls{\ecfun fx{\tau}{\tau}{\ls{\cstmt}}} \\
    \cexp & ::= n \mid () \mid x \mid \cexp+\cexp \mid \{\ls{\fd=\cexp}\} \mid \cexp.\fd \mid \eptrfd{\cexp}{\fd} \\
    \cstmt & ::= \evardecl {\tau}x{\cexp} \mid \evardecl{\tau}{x}{\eapply f{\cexp}} \mid \eif{\cexp}{\ls{\cstmt}}{\ls{\cstmt}} \mid \ereturn \cexp \\
    & \mid \{\ls{\cstmt}\} \mid \earray {\tau}xn \mid \evardecl{\tau}{x}{\eread {\cexp}} \mid \ewrite {\cexp}{\cexp} \mid \memset{\cexp}{n}{\cexp} \\
  \end{array}
\]

\noindent
The syntax is unsurprising, with two notable exceptions.
%
First, despite the closeness to C syntax, contrary to C and similarly
to \lamstar, block scopes are not required for branches of a
conditional statement, so that any local variable or local array
declared in a conditional branch, if not enclosed by a further block,
is still live after the conditional statement.
%
Second, non-array local variables are immutable after
initialization.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure*}
  \small
  \begin{mathpar}
  \inferrule* [Right=Block]
  {
    %%\;
  }
  {
    \cp \vdash (S, V, \{\ls{\cstmt_1}\};\ls{\cstmt_2}) \step (S;(\{\},V,\symhole;\ls{\cstmt_2}), V, \ls{\cstmt_1})
  }

  \inferrule* [Right=Empty]
{
}
{
  \cp \vdash (S; (M, V', E), V, []) \step (S, V', \fplug{E}{()})
}

\inferrule* [Right=CIfF]
{
  \eval{\cexp}{(V)} = 0
}
{
  \cp \vdash (S, V, \eif{\cexp}{\ls{\cstmt_1}}{\ls{\cstmt_2}};\ls{\cstmt}) \step_\brf (S, V, \ls{\cstmt_2};\ls{\cstmt})
}

\inferrule* [Right=Call]
{
  \cp(f)=\ecfuntwo{y}{\tau_1}{\tau_2}{\ls{\cstmt_1}} \\
  \eval{\cexp}{(V)}=v
}
{
  \cp \vdash (S, V, \tau\;x=f\;\cexp; \ls{\cstmt}) \step (S;(\None, V, \tau\;x=\symhole;\ls{\cstmt}), \{\}[y\mapsto v], \ls{\cstmt_1})
}

\inferrule* [Right=CRead]
{
  \eval{\cexp}{(V)} = (b, n, \ls{\fd}) \quad
  \symget(S, (b, n, \ls{\fd})) = v \quad
  \trace = \symread\;(b,n,\ls{\fd})
}
{
  \cp \vdash (S, V, \evardecl{\tau}{x}{\eread \cexp}; \ls{\cstmt}) \step_{\trace} (S, V[x \mapsto v], \ls{\cstmt})
}

\inferrule* [Right=ArrDecl]
{
  \quad \\\\
  S = S'; (M, V, E) \\
  b\not\in S \\
  V' = V[x\mapsto (b, 0, [])]
}
{
  \cp \vdash (S, V, \tau\;x[n]; \ls{\cstmt}) \step (S';(M[b\mapsto \None^n], V, E), V', \ls{\cstmt})
}

\end{mathpar}
\caption{Selected semantic rules from \cstar}
\label{fig:cstar-sem}
\end{figure*}

\paragraph{Operational semantics, in contrast to \lamstar}
A \cstar evaluation configuration $C$ consists of a stack $S$, a
variable assignment $V$ and a statement list $\ls{\cstmt}$ to be
reduced. A stack is a list of frames. A frame $F$ includes frame
memory $M$, local variable assignment $V$ to be restored upon function
exit, and continuation $E$ to be restored upon function exit.
%
Frame memory $M$ is optional: when it is $\bot$, the frame is called a
``call frame''; otherwise a ``block frame'', allocated whenever
entering a statement block and deallocated upon exiting such block. A
frame memory is just a partial map from block identifiers to value
lists. Each \cstar statement performs at most one function call, or
otherwise, at most one side effect. Thus, \cstar is deterministic.

The semantics of \cstar is shown to the right in
Figure~\ref{fig:cstar-sem}, also illustrating the translation
from \lamstar to \cstar. There are three main differences.
First, \cstar's calling convention (rule {\sc
Call}) shows an explicit call frame being pushed on the stack, unlike
\lamstar's $\beta$ reduction.
%
Additionally, \cstar expressions do not have side effects and do not
access memory; thus, their evaluation order does not matter and their
evaluation can be formalized as a big-step semantics; by themselves,
expressions do not produce events. This is apparent in rules like {\sc
CIfF} and {\sc CRead}, where the expressions are evaluated atomically
in the premises.
%
Finally, \kw{newbuf} in \lamstar is translated to an array declaration
followed by a separate initialization. In \cstar, declaring an array
allocates a fresh memory block in the current memory frame, and makes
its memory locations available but uninitialized.  Memory write
(resp. read) produces a $\symwrite$ (resp. $\symread$)
event. $\memset{\cexp_1}{m}{\cexp_2}$ produces $m$ $\symwrite$ events,
and can be used only for arrays.

%% \paragraph{\lamstar to \cstar translation}

%% \tr{Figure disappeared, so the following paragraph can be shrunk.}

%% The compilation procedure is defined in Figure \ref{fig:lamtoc} as
%% inference rules, which should be read as functions defined by
%% pattern-matching. The compilation is a partial function, encoding
%% syntactic constraints on \lamstar programs that can be compiled. For
%% example, compilable \lamstar top-level functions must be wrapped in a
%% $\withframe$ construct.  Also, arguments to $\kw{newbuf}$, etc., or to
%% functions, and local definitions, must be pure (i.e. may contain
%% variables, but must not contain $\kw{if}$, $\kw{withframe}$ or any
%% kind of $\kw{let}$). Those syntactic restrictions are enforced\ch{met?} by
%% \lowstar-to-\lowstar transformations whose correctness proofs are left
%% as future work.

%% Given those syntactic restrictions, most of the translation rules are
%% straightforward. $\downarrow$ translates \lamstar expressions into
%% \cstar statement lists, whereas $\downlsquigarrow$ translates
%% variables and pure \lamstar expressions into \cstar
%% expressions. $\withframe$ is translated into a \cstar
%% block. $\kw{newbuf}$ is translated into an array declaration followed
%% by a $\kw{memset}$. The translation of functions $\downdownarrows$
%% requires that the translated function body be a list of \cstar
%% statements followed by a \cstar expression, so that the expression
%% serves as the returned result.

\paragraph{Correctness of the \lamstar-to-\cstar transformation}

We proved that execution traces are exactly preserved from
\lamstar to \cstar:

\begin{lemma}[\lamstar to \cstar] \label{lem:lamstar-to-cstar}
 Let $\lp$ be a \lamstar program and $\lexp$ be a \lamstar entry point
 expression, and assume that they compile: $\lowtocd(\lp) = \cp$ for
 some \cstar program $\cp$ and $\lowtoc(\lexp) = \ls{\cstmt}; \cexp$
 for some \cstar list of statements $\ls{\cstmt}$ and expression
 $\cexp$.
 
 Let $V$ be a mapping of local variables containing the initial values
 of secrets. Then, the \cstar program $\cp$ terminates with trace
 $\trace$ and return value $\lv$, i.e., $\cp \vdash ([], V,
 \ls{\cstmt}; \kw{return} ~ \cexp) \stackrel{\trace,\ast}{\rightarrow}
 ([], V', \kw{return} ~ \lv)$ if, and only if, so does the \lamstar
 program: $\lp \vdash (\{\}, \lexp[V])
 \stackrel{\trace,\ast}{\rightarrow} (H', \lv)$; and similarly for
 divergence.
\end{lemma}

In particular, if the source \lamstar program is safe, then so is the
target \cstar program. It also follows that the trace equality
security property is preserved from \lamstar to \cstar.
%
We prove this theorem by bisimulation. In fact, it is enough to prove
that any \lamstar behavior is a \cstar behavior, and flip the diagram
since \cstar is deterministic. That \cstar semantics use
big-step semantics for \cstar expressions complicates the bisimulation
proof a bit because \lamstar and \cstar steps may go out-of-sync at
times. Within the proof we used a relaxed notion of simulation
(``quasi-refinement'') that allows this temporary discrepancy by some
stuttering, but still implies bisimulation.
