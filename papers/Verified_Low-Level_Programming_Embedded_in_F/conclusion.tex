This paper advocates a new methodology for carrying out high-level
proofs on low-level code. By embedding a low-level language and memory
model within \fstar, the programmer not only enjoys sophisticated
proofs but also gets to write their low-level code in a more modular
style, using features functional programmers take for granted,
including recursion and type abstraction. Our toolchain, relying on
partial evaluation and the latest advances in C compilers, shows that
we can write code in a style suitable for verification \emph{and}
enjoy the same performance as hand-written C code.

We are currently making progress in three different directions. First,
continuing our integration of AEAD within miTLS, we aim to port the
miTLS protocol layer to \lowstar, in order to get an entire verified,
TLS library in C. Second, parts of our toolchain are unverified. We
plan to formalize and verify using \fstar parts of the \kremlin tool,
notably the \lamstar to \cstar transformation. Third, we are working
on embedding assembly instructions within \lowstar, allowing us to
selectively optimize our code further towards closing the performance
gap that still remains relative to architecture-specific, hand-written
assembly routines.

%% with the assembly numbers from
%% Table~\ref{tab:haclperf}.

% We have acquired significant experience writing large-scale developments in
% \lowstar, and can confidently say that the approach scales up, both in terms of
% verification effort and performance of the generated code.\ch{20k
%   lines doesn't seem large scale to me, but it depends with what you
%   compare; only verified software? The abstract is a lot more cautious
%   about making such strong claims; should decide what's the strongest
%   thing we can reasonably claim.}
% Some parts of our AEAD development
% suffer from a performance penalty, due to intermediary values and indirections
% required for proving security. As we improve our toolchain, we
% plan to get rid of these inefficiencies.

% \lowstar was driven by the demands of cryptographic code and libraries, and
% having a concrete use-case was highly beneficial to help drive the design. However, our approach is general and relevant beyond cryptographic algorithms, as
% exemplified by PneuTube, a systems application that integrates with C-style
% network APIs. We plan to push further on the cryptographic side, by writing the
% rest of miTLS in the \lowstar fragment of \fstar, but also to expand our reach
% and write more systems-oriented code, such as parsers and servers.

% These new applications will require new features from our toolchain; we plan
% to add support for polymorphic code via monomorphization;
% an automatically-managed heap region to ease the transition from existing code,
% using a conservative GC or reference-counting; support for arenas and mass
% deallocation in the
% manually-managed heap. We are looking closely at also targeting C++11,
% to leverage closures and in-library shared (reference counted) pointers.

% Several \lowstar-to-\lowstar passes are not formalized; these include the
% briefly mentioned \li+StackInline+ effect, and the various hoistings required to
% go to the statement form expected by the \lamstar-to-\cstar translation.
% In the short run, we plan to formalize these extra passes on paper.
% In the long run, we would like to rewrite KreMLin in \fstar and
% construct a machine checked proof of semantics preservation.

% \jp{\lowstar is\ch{should be?} generally applicable to low-level,
%   memory-safe programming, but our main application so far has been
%   low-level crypto algorithms.}
% \ch{while at the moment this is aimed at crypto,
%   we want to broaden the scope in the future}

