% Needed for proper arXiv processing, it seems
\pdfoutput=1

% JP: note: \newif takes a single argument, generates \foofalse, which is then
% called to set the initial boolean value.
\newif\ifjonathan\jonathanfalse
\newif\ifanon\anonfalse
\newif\ifdraft\draftfalse
\newif\iflong\longfalse
\newif\ifpagelimits\pagelimitsfalse
\newif\ifcamera\cameratrue

% override various ifs in your local.tex file
\IfFileExists{local.tex}
  {\input{local}}
  {}

% The following \documentclass options may be useful:
% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.
\ifanon
%% For double-blind review submission
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
\else
%% For technical report and camera ready
\documentclass[format=acmsmall, review=false, screen=true]{acmart}\settopmatter{printfolios=true}
\fi

\setcopyright{rightsretained}
\acmJournal{PACMPL}
\acmYear{2017}
\acmVolume{1}
\acmNumber{ICFP}
\acmArticle{17}
\acmMonth{9}
\acmDOI{10.1145/3110261}
\acmPrice{}

\ifcamera\else
\makeatletter
\@ACM@printacmreffalse
\@ACM@printccsfalse
\def\@copyrightpermission{This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}}
\fancypagestyle{firstpagestyle}{%
  \fancyhf{}%
  \renewcommand{\headrulewidth}{\z@}%
  \renewcommand{\footrulewidth}{\z@}%
    \fancyhead[LE]{\ACM@linecountL\@headfootfont\thepage}%
    \fancyhead[RO]{\@headfootfont\thepage}%
    \fancyhead[RE]{\@headfootfont\@shortauthors}%
    \fancyhead[LO]{}%
    \fancyfoot[RO,LE]{}%
}
\fancypagestyle{standardpagestyle}{%
  \fancyhf{}%
  \renewcommand{\headrulewidth}{\z@}%
  \renewcommand{\footrulewidth}{\z@}%
    \fancyhead[LE]{\ACM@linecountL\@headfootfont\thepage}%
    \fancyhead[RO]{\@headfootfont\thepage}%
    \fancyhead[RE]{\@headfootfont\@shortauthors}%
    \fancyhead[LO]{\ACM@linecountL\@headfootfont\shorttitle}%
    \fancyfoot[RO,LE]{}%
}
\pagestyle{standardpagestyle}
\def\@mkbibcitation{}
% \ifcamera\else, manuscript\fi -- didn't set this for documentclass since that changes formatting
\@ACM@manuscripttrue % bit like \ifcamera\else, authorversion\fi

% arXiv screws up the title boldness, so need to convince it to do it right
\def\@titlefont{\sffamily\LARGE\bfseries}

\makeatother
\fi


%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations

% Because of the diacritic in JK's name
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{amstext}
\usepackage{MnSymbol}
\usepackage{amsthm}
\usepackage{hyperref}
%% \usepackage{microtype}
\usepackage{balance}
\usepackage{upquote} %for a proper backtick `
% \usepackage{mathabx}
\usepackage{verbatim}

\usepackage{mathpartir}
\usepackage{tabularx}
  % A column which takes as much width as is available _and_ aligns right.
  \newcolumntype{R}{>{\raggedleft\arraybackslash}X}%
  \newcolumntype{Y}{>{\centering\arraybackslash}X}%

\usepackage{xparse}
\usepackage{enumerate}
\usepackage{microtype}

\hyphenation{as-surance}

\usepackage{tikz}
  \usetikzlibrary{calc}
  \usetikzlibrary{positioning}
  \usetikzlibrary{tikzmark}
  \usetikzlibrary{shapes.geometric}
  \usetikzlibrary{decorations.text}
  \usetikzlibrary{backgrounds}  % drawing the background after the foreground

% \pagelimitstrue\draftfalse  %% -- Turn this on to check your page limits
% PLDI CFP: Appendices should not be part of the paper,
%           but should be submitted as supplementary material.

\usepackage{listings}
  \include{lstfstar}
  \lstset{language=fstar,numbers=left,escapechar=!,basicstyle=\footnotesize}
  \let\lst\lstinline
  \let\li\lstinline

% \ifjonathan
%   \usepackage{minted}
%   \usemintedstyle{tango}
%   \newminted[ocaml]{ocaml}{mathescape,fontsize=\footnotesize,linenos,escapeinside=!!}
%   \newminted[cpp]{cpp}{mathescape,fontsize=\footnotesize,linenos,escapeinside=!!}
% \else
%   \usepackage{fancyvrb}
%   \DefineVerbatimEnvironment%
%     {cpp}{Verbatim}
%     {numbers=left,fontsize=\footnotesize}
%   \DefineVerbatimEnvironment%
%     {ocaml}{Verbatim}
%     {numbers=left,fontsize=\footnotesize}
% \fi

%% \newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
%% \newtheorem{definition}{Definition}
%% \newtheorem{theorem}{Theorem}
%% \newtheorem{conjecture}{Conjecture}
%% \newtheorem{corollary}{Corollary}
\input{macros}
\usepackage{float}
  \floatstyle{plaintop}
  \restylefloat{table}

% \geometry{head=23pt, headsep=6pt}

\begin{document}

% \acmBadgeR[https://github.com/project-everest/everest]{artifact_evaluated-reusable.png}
% \acmBadgeL[https://github.com/project-everest/everest]{artifact_available.png}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

%% \conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
%% \copyrightyear{20yy}
%% \copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
%% \copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

%% \titlebanner{banner above paper title}        % These are ignored unless
%% \preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Verified Low-Level Programming Embedded in \fstar
%\ifanon\vspace{-1.5cm}\fi
}
%% \subtitle{Subtitle Text, if any}

\ifanon
\author{}
\else
\author{Jonathan~Protzenko}
\affiliation{\institution{Microsoft Research}\ifcamera, USA\fi}
\author{Jean-Karim~Zinzindohoué}
\affiliation{\institution{INRIA Paris}\ifcamera, France\fi}
\author{Aseem~Rastogi}
\affiliation{\institution{Microsoft Research}\ifcamera, USA\fi}
\author{Tahina~Ramananandro}
\affiliation{\institution{Microsoft Research}\ifcamera, USA\fi}
\author{Peng~Wang}
\affiliation{\institution{MIT CSAIL}\ifcamera, USA\fi}
\author{Santiago~Zanella-Béguelin}
\affiliation{\institution{Microsoft Research}\ifcamera, USA\fi}
\author{Antoine~Delignat-Lavaud}
\affiliation{\institution{Microsoft Research}\ifcamera, USA\fi}
\author{C\u{a}t\u{a}lin~Hri\c{t}cu}
\affiliation{\institution{INRIA Paris}\ifcamera, France\fi}
\author{Karthikeyan Bhargavan}
\affiliation{\institution{INRIA Paris}\ifcamera, France\fi}
\author{Cédric~Fournet}
\affiliation{\institution{Microsoft Research}\ifcamera, USA\fi}
\author{Nikhil~Swamy}
\affiliation{\institution{Microsoft Research}\ifcamera, USA\fi}
\makeatletter
% \renewcommand{\@shortauthors}{J. Protzenko, J-K. Zinzindohoué, A. Rastogi, T.
% Ramananandro, P. Wang,\\ S. Zanella-Béguelin, A. Delignat-Lavaud, C. Hri\c{t}cu, K.
% Bhargavan, C. Fournet, and N. Swamy}
\renewcommand{\@shortauthors}{Protzenko \emph{et.al.}}
\makeatother
\fi

\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10011741</concept_id>
<concept_desc>Theory of computation~Hoare logic</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10003790.10011740</concept_id>
<concept_desc>Theory of computation~Type theory</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10011007.10010940.10010992.10010993</concept_id>
<concept_desc>Software and its engineering~Correctness</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10010940.10010992.10010998.10010999</concept_id>
<concept_desc>Software and its engineering~Software verification</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011041.10011047</concept_id>
<concept_desc>Software and its engineering~Source code generation</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
<concept_desc>Software and its engineering~Functional languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011039.10011311</concept_id>
<concept_desc>Software and its engineering~Semantics</concept_desc>
<concept_significance>300</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011041</concept_id>
<concept_desc>Software and its engineering~Compilers</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Hoare logic}
\ccsdesc[300]{Theory of computation~Type theory}
\ccsdesc[500]{Software and its engineering~Correctness}
\ccsdesc[500]{Software and its engineering~Software verification}
\ccsdesc[500]{Software and its engineering~Source code generation}
\ccsdesc[300]{Software and its engineering~Functional languages}
\ccsdesc[300]{Software and its engineering~Semantics}
\ccsdesc[300]{Software and its engineering~Compilers}


%% \category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
%% \terms
%% term1, term2

\keywords{verified compilation, low-level programming, verified cryptography}

% \ch{PLDI is double blind, previous work should be cited in 3rd person}

% \cf{I prefer F$^\star$, C$^\star$, etc}

% \ifdraft
% Title variations:
% \begin{itemize}
% \item Verified and Efficient Low-Level Programming in \fstar
%   % \ch{Cedric likes this title, and supports pitching \lowstar as
%   %   a language (maybe not domain specific) for low-level programming}
% \item A DSL for Verified, Efficient, Cryptographic Implementations in \fstar
% \item A DSL for Efficient, Verified Cryptographic Implementations in \fstar
% \item Programming, Verifying and Compiling Cryptographic Implementations in \fstar
% \item Programming, Verifying and Compiling Secure Cryptographic Implementations in \fstar
% \item The Lord of XORing
% \item An Embedded DSL for Verified and Efficient Low-Level Programming in \fstar
% \item Embedding ...
% \item Low-Level Verified Programming Embedded in \fstar
% \item Verified Low-Level Programming Embedded in \fstar
% \end{itemize}
% \fi

\input{abstract}
\maketitle

\input{intro}
\ifpagelimits
\newpage
\fi
\input{examples}
\ifpagelimits
\newpage
\fi
\input{formal}
\ifpagelimits
\newpage
\fi

\section{KreMLin: a Compiler from \lowstar to C}
\label{sec:impl}

\subsection{From \lowstar to Efficient, Elegant C}

As explained previously, \lamstar is the core of \lowstar, post
erasure. Transforming \lowstar into \lamstar proceeds in several
stages. First, we rely on \fstar's existing normalizer and erasure and
extraction facility (similar to features in Coq~\citep{Letouzey08}),
to obtain an ML-like AST for \lowstar terms. Then, we use our new tool
KreMLin that transforms this AST further until it falls within the
\lamstar subset formalized above. KreMLin then performs the \lamstar
to \cstar transformation, followed by the \cstar to C transformation
and pretty-printing to a set of C files. KreMLin generates C11 code
that may be compiled by GCC; Clang; Microsoft's C compiler or
CompCert. We describe the main transformations performed by KreMLin,
beyond those formalized in \sref{formal}, next.

\paragraph{Structures by value}
We described earlier (\sref{structs}) our \lowstar struct library that grants the
programmer fine-grained control over the memory layout, as well as
mutability of interior fields. As an alternative, \kremlin supports immutable,
by-value structs. Such structures, being pure, come with no liveness proof obligations.
The performance of the generated C code, however, is less
predictable: in many cases, the C compiler will optimize and pass such structs
by reference, but on some ABIs (x86), the worst-case scenario may be costly.

Concretely, the \fstar programmer uses tuples and inductive
types. Tuples are monomorphized into specialized inductive
types. Then, inductive types are translated into idiomatic C code:
single-branch inductive types (e.g., records) become actual C structs,
inductives with only constant constructors become C enums, and other
inductives becomes C tagged unions, leveraging C11 anonymous unions
for syntactic elegance. Pattern matches become, respectively,
switches, let-bindings, or a series of cascading if-then-elses.

\paragraph{Whole-program transformations}
\kremlin perform a series of whole-program transformations. First, the
programmer is free to use parameterized type abbreviations. \kremlin substitutes
an application of a type abbreviation with its definition, since C's \li+typedef+ does
not support parameters. (C++11 alias templates would support this use-case.)
%
Second, \kremlin recursively inlines all \li+StackInline+ functions, as required for
soundness (cf. \sref{crypto}).
%
Third, \kremlin performs a reachability analysis. Any function that is not
reachable from the \li+main+ function or, in the case of a library, from a
distinguished API module, is dropped. This is essential for generating
palatable C code that does not contain unused helper functions used only for
verification.
%
Fourth, \kremlin supports a concept of ``bundle'', meaning that several \fstar
modules may be grouped together into a single C translation unit, marking all of
the functions as \li+static+, except for those reachable via the distinguished API
module. This not only makes the code much more idiomatic, but also triggers a
cascade of optimizations that the C compiler is unable to perform across
translation units.

\paragraph{Going to an expression language}
\fstar is, just like ML, an expression language. Two transformations are
required to go to a statement language: \emph{stratification} and
\emph{hoisting}. Stratification places buffer
allocations, assignments and conditionals in statement
position before going to \cstar. Hoisting, as discussed in
\sref{to-clight}, deals with the discrepancy between C99 block scope
and \lowstar \li[language={}]{with_frame}; a buffer allocated under a \li+then+
branch must be hoisted to the nearest enclosing \li+push_frame+,
otherwise its lifetime would be shortened by the resulting C99
block after translation.

\paragraph{Readability}
KreMLin puts a strong emphasis on generating readable C, in the hope that
security experts not familiar with \fstar can review the generated C code.
Names are preserved; we use \li+enum+ and \li+switch+ whenever possible;
functions that take \li+unit+ are compiled into functions with no parameters;
functions that return \li+unit+ are compiled into \li+void+-returning functions.
The internal architecture relies on an abstract C AST and what we believe is a
correct C pretty-printer.

\paragraph{Implementation}
KreMLin represents about 10,000 lines of OCaml, along with a minimal set of
primitives implemented in a few hundred lines of C. After \fstar has extracted and
erased the AEAD development, KreMLin takes less than a second to generate the
entire set of C files. The implementation of KreMLin is optimized for
readability and modularity; there was no specific performance concern in this
first prototype version. KreMLin was designed to support multiple backends; we
are currently implementing a WebAssembly backend to provide verified, efficient
cryptographic libraries for the web.

\subsection{Integrating \kremlin's Output}

\kremlin generates a set of C files that have
no dependencies, beyond a single \li+.h+ file and C11 standard headers, meaning
\kremlin's output can be readily integrated into an existing source tree.

To allow code sharing and re-use, programmers may want to generate a shared
library, that is, a \li+.dll+ or \li+.so+ file that can be distributed along
with a public header (\li+.h+) file. The programmer can achieve this by writing
a distinguished API module in \fstar, exposing only carefully-crafted function
signatures. As exemplified earlier (\fref{chacha20-both}), the translation is
predictable, meaning the programmer can precisely control, in \fstar, what
becomes, in C, the library's public header. The
bundle feature of \kremlin then generates a single C file for the library;
upon compiling it into a shared object, the only visible symbols are those
exposed by the programmer in the header file.

We used this approach for our \haclstar library. Our public header file exposes
functions that have the exact same signature as their counterpart in the NaCL
library. If an existing binary was compiled against NaCL's public header file,
then one can configure the dynamic linker to use our \haclstar library instead,
without recompiling the original program (using the infamous ``LD preload trick'').

The functions exposed by the library comply with the C ABI for the chosen toolchain.
This means that one may use the library from a variety of programming languages,
relying on foreign-function interfaces to interoperate. One popular approach is
to generate bindings for the C library \emph{at run-time} using the ctypes
and the \li+libffi+~\cite{libffi} libraries. This is an approach leveraged by
languages such as JavaScript, Python or OCaml, and requires no recompilation.

An alternative is to write bindings by hand, which allows for better performance
and control over how data is transformed at the boundary, but requires writing
and recompiling potentially error-prone C code. This is the historical way of
writing bindings for many languages, including OCaml. We plan to have \kremlin
generate these bindings automatically. We used this approach in miTLS,
effectively making it a mixed C/OCaml project. We intend to eventually lower all
of miTLS into \lowstar.

\section{Building Verified \lowstar Libraries and Applications}
\label{sec:moreexamples}
\newcommand\fixme[1]{{\color{red}{#1}}}
\begin{table}[ht] \centering
\begin{tabular}{|l|r|r|r|r|}
  \hline
  \multicolumn{1}{|c|}{Codebase} & \multicolumn{1}{c|}{LoC} & \multicolumn{1}{c|}{C LoC} & \multicolumn{1}{c|}{\%annot} & \multicolumn{1}{c|}{Verif. time} \\
  \hline
  \lowstar standard library& 8,936  &  N/A   &  N/A   & 8m \\\hline
  \haclstar                & 6,050  & 11,220 &  28\%  & 12h \\
  miTLS AEAD               & 13,743 & 14,292 & 56.5\% & 1h 10m \\
  \hline
\end{tabular}
\caption{Evaluation of verified \lowstar libraries and applications (time reported on an Intel Core E5 1620v3 CPU)}
\label{tab:applications}
\end{table}
%% (+ 8936 6050 13743) = 28,729

%% wc -l FStar.FunctionalExtensionality.fst FStar.PropositionalExtensionality.fst FStar.PredicateExtensionality.fst FStar.TSet.fst FStar.Heap.fst FStar.Set.fst FStar.Map.fst FStar.Squash.fst FStar.Classical.fst FStar.List.Tot.Base.fst FStar.List.Tot.Properties.fst FStar.List.Tot.fst FStar.HyperHeap.fst FStar.HyperStack.fst FStar.Ghost.fst FStar.ST.fst FStar.All.fst FStar.StrongExcludedMiddle.fst FStar.Seq.Base.fst FStar.Seq.Properties.fst FStar.Seq.fst FStar.Mul.fst FStar.BitVector.fst FStar.Math.Lib.fst FStar.Math.Lemmas.fst FStar.UInt.fst FStar.UInt32.fst FStar.Buffer.fst FStar.DependentMap.fst FStar.Int.fst FStar.Int8.fst FStar.Struct.fst FStar.UInt8.fst
%%     35 FStar.FunctionalExtensionality.fst
%%      2 FStar.PropositionalExtensionality.fst
%%     14 FStar.PredicateExtensionality.fst
%%    108 FStar.TSet.fst
%%     80 FStar.Heap.fst
%%    129 FStar.Set.fst
%%    140 FStar.Map.fst
%%     26 FStar.Squash.fst
%%    127 FStar.Classical.fst
%%    454 FStar.List.Tot.Base.fst
%%    854 FStar.List.Tot.Properties.fst
%%      3 FStar.List.Tot.fst
%%    293 FStar.HyperHeap.fst
%%    322 FStar.HyperStack.fst
%%     87 FStar.Ghost.fst
%%     56 FStar.ST.fst
%%     42 FStar.All.fst
%%      4 FStar.StrongExcludedMiddle.fst
%%    241 FStar.Seq.Base.fst
%%    803 FStar.Seq.Properties.fst
%%      3 FStar.Seq.fst
%%      4 FStar.Mul.fst
%%    112 FStar.BitVector.fst
%%    122 FStar.Math.Lib.fst
%%    627 FStar.Math.Lemmas.fst
%%    817 FStar.UInt.fst
%%    165 FStar.UInt32.fst
%%   1236 FStar.Buffer.fst
%%    211 FStar.DependentMap.fst
%%    158 FStar.Int.fst
%%    157 FStar.Int8.fst
%%   1338 FStar.Struct.fst
%%    166 FStar.UInt8.fst
%%   8936 total

%% Verified module: FStar.FunctionalExtensionality (191 milliseconds)
%% Verified module: FStar.PropositionalExtensionality (21 milliseconds)
%% Verified module: FStar.PredicateExtensionality (74 milliseconds)
%% Verified module: FStar.TSet (1156 milliseconds)
%% Verified module: FStar.Heap (568 milliseconds)
%% Verified module: FStar.Set (2224 milliseconds)
%% Verified module: FStar.Map (4292 milliseconds)
%% Verified i'face (or impl+i'face): FStar.Squash (36 milliseconds)
%% Verified module: FStar.Classical (2305 milliseconds)
%% Verified module: FStar.List.Tot.Base (4500 milliseconds)
%% Verified module: FStar.List.Tot.Properties (13010 milliseconds)
%% Verified module: FStar.List.Tot (15 milliseconds)
%% Verified module: FStar.HyperHeap (15689 milliseconds)
%% Verified module: FStar.HyperStack (13793 milliseconds)
%% Verified module: FStar.Ghost (1101 milliseconds)
%% Verified module: FStar.ST (10937 milliseconds)
%% Verified module: FStar.All (31 milliseconds)
%% Verified module: FStar.StrongExcludedMiddle (123 milliseconds)
%% Verified module: FStar.Seq.Base (12797 milliseconds)
%% Verified module: FStar.Seq.Properties (35056 milliseconds)
%% Verified module: FStar.Seq (19 milliseconds)
%% Verified module: FStar.Mul (27 milliseconds)
%% Verified module: FStar.BitVector (8754 milliseconds)
%% Verified module: FStar.Math.Lib (6568 milliseconds)
%% Verified module: FStar.Math.Lemmas (53978 milliseconds)
%% Verified module: FStar.UInt (72911 milliseconds)
%% Verified module: FStar.UInt32 (9854 milliseconds)
%% Verified module: FStar.Buffer (130905 milliseconds)
%% Verified module: FStar.DependentMap (3470 milliseconds)
%% Verified module: FStar.Int (6559 milliseconds)
%% Verified module: FStar.Int8 (10474 milliseconds)
%% Verified module: FStar.Struct (47486 milliseconds)
%% Verified module: FStar.UInt8 (11871 milliseconds)
%% All verification conditions discharged successfully

%% real    8m5.803s
%% user    0m0.000s
%% sys     0m0.045s
  
In this section, we describe two examples (summarized in
Table~\ref{tab:applications}) that show how \lowstar can be used to
build applications that balance complex verification goals with high
performance.
%
First, we describe \haclstar{}, an efficient library of cryptographic
primitives that are verified to be memory safe, side-channel
resistant, and, where there exists a simple mathematical
specification, functionally correct.
%
%Integrating \haclstar into a larger cryptographic application, we
%describe \emph{PneuTube}, an efficient, verified, secure file transfer
%application implemented in \lowstar.
%
Then, we show how to use \lowstar for type-based cryptographic
security verification by implementing and verifying the AEAD
construction in the Transport Layer Security (TLS) protocol.
%
We show how this \lowstar library can be integrated within miTLS, 
an \fstar implementation of TLS that is compiled to OCaml.

\subsection{\haclstar: A Fast and Safe Cryptographic Library}
\label{sec:haclstar}

%% In the wake of the Heartbleed vulnerability in OpenSSL, many concerns
%% have been raised about the quality of cryptographic implementations,
%% and indeed, numerous other memory safety (see e.g. CVE-2016-7054), functional
%% correctness~\cite{brumley2012practical}, and side-channel
%% issues~\cite{albrecht2016lucky} continue to be in found popular
%% cryptographic libraries.
%%NS: Already cited a ton of them in the intro

In the wake of numerous security vulnerabilities,
\citet{bernstein2012security} argue that libraries like OpenSSL are
inherently vulnerable to attacks because they are too large, offer too many obsolete options, and
expose a complex API that programmers find hard to use securely.
%
Instead they propose a new cryptographic API called NaCl that uses a
small set of modern cryptographic primitives, such as
Curve25519~\cite{curve25519} for key exchange, the Salsa family of
symmetric encryption algorithms~\cite{bernstein2008salsa20}, which
includes Salsa20 and ChaCha20, and Poly1305 for message
authentication~\cite{bernstein2005poly1305}.
%
These primitives were all designed to be fast and easy to implement
in a side-channel resistant coding style.
%
Furthermore, the NaCl API does not directly expose these low-level
primitives to the programmer. Instead it recommends the use of simple
composite functions for symmetric key authenticated encryption
(\texttt{secretbox}/\texttt{secretbox\_open}) 
and for public key authenticated encryption (\texttt{box}/\texttt{box\_open}).

The simplicity, speed, and robustness of the NaCl API has proved popular among 
developers. Its most popular implementation is Sodium~\cite{libsodium}, which has bindings
for dozens of programming languages and is written mostly in C, with a few components in assembly.
%
An alternative implementation called TweetNaCl~\cite{bernstein2014tweetnacl} seeks
to provide a concise implementation that is both readable and \emph{auditable} for 
memory safety bugs, a useful point of comparison for our work.
%
With \lowstar, we show how we can take this approach even further by
placing it on formal, machine-checked ground, without compromising
performance.

\paragraph*{A Verified NaCl Library}
We implement the NaCl API, including all its component algorithms, 
in a \lowstar library called \haclstar, mechanically verifying that 
all our code is memory safe, functionally correct,  and side-channel resistant.
%
The C code generated from \haclstar is ABI-compatible and can be used as a drop-in replacement for
Sodium or TweetNaCl in any application, in C or any other language, that relies on these libraries.
%
Our code is written and optimized for 64-bit platforms; on 32-bit
machines, we rely on a stub library for performing 64x64-bit 
multiplications and other 128-bit operations.

We implement and verify four cryptographic primitives:
ChaCha20, Salsa20, Poly1305, and Curve25519, and then use them to
build three cryptographic constructions: AEAD, \texttt{secretbox} 
and \texttt{box}. 
%
For all our primitives, we prove that our stateful optimized code
matches a high-level functional specification written in \fstar.
%
These are new verified implementations. Previously, \citet{saw-cryptol} used SAW
and Cryptol to verify C and Java implementations of Chacha20,
Salsa20, Poly1305, AES, and ECDSA. Using a different methodology, \citet{vale}
verifies an assembly version of Poly1305.
%
Curve25519 has been verified before:
%
\citet{chen2014verifying} verified an optimized 
low-level assembly implementation using an SMT solver;
%
\citet{ZBB16} wrote and verified a high-level
library of three curves, including Curve25519, in F* and generated an
OCaml implementation from it.
%
Our verified Curve25519 code explores a third direction by targeting 
reference C code that is both fast and readable.

A companion paper currently under review~\cite{haclstar} is entirely devoted to the \haclstar
library, and contains an in-depth evaluation of the proof methodology, several
new algorithms that were verified since the present paper was written, along
with a more comprehensive performance analysis.


\begin{table}[h]
  \footnotesize
%% \resizebox{\columnwidth}{!}{
\begin{tabular}{|l|r|r|r|r||r|}
  \hline
  \multicolumn{1}{|c|}{Algorithm} & \multicolumn{1}{c|}{\haclstar} & \multicolumn{1}{c|}{Sodium} & \multicolumn{1}{c|}{TweetNaCl} &\multicolumn{1}{c||}{OpenSSL} & \multicolumn{1}{c|}{eBACS Fastest}   \\
  \hline
  ChaCha20      & 6.17 cy/B  & 6.97 cy/B  & - & 8.04 cy/B & 1.23 cy/B\\
  Salsa20       & 6.34 cy/B  & 8.44 cy/B  & 15.14 cy/B & - & 1.39 cy/B\\
  Poly1305      & 2.07 cy/B  & 2.48 cy/B  & 32.32 cy/B & 2.16 cy/B & 0.68 cy/B \\
  Curve25519    & 157k cy/mul & 162k cy/mul  & 1663k cy/mul & 359k cy/mul & 145k cy/mul\\
  \hline
  AEAD-ChaCha20-Poly1305          & 8.37 cy/B & 9.60 cy/B  & - & 8.53 cy/B  & \\
  SecretBox     & 8.43 cy/B & 11.03 cy/B  & 50.56 cy/B & -  &  \\
  Box           & 18.10 cy/B & 20.97 cy/B  & 149.22 cy/B & -  &  \\
  \hline
\end{tabular}
%% }
\caption{Performance in CPU cycles: 64-bit \haclstar,  64-bit Sodium (pure C, no assembly), 
32-bit TweetNaCl, 64-bit OpenSSL (pure C, no assembly), and the fastest assembly implementation
included in eBACS SUPERCOP. All code was compiled using \texttt{gcc -O3} optimized and
run on a 64-bit Intel Xeon CPU E5-1630. Results are averaged over 1000 measurements, each
processing a random block of $2^{14}$ bytes; Curve25519 was averaged over 1000 random key-pairs.}
\label{tab:haclperf}
\end{table}

\begin{table}[h]
  \footnotesize
  \begin{tabular}{|l|r|r|r|}
    \hline
    \multicolumn{1}{|c|}{Algorithm} & \multicolumn{1}{c|}{\haclstar} & \multicolumn{1}{c|}{OpenSSL} & \multicolumn{1}{c|}{CNG} \\
    \hline
    Curve25519 \hspace{2em} & 17700 mul/s ($\sigma=246$) & 8033 mul/s ($\sigma=120$) & 7490 mul/s ($\sigma=114$) \\
    \hline
  \end{tabular}
  \caption{Performance in operations per second: 64-bit \haclstar, 64-bit
  OpenSSL (assembly disabled) and Microsoft's ``Crypto New Generation'' (CNG)
  library on a 64-bit Windows 10 machine. These results were obtained by writing
  an OpenSSL engine that calls back to either \haclstar, CNG, or OpenSSL
  itself (so as to include the overhead of going through a pluggable engine).
  The \li+speed ecdhx25519+ command runs multiplications for 10s, then counts
  the number of multiplications performed. We show the average over 10 runs of
  this command. The machine is a desktop machine with a 64-bit Intel Xeon CPU
  E5-1620 v2 nominally clocked at 3.70Ghz.}
\end{table}

\paragraph*{Performance}
%
Table~\ref{tab:haclperf} compares the performance of \haclstar to Sodium, TweetNaCl,
and OpenSSL by running each primitive on a 16KB input; we chose this size since it
corresponds to the maximum record size in TLS and represents a good balance
between small network messages and large files. 
%
We report averages over 1000 iterations expressed in cycles/byte.
%
For Curve25519, we measure the time taken for one call to scalar multiplication.
%
For comparison with state-of-the-art assembly implementations, for each primitive,
we also include the best performance for any implementation (assembly or C)
included in the eBACS SUPERCOP benchmarking framework.\footnote{\url{https://bench.cr.yp.to/supercop.html}} 
%
These fastest implementation are typically in architecture-specific assembly.

We performed these tests on a variety of 64-bit Intel CPUs (the most
popular desktop configuration) and these performance numbers were
similar across machines. To confirm these measurements, we also ran
the full eBACS SUPERCOP benchmarks on our code, as well as the OpenSSL
\texttt{speed} benchmarks, and the results closely mirrored
Table~\ref{tab:haclperf}. However, we warn the performance numbers 
could be quite different on (say) 32-bit ARM platforms.

We observe that for ChaCha20, Salsa20, and Poly1305, \haclstar achieves comparable performance 
to the optimized C code in OpenSSL and Sodium and significantly better performance than 
TweetNaCl's concise C implementation.
%
Assembly implementations of these primitives are about 3-4 times faster; they typically
rely on CPU-specific vector instructions and careful hand-optimizations.

Our Curve25519 implementation is about the same speed as Sodium's
64-bit C implementation (\texttt{donna\_c64}) and an order of magnitude
faster than TweetNaCl's 32-bit code.  It is also significantly faster
than OpenSSL because even 64-bit OpenSSL uses a Curve25519 implementation 
that was optimized for 32-bit integers, whereas the implementations in 
Sodium and \haclstar take advantage of the 64x64-bit multiplier available 
on Intel's 64-bit platforms.
%
The previous \fstar implementation of Curve25519~\cite{ZBB16} 
running in OCaml was not optimized for performance; it
is more than 100x slower than \haclstar.
%
The fastest assembly code for Curve25519 on eBACS is the one verified
in ~\cite{chen2014verifying}. This implementation is only 1.08x faster
than our C code, at least on the platform on which we tested, which
supported vector instructions up to 256 bits.  We anticipate that the
assembly code may be significantly faster on platforms that support
larger 512-bit vector instructions.
%


AEAD and \texttt{secretbox} essentially amount to a ChaCha20/Salsa20 cipher sequentially
followed by Poly1305, and their performance reflects the sum of the two primitives.
%
Box uses Curve25519 to compute a symmetric key, which it then uses to encrypt 
a 16KB input. Here, the cost of symmetric encryption dominates over Curve25519.

In summary, our measurements show that \haclstar is as fast as (or faster than)
state-of-the-art C crypto libraries and within a small factor of hand-optimized assembly code.
%
This finding is not entirely unexpected, since we wrote our \lowstar code 
by effectively porting the fastest C implementations to \fstar, and any
algorithmic optimization that is implemented in C can, in principle,
be written (and verified) in \lowstar.
%
What is perhaps surprising is that we get good performance even though
our \lowstar code, and consequently the generated C, heavily relies on 
functional programming patterns such as tail-recursion, and even though
we try to write generic compact code wherever possible, rather than trying 
to mimic the verbose inlined style of assembly code.
%
We find that modern compilers like GCC and CLANG are able to optimize
our code quite well, and we are able to benefit from their advancements,
without having to change our coding style.
%
Where needed, KreMLin helps the C compiler by inserting attributes like
\texttt{const}, \texttt{static} and \texttt{inline} that act as optimization hints.

\paragraph*{Balancing Trust and Performance}
%
All the above performance numbers were obtained with GCC-6 with most
architecture-specific optimizations turned on
(\texttt{-march=native}).  Consequently, any bug in GCC or its plugins
could break the correctness and security guarantees we proved in
\fstar for our source code.  For example, GCC has an auto-vectorizer
that significantly improves the performance of our ChaCha20 and
Salsa20 code in certain use cases, but does so by substantially
changing its structure to take advantage of the parallelism provided
by SIMD vector instructions. To avoid trusting this powerful 
but unverified mechanism, and for more consistent results across platforms,
we turned off auto-vectorization (\texttt{-fno-tree-vectorize}) 
for the numbers in Table~\ref{tab:haclperf}. For similar reasons, 
we turned off link-time optimization (\texttt{-fno-lto}) since 
it relies on an external linker plugin, and can change the 
semantics of our library every time it is linked with a new application.

Ideally, we would completely remove the burden of trust on the C
compiler by moving to CompCert, but at significant performance
cost. Our Salsa20 and ChaCha20 code incurs a relatively modest 3x
slowdown when compiled with CompCert 3.0 (with \texttt{-O3}). 
However, our Poly1305 and Curve25519 code incurs a 30-60x slowdown,
which makes the use of CompCert impractical for our library.
We anticipate that this penalty will reduce as CompCert
improves, and as we learn how to generate C code that would be
easier for CompCert to optimize. For now, we continue to use GCC and
CLANG and comprehensively test the generated code using third-party
tools. For example, we test our code against other implementations,
and run all the tests packaged with OpenSSL. We also 
test our compiled code for side-channel leaks using tools like 
DUDECT.\footnote{\url{https://github.com/oreparaz/dudect}}


%% \begin{figure}
%% \centerline{\includegraphics[width=0.8\columnwidth]{pneutube}}
%% \caption{PneuTube: Asynchronous file transfer with end-to-end confidentiality and 
%%   authentication for file contents and metadata (file name, size, etc.).}
%% \label{fig:pneutube}
%% \end{figure}
\paragraph*{PneuTube: Fast encrypted file transfer}
Using \haclstar, we can build a variety of high-assurance security
applications directly in \lowstar.
%
PneuTube is a \lowstar program that securely transfers files from a host $A$ to a
host $B$ across an untrusted network.
%
Unlike classic secure channel protocols like TLS and SSH, PneuTube is
\emph{asynchronous}, meaning that if $B$ is offline, the file may be
cached at some untrusted cloud storage provider and retrieved later. 

PneuTube breaks the file into \emph{blocks} and encrypts each block
using the \texttt{box} API in \haclstar (with an optimization that
caches the result of Curve25519).
%
It also protects file metadata, including the file name and
modification time, and it hides the file size by padding the file
before encryption to a user-defined size.
%
We verify that our code is memory-safe, side-channel resistant, and that
it uses the I/O libraries correctly (e.g., it only reads or writes
a file or a socket between calling open and close).

PneuTube's performance is determined by a combination of the crypto
library, disk access (to read and write the file at each end) and  network I/O. 
%
Its aynchronous design is particularly rewarding on high-latency
network connections, but even when transferring a 1GB file from one
TCP port to another on the same machine, PneuTube takes just 6s.
%
In comparison, SCP (using SSH with ChaCha20-Poly1305) takes 8 seconds. 



\iffalse
%ADL what do you want to do with this?
\begin{lstlisting}
val crypto_box_easy:
  c:uint8_p -> (* To store the ciphertext *)
  m:uint8_p -> (* Plaintext *)
  mlen:u64{...}  -> (* Plaintext length *)
  n:uint8_p{...} -> (* Nonce *)
  pk:uint8_p{...} -> (* Public Key of the other party *)
  sk:uint8_p{...} -> (* Our private key *)
  Stack u32
    (requires (fun h -> crypto_box_pre h c m mlen c pk sk))
    (ensures  (fun h0 z h1 -> crypto_box_post h0 z h1 c m
                                          mlen c pk sk))
\end{lstlisting}
\fi

\subsection{Cryptographically Secure AEAD for miTLS}
\label{sec:aead}

We use our cryptographically secure AEAD library (\S\ref{sec:crypto})
within miTLS~\cite{mitls}, an existing implementation of TLS in \fstar.
%
In a previous verification effort, AEAD encryption was idealized as a
cryptographic assumption (concretely realized using bindings to
OpenSSL) to show that miTLS implements a secure authenticated channel.
%
However, given vulnerabilities such as CVE-2016-7054, this AEAD
idealization is a leap of faith that can undermine security when the
real implementation diverges from its ideal behavior.

%% Recall from \S\ref{sec:crypto} that \fstar can be used to prove cryptographic
%% security by encoding cryptographic assumptions as idealized interfaces, and
%% by reasoning on the properties of the ideal functionality.
%% %
%% This approach has been successfully applied to large-scale projects such as
%% miTLS~\cite{mitls}. In miTLS, AEAD encryption
%% is idealized as a cryptographic assumption (concretely realized using bindings
%% to OpenSSL) to show that TLS implements a secure authenticated channel.
%% %
%% As shown by vulnerabilities such as CVE-2016-7054, this AEAD idealization is
%% a major leap of faith that can undermine the guarantees of miTLS when the
%% real implementation diverges from its ideal behavior.
%% %
%% We replace the AEAD idealization with a provably secure AEAD construction
%% that idealizes the pseudo-random function (which uses our verified ChaCha20
%% implementation concretely) and the authentication tag computation
%% (which uses our verified Poly1305 implementation concretely).
%% %
%% Although the details of this security proof are intricate and are detailed in a
%% separate submission (see \S\ref{sec:related}), we emphasize that \lowstar
%% lets one reason about the ideal
%% behavior of concrete low-level implementations that manage various kinds
%% of state (ghost state for the ideal functionality, heap state of the PRF,
%% stack state of input and output buffers). 

We integrated our verified AEAD construction within miTLS at two
levels~\cite{record}.
%
First, we replace the previous AEAD idealization with a module that
implements a similar ideal interface but translates the state and
buffers to \lowstar representations.
%
This reduces the security of TLS to the PRF and MAC idealizations in AEAD.
%
We integrate AEAD at the C level by substituting
the OpenSSL bindings with bindings to the C-extracted version of AEAD.
%
This introduces a slight security gap, as a small adapter that
translates miTLS bytes to \lowstar buffers and calls into AEAD in C is
not verified.
%
We confirm that miTLS with our verified AEAD interoperates with
mainstream implementations of TLS 1.2 and TLS 1.3 on ChaCha20-Poly1305
ciphersuites.

%% %
%% The OCaml-extracted version only achieves a 74 KB/s throughput on a
%% 1GB file transfer. Thus, while it is useful as a reference for
%% verification, it is not usable in practice.
%% %
%% In C, we achieve a 69 MB/s throughput, which is about 20\% of the 354
%% MB/s obtained with OpenSSL.
%% %
%% There is a noticeable cost stemming from the AEAD proof
%% infrastructure, such as indirections needed for algorithmic agility.
%% %
%% Better specialization support in KreMLin may help reduce this
%% overhead.

\iffalse
%ADL Inlining this table for now as we don't report AES
\begin{table}[ht]
\resizebox{\columnwidth}{!}{
\begin{tabular}{|l|c|c|c|}
  \hline
   & AEAD (ML) & AEAD (C) & OpenSSL \\
  \hline
  ChaCha20-Poly1305 & 74 KB/s & 69 MB/s & 354 MB/s \\
  \hline
\end{tabular}
}
  \caption{miTLS Throughput Comparison}
\label{tab:tls}
\vspace{-5mm}
\end{table}
\fi

\iffalse

\subsection{PneuTube}
Our last application, PneuTube, combines cryptographic security verification
and native levels of performance.
%


Our first verification goal is file integrity and sender authentication:
if $B$ receives a file (ostensibly) from $A$, with metadata $m$ and
contents $c$, then $A$ must have sent this file to $B$.
%
In other words, an attacker who controls the network and the
cloud storage provider cannot tamper with files en route.
%
Our second goal is end-to-end confidentiality: the attacker cannot distinguish
between the file contents and a random stream of data of the same length.
%
PneuTube also protects the metadata: it encrypts the file name and
modification time and it hides the file size by padding the file before
encryption.
%
Hence, PneuTube provides better traffic analysis protection than even SSH,
which leaks file length.

\begin{figure}
\centerline{\includegraphics[width=0.8\columnwidth]{pneutube-arch}}
\caption{PneuTube Code Structure}
\label{fig:pneutube-arch}
\end{figure}

The modular structure of PneuTube is depicted in Figure~\ref{fig:pneutube-arch}.
%
The \li$PneuTube$ module uses trusted C libraries (\li$FileIO$, \li$SocketIO$)
for accessing the file system and TCP sockets, and it uses the \haclstar library 
for boxing and unboxing blocks of data.
%
We verify our security goals by type-checking \li$PneuTube$ against the typed
interfaces for these modules, and by relying on the cryptographic assumption
that \haclstar implements public key authenticated encryption (PKAE).
%
Unlike \S\ref{sec:aead}, we do not prove that the box construction of
\haclstar is PKAE-secure based on lower-level assumptions.

We evaluate PneuTube by compiling it to C and by downloading a 1GB
file over the local network. This takes about 5s with PneuTube, while
transferring the same file over SSH (using scp) takes about 8s. 
\fi

\iffalse
% ADL leftover text?
Leveraging on our previous PKAE example, we build a secure file transfer application that
consumes our \textit{box} API. We model typestate by
tying the state of a TCP socket to the current (monadic) heap.

\begin{lstlisting}
module Tcp
val close: s:socket -> Stack bool
  (requires (fun h0 -> current_state h0 s = Open))
  (ensures  (fun _ r h1 -> r ==> current_state h1 s = Closed))
\end{lstlisting}
\fi

\section{Related Work}
\label{sec:related}

\ch{Do we need to relate to Fiat Crypto.
  Independent parallel work.
  \url{https://github.com/mit-plv/fiat-crypto}
  \url{https://people.csail.mit.edu/jgross/personal-website/papers/2017-fiat-crypto-pldi-draft.pdf}
}

\ch{Idris also compiles to C. Want to relate?
  \url{http://docs.idris-lang.org/en/latest/reference/codegen.html}}

Many approaches have been proposed for verifying the functional
correctness and security of efficient low-level code.
%
A first approach is to build verification frameworks for C using
verification condition generators and SMT solvers~\cite{Kirchner:2015,
  cohen2009vcc, verifast}.
%
While this approach has the advantage of being able to verify existing
C code, this is very challenging: one needs to deal with the
complexity of C and with any possible optimization trick in the book.
%
Moreover, one needs an expressive specification language and escape
hatches for doing manual proofs in case SMT automation fails.
%
So others have deeply embedded C, or C-like languages, into proof
assistants such as Coq~\cite{beringer2015verified,
  Appel15, ChenWSLG16} and Isabelle~\cite{WinwoodKSACN09,
  Schirmer2006} and built program logics and verification
infrastructure starting from that.
%
This has the advantage of using the full expressive power of the proof
assistant for specifying and verifying properties of low-level programs.
%
This remains a very labor-intensive task though, because C programs
are very low-level and working with a deep embedding is often cumbersome.
%
Acknowledging that uninteresting low-level reasoning was a determining
factor in the size of the seL4 verification effort~\cite{Klein09sel4:formal},
\citet{GreenawayLAK14, GreenawayAK12} have recently
proposed sophisticated tools for automatically abstracting the
low-level C semantics into higher-level monadic specifications to ease reasoning.
%
We take a different approach: we give up on verifying existing C code
and embrace the idea of writing low-level code in a subset of C
shallowly embedded in \fstar{}.
%
This shallow embedding has significant advantages in terms of reducing
verification effort and thus scaling up verification to larger programs.
%
This also allows us to port to C only the parts of an \fstar program
that are a performance bottleneck, and still be able to verify the
complete program.

\ch{Can we use the \%annot column to quantitatively support the
  ``reducing verification effort'' claim?}

% \ch{Don't think that the latest Isabelle
% work~\cite{GreenawayLAK14, GreenawayAK12} classifies as a deep embedding. They
% present a tool that automatically abstracts low-level C semantics
% into higher level specifications = a shallow monadic embedding. The
% aim is to generate a verified, human-readable specification,
% convenient for further reasoning.'' So what they do goes in
% the opposite direction from what we do. They perform control-flow
% abstraction, heap abstraction, and word to integers abstraction.}

% \ch{Now intro starts with this}
% Finally, one last strand of work uses a radically different approach,
% and relies on a high-level, memory-safe languages such as OCaml for
% writing the cryptographic protocol implementations, and OCaml's
% foreign function interface (FFI) for integrating within existing
% codebases~\cite{kaloper2015not, bhargavan2014proving, LochbihlerZ14}.
% A typical concern is the presence of side-channels due to the use of a
% garbage-collector. Furthermore, since overall performance depends so
% much on the underlying cryptographic primitives, ironically these
% high-level implementations link to insecure C code such as OpenSSL
% libcrypto to perform the actual cryptographic operations.

Verifying the correctness of low-level cryptographic code is
receiving increasing attention~\cite{Appel15, cryptol-s2n,
  beringer2015verified}.
%
The verified cryptographic applications we have written in \lowstar
and use for evaluation in this paper are an order of magnitude larger
than most previous work.
%
Moreover, for AEAD we target not only functional correctness, but also
cryptographic security.

% \ch{Could relate this to the Appel et al proof}
% %
% Galois develops the Cryptol DSL~\cite{cryptol} for specifying crypto
% algorithms and the SAW tool for verifying them against C and Java
% implementations~\cite{saw}.
% % (and at least originally, also compiling such specifications to VHDL).
% SAW uses symbolic execution to recover a formal model of the program
% and then verification condition generation to prove equivalence of models.
% %
% Cryptol and SAW were recently used~\cite{cryptol-s2n} to prove the
% correctness of the C implementation of HMAC in Amazon's s2n TLS
% library~\cite{s2n}.\ch{That's only 100 lines of code though!}

In order to prevent the most devastating low-level attacks, several researchers
have advocated dialects of C equipped with type systems for memory safety
\cite{condit2007dependent, jim2002cyclone, Tarditi16}.
% sound\ch{Added Checked C to the list,
%   although that's not sound. Do we really want to focus on the sound part;
%   all these systems have escape hatches that break soundness, no?}
Others have designed new languages with type
systems aimed at low-level programming, including for instance linear
types as a way to deal with memory
management~\cite{amani2016cogent, matsakis2014rust}. One drawback is
the expressiveness limitations of such type systems:
%the ``complexity wall'' of the type system
once memory safety relies on more complex invariants than these type
systems can express, compromises need to be made, in terms of
verification or efficiency.
%
\lowstar can perform arbitrarily sophisticated reasoning to establish
memory safety, but does not enjoy the benefits of efficient decision
procedures~\cite{rust} and currently cannot deal with concurrency.

% \ch{Merged with previous para}
% Rust~\cite{rust} is an increasingly popular systems programming language. Its type
% system aims to guarantee memory and thread safety, while imposing no
% performance penalty. Programs that fit within Rust's {\em lifetime}
% type discipline are memory safe. We can perform arbitrarily
% sophisticated reasoning to establish memory safety, but do not enjoy
% the benefits of the lifetime automated decision procedure. We also do
% not deal with concurrency in \lowstar.
We are not the first to propose writing efficient and verified C code
in a high-level language. LMS-Verify~\cite{lms-verify} recently
extended the LMS meta-programming framework for Scala with
support for lightweight verification. Verification
happens at the generated C level, which has the advantage of taking
the code generation machinery out of the TCB, but has the disadvantage
of being far away from the original source code.
% This has serious scalability consequences:
% our verification experiments are orders of magnitude larger than the
% HTTP parser verified so far with LMS-Verify, although we deal with functional
% correctness and security, not just memory safety.\ch{Need to be more
%   careful with this since Nada is on the ERC!?}

Bedrock~\cite{chlipala2013bedrock} is a generative meta-programming
tool for verified low-level programming in Coq.
%
The idea is to start from assembly and build up structured code
generators that are associated verification condition generators.
%
The main advantage of this ``macro assembly language'' view of
low-level verification is that no performance is sacrificed while
obtaining some amount of abstraction.
%
One disadvantage is that the verified code is not portable.

\ch{Could also compare to Ironclad / Ironfleet, Compiler from Dafny to
  x86 -- translation validation ... their high-level specs are at
  least checked before translating; they do some crypto too}
% Spartan. -- parallel submission, won't relate to it

Our companion paper ``Implementing and Proving
the TLS 1.3 Record Layer''~\cite{record} is available online.
It describes a cryptographic model and
proof of security for AEAD using a combination of \fstar verification
and meta-level cryptographic idealization arguments. To make the point that
verified code need not be slow, the paper mentions that the
AEAD implementation can be ``extracted to C using an experimental backend
for \fstar'', but makes no further claims about this backend. The
current work introduces the design, formalization,
implementation, and experimental evaluation of this C backend for \fstar.
%
% > Thanks for letting me know of your concurrent submission. The
% papers are clearly related at some level. In evaluating the paper,
% we will take that into account. I see that the record.pdf submission
% is blinded (i.e. author names are removed), thus, reviewers can
% potentially take a look.
% > One thing you can do to clarify the
% relationship you described in your mail is to take the record.pdf
% and make it available as a supplementary material, and perhaps
% describe the differences, as you did in the mail, directly in the
% related work of the paper. This will make it easier for us.

% {\scriptsize
% \begin{verbatim}
% Related work, compare to:
% 1. deep embedding in proof assistants
%    and extrinsic proofs of deep properties
% 2. Hoare-style verifiers for C programs:
%    VCC, Verifast
%    + they verify *existing* C programs
%    + embrace as much as C as possible
%    + try to do all their proofs by VC generation
% 3. Dependently typed: Deputy, Cyclone etc.
%    + C with a type system for simple invariants;
%      focus is on memory safety
%    + the reason this failed is that you hit a wall of complexity; for
%      which simple invariants are not enough; no such problem with F*
% 2. fiat crypto, Gallois, DeepSpec
%   + verify low-level directly
%   + struggling with the low-level
% \end{verbatim}
% }

\comment{
old ideas of compiling ML to Rust, compare to optimizing compilers
(e.g. OCaml), etc. esp. how we compare to OCaml (extra bit, no pointer
arithmetic).
}\ch{Not sure what this is about}


% Could also compare to WysStar, which is another security-verification
% oriented DSL on top of \fstar
% \url{https://research.microsoft.com/en-us/um/people/nswamy/papers/wys.pdf}

\section{Conclusion}
\input{conclusion}

\section*{Acknowledgments}
We thank the anonymous reviewers for their excellent reviews. We also thank
Abhishek Anand and Mike Hicks, for useful feedback and discussion which helped
shape the work presented here, as well as Armaël Guéneau, for his work on a
mechanized proof.
%
J-K. Zinzindohou\'e and K. Bhargavan received funding from the
European Research Council (ERC) under the European Union’s Horizon
2020 research and innovation programme (grant agreement no. 683032 - CIRCUS).
%
C. Hri\c{t}cu was in part supported by the European Research Council
under ERC Starting Grant SECOMP (715753).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\iflong
\newpage
\appendix

%% taramana 2016-11-14: from \lamstar to \cstar
\input{low-to-c-appendix}

%% taramana 2016-10-06: from \cstar to CompCert C and beyond
\input{toclight-appendix}

\newpage
\section{Proof of the secret independence theorem}

\begin{small}
\verbatiminput{abstraction.txt}
\end{small}

%% \appendix
%% \section{Appendix Title}

%% This is the text of the appendix, if you need one.

%% \acks

%% Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

%% \begin{thebibliography}{}
%% \softraggedright

%% \bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%% P. Q. Smith, and X. Y. Jones. ...reference text...

%% \end{thebibliography}

\newpage
\fi%long

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The bibliography should be embedded for final submission.
% taramana 2016-10-07: Until then, let us use the following:
\bibliography{biblio,fstar,tls}

\iflong
\else
\balance
\fi

\end{document}
