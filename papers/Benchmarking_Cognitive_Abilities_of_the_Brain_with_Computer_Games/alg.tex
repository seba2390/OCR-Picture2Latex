BrainB is a Qt C++ desktop application that uses the OpenCV library. It is developed as an open source project 
that is available on GitHub \cite{brainbsw}. Its source can be built easily on GNU/Linux systems. But the latest (6.0.3) Windows binary release can also be downloaded as a ZIP file from \url{http://smartcity.inf.unideb.hu/~norbi/BrainBSeries6/}.


It is important to show the algorithm of BrainB  as precise as possible because the randomness plays a key role in its operation due to boxes doing random walks.
The code snippet shown in Listing \ref{updadeHeroes} is the heart of our benchmark program. 
It is a simplified version of the original source code that can be found in the GitHub repository at  \url{https://github.com/nbatfai/esport-talent-search/blob/master/BrainBWin.cpp#L65}.
This code is executed at every 100 milliseconds that is ten times per second. 
First, as shown in Line \ref{dist}, it computes the distance between the mouse pointer and the center of the box of Samu Entropy and the result is stored in the variable called $dist$ that holds the square of the Euclidean distance. If the distance is larger than $121$ pixels ($11$ is the square root of $121$) and 
if it reoccurs $12$ consecutive times or more in a row (that means at least a time interval of $1.2$ seconds) 
and it is also true that the player was controlling the character well in the previous time slices 
(that is in Line \ref{found} the $state$ is equal to $found$)
then we say that the user has lost the character Samu Entropy and the visual complexity of the display will be saved in Line \ref{save}. The sequence of these losing values and the symmetrical finding values saved in Line \ref{save2} are shown in Fig \ref{brainbs6winnb1}. The complexity is computed in bits per second (bps) units that is based on the number of changed pixels between two consecutive rectangular environments of the character with a given width and height.


%\lstset{language=C++,numbers=left,stepnumber=1,numbersep=-1pt,basicstyle=\scriptsize\ttfamily,caption={The algorithm for administration of  losing and finding the character},label=updadeHeroes,escapechar=|}


\begin{lstlisting}[language={C++},numbers={left},stepnumber={1},numbersep={-1pt},basicstyle={\scriptsize\ttfamily},caption={The algorithm for administration of  losing and finding the character.},label={updadeHeroes},escapechar={|}]
 int dist = ( this->mouse_x - x ) * ( this->mouse_x - x ) |\label{dist}|
  + ( this->mouse_y - y ) * ( this->mouse_y - y );

 if ( dist > 121 ) 
  {
    ++nofLost;
    nofFound = 0;
    if ( nofLost > 12 ) 
      {
        if ( state == found && firstLost ) |\label{found}|
          {
            found2lost.push_back(brainBThread->get_bps()); |\label{save}|
          }
        firstLost = true; |\label{foundlost}|
        state = lost;
        nofLost = 0;
        brainBThread->decComp();
      }
  } 
 else 
  {
    ++nofFound;
    nofLost = 0;
    if ( nofFound > 12 ) 
      {
        if ( state == lost && firstLost ) |\label{lost}|
          {
            lost2found.push_back(brainBThread->get_bps()); |\label{save2}|
          }
        state = found;|\label{lostfound}|
        nofFound = 0;
        brainBThread->incComp();
      }
  }
\end{lstlisting}


The final result printed by the benchmark after it ends in the form \enquote{\textit{U R about 5.92902 Kilobytes}} is the mean of upper bounds for the bps values of the display measured when the variable state changes from found to lost (in Listing \ref{updadeHeroes} from Line \ref{found} to \ref{foundlost}) and vice versa, when the variable state changes from lost to found (in Listing \ref{updadeHeroes} from Lines \ref{lost} to \ref{lostfound}). The simple calculation of this final result is shown in Listing \ref{bps}.


\begin{lstlisting}[language={C++},numbers={left},stepnumber={1},numbersep={-1pt},basicstyle={\scriptsize\ttfamily},caption={The calculation of the final result of the benchmark that is produced in a text file that is saved in the folder where the benchmark was started.},label={bps},escapechar={|}]
  int m1 = mean ( lost2found );
  int m2 = mean ( found2lost );
  
  double res = ( ( ( ( double ) m1
     + ( double ) m2 ) /2.0 ) /8.0 ) /1024.0;
     
  textStream << "U R about " << res << " Kilobytes\n";
\end{lstlisting}


\begin{figure}
  \centering
%    \includegraphics[width=0.5\textwidth]{nb1}
     \includegraphics[width=0.75\textwidth]{nb1}
  \caption{The bps values associated to events of losing and finding. The first element of this sequence is the first element of the \textit{lost2found} (shown in Listing \ref{updadeHeroes} Line \ref{found}) sequence. 
  The second element is the first element of the \textit{found2lost}, and so on. It should be noticed that the 
  losing (labelled by L) and finding (F) events are mixed, see, for example the 13th event on the $x$ axis where the complexity of finding is greather than the complexity of losing in this individual measurement. This test was performed by the first author (46 years old, 
  on a Dell XPS 9333 ultrabook with Windows 10 using the touchpad, 
  resolution 1920x1080, scale 150\%). The final result was 5.92902 Kilobytes. All the logged data can be found at \url{http://smartcity.inf.unideb.hu/~norbi/BrainBSeries6/measurements/NB/}. Fig \ref{brainbs6screen} shows the last screenshot of this experiment.}
   \label{brainbs6winnb1}
\end{figure}
