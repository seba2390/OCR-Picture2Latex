\addcontentsline{toc}{section}{Preliminaries}
\section{Preliminaries}
Throughout this paper, the following notions are used to introduce our proposed approach.
Let $\Sigma$ be a finite alphabet.
\small
\begin{compactitem}
	\item $\Sigma^*$: is the set of all finite words over $\Sigma$, comprising the empty word $\varepsilon$;
	\item $L \subseteq \Sigma^*$: $L$ the language defined on $\Sigma^*$.
\end{compactitem}
The sequence $u$ is a prefix of  $v \in \Sigma^*$, denoted by $u \prec v$, if $\exists w$ s.t $u \cdot w = v$. We note $v-u=w$.
\subsection{Petri nets, WF-net and oWF-nets}
To model the services under consideration in our case study, we use Petri nets. A service can be considered as a control structure describing its behavior in order to reach a final state. We can represent it using a Workflow net, a subclass of Petri nets. A WF-net satisfies two requirements: it has one input place $i$ and one output place $o$, and every transition $t$ or place $p$ should be located on a path from place $i$ to place $o$. To model the communication aspect of a service, we can use another variant of Petri nets called open Work-Flow nets which is enriched with communication places representing the (asynchronous) interface. Each communication place represents a channel to send or receive messages to or from another oWF-net. 
\begin{definition}[oWF-net \cite{Massuthe05anoperating}] \mbox{} \\
\small
	An open Work-Flow net is defined by a tuple $\mathcal{N} = (P, T, F,W,m_0, I,O,m_f)$:
	\vspace{-0.3cm}
	\begin{itemize}
		\item $(P, T, F, W)$ is a WF-net;
			\begin{compactitem}
			\item $P$ is a finite set of places and $T$ a finite set of transitions;
			\item $F$ is a flow relation $F\subseteq  (P\times T) \cup  (T\times P);$
			\item $W: F \rightarrow \mathbb{N}$ is a mapping allocating a weight to each arc.
			\end{compactitem}
		\item $m_0$ is the initial marking;
		\item $I$ is a set of input places and $O$ is a set of output places ($I\cup O$: the set of interface places). 
		\item $m_f$ is a final marking.
	\end{itemize}
\end{definition}
\vspace{-0.3cm}
Having the same semantics as Petri nets, the behavior of WF-nets and oWF-nets can be represented by Labeled Transition Systems (LTS), a more general model than the reachability graph.

\subsection{Labeled Transition System}
An LTS is defined as follows:
\begin{definition}[Labeled Transition System] \mbox{} \\
\small
A Labeled Transition System is a  $4$-tuple $\mathcal{G}=(Q,q_{init},\Sigma,\delta)$:
	\small
	\vspace{-0.3cm}
	\begin{itemize}
		\item $Q:$ a finite set of states;
		\item $q_{init}:$ the initial state;
		\item $\Sigma:$ actions' alphabet;
		\item $\delta: Q \times \Sigma  \rightarrow Q:$ the transition function where: $q,\; q' \in Q$ and $\sigma \in \Sigma$, $\delta (q,\sigma)=q'$ meaning that an event $\sigma$ can be executed at state $q$ leading to state $q'$.
	\end{itemize}
\end{definition}
\vspace{-0.3cm}
The language of an LTS $\mathcal{G}$ is defined by $L(\mathcal{G})=\{t \in \Sigma^*, q_0 \xrightarrow{t} q_f\}$. An LTS can be considered as an automaton where all states are accepting final states. Therefore, the language accepted by the LTS is prefix-closed.

To reflect the observable behavior of an LTS, we specify a subset of events $\Sigma_o \subseteq \Sigma$ and $\Sigma - \Sigma_o = \Sigma_{u}$ where $\Sigma_o$ is the set of events visible to a given observer and $\Sigma_{u}$ is the set of events which are invisible to said-observer. The behavior visible by an observer is defined by the projection $P_{\Sigma_o}$ from $\Sigma^*$ to $\Sigma_o^*$ that removes from a sequence in $\Sigma^*$ all events not in $\Sigma_o$. Formally, $P_o$: $\Sigma^*$ $\rightarrow \Sigma^*_o$ is defined s.t.:\\
$ \begin{cases}
P_{\Sigma_o}(\epsilon)=\epsilon; \\
P_{\Sigma_o}(u \cdot \sigma)= \begin{cases}
P_{\Sigma_o}(u) \:\text{if}\: \sigma \notin \Sigma_o;\\
P_{\Sigma_o}(u)\cdot \sigma \;\text{otherwise}.
\end{cases} $ 
 \text{Where:} $\sigma \in \Sigma \: \text{and} \: u \in \Sigma^*$.
$ \end{cases}$
\subsection{Opacity}
Opacity's main interest is in capturing the possibility of using observations and prior-knowledge of a system's structure to infer secret information. It reflects a wide range of security properties. Opacity's parameters are a secret predicate, given as a subset of sets or traces of the system's model, and an observation function. This latter captures an intruder's abilities to collect information about the system. A system is, thus, opaque w.r.t. the secret and the observation function, if and only if for every run that belongs to the secret, there exists another run with a similar projection from the observer's point of view and that does not belong to the secret \cite{Dubrieil2009, falcone, FengLin}.
In this paper, we focus on 3 opacity variants as defined by the authors in \cite{falcone}: simple, $K$-step weak and $K$-step strong opacity.
\begin{definition}[Simple opacity \cite{falcone}] \mbox{} \\
\small
	Given an LTS $\mathcal{G}=(Q,q_{0},\Sigma,\delta)$ with $\Sigma_{o} \subseteq \Sigma$ is the set of observable events and $S\subseteq Q$ is the set of secret states.
	The secret $S \subseteq Q$ is opaque under the projection map $P_{\Sigma_{o}}$ ou $(G, P_{\Sigma_{o}})-opaque$ iff: $ \forall u \in L_{S}(G), \exists v\in L(\mathcal{G}): (v\;\approx_{\Sigma_{o}} \: u) \wedge (v \notin L_{S}(G)).$
	\label{def:simpleop}
\end{definition}

While simple opacity deals with the non-discloser of the fact that the system is currently in a secret state, $K$-step opacity deals with the non-discloser of the fact that the system was in a secret state in the past. $K$-step weak opacity ensures that the system wasn't in a secret state $K$ observable events ago, while $K$-step strong opacity formulates the need to make sure that, $K$-steps backwards, the system does not end, and have not crossed any secret states.

\subsection{Symbolic Observation Graph}
The SOG is an abstraction of the reachability graph. It is constructed by exploring a system's observable actions which are used to label its edges. The unobservable actions are hidden within the SOG nodes named aggregates. Binary Decision Diagrams (BDDs) \cite{bryant92} are used to represent and efficiently manage the SOG nodes.
The definition of an aggregate and that of the SOG are given in the following:
\begin{definition}[Aggregate] \mbox{} \\
\small
	Given an LTS $\mathcal{G}\:=(Q,q_{0},\Sigma,\rightarrow, \delta)$ with $\Sigma = \Sigma_{o} \cup \Sigma_{u}$. An aggregate $aâ€™$ is a non empty set of states satisfying: $q\in a \Leftrightarrow Saturate(q)\subseteq a$ where: $Saturate(q)=\{ q' \in Q :  q \xrightarrow{w} q' \text{and} \: w \in \Sigma^{*}_{u}\}.$
\end{definition}

\begin{definition}[Deterministic SOG] \mbox{} \\
\small
A deterministic $SOG (\mathcal{A})$  associated with an LTS $\mathcal{G}= (Q,q_{0},\Sigma_{o}\cup\Sigma_{u},\delta)$ is an LTS  $(A,a_{0},\Sigma_{o},\Delta)$ where:
\vspace{-0.3cm}
\begin{enumerate}
\item \label{def:SOG:dnodes}$A$ a finite set of aggregates with:
\begin{enumerate}
\item \label{def:SOG:dnodes1} $a_0 \in A$ is the initial aggregate s.t. $a_0=Saturate(q_{0}) \text{;}$
\item \label{def:SOG:dnodes2} For each $a \in  A$, and for each $\sigma\in \Sigma_{o}$, $\exists q\in a, q'\in Q \colon q
\xrightarrow{\sigma} q' \Leftrightarrow \exists a'\in A:\; a'=Saturate (\{q'\in Q, \exists q\in a \: with \:
q \xrightarrow{\sigma}q'\}) \wedge (a,\sigma,a') \in \Delta$;
\end{enumerate}
%\item \label{def:SOG:dlabels} $\Sigma_{A}=\Sigma_{o}$;
\item \label{def:SOG:darcs} $\Delta \subseteq A\times
\Sigma_{o} \times A$  is the transition relation.
\end{enumerate}
\end{definition}
\vspace{-0.3cm}
The SOG allows the on-the-fly-verification of opacity variants: simple, $K$-step weak and $K$-step strong opacity \cite{bourouis2015checking}. It also allows the detection of cases of opacity violation.  