	
\scalebox{0.87}{
	\begin{minipage}[t]{6.1cm}
		\null 
		\begin{algorithm}[H]
			\label{alg:OSOG}
			\caption{SOG-based Opacification}
			%\tiny
			\scriptsize 
			\SetAlgoLined
			\SetKwInput{KwFunc}{Procedure}
			\KwFunc{SOG-based Opacification ($(P, T, F,W),m_o,m_S,\Sigma_{o}\cup\Sigma_{u}$)}
			$\textbf{Vertices}\; V; \; \textbf{Edges}\; E$\;
			$\textbf{Aggregate} \; a,a'$\;
			$\textbf{Stack} \; st, \;CounterExample$\;
			$\textbf{Incidence Matrix} \; C$\;
			\Begin{
				$(Q,q_{init},\Sigma,\delta) \leftarrow \textbf{BuildReachabilityGraph}(P, T, F,W,m_o)$\;
				$S \leftarrow m_S$\;
				$a \leftarrow Saturate(\{q_{init}\})$\;
				
				\If{($a \subseteq S$)}{
					$CounterExample.\textbf{Push}(\epsilon,a,\epsilon,a)$;
				}
				%else if1
				$V \leftarrow {a}; E \leftarrow \varnothing $\;
				$trace\leftarrow\emptyset$\;
				$st.\textbf{push}\left((a,EnableObs(a))\right)$\;
				\While{$(st \neq \emptyset)$}{
					$(a,enb) \leftarrow st.\textbf{Top}()$\;
					\eIf{$(enb \neq \emptyset)$}{
						$st.\textbf{Pop}()$\;
					} %else if2
					{
						$t \leftarrow RemoveLast(st.Top.Second())$\;
						$a' \leftarrow Img(a,t)$\;
						$a' \leftarrow Saturate(a')$\;	
						\eIf{(Treated(a'))}{
							$E \leftarrow E \cup t$\;
							$Save(a \xrightarrow{t} a')$\;		
						} %else if3
						{
							\If{($a' \subseteq S$)}{
								$Trace= Print$\\ \nonl $CounterExample()$\;
								$CounterExample.$\\ \nonl$\textbf{Push}(trace,a,t,a')$\;	
							} %end if4
							
							$V \leftarrow V \cup \{a'\}$\;
							$ E \leftarrow E \cup t$\;
							$Save(a \xrightarrow{t} a')$\;
							$st.\textbf{Push}(a',EnableObs(a'))$\;
							
						}%end if3
					} %end if2
				} %While
				%end if1
				\If{$(CounterExample \neq \emptyset )$}{$\textbf{Opacification}()$\;}
			} % endbegin
		\end{algorithm}
	\end{minipage}%
}
%\vspace{5cm}
\scalebox{0.93}{
	\begin{minipage}[t]{6.1cm}
		\null
		\begin{algorithm}[H]
			\label{alg:Opacification}
			\caption{Opacification}
			%\tiny
			\scriptsize 
			\SetAlgoLined
			\SetKwInput{KwFunc}{Procedure}
			\KwFunc{Opacification$()$}
			\Begin{
				$minSL=\textbf{ComputationMinSL}(L()$\;
				\While{$(CounterExample \neq \emptyset)$}{
					$(trace,a,t,a')\leftarrow CounterExample.\textbf{Top}()$\;
					\If{($NotTreated(a'))$}{
						\ForEach{$u \;\textbf{in }\; minSL$}{
							\If{$(u = trace)$}{
								\tcc{SOG Opacification}
								$q_{new} = new \; State()$\;
								$a' \leftarrow a' \cup \{q_{new}\}$\;
								$Save(a \xrightarrow{t}a')$\;
								\tcc{LTS Opacification}
								$q\leftarrow CounterExample.\textbf{Top.Fourth}()$\;
								$t_{new} \leftarrow new \; UnobservableTransition()$\;
								$Q \leftarrow Q \cup {q_{new}}$\;
								$\Sigma_{u} \leftarrow \Sigma_{u} \cup t_{new}$\;
								$\delta(q,t_{new})=q_{new}$\;
								\tcc{Petri net Opacification}
								$p_{new} \leftarrow new Place()$\;
								$P \leftarrow P \cup p_{new}$\;
								$T \leftarrow T \cup t_{new}$\;
								$p \leftarrow$ $\textbf{getPlace}()$\;
								$F \leftarrow F \cup (p, t_{new})$\;
								$F \leftarrow F \cup (t_{new}, p_{new})$\;
								$W \leftarrow W \cup \{ ((p, t_{new}) \longmapsto 1) , ((t_{new}, p_{new}) \longmapsto 1)  \}$\;
								$C(p_{new},t_{new}) \leftarrow W(t_{new},p_{new}) - W(p_{new},_{tnew}) $\;
							}	%endIf1
						}%end foreach	
					}%end if not treaed
					$CounterExample.\textbf{Pop}()$\;
				}%end while
			}
		\end{algorithm}
	\end{minipage}
}