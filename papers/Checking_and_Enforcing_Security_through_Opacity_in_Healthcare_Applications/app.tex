\addcontentsline{toc}{section}{SOG-based Enforcement of Opacity}
\section{SOG-based Enforcement of Opacity}
In this section, we describe the opacity enforcement problem introducing algorithms to secure the heart attack detection system. Considering a language $L$ and a secret language $L(\varphi) \in L$, when opacity fails of a secret $\varphi$ for a finite system $S$, we provide an effective method to synthesize automatically a system $S'$ obtained by minimally modifying the system S so that the secret $\varphi$  is opaque for $S'$. To synthesize $S'$, we focus on language modification. If a secret language $L(\varphi)$ is not opaque for a system behavior described by the language $L(S)$, we can modify the behavior by padding it with dummy behaviors. We can then extend the language by computing a minimal super-language of $L$. In \cite{Yeddes16}, the author has derived an algorithm to compute $min \; \prod_{super}^\varphi$ to assist the designer develop a system that satisfies the opacity property for a secret language.
\begin{theorem} \cite{Yeddes16}
	\label{theorem:minimal}
	Let a language $L$ defined on an alphabet $\Sigma = \Sigma_{o} \cup \Sigma_{u} $ and a static projection $\pi_O$ defined above on the same alphabet and a secret $\varphi \subseteq L$, then:
	\centering $min\; \prod_{super}^\varphi(L) = L \cup (\pi_o(\varphi) \backslash (\pi_o(\varphi)\cap \pi_o(L \backslash \varphi)))$	
\end{theorem}

The proposed approach builds upon the SOG structure to check the system's opacity. If the system is not opaque, the SOG construction allows for detection of all opacity violations provided as a counterexample. These counterexamples will later be used to improve the system security (opacity) by locating the paths leading to the disclosure of private information and performing necessary changes that would render it opaque. 
Then we compute the minimal super-language that provides us with the restricted language to be added in order to modify the system behavior. For each incident of opacity violation, we match a trace among the calculated super-language and an unobservable event will be added to this trace. In order to opacify the system, we apply the backtracking method. We implement adjustments where needed to the SOG and the LTS and we thus return to the starting model, the Petri net. 

\subsection{The SOG-based Algorithm for the Verification of Simple Opacity}
The use of SOG-based algorithm in the verification of simple opacity proved efficient \cite{bourouis2015checking}. This is due to the symbolic representation of the aggregates (employing BDDs), and to the on-the-fly verification (Opacity is verified while constructing the SOG). The SOG construction is stopped when the property is proven unsatisfied and a trace (counterexample) that violates the opacity is supplied. To adopt this algorithm for our enforcement approach, we will bring necessary modifications to it.
\input{sogalgorithm.tex}

The verification is performed on LTS-modeled systems. Taking into account that we are trying to opacify Petri nets, the first modification needed to the algorithm presented in \cite{bourouis2015checking} consists in replacing the input by a Petri net-modeled system. The petri net has 2 sets of transitions: observable and unobservable actions, and a set of secret marking subsequently representing the states judged to be secret in the LTS.  We add in line 3 a Stack, namely $CounterExample$  with all the standard functions ($push$, $pop$ and $top$), whose elements are quadruples composed by the counter-examples, a transition $t$, an actual aggregate $a$ and an aggregate $a'$, successor of $a$ by $t$. Then, the algorithm 1 starts by constructing (line 6) the reachability graph which represents the LTS. Once other changes have been made (i.e. line 10 \& 29), when the opacity is violated, neither the verification nor the construction of the SOG stops. All the paths leading to the disclosure of privacy are stacked into $CounterExample$. Once all nodes are explored and the SOG construction is finished, and if the stack is not empty we proceed to opacification.
\subsection{The Opacification Proposed Algorithm}
The opacification algorithm has a pretty straightforward mechanism. It begins by computing the minimal super-language ( Theorem \ref{theorem:minimal}). The next step consists in recuperating (line 4) the first elements of the stack ($CounterExample$). Next, the algorithm goes through the $foreach$ loop which takes each word of the calculated super-language. If such a word is equivalent with the trace recuperated from the stack, then we proceed to opacify the SOG. We begin by creating (line 8) a new state $q_{new}$ that we will add (line 9) into the aggregate $a'$.
At line 11, we pass to opacify the LTS. We retrieve the last state $q$ included in the aggregate $a'$. A new unobservable transition $t_{new}$ will be created. Then, the algorithm inserts (line 13) the new state $q_{new}$ to the LTS states, adds (line 14) the new transition $t_{new}$ to the set of unobservable events $\Sigma_{u}$, and defines the transition function between $q$, $t_{new}$ and $q_{new}$. 
Starting from line 16, the algorithm performs the Petri net opacification by creating, at first a new place $p_{new}$ and adding it to the set of places. It also adds the transition $t_{new}$ to the set of transitions. To specify the flow relation between $p$, $t_{new}$ and $p_{new}$, the algorithm adds an arc for each relation and assigns to each arc a weight. Afterwards, it modifies the incidence matrix. Finally, the algorithm pops the stack and restarts the operations until the final emptying of the stack presenting the ending test of the while loop.

Being a particular type of Petri nets, oWF-nets require different method of opacification. When fetching the place $p$ (the execution of $getPlace$), we have to exclude the output places. Furthermore, oWF-nets require only one final place $p_o$. So, following the addition of the unobservable transition $t_{new}$, we must escape adding the new place. And a flow relation will be added between $t_{new}$ and $p_o$. Other specific case that may be necessary,  when the place returned by $getPlace$ is a destination place, we require further changes on the oWF-net. The first step is to retrieve the transition that following its crossing marked the output place. Step two is to delete the flow relation between $t$ and $p_o$. The following step is to create a new place $p_{new}$ and to add the unobservable transition $t_{new}$. Then, we create the flow relations between $t$, $p_{new}$, $t_{new}$ and $p_o$.
\subsection{Case Study Opacification}
Through the case study presented earlier, we will show the practical use of our approach. In this section, we will describe the changes we are making to render the CPr workflow opaque.

Conducting the opacity verification, we noted that the CPr workflow is not opaque and the algorithm 1 returned two counterexamples: 
$CounterExample=\{
(T_7T_{13}T_{19}T_{18},$\\$ \; \{S_{13},S_{18}\}, \; T_{18}, \; \{S_{22}\}), \;
(T_7T_{13}T_{16}T_{21}, \; \{S_{14},S_{19}\}, \; T_{21}, \{S_{23}\}) \}$. \\
As the opacification algorithm starts by computing the minimal super-language, the function $ComputationMinSL$ returns the following result: \\ $minSl=\{T_7T_{13}T_{19}T_{18},\; T_7T_{13}T_{16}T_{21}\}$.

The next step of our opacification approach is to bring the necessary modifications to the SOG and then we return to the LTS and to the Petri-net. To treat the first opacity violation for the CPr, the algorithm 2 starts by creating a new state $q_{new}=S_{27}$. This is added to the aggregate that contains $S_{22}$. Then, a new unobservable transition is created ($t_new = T_ {22}$) and  the relation between $S_{22}$, $T_{22}$ and $S_{27}$ is defined. 
The final step is the opacification of the oWF-net. To do this, we applied the specific case of algorithm 2. We start first by removing the flow relation ($T_{21} Ã— P_o$). Thereafter, we add the place $P_ {17}$. Finally, we add flow relations: $F \leftarrow F \cup (T_{21},P_{17})$, $F \leftarrow F \cup (P_{17},T_{22})$ et $F \leftarrow F \cup (T_{22},P_o)$.

The changes made to render the CPr workflow opaque are depicted in Figure \ref{fig:prive_opacification}.
\input{opacification_prive.tex}

