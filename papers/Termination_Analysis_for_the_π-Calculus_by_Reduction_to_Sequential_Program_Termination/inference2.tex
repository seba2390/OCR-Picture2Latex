\newcommand{\constr}{\mathbb{C}}
\newcommand{\Inf}[4]{\fname{Inf}(#1; #2; #3; #4)}
\newcommand{\newty}[1]{\fname{NewTy}(#1)}
\newcommand{\newtys}[1]{\fname{NewTys}(#1)}
\newcommand{\subty}[3]{\fname{SubTy}(#1; #2; #3)}
\newcommand{\subtys}[3]{\fname{SubTys}(#1; #2; #3)}

\subsection{Type Inference}  \label{sec:inference}

This section discusses how to infer refinement types automatically
to automatically achieve the transformation.
As in refinement type inference for functional programs~\cite{Jhala08,Unno09PPDP,DBLP:journals/jar/ChampionCKS20},
we can reduce refinement type inference for the \(\pi\)-calculus to
the problem of CHC (Constrained Horn Clauses) solving~\cite{Bjorner15}.

We explain the procedure through an example.
Once again, we use the process \( \DEC \) introduced in Example~\ref{ex:weakeness-of-basic-transformation}.
We first perform type inference for the simple type system in Section~\ref{sec:targetlanguage}, and (as we have seen) obtain the following simple types for \( \pre \) and \( f \):
\begin{align*}
    \pre\COL \Chty{\reg_1}{\ty}{\sChty{\reg_2}{\ty}}, \quad
    \cname{f} \COL \Chty{\reg_3}{\ty}{\sChty{\reg_4}{\ty}}
\end{align*}
Here, we have omitted the types for other (bound) channels \(r,s,y\),
as they can be determined based on those of \( \pre \) and \( f \).
Based on the simple types, we prepare the following templates for refinement types.
\begin{align*}
  \pre\COL \rch{\reg_1}{n}{P_1(n)}{\sChty{\reg_2}{x; P_2(n,x)}}, \quad
  f\COL \rch{\reg_3}{n}{P_3(n)}{\sChty{\reg_4}{x; P_4(n,x)}}.
\end{align*}
Here, \(P_i\) (\(i\in\set{1,\ldots,4}\)) is a predicate variable that represents
unknown conditions.

Based on the refinement type system, we can generate the following constraints on
the predicate variables.
\[
\begin{array}{l}
  \forall n.(P_1(n) \imp P_2(n, n-1))\qquad
  \forall n.(P_3(n)\land n<0 \imp P_4(n, 1)) \\
  \forall n.(P_3(n)\land n\ge 0 \imp P_1(n-1))\\
  \forall n,x.(P_3(n)\land n\ge 0\land P_2(n-1,x) \imp P_3(x))\\
  \forall m.(\TRUE \imp P_3(m))
\end{array}
\]
Here, the first constraint comes from the first line of the process,
and the second constraint (the third and fourth constraints, resp.)
comes from the then-part (the else-part, resp.)
of the second line of the process. The last constraint
comes from \(\outatom{f}{m}{r}\).

The generated constraints are in general a set of \emph{Constrained Horn Clauses}
(CHCs)~\cite{Bjorner15} of the form
\(\forall \seq{x}.( P_1(\seq{v}_1)\land \cdots \land P_k(\seq{v}_k)\land \pred \imp H)\),
where \(P_1,\ldots,P_k\) are predicate variables, \(\pred\) is a formula
of integer arithmetic (without predicate variables),
and \(H\) is either of the form \(P(\seq{v})\) or \(\pred'\).
The problem of finding a solution (i.e. an assignment of predicates to
predicate variables) of a set of CHCs is undecidable in general,
but there are various automated tools (called CHC solvers)
for solving the problem~\cite{DBLP:journals/fmsd/KomuravelliGC16,DBLP:journals/jar/ChampionCKS20}.
Thus, by using such a CHC solver, we can solve the constraints on predicate variables,
and obtain refinement types by substituting the solution for the templates of
refinement types.

For the example above, the following is a solution.
\[
\begin{array}{l}
  P_1(n)\equiv \TRUE\qquad P_2(n,x)\equiv x < n\qquad 
P_3(x) \equiv \TRUE \qquad P_4(n,x)\equiv \TRUE.
\end{array}
\]
This is exactly the predicates we used in Example~\ref{ex:refined-transformation-for-f} to translate \( \DEC \) using the refined approach.

\subsubsection*{Adding extra CHCs.}
Actually, a further twist is necessary in the step of CHC solving.
As in the example above, all the CHCs generated based on the refinement typing rules
are of the form \(\cdots \imp P_i(\seq{v})\) (i.e., the head of every CHC is
an atomic formula on a predicate variable).
Thus, there always exists a trivial solution for the CHCs, which instantiates
all the predicate variables to \(\TRUE\).
For the example above,
\[
\begin{array}{l}
  P_1(n)\equiv \TRUE\qquad P_2(n,x)\equiv \TRUE\qquad 
P_3(n) \equiv \TRUE \qquad P_4(n,x)\equiv \TRUE
\end{array}
\]
is also a solution,
but using the trivial solution,
our transformation yields the non-terminating program.
This program is essentially the same as the one in Example~\ref{ex:weakeness-of-basic-transformation} since \( \ndlet*{x}{\assexp{\TRUE}}\Exp \) is equivalent to \( \ndlet*{x}\Exp \).
Typical CHC solvers indeed tend to find the trivial solution.

To remedy the problem above, in addition to the CHCs generated from the typing rules,
we add extra constraints that prevent infinite loops.
For the example above, the definition of \(\Fname{\reg_3} \) (which corresponds to the channel \( f \)) in the translated program is of the form
\[  \Fname{\reg_3}(n) = \ifexp{\!n<0\!}{\!\skipexp\!}{\Fname{\reg_1}(n) \nondet  (\letexp{x}{\ndint}\assexp{P_2(n,x)}\Fname{\reg_3}(x))}.
\]
Thus we add the clause:
\[ P_2(n,x) \imp n\ne x\]
to prevent an infinite loop \(\Fname{\reg_3}(m)\red \Fname{\reg_3}(m) \red \cdots\).
With the added clause, a CHC solver \hoice{}~\cite{DBLP:journals/jar/ChampionCKS20}
indeed returns \(n<x\) as the solution for \(P_2(n,x)\).

In general, we can add the extra CHCs in the following, counter-example-guided manner.
\begin{enumerate}
\item \(\mathcal{C} := \) the CHCs generated from the typing rules
\item \(\theta := \mathit{callCHCsolver}(\mathcal{C})\)
\item \(S := \) the sequential program generated based on the solution \(\theta\)
\item if \(S\) is terminating then return OK; otherwise, 
 analyze \( S \) to find an infinite reduction sequence, add an extra clause to \(\mathcal{C}\) to disable the infinite sequence, and go back to 2.
\end{enumerate}
\changed{
More precisely, in the last step, the backend termination analysis tool generates a lasso
as a certificate of non-termination. We extract 
a chain $f(\seq{x}) \to \dots \to f(\seq{x}')$ of recursive calls
from the lasso, and
add an extra clause requiring $\seq{x} \neq \seq{x}'$
to \(\mathcal{C}\). This is naive and insufficient
for excluding out an infinite sequence like \(f(1)\to f(2) \to f(3) \to \cdots\).
We plan to refine the method by incorporating more sophisticated techniques
developed for sequential programs~\cite{hashimoto2015refinement}.
}