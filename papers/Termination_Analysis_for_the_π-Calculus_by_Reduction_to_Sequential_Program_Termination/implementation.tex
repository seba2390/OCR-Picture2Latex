\section{Implementation and Preliminary Experiments}  \label{sec:implementation}





\subsection{Implementation}
We have implemented a termination analysis tool for the $\pi$-calculus based on the method
described in Sections~\ref{sec:approach} and \ref{sec:refinement}.
This tool was written in OCaml. We chose C language as the actual target of our translation,
and used \ult{}~\cite{heizmann2016ultimate} (version 0.2.1) as a termination analysis tool for C.

For the refinement type inference described in Section~\ref{sec:inference},
we have used
\hoice{}~\cite{DBLP:journals/jar/ChampionCKS20} (version 1.8.3)
and \zthree{}~\cite{de2008z3} (version 4.8.10) as backend CHC solvers.
Since a stronger solution for CHCs is preferable as discussed at the end of
Section~\ref{sec:inference}, if \hoice{} and \zthree{} return
different solutions
\(\set{\predvar_1\mapsto \pred_1,\ldots,\predvar_n\mapsto \pred_n}\)
and 
\(\set{\predvar_1\mapsto \pred'_1,\ldots,\predvar_n\mapsto \pred'_n}\),
then we used the solution
\(\set{\predvar_1\mapsto \pred_1\land \pred'_1,\ldots,\predvar_n\mapsto \pred_n\land \pred'_n}\)
for inserting \textbf{Assume} commands.

To make the analysis precise, the implementation is actually based on an extension of
the refinement type system in Section~\ref{sec:rtype} with subtyping; 
see \ifaplas{the extended version~\cite{fullversion}}{Appendix~\ref{sec:subtyping}}.

\subsection{Preliminary Experiments}
\label{sec:experiments}

We prepared a collection of $\pi$-calculus processes,
and ran our tool on them.
Our experiment was conducted on Intel Core i7-10850H CPU with 32GB memory.
For comparison, we have also run the termination analysis mode of
\typical{}~\cite{TyPiCal,KobayashiHybrid} on the same instances.

\newcolumntype{Y}{>{\centering\arraybackslash}p{5em}}
\newcolumntype{Z}{>{\centering\arraybackslash}p{12em}}
\begin{table}[tbp]
    \centering
    \caption{Results of the experiments}
    \begin{tabular}{ZYYY}
        \hline
        Test case & Basic & Refined & \typical{} \\ \hline \hline
        client-server   &  2.5 &  2.7 & 0.006 \\
        stateful-server-client & FAIL & FAIL & 0.006 \\
        parallel-or     &  2.4 &  2.9 & 0.006 \\
        broadcast       &  3.6 &  3.3 & 0.004 \\
        btree           & FAIL & FAIL & 0.011 \\
        stable          & FAIL & FAIL & 0.003 \\
        ds-ex5-1        & FAIL & FAIL & 0.002 \\
        factorial       &  3.9 &  4.4 & 0.002 \\
        ackermann       & 22.4 & 26.0 & 0.003 \\
        \hline
        fibonacci       &  4.8 &  4.4 & 0.003 \\
        even/odd        &  7.0 &  7.6 & 0.002 \\
        factorial-pred  & FAIL & 28.2 & FAIL  \\
        fibonacci-pred  & FAIL & 28.2 & FAIL  \\ 
        even/odd-pred   & FAIL & 10.1 & FAIL  \\
        sum-neg         &  7.6 & 13.1 & FAIL  \\
        upperbound      &  3.8 &  3.9 & FAIL  \\
        nested-replicated-input1    &  2.3 &  2.4 & FAIL  \\
        nested-replicated-input2    & FAIL & FAIL & FAIL  \\
        nested-replicated-input3    &  3.7 &  4.0 & 0.010 \\
        deadlock        & FAIL &  2.9 & FAIL  \\
        \hline
    \end{tabular}
    \label{tab:result}
\end{table}


The experimental results are summarized in Table~\ref{tab:result}.
The columns ``Basic'' and ``Refined'' show the results for
the basic method in Section~\ref{sec:approach}
and the refined method in Section~\ref{sec:refinement} respectively.
The numbers show the running times measured in seconds, and
``FAIL'' means that the verification failed due to the incompleteness of
the reduction; non-terminating sequential programs were obtained in those cases.
The column ``\typical{}'' shows the analogous result for \typical{}.
The termination analysis of \typical{} roughly depends on Deng and Sangiorgi's
method~\cite{Deng06IC}. ``FAIL'' in the column means that the process does not
satisfy the (sufficient) conditions for termination~\cite{Deng06IC}.
The termination analysis of \typical{} treats numbers as natural numbers,
and is actually unsound in the presence of arbitrary integers
(for example, \(\outatom{f}{m}{r}\PAR
\rinexp{f}{x}{r}{\ifexp{x=0}{\soutatom{r}{1}}{\outatom{f}{x-1}{r}}}\) is
judged to be terminating for any \(m\)).

The test cases consist of two categories. The first one, shown above
the horizontal line, has been taken from the sample programs of \typical{}.
Among them, we have excluded out those that are not
related to termination analysis (note that \typical{} can perform deadlock/lock-freedom
analysis and information flow analysis besides termination analysis).
The second category, shown below the horizontal line, consists of those prepared by
us,\footnote{Unfortunately, there are no
  standard benchmark set for the termination analysis for the \(\pi\)-calculus.}
including the samples discussed in the paper.
All the processes in the test cases are terminating.


For \testcase{stateful-server-client}, \testcase{btree}, \testcase{stable},
and \testcase{ds-ex5-1} in the first category, and \testcase{nested-replicated-input2}
in the second category,
our analysis fails for essentially the same reason.
The following is a simplified version of \testcase{ds-ex5-1}:
\[
\soutatom{a}{} \PAR \soutatom{b}{} \PAR \srinexp{a}{}\sinexp{b}{}\soutatom{a}{}.
\]
The process above is terminating because each run of the third process consumes
a message on \(b\). Our reduction however ignores communications on \(b\) and produces
the following non-terminating program:
\[
(\set{\Fname{\reg_a}()=\Fname{\reg_a}(), \Fname{\reg_b}()=\skipexp}, \Fname{\reg_a}()\nondet
\Fname{\reg_b}()).
\]




For the second category, our refined method clearly outperforms the basic method
and \typical{}.
We explain some of the test cases in the second category.
The test cases \testcase{fibonacci} and \testcase{nested-replicated-input3} are from Example~\ref{ex:fib}
and \ref{ex:nested_rep} respectively, and \testcase{even/odd} is a mutually recursive process
that judges whether a given number is even or odd.
The process \testcase{deadlock} is the following one:
\[    \srinexp{\cname{loop}}{} \soutatom{\cname{loop}}{} 
    \PAR \sinexp{r}{} \soutatom{\cname{loop}}{}. \]
    This process is terminating, because the subprocess
    \(\sinexp{r}{} \soutatom{\cname{loop}}{}\) is blocked forever, without ever sending
    a message to \(\cname{loop}\).
    With the refinement type system, the channel \(r\) is given type:
    \(\sChty{\reg}{\epsilon;\FALSE}\), and
    \(\sinexp{r}{} \soutatom{\cname{loop}}{}\) is translated to:
    \[
\letexp{\epsilon}{\epsilon}{\assexp{\FALSE}{\Fname{\reg_{\cname{loop}}}()}},
    \]
    which is terminating by $\ASSUME(\FALSE)$.
    The process \testcase{upperbound} is the following process:
    \begin{align*}
    \soutatom{f}{0} \PAR \srinexp{f}{x} \ifexp{x>10}{\zeroexp}{\soutatom{f}{x+1}}.
\end{align*}
    It is terminating because the argument of \(f\) monotonically increases, and is bounded
    above by \(10\). \typical{} cannot make such reasoning.


