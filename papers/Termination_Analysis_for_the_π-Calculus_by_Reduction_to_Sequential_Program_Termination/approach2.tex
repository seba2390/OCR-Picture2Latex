\section{Basic Transformation}  \label{sec:approach}

This section presents our transformation from
a  \(\pi\)-calculus process to a sequential program,
so that
if the transformed program is terminating then the original process is terminating.

As explained in Section~\ref{sec:introduction}, the idea is to transform
an infinite chain of message passing on replicated input channels to
an infinite chain of recursive function calls.
Table~\ref{tab:trans} summarizes the correspondence between
processes and  sequential programs.
As shown in the table, a replicated input process is transformed to
a function definition, whereas a non-replicated input process is
just ignored, and integer bound variables are non-deterministically instantiated.
Note that channel arguments \(\seq{z}\) are ignored in both cases.
Instead, we prepare a global function name \(\Fname{\reg}\) for each
region \(\reg\); \(\regof{x}\) in the table indicates the region assigned to
the channel type of \(x\).\footnote{Thus, 
  the simple type system with
  ``regions'' introduced in the previous section is used here as a simple
  may-alias analysis.
  If \(x\) and \(y\) may be bound to the same channel during reductions,
  the type system assigns the same region to \(x\) and \(y\),
  hence \(x\) and \(y\) are
  mapped to the same function name \(\Fname{\regof{x}}\) by our transformation.}
  

\begin{table}[tbp]
  \caption{Correspondence between processes and sequential programs}
  \label{tab:trans}
\begin{tabular}{|l|l|}
  \hline
  processes & sequential programs \\
  \hline
  \hline
  replicated input (\(\rinexp{x}{\seq{y}}{\seq{z}}\cdots\)) & function definition  \(\Fname{\regof{x}}(\seq{y})=\cdots\)\\
  \hline
  non-replicated input (\(\inexp{x}{\seq{y}}{\seq{z}}\cdots\)) &
  non-deterministic instantiation (\(\ndlet{y}\cdots\))\\
  \hline
  output (\(\outexp{x}{\seq{v}}{\seq{w}}\cdots\)) &
    function call (\(\Fname{\regof{x}}(\seq{v})\nondet \cdots\))\\
    \hline
    parallel composition (\(\cdots\PAR\cdots\)) &
    non-deterministic choice (\(\cdots\nondet \cdots\))\\
    \hline
\end{tabular}
\end{table}

We define the transformation relation
$\env; \chenv \vdash P \Rightarrow \prog{\Def}{\Exp}$,
which means that the \(\pi\)-calculus process \(P\) well-typed
under \(\env;\chenv\) is transformed to the sequential program \((\Def,\Exp)\).
The relation is defined by the rules in Figure~\ref{fig:program_transformation}.
\begin{figure}[tb]
  \typicallabel{SX-RIn}
  \infrule[SX-Nil]{}
          {\env; \chenv \vdash \textbf{0} \Rightarrow
            \prog{\set{ \fdef{\Fname{\reg}}{\seq{y}}{\skipexp}
              \mid x\COL\Chty{\reg}{\seq{\ty}}{\seq{\chty}} \in \chenv, 
                   \len{\seq{y}} = \len{\seq{\ty}} }}{\skipexp}}
          \vspace*{1ex}
          \infrule[SX-In]
            {\env; \chenv \vdash x : \Chty{\reg}{\seq{\ty}}{\seq{\chty}}\andalso
            \env, \seq{y} : \seq{\ty}; \chenv, \seq{z} : \seq{\chty} \vdash P \Rightarrow \prog{\Def}{\Exp}}
            {\env; \chenv \vdash \inexp{x}{\seq{y}}{\seq{z}}P \Rightarrow
              \prog{\ndlet{y}{\Def}}{\ndlet{y}{\Exp}}}
          \vspace*{1ex}
\infrule[SX-RIn]
{\env; \chenv \vdash x : \Chty{\reg}{\seq{\ty}}{\seq{\chty}}\andalso
  \env, \seq{y} : \seq{\ty}; \chenv, \seq{z} : \seq{\chty} \vdash P \Rightarrow
  \prog{\Def}{\Exp}}
{\env; \chenv \vdash \rinexp{x}{\seq{y}}{\seq{z}}P \Rightarrow
  \prog{\set{ \fdef{\Fname{\reg}}{\seq{y}}{\Exp} } \mrg (\ndlet{y}{\Def})} {\skipexp}}
\vspace*{1ex}
\infrule[SX-Out]
{\env; \chenv \vdash x : \Chty{\reg}{\seq{\ty}}{ \seq{\chty}}\andalso
\env; \chenv \vdash \seq{v} : \seq{\ty}\andalso
\env; \chenv \vdash \seq{w} : \seq{\chty}\andalso
\env; \chenv \vdash P \Rightarrow \prog{\Def}{\Exp}}
{\env; \chenv \vdash \outexp{x}{\seq{v}}{\seq{w}}P \Rightarrow
  \prog{\mathcal{D}}{\Fname{\reg}(\seq{v}) \nondet \Exp}}

\infrule[SX-Par]
{\env; \chenv \vdash P_1 \Rightarrow \prog{\Def_1}{\Exp_1}\andalso
\env; \chenv \vdash P_2 \Rightarrow \prog{\Def_2}{\Exp_2}}
{\env; \chenv \vdash P_1 \mid P_2 \Rightarrow \prog{\Def_1 \mrg \Def_2}{\Exp_1 \nondet \Exp_2}}

\vspace*{1ex}
\infrule[SX-Nu]
        {\env; \chenv, x : \chty \vdash P \Rightarrow \prog{\Def}{\Exp}}
        {\env; \chenv \vdash \nuexp{x \COL \chty}P \Rightarrow \prog{\Def}{\Exp}}
          \vspace*{1ex}

\infrule[SX-If]
{\env; \chenv \vdash v : \ty\andalso
 \env; \chenv \vdash P_1 \Rightarrow \prog{\Def_1}{\Exp_1}\andalso
 \env; \chenv \vdash P_2 \Rightarrow \prog{\Def_2}{\Exp_2}}
{\env; \chenv \vdash \ifexp{v}{P_1}{P_2} \Rightarrow
  \prog{\Def_1 \mrg \Def_2}{\ifexp{v}{\Exp_1}{\Exp_2}}}

          \vspace*{1ex}

\infrule[SX-LetND]
{\env, \seq{x}: \seq{\ty}; \chenv \vdash P \Rightarrow \prog{\Def}{\Exp}}
{\env; \chenv \vdash \ndlet{x}{P} \Rightarrow
  \prog{\ndlet{x}{\Def}}{\ndlet{x}{\Exp}}}

    \begin{align*}
        \ndlet{x}{\Def} \coloneqq
& \{ \fdef{f}{\tilde{y}}{(\ndlet{x}{\Exp})} \mid \fdef{f}{\tilde{y}}{E} \in \Def \} 
    \end{align*}
    \normalsize
    \caption{The rules of simple type-based program transformation}
    \label{fig:program_transformation}
\end{figure}

We explain some key rules.
In \rn{SX-Nil}, \(\zeroexp\) is translated to \((\Def,\skipexp)\),
where \(\Def\) is the set of trivial function definitions.
In \rn{SX-In}, a (non-replicated) input is just removed, 
and the bound variables are instantiated to non-deterministic integers;
this is because we have no information about \(\seq{y}\); this will be refined
in Section~\ref{sec:refinement}. In contrast,
in \rn{SX-RIn}, a replicated input is converted to a function definition.
Since \(\Def\) generated from \(P\) may contain \(\seq{y}\), they are
 bound to non-deterministic integers and merged with the new definition for \(\Fname{\reg}\).
In \rn{SX-Out}, an output is replaced by a function call.
In \rn{SX-Par}, parallel composition is replaced by non-deterministic choice.



\begin{example}
\label{ex:fib}
\newcommand{\FIB}{P_\text{fib}}
    Let us revisit the Fibonacci example used in the introduction to explain the actual translation.
    Using the syntax we introduced, the Fibonacci process \( \FIB \) can now be defined as:
    \begin{align*}
        & \nuexp{\fib\COL \Chty{\reg_1}{\ty}{\sChty{\reg_2}{\ty}}}\rinexp{\fib}{n}{r} \\
        & \quad \ifexp{n<2}{\soutatom{r}{1}}{(\nu r_1\COL \sChty{\reg_2}{\ty})(\nu r_2\COL \sChty{\reg_2}{\ty})\\
        & \quad (\outatom{\fib}{n-1}{r_1} \PAR \outatom{\fib}{n-2}{r_2} \PAR \sinexp{r_1}{x} \sinexp{r_2}{y} \soutatom{r}{x+y})} \\
        & \PAR \letexp{m}{\ndint}{(\nu r\COL \sChty{\reg_2}{\ty}) \outatom{\fib}{m}{r}}
    \end{align*}
    Note that \( \nuexp{\fib} \) and \( \ndletatom{m} \) have been added to close the process.
    %
    We can derive $\emptyset; \emptyset \vdash \FIB \Rightarrow \prog{\Def}{\Exp}$,
    where $\Def$ and $\Exp$ are given as follows:\footnotemark
    \footnotetext{The program written here has been simplified for the sake of readability.
    For instance, we removed some redundant \( \skipexp \), trivial function definitions, and unused non-deterministic integers.
    The other examples that will appear in this paper are also simplified in the same way.
    }
\begin{align*}
        \Def &=  \{ \fdef{\Fname{\reg_1}}{z}{\ifexp{z<2}{\Fname{\reg_2}(1)}{( \Fname{\reg_1}(z-1) \nondet \Fname{\reg_1}(z-2) \\ 
               &\qquad\qquad\qquad \nondet \letexp{x}{\ndint}{\letexp{y}{\ndint}{\Fname{\reg_2}(x+y)}} )}}, \\
               &\ \quad  \fdef{\Fname{\reg_2}}{z}{\skipexp} \} \\ 
        \Exp &= \letexp{m}{\ndint}{\Fname{\reg_1}(m)}
    \end{align*}
    Here \( \Fname{\reg_1} \) is the ``Fibonacci function'' because \( \reg_1 \) is the region assigned to the channel \( \cname{fib}\) in \( \FIB \).
    The function call \( \Fname{\reg_2} (x + y)\) corresponds to the output \( \soutatom{r}{x + y} \); the argument of the function call is actually a nondeterministic integer because \( \sinatom{r}{x} \) and \( \sinatom{r}{y} \) are translated to non-deterministic instantiations.
    Since the program $(\Def, \Exp)$ is terminating,
    we can verify that $\FIB$ is also terminating.
    \qed
\end{example}


\begin{example}
\label{ex:nested_rep}
To help readers understand the rule \rn{SX-RIn}, we consider the following process, which contains a nested input:
\begin{align*}
 \rinexp{f}{x}{r}\srinexp{g}{y, z}(\ifexp{y \leq 0}{\soutatom{r}{z}}{\soutatom{g}{y - 1, x + z}} ) \PAR \outexp{f}{2}{r}\soutatom{g}{3,0}
\end{align*}
%
where \( f \COL \Chty{\reg_1}{\ty}{\sChty{\reg_2}{\ty}} \) and \( g \COL \sChty{\reg_3}{\ty, \ty} \).
This process computes \( x * y + z \) (which is \( 6 \) in this case) and returns that value using \( r \).
This program is translated to:
\begin{align*}
  &\fdef{\Fname{\reg_1}}{x}{\skipexp}\qquad \fdef{\Fname{\reg_2}}{z}{\skipexp} \\
  &\fdef{\Fname{\reg_3}}{y, z}{\ndlet*{x}{\ifexp{y \leq 0}{\Fname{\reg_2}(z)}{} } \Fname{\reg_3}(y - 1, x + z)}
\end{align*}
with the main expression  \( \Fname{\reg_1}(2) \nondet \Fname{\reg_3}(3, 0) \).
Note that the body of \( \Fname{\reg_1}\), which is the function corresponding to \( f \), is \( \skipexp \).
This is because when the rule \rn{SX-RIN} is applied to 
\( \srinatom{g}{y, z}\ldots\),
the main expression of the translated program becomes \( \skipexp \).
Observe that the function definition for \( \Fname{\reg_3} \) still contains a free variable \( x \) at this moment.
Then \( \Fname{\reg_3} \) is closed by \( \ndletatom{x} \) when we apply the rule \rn{SX-RIn} to \( \srinatom{f}{x; r}\ldots \).
%
We can check that the above program is terminating, and thus we can verify that the original process is terminating.
%
Note that some precision is lost in the application of \rn{SX-RIn} above
since we cannot track the relation between the argument of \( \Fname{\reg_1} \)
and the value of \( x \) used inside \( \Fname{\reg_3}\). This loss causes a problem if, for example, the condition \(y\le 0\) in
  the process above is replaced with \(y\le x\). The body of
  \(\Fname{\reg_3}\) would then become
  \(\ndlet*{x}{\textbf{if } y\le x\ \cdots}\), hence the sequential program would be
    non-terminating.
 \qed
\end{example}

\begin{remark}
A reader may wonder why
a non-replicated input is removed in \rn{SX-In},
rather than translated to a function definition as done for a replicated input.
It is actually possible to obtain a sound transformation even if we treat
non-replicated inputs in the same manner as replicated inputs,
but we expect that our approach of removing non-replicated inputs often works
better.
For example,
  consider $\sinexp{x}{y}\soutatom{x}{y} \PAR \soutatom{x}{0}$.
  Our translation generates
  $\prog{\{\fdef{\Fname{\reg_x}}{z}{\skipexp}\}}{(\ndlet*{y}{\Fname{\reg_x}(y)}) \nondet \Fname{\reg_x}(0)}$
  which is terminating,
  whereas if we treat the input in the same way as a replicated input,
  we would obtain
  $\prog{\{\fdef{\Fname{\reg_x}}{z}{\Fname{\reg_x}(z)}\}}{\Fname{\reg_x}(0)}$
  which is not terminating.
 Our approach also has some defect.
  For example, consider
  $\soutatom{x}{0} \PAR \sinexp{x}{y} \ifexp{y=0}{\zeroexp}{\Omega}$
  where $\Omega$ is a diverging process. 
  Our translation yields
  $\prog{\{\fdef{\Fname{\reg_x}}{z}{\skipexp}\}}{\Fname{\reg_x}(0) \nondet \ndlet*{y}{\ifexp{y=0}{\skipexp}{\Omega'}}}$
  which is non-terminating.
  On the other hand, if we treat the input like a replicated input,
  we would obtain
  $\prog{\{\fdef{\Fname{\reg_x}}{z}{\ifexp{z=0}{\skipexp}{\Omega'}}\}}{\Fname{\reg_x}(0)}$
  which is terminating.
  This issue can, however,
  be mitigated by the extension with refinement types in Section~\ref{sec:refinement}.
Our choice of removing non-replicated inputs is also 
consistent with Deng and Sangiorgi's type system~\cite{Deng06IC}, which
prevents an infinite chain of communications on replicated input channels by using types
and ignores non-replicated inputs.
\qed
\end{remark}


The following theorem states the soundness of our transformation.
\begin{theorem}[soundness]  \label{thm:soundness}
  Suppose  $\emptyset; \emptyset \vdash P \Rightarrow \prog{\Def}{\Exp}$.
    If $(\Def, \Exp)$ is terminating, then so is $P$.
\end{theorem}
We briefly explain the proof strategy; see \ifaplas{the extended version~\cite{fullversion}}{Appendix~\ref{sec:soundness}}
for the actual proof.
Basically, our idea is to show that the translated program simulates the original process.
Then we can conclude that if the original process is non-terminating then so is the sequential program.
However, there is a slight mismatch between the reduction of a process and that of the sequential program that we need to overcome.
Recall that \( \srinexp{f}{x}P \PAR \soutatom{f}{1} \PAR \soutatom{f}{2} \) is translated to \( \Fname{\reg_f}(1) \nondet \Fname{\reg_f}(2) \) with a function definition for \( \Fname{\reg_f} \).
In the sequential program, we need to make a ``choice'', e.g.~if \( \Fname{\reg_f}(1) \) is called, we cannot call \( \Fname{\reg_f}(2) \) anymore.
On the other hand, the output \( \soutatom{f}{2} \) can be used even if \( \soutatom{f}{1} \) has been used before.
To fill this gap, we introduce a non-standard reduction relation, which does not discard branches of non-deterministic choices and show the simulation relation using that non-standard semantics.
Then we show that if there is an infinite non-standard reduction sequence, then there is an infinite subsequence that corresponds to a reduction along a certain choice of non-deterministic branches.
This step is essentially a corollary of the K\"onig's Lemma.
This is because the infinite non-standard reduction sequence can be reformulated as an infinite tree in which branches correspond to non-deterministic choices \( \oplus \) (thus the tree is finitely branching) and paths correspond to reduction sequences.


The following example indicates that the basic transformation is
sometimes too conservative.
\begin{example}
  \label{ex:weakeness-of-basic-transformation}
Let us consider the following process \( \DEC \):
\begin{align*}
    &\rinexp{\pre}{n}{r} \soutatom{r}{n-1} \\
    & \PAR \rinexp{f}{n}{r} \ifexp{n<0}{ \soutatom{r}{1} }{ \nuexp{s \COL \sChty{\reg_2}{\ty} } (\outatom{\pre}{n}{s} \PAR \sinexp{s}{x}\outatom{f}{x}{r}) } \\
    &\PAR \outatom{f}{m}{r}
\end{align*}
where
\( \pre\COL \Chty{\reg_1}{\ty}{\sChty{\reg_2}{\ty}} \), \(\cname{f} \COL \Chty{\reg_3}{\ty}{\sChty{\reg_4}{\ty}} \) and \( r \COL \sChty{\reg_4}{\ty}\).
This process, which also appeared in the introduction, keeps on decrementing the integer \( m \) until it gets negative and then returns \( 1 \) via \( r \).
We can turn this process into a closed process \( \DECclosed \) by restricting the names \( \pre \), \( \cname{f} \), \( \cname{r} \) and adding \( \ndletatom{m} \) in front of the process.
Note that \( \DECclosed \) is terminating.

The process \( \DECclosed \) is translated to:
\begin{align*}
  &\fdef{\Fname{\reg_1}}{n}{\Fname{\reg_2}(n-1)}, 
  \qquad \fdef{\Fname{\reg_2}}{x}{\skipexp},
  \qquad \fdef{\Fname{\reg_4}}{x}{\skipexp}, \\
  & \fdef{\Fname{\reg_3}}{n}{\ifexp{n<0}{\Fname{\reg_4}(1) \\ &\qquad\qquad }
            {(\Fname{\reg_1}(n) \nondet \letexp{x}{\ndint}{\Fname{\reg_3}(x)}})}
\end{align*}
with the main expression \( \ndlet*{m}{\Fname{\reg_3}(m)} \).
Observe that the function \( f_{\reg_3}\) is applied to a non-deterministic integer, not \( n - 1\).
Thus, this program is not terminating, meaning that we fail to verify that the original process is terminating.
This is due to the shortcoming of our transformation that all the integer   values received by non-replicated inputs are replaced by non-deterministic integers.
This problem is addressed in the next section.
\qed
\end{example}

