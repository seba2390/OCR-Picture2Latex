\section{Improving Transformation Using Refinement Types}  \label{sec:refinement}

In this section, we refine the basic transformation in the previous section
by using a refinement type system.

Recall that in Example~\ref{ex:weakeness-of-basic-transformation},
the problem was that information about values received by non-replicated
inputs was completely lost.
By using a refinement type system for the \(\pi\)-calculus,
we can statically infer that \(x<n\) holds between \(x\) and \(n\) in
the process in Example~\ref{ex:weakeness-of-basic-transformation}.
Using that information, we can transform the process in Example~\ref{ex:weakeness-of-basic-transformation} and obtain
\[
    \fdef{\Fname{\reg_3}}{n}{\ifexp{n<0}{\cdots}
            {(\Fname{\reg_1}(n) \nondet \letexp{x}{\ndint}{\assexp{x < n}\Fname{\reg_3}(x)}})}
\]
for the definition of \( \Fname{\reg_3}\).
This is sufficient to conclude that the resulting program is terminating.

In the rest of this section, we first introduce a refinement type system
in Section~\ref{sec:rtype} and explain the refined transformation in Section~\ref{sec:rx}.
We then discuss how to automatically infer refinement types and
achieve the refined transformation in Section~\ref{sec:inference}.



\subsection{Refinement Type System}
\label{sec:rtype}


The set of \emph{refinement channel types}, ranged over by $\chty$, is given by:
\begin{align*}
    \chty ::= \rch{\reg}{\seq{x}}{\pred}{\seq{\chty}}
\end{align*}
Here, \(\pred\) is a formula of integer arithmetic.
We sometimes write just
\(\rchepsilon{\reg}{\seq{x}}{\pred}\) for
\(\rch{\reg}{\seq{x}}{\pred}{\epsilon}\).
Intuitively, 
$\rch{\reg}{\tilde{x}}{\pred}{\tilde{\chty}}$
describes channels that are used for transmitting
a tuple \((\seq{x};\seq{y})\) such that (i) \(\seq{x}\) are integers
that satisfy \(\pred\), and (ii) \(\seq{y}\) are channels of types \(\seq{\chty}\).
For example, the type
\(\rch{\reg_1}{x}{\TRUE}{\rchepsilon{\reg_2}{z}{z<x}}\)
describes channels used for transmitting a pair
\((x, y)\), where \(x\) may be any integer, and \(y\) must be a channel of
type \(\rchepsilon{\reg_2}{z}{z<x}\), i.e.,
a channel used for passing an integer \(z\) smaller than \(x\).%
Thus, if \(u\) has type \(\rch{\reg_1}{x}{\TRUE}{\rchepsilon{\reg_2}{z}{z<x}}\),
then the process
\(\inexp{u}{n}{r}{\soutatom{r}{n-1}}\) is allowed
but \(\inexp{u}{n}{r}{\soutatom{r}{n}}\) is not.


Type judgments for processes and expressions are
now of the form \( \env;\predenv;\chenv \p P \) and \( \env;\predenv;\chenv \p v\COL\mty \), where \( \predenv \) is a sequence of formulas.
Intuitively, \( \env;\predenv;\chenv \p P \) means that \( P \) is well-typed under the environments \( \env \) and \( \chenv \) assuming that all the formulas in \( \predenv \) holds.

The selected typing rules are shown in Figure~\ref{fig:refinement_type_system}.
The rules for the other constructs are identical to that of the simple type system; 
the complete list of typing rules appears in \ifaplas{the extended version~\cite{fullversion}}{Appendix~\ref{sec:refinement-apx}}. %
The rules shown in Figure~\ref{fig:refinement_type_system} are fairly standard rules for refinement type systems.
In \rn{RT-Out}, the notation
\(\predenv \vDash \pred\) means that \(\pred\) is a logical consequence of
\(\predenv\); for example, \(x<y, y<z \vDash x<z\) holds.
In the typing rules, we implicitly require that
all the type judgments are well-formed, in the sense that
all the integer variables occurring in a formula is
properly declared in \(\env\) or bound by a channel type constructor;
see \ifaplas{the extended version~\cite{fullversion}}{Appendix~\ref{sec:refinement-apx}}
for the well-formedness condition.
\begin{figure}[tb]
    \centering
    \small
    \begin{minipage}{\linewidth}
        \centering
        \begin{prooftree}
            \AxiomC{$\env;\predenv;\chenv\p x\COL\rch{\reg}{\seq{y}}{\pred}{\seq{\chty}}$}
            \AxiomC{$\env,\seq{y}\COL\seq{\ty}; \predenv,\pred; \chenv,\seq{z}\COL\seq{\chty} \p P$}
            \RightLabel{\textsc{(RT-In)}}
            \BinaryInfC{$\env;\predenv;\chenv\p \inexp{x}{\seq{y}}{\seq{z}}P$}
        \end{prooftree}
    \end{minipage}
    \\
    \begin{minipage}{0.93\linewidth}
        \infrule[RT-Out]
        {\env;\predenv;\chenv\p x\COL\rch{\reg}{\seq{y}}{\pred}{\seq{\chty}}\andalso
        \env;\predenv;\chenv\p \seq{v}\COL\seq{\ty}\andalso
        \predenv \vDash [\seq{v}/\seq{y}]\pred\\
        \env;\predenv;\chenv\p \seq{w}\COL[\seq{v}/\seq{y}]\seq{\chty}\andalso
        \env;\predenv;\chenv\p P}
        {\env;\predenv;\chenv \vdash \outexp{x}{\seq{v}}{\seq{w}}P}
    \end{minipage}
    \\
    \begin{minipage}{\linewidth}
        \centering
        \begin{prooftree}
            \AxiomC{$\env;\predenv;\chenv\p x\COL\rch{\reg}{\seq{y}}{\pred}{\seq{\chty}}$}
            \AxiomC{$\env,\seq{y}\COL\seq{\ty}; \predenv,\pred; \chenv,\seq{z}\COL\seq{\chty} \p P$}
            \RightLabel{\textsc{(RT-RIn)}}
            \BinaryInfC{$\env;\predenv;\chenv\p \rinexp{x}{\seq{y}}{\seq{z}}P$}
        \end{prooftree}
    \end{minipage}
    \\
    \begin{minipage}{\linewidth}
        \centering
        \begin{prooftree}
            \AxiomC{$\env; \predenv; \chenv \p v\COL\ty$}
            \AxiomC{$\env; \predenv, v \neq 0; \chenv \p P_1$}
            \AxiomC{$\env; \predenv, v =    0; \chenv \p P_2$}
            \RightLabel{\textsc{(RT-If)}}
            \TrinaryInfC{$\env;\predenv;\chenv\p \ifexp{v}{P_1}{P_2}$}
        \end{prooftree}
    \end{minipage}
    \\
    \begin{minipage}{0.45\linewidth}
        \centering
        \begin{prooftree}
            \AxiomC{$x \COL \chty \in \chenv$}
            \RightLabel{\textsc{(RT-Var-Ch)}}
            \UnaryInfC{$\env;\predenv;\chenv \p x\COL\chty$}
        \end{prooftree}
    \end{minipage}
    \normalsize
    \caption{\skchanged{Selected} typing rules of the refinement type system for the $\pi$-calculus}
    \label{fig:refinement_type_system}
\end{figure}



\subsection{Program Transformation}
\label{sec:rx}



Based on the refinement type system above,
we refine the transformation relation to
$\env; \predenv; \chenv \vdash P \Rightarrow \prog{\Def}{\Exp}$.
The only change is in the following rule for non-replicated inputs.\footnote{The rule for replicated inputs is also modified in a similar manner.}
\infrule[RX-In]
        {\env;\predenv;\chenv\p x\COL\rch{\reg}{\tilde{y}}{\pred}{\tilde{\chty}}
          \andalso
          \env,\seq{y}\COL\seq{\ty}; \predenv,\pred; \chenv,\seq{z}\COL\seq{\chty} \vdash P \Rightarrow \prog{\Def}{\Exp}}
        {\env;\predenv;\chenv \vdash \inexp{x}{\seq{y}}{\seq{z}}P
          \qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad         \\
          \Rightarrow
          \prog{\ndlet{y}{\textbf{Assume}(\pred);\Def}}{\ndlet{y}{\assexp{\pred}\Exp}}}
        Here, we insert \(\assatom{\pred}\), based on the refinement type
        of \(x\).
        The expression \(\ndlet{y}{\textbf{Assume}(\pred);\Exp}\) first
        instantiates \(\seq{y}\) to some integers in a non-deterministic manner,
        but proceeds to evaluate \(E\) only if the values of \(\seq{y}\) satisfy
        \(\pred\). Thus, the termination analysis for the target sequential program may assume that
       \(\seq{y}\) satisfies \(\pred\) in \(\Exp\).
        



\begin{example}  \label{ex:refined-transformation-for-f}
Let us explain how the process \( \DEC \) introduced in Example~\ref{ex:weakeness-of-basic-transformation} is translated by the refined translation.
Recall that the following simple types were assigned to the channels:
\begin{align*}
    \pre\COL \Chty{\reg_1}{\ty}{\sChty{\reg_2}{\ty}}, \quad
    \cname{f} \COL \Chty{\reg_3}{\ty}{\sChty{\reg_4}{\ty}}, \quad
    r \COL \sChty{\reg_4}{\ty}, \quad
    s \COL \sChty{\reg_2}{\ty}.
\end{align*}
By the refinement type system, the above types can be refined as:
\begin{align*}
    &\pre\COL \rch{\reg_1}{n}{\TRUE}{\sChty{\reg_2}{x; x < n}}, \quad
    \cname{f} \COL \rch{\reg_3}{n}{\TRUE}{\sChty{\reg_4}{x; \TRUE}}, \\
    &r \COL \sChty{\reg_4}{x; \TRUE}, \quad
    s \COL \sChty{\reg_2}{x; x < n}.
\end{align*}
For example, one can check that the output \( \soutatom{r}{n - 1} \) on the first line of \( \DEC \) is well-typed because \( \models [n - 1/x]x < n \) holds.
Note that this \( r \) is the variable bound by \( \inatom{\pre}{n}{r} \) and thus has the type \( \sChty{\reg_2}{x; x < n} \).

Therefore, by the rule \rn{RX-In}, the input \( \sinexp{s}{x}\outatom{f}{x}{r} \) is now translated as follows:
\infrule{\env;\predenv;\chenv\p s\COL\sChty{\reg_2}{x; x < n}
          \quad
          \env, x \COL \ty; \predenv,x < n; \chenv \vdash \outatom{f}{x}{r} \Rightarrow \prog{\Def}{\Fname{\reg_3}(x)}}
{\env;\predenv;\chenv \vdash \sinexp{s}{x}\outatom{f}{x}{r} \hspace{7cm}
          \qquad \\
          \Rightarrow
          \prog{(\ndlet*{x}{\textbf{Assume}(x < n);\Def})}{(\ndlet*{x}{\textbf{Assume}(x < n);\Fname{\reg_3}(x)})}}
with suitable \( \env \), \( \predenv \) and \( \chenv \).
By translating the whole process, we obtain
\begin{align*}
\Fname{\reg_3}(n) = \ &\textbf{if }{n<0} \textbf{ then } \Fname{\reg_4}(1) \\
    &\textbf{else }(\Fname{\reg_1}(n) \nondet \ndlet*{x}{\assexp{x < n}{\Fname{\reg_3}(x)}})
\end{align*}
as desired.
The other function definitions are given as in the case of Example~\ref{ex:weakeness-of-basic-transformation} (except for the fact that some redundant assertions \( \ndlet*{x}{\assatom{x < n}} \) are added).
\end{example}

%
\shchanged{
The soundness of the refined translation is obtained from the following argument.
We first extend the \(\pi\)-calculus with the $\ASSUME$ statement.
Then the refined translation can be decomposed into the following two steps:
(a) given a \(\pi\)-calculus process $P$,
insert $\ASSUME$ statements based on refinement types 
and obtain a process $P'$; and
(b) apply the translation of Section~\ref{sec:approach} to $P'$ (where $\ASSUME$ is just mapped to itself)
and obtain a sequential program $S$.
The soundness of step (b) follows by an easy modification of the proof\ifaplas{}{ in Appendix~\ref{sec:soundness}} 
for the basic transformation (just add the case for $\ASSUME$).
So, the termination of \(S\) would imply that of \(P'\).
Now, from the soundness of the refinement type system (which follows from a standard
argument on type preservation and progress), it follows that the $\ASSUME$ statements
inserted in step (a) always succeed. Thus,
the termination of \(P'\) would imply that of \(P\).
We can, therefore, conclude that if \(S\) is terminating, so is \(P\).
}