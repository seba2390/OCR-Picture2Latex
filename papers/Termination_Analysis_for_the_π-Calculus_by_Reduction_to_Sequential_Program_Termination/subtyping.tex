\section{Refinement Type System with Subtyping}
\label{sec:subtyping}

As mentioned in Section~\ref{sec:implementation},
the implementation is based on the following extension of the refinement type system in Section~\ref{sec:rtype}.

The set of \emph{refinement i/o channel types}, ranged over by $\chty$, is given by:
\[ 
    \chty ::= \ioch{\reg}{\seq{x}}{\inty{\pred}}{\inty{\seq{\chty}}}{\outy{\pred}}{\outy{\seq{\chty}}}
\]
Here, \(\ioch{\reg}{\seq{x}}{\inty{\pred}}{\inty{\seq{\chty}}}{\outy{\pred}}{\outy{\seq{\chty}}}\)
is the type of channels used for \emph{receiving} tuples \((\seq{x};\seq{y})\)
such that \(\seq{x}\) satisfies \(\pred_I\) and \(\seq{y}\) have types
\(\inty{\seq{\chty}}\),
and for \emph{sending} tuples \((\seq{x};\seq{y})\)
such that \(\seq{x}\) satisfies \(\pred_O\) and \(\seq{y}\) have types
\(\outy{\seq{\chty}}\).
The distinction between the types of input (i.e. received) values  and those of
output (i.e. sent) values has been inspired by
the type system of Yoshida and Hennessy~\cite{DBLP:conf/concur/YoshidaH99}.
It leads to a more precise type system than Pierce and Sangiorgi's subtyping,
and is convenient for automatic refinement type inference~\cite{Pierce96MSCS}
(because we need not infer input/output modes and perform case analysis on the modes).

The subtyping relation on channel types is defined by:
\infrule[RT-Sub-Ch]
{\predenv,\inty{\pred} \vDash \inty{\pred}' \andalso
 \env,\seq{x}\COL\seq{\ty};\predenv,\inty{\pred}\p  \inty{\seq{\chty}} \subtype \inty{\seq{\chty}}' \\
 \predenv,\outy{\pred}' \vDash \outy{\pred} \andalso
 \env,\seq{x}\COL\seq{\ty};\predenv,\outy{\pred}'\p  \outy{\seq{\chty}}' \subtype \outy{\seq{\chty}}
}
{\env;\predenv\p 
    \ioch{\reg}{\seq{x}}{\inty{\pred}}{\inty{\seq{\chty}}}{\outy{\pred}}{\outy{\seq{\chty}}} 
    \subtype 
    \ioch{\reg}{\seq{x}}{\inty{\pred}'}{\inty{\seq{\chty}}'}{\outy{\pred}'}{\outy{\seq{\chty}}'}
}
Note that the 
 channel type $\ioch{\reg}{\seq{x}}{\inty{\pred}}{\inty{\seq{\chty}}}{\outy{\pred}}{\outy{\seq{\chty}}}$
is covariant on $\inty{\pred}$ and $\inty{\seq{\chty}}$, 
and contravariant on $\outy{\pred}$ and $\outy{\seq{\chty}}$.

We make the following two modifications to the typing rules.
\begin{enumerate}
\item
  We add the following subsumption rule.
        \infrule[RT-Sub]
                {\env;\predenv;\chenv\p v\COL \chty\andalso \env;\predenv\p \chty \subtype \chty'}
                {\env;\predenv;\chenv\p v\COL \chty'}

  \item
    We refine the well-formedness condition on types and type environments by:
\infrule{\FV(\pred)\subseteq \dom(\env)\cup \set{\seq{x}}\\
  \tyok{\env, \seq{x}\COL\seq{\ty}}{\inty{\seq{\chty}}}\\
  \tyok{\env, \seq{x}\COL\seq{\ty}}{\outy{\seq{\chty}}}
}
{\tyok{\env}{\ioch{\reg}{\seq{x}}{\inty{\pred}}{\inty{\seq{\chty}}}{\outy{\pred}}{\outy{\seq{\chty}}}}}

\infrule{
   \FV(\predenv) \subseteq \dom(\env)
}
{\tyenvok{\env}{\predenv}{\emptyset}}


\infrule{\tyok{\env}{\ioch{\reg}{\seq{x}}{\inty{\pred}}{\inty{\seq{\chty}}}{\outy{\pred}}{\outy{\seq{\chty}}}}\\
  \predenv, \outy{\pred} \models \inty{\pred}
  \andalso
  \env,\seq{x}\COL\seq{\ty};\predenv,\outy{\pred}\p \outy{\seq{\chty}} \subtype
  \inty{\seq{\chty}}}
{\tyenvok{\env}{\predenv}{\chenv,y\COL\ioch{\reg}{\seq{x}}{\inty{\pred}}{\inty{\seq{\chty}}}{\outy{\pred}}{\outy{\seq{\chty}}}}}

The requirement for the subtyping relation in the last rule
 ensures the consistency between the types of
values expected by a receiver process and those actually output by a sender process;
for example, the channel type
\(\ioch{\reg}{x}{x>0}{\epsilon}{x<0}{\epsilon}\) is judged to be ill-formed,
because the type indicates that a receiver process expects a positive value \(x\) but 
a sender will output a negative value on the channel.
\end{enumerate}

The following example demonstrates the usefulness of subtyping for refinement channel
types.
\begin{example}
  \label{ex:subtyping}
  Let us consider the following process:
  \[
  \begin{array}{l}
    \rinexp{\pre}{x}{r}\soutatom{r}{x-1}\\
\PAR
\srinexp{f}{x}\ifexp{x<0}{\zeroexp}
        {\nuexp{s}(\outatom{\pre}{x}{s}\PAR \sinexp{s}{y}\soutatom{f}{y})}\\
\PAR \soutatom{f}{100}\\
\PAR \rinexp{c}{x}{r}\letexp{y}{\ndint}\soutatom{r}{y}\\
\PAR \soutatom{d}{\pre}\PAR \soutatom{d}{c}
  \end{array}
  \]
  The process consisting of the first three lines
  is a variation of the process in Example~\ref{ex:weakeness-of-basic-transformation},
  which is obviously terminating.
  Without the fourth and fifth lines, we would be able to assign
  the type \(\rch{\reg_1}{x}{\TRUE}{\rch{\reg_2}{y}{y<x}{\epsilon}}\)
  in the refinement type system in Section~\ref{sec:refinement},
  and reduce the process to a terminating program.

  The processes on the \skchanged{fifth} line, however, force us to assign the same type
  to \(\pre\) and \(c\) in the refinement type system in Section~\ref{sec:refinement},
  and thus we can assign only \(\rch{\reg_1}{x}{\TRUE}{\rch{\reg_2}{y}{\TRUE}{\epsilon}}\)
  to \(\pre\), failing to transform the process to a non-terminating program.

  With subtyping, we can assign the following types to \(\pre\), \(c\), and \(d\):
  \[
  \begin{array}{l}
    \pre\COL
    \ioch{\reg_1}{x}{\TRUE}{\ioch{\reg_2}{y}{\TRUE}{\epsilon}{y<x}{\epsilon}}{\TRUE}{\ioch{\reg_2}{y}{\TRUE}{\epsilon}{y<x}{\epsilon}}\\
    c\COL
    \ioch{\reg_1}{x}{\TRUE}{\ioch{\reg_2}{y}{\TRUE}{\epsilon}{\TRUE}{\epsilon}}{\TRUE}{\ioch{\reg_2}{y}{\TRUE}{\epsilon}{\TRUE}{\epsilon}}\\
    d\COL
    \ioch{\reg_0}{\epsilon}{\TRUE}{\chty}{\TRUE}{\chty}\\
    \mbox{where}\\
    \chty =
    \ioch{\reg_1}{x}{\TRUE}{\ioch{\reg_2}{y}{\TRUE}{\epsilon}{y<x}{\epsilon}}{\TRUE}{\ioch{\reg_2}{y}{\TRUE}{\epsilon}{\TRUE}{\epsilon}}\\
  \end{array}
  \]
  Note that the types of \(\pre\) and \(c\) are
  subtypes of \(\chty\).
  Here, the type of \(\pre\) indicates that
  the value \(y\) sent along the second argument \(r\) should be smaller than
  the first argument \(x\).
  Thus, the process on the second line is translated to the following
  function definition:
  \[
 \begin{array}{l}
\Fname{\reg_f}(x)=\ifexp{x<0}{\skipexp}\\\qquad\qquad{
  (\Fname{\pre}(x)\nondet (\letexp{y}{\ndint}\assexp{y<x}\Fname{\reg_f}(y)))}
\end{array}
\]

\end{example}
