\section{Conclusion}  \label{sec:conclusion}

We have proposed a method for reducing termination verification for
the \(\pi\)-calculus to that for sequential programs and implemented
an automated termination analysis tool based on the method.
Our approach allows us to reuse powerful termination analysis tools
developed for sequential programs.

Future work includes (i) a further refinement of our reduction
and (ii) applications of our method to other message-passing-style
concurrent programming languages.
As for the first point, there are a few known limitations in the current reduction.
Besides the issues mentioned at the end of Example~\ref{ex:nested_rep}
and Section~\ref{sec:implementation},
there is a limitation that channels of the same region are merged to the same function,
which leads to the loss of precision.
For example, consider:
\begin{align*}
  &\srinexp{c}{x} \ifexp{x < 0}{\zeroexp }{\soutatom{c}{x - 1}} \\
&  \PAR \srinexp{d}{x} \ifexp{x > 0}{\zeroexp }{\soutatom{d}{x + 1}} \\
&\PAR \soutatom{e}{c} \PAR \soutatom{e}{d} \PAR \soutatom{c}{0}
\end{align*}
The process is terminating, but our approach fails to prove it. Since the same region
is assigned to \(c\) and \(d\) (because both are sent along \(e\)), the replicated input processes
are translated to non-deterministic function definitions:
\begin{align*}
    \Fname{\reg}(x) &= \ifexp{x < 0}{\skipexp}{\Fname{\reg}(x - 1)} \\
    \Fname{\reg}(x) &= \ifexp{x > 0}{\skipexp}{\Fname{\reg}(x + 1)}, 
\end{align*}
which cause an infinite reduction \(\Fname{\reg}(0) \red \Fname{\reg}(-1)\red \Fname{\reg}(0)\red \cdots\).
One remedy to this problem would be to introduce region polymorphism and translate
processes to higher-order functional programs.
