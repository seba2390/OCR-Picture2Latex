\section{Related Work}  \label{sec:relatedwork}

As mentioned in Section~\ref{sec:introduction}, there have been a number of
studies on termination of the \(\pi\)-calculus~\cite{Deng06IC,Demangeon07,SangiorgiTermination,KobayashiHybrid,Yoshida04IC,DBLP:journals/jlp/DemangeonHS10,Venet98SAS},
but most of them have been rather theoretical, and few tools have been developed.
Our technique has been partially inspired by Deng and Sangiorgi's work~\cite{Deng06IC}, especially by their observation that a process is terminating just if
there is no infinite chain of communications on replicated input processes.
Deng and Sangiorgi ensured the lack of infinite chains by using a type system.
They actually proposed four system, a core system and three kinds of extensions.
Our approach roughly corresponds to the first extension of their system (\cite{Deng06IC}, Section 4), which requires that, in every
chain of communications, the values of messages
monotonically decrease. An advantage of our approach is that we can use mature tools
for sequential programs to reason about how the values of messages change.
Our approach does not subsume the second and third extensions of Deng and Sangiorgi's
system, which take into account synchronizations over multiple channels; it is
left for future work to study whether such extensions can be incorporated in
our approach.

To our knowledge,
\typical{}~\cite{TyPiCal,KobayashiHybrid}
is the only automated termination analysis tool.
\typical{}'s termination analysis is based on Deng and Sangiorgi's
method~\cite{Deng06IC}, but is quite limited in reasoning about
the values sent along channels; it only considers natural numbers, and
the ordering on them is limited to the standard order on natural numbers.
Thus, for example, \typical{} cannot prove the termination of the process \testcase{upperbound}
as described in Section~\ref{sec:implementation}.

Recently, there have been studies on type systems for estimating
the (time) complexity of processes for the
\(\pi\)-calculus~\cite{DBLP:conf/esop/BaillotG21,DBLP:conf/concur/BaillotG021} and related session
calculi~\cite{DBLP:conf/lics/Das0P18,DBLP:journals/pacmpl/Das0P18}.
Since the existence of a finite upper-bound implies termination, those analyses
can, in principle, be used also for reasoning about termination, but the resulting
termination analysis would be too conservative.
It would be interesting to investigate whether our approach of reduction to 
sequential programs can be extended to achieve complexity analysis for the
\(\pi\)-calculus.
\changed{Refinement types for variants of the \(\pi\)-calculus have been
studied before~\cite{griffith2013liquidpi,baltazar2012linearly}.
Our contribution in this regard is the application to
termination analysis.}

Cook et al.~\cite{Cook07PLDI} proposed a method for proving
termination of multi-threaded programs. Their technique also makes use
of a termination tool for sequential programs.  As their language
model is quite different from ours (they deal with imperative programs
with shared memory and locks, rather than message-passing programs),
however, their method is quite different from ours.



