% vim: set ts=2 sw=2 sts=2:
% vim: set wrap breakindent tw=85 cc=85:
% !TEX root = paper_ppme_TOMS.tex

\section{The PPM Environment: Architecture and Implementation}
\label{sec:implementation_use_cases}
%The \emph{PPM Environment} (PPME) is an IDE and DSL for developing numerical simulations using the parallel particle-mesh method.
 %It aims to reduce the knowledge gap, that is, the mismatch between domain experts and the required expertise for an efficient use of HPC resources~\cite{Sbalzarini2009}.
 %Therefore, it provides high-level abstractions and notations that are well-known to domain experts and, thus, align with the class of problems relevant in particle-mesh-based simulations.
 %
%The development process of scientific applications can be improved by domain-specific tools and languages.
The \emph{productivity} of scientific programmers can be increased by providing high-level abstractions for
computational models, such that the developer is not bothered with details of the programming language
or the underlying hardware architecture. While \emph{quality} is hard to measure, an IDE can check for common errors up-front and present the developer with meaningful warnings
and error messages. Additionally, static program analysis, paired with domain knowledge, can be used to
improve performance, accuracy, and/or efficiency of simulations.
Incorporating third-party applications allows
to reuse established tools for analysis and program transformation instead of reimplementing their features. 
\revii{Full access to the underlying language and implementation enables advanced scientific programmers to leverage their knowledge to add new language-level features and to have full control over program performance.}
All of these features are available in PPME.

\subsection{Internal Structure of PPME}
\revii{Based on the Meta Programming System (MPS)}, PPME adds an additional layer on top of the existing PPML 
stack~\cite{Sbalzarini2006a,Awile:2013a} and does not require any adaptation in the underlying framework.
It generates source code against PPML, and therefore makes use of the established workflow, using PPML
as an intermediate representation. Figure~\ref{fig:ppme-access_layer} illustrates how PPME fits between
the user program and the PPM middleware. Application developers interact with the development environment
to implement particle methods and the related configuration files. %Furthermore, the IDE provides a simpler access to the PPM library than PPML.
PPML's original purpose of hiding technical details, specific realizations, and the explicit target platform
is preserved. However, PPME offers a more consistent DSL syntax and incorporates domain-specific
elements as first-class concepts.

  \begin{figure}[tp]
    \begin{minipage}[b]{.57\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{img/ppme_overview.pdf}
      \caption{PPME: New access layer to the underlying PPML.}
      \label{fig:ppme-access_layer}
    \end{minipage}
    \hfill
    \begin{minipage}[b]{.40\textwidth}
      \centering
      \includegraphics[width=1\textwidth]{img/ppme_architecture.pdf}
      \caption{Modular architecture of PPME.}
      \label{fig:ppme-architecture}
    \end{minipage}
  \end{figure}

In PPME, the domain metamodel of Section~\ref{sec:domain-metamodel}
is organized in language packages, called \emph{solutions} in MPS. The clean separation between
different sub-languages enables a good separation of concerns. The lower layers form a base DSL with
general language constructs such as expressions, literals, and statements. These concepts are reused in the upper
layers to define domain-specific language concepts for particle-mesh methods on top of the base language.
Reusing lower layers and their extension is key in the design of PPME, enabling easier
maintenance and custom extensions for specific cases as plug-ins. 

\revii{Figure~\ref{fig:ppme-architecture} provides
a schematic view of PPME's internal language stack. The bottom layers form the main DSL while sub-languages
are used to keep the implementation modular and maintainable. At the interface to the underlying PPM library, 
MPS manages code transformation and generation. The top layer is open to new application-specific extensions, e.g., for particle-based image processing~\cite{Afshar2016}.
The languages packages of PPME (cf. Figure~\ref{fig:ppme-architecture}) are:}

\textbf{ppme.expressions}.
This package provides general expressions as can be found in most programming languages, e.g., mathematical
and logical expressions, and literals for integer and floating-point numbers. Moreover, the base types available in
PPME are defined in this package, as well as essential parts of the type system introduced in Section~\ref{sec:types_units}.
%
As already mentioned previously, the main purpose of the static type system is to detect illegal expressions early,
at compile time or while editing. The PPME editor therefore instantaneously analyzes the program using the type-inference rules.
When an error type $\mathbb{E}$ is derived, the editor displays an error mark and a cause-related error message, if the
cursor is hovered over the erroneous expression. 

\textbf{ppme.statements}.
The statements sub-language contains a basic set of imperatives, such as expression statements, if-else clauses, and loops.
Furthermore, variable declarations and references are part of this package.
The type system is enriched with variable support where necessary (cf. Section~\ref{sec:type_rules}).
Overall, the elements of this language are universal since they are independent of the domain they are used in.

\textbf{ppme.core}.
The core package contains most elements specific to particle methods.
It extends the solutions for expressions and statements by adding new domain-specific types, expressions, and statements.
Selected constructs of PPML are reflected in PPME while remaining consistent with the base language's concepts.
For instance, the \emph{timeloop} construct of PPML is available in this package.

\textbf{ppme.modules}.
A module in PPME is the top-level structure for client programs written in PPME. It contains the simulation code
and optional specifications for imported control parameters. A module translates to a PPML client, but the
IDE can use additional knowledge about the domain better than PPML, e.g., by referencing external control
files and inspecting the code.

\textbf{ppme.lang}.
This package is an MPS \emph{devkit} that contains the above base languages of PPME (not shown explicitly in Figure~\ref{fig:ppme-architecture}).
In MPS, devkits group interconnected languages as one unit. Hence, to get the base functionality of
PPME's language it suffices to include the devkit in an MPS project, covering all language dependencies.

In addition to these base languages, PPME provides optional solutions that add dimensions and physical units into program specifications,
and for the integration of external analysis tools. Both serve as examples for further extensions
tailored to specific use-cases:

\textbf{ppme.physunits}.
The optional physical-units integration enables developers to annotate further meta information to variables and constants.
This includes means for adding dimensions and physical unit specifications as an additional extensible
layer in the type system (cf. Section~\ref{sub:dimension_annotations}).

\textbf{ppme.analysis}
The analysis language consists of an exemplary binding of \emph{Herbie} as an external analysis tool for improving
floating-point expressions~\cite{Panchekha2015}. We elaborate a general framework enabling the access of custom
 tools in the environment. More details on this tool integration will be given later in Section~\ref{sec:analysis}.

\subsection{Code Generation}
The code-generation process in PPME involves an integrated transformation and analysis chain. This process is
sketched subsequently, followed by two concrete example transformation steps.

\subsubsection{Transformation Process}
Code generation in PPME is implemented via several model-to-model transformations
refining the program, and a final text-generation stage that produces source code in
the PPML target language. 
%
%\footnote{
\revii{Models in MPS are directed graphs with type annotations derived from the metamodel. The graphs have a distinct spanning tree, which in general corresponds to an abstract syntax tree. Model-to-model transformations map an input graph to an output graph, where the output graph may use the same or different type annotations given by the same or another metamodel. Models must adhere the structural constraints defined by their metamodels. An excerpt of the PPME metamodel is given in Figure~\ref{fig:domain-model}.}
%}
%
\revii{During the transformation process,} the internal graph-based representation of the program is
enriched with additional information that is explicitly required to generate the
output in the target language, e.g., a list of variables accessed in a loop can be
derived from the loop's body and made available explicitly for further processing. In
general, the concept of staged language processing is advantageous, for example to yield
different output representations of an input program, or for transformation chaining.
%
%\tn{elaborate this aspect in more detail with focus on LWs?} The concept of
%transformation stages allows for different fields off application. On the one hand,
%several transformations for the same model could be executed in parallel, yielding
%several representations of a single input program (e.\,g., producing customized
%versions for % several target platforms). On the other hand, transformations can be
%chained, i.\,e., the result of one transformation is used as the input of the next
%one. Since PPME aims for modular language extension and composition, the underlying
%language workbench has to support transformations introduced by different language
%extensions.

Dependencies between transformation steps are resolved automatically so that a global
transformation sequence for a given program can be computed. This allows adding new
features and further transformations to extend PPME without affecting
other components.

%Supporting PPME's goals towards language extensibility, MPS automatically resolves
%dependencies and computes a global transformation sequence for a given
%program\jc{Turn this around, as a feature of PPME thanks to MPS}. This allows adding
%new features and plug in transformations without affecting other components.

\begin{figure}[tp]
  \centering
  \includegraphics[scale=0.7]{img/ppme-transformations.pdf}
  \caption{%
    Domain-specific abstractions in a PPME module are transformed (\textbf{T}) into
    lower-level representations. From this enriched module, PPML client code is
    generated (\textbf{G}) which is subsequently processed (\textbf{P}) to Fortran
    code and compiled (\textbf{C}) to a binary linking against the PPM Library.%
  }
  \label{fig:ppme-transformation} % chkTex 24
\end{figure}
%
To avoid unnecessary overhead during the generation phase, textual output is produced
in only two cases: (a) when the final output in the target language is generated, and
(b) when external tools and analyses require textual input. This restriction enables
full control of the transformation phase within MPS, taking into account the
enrichments of various transformations and results of external components, such as
Herbie and other tools. The produced source code can then be compiled using a regular
compiler. 

% JC: Next as separate paragraph - (issue 13)
The code generation process is illustrated in Figure~\ref{fig:ppme-transformation}. It starts
with a simulation program implemented using the domain metamodel introduced in
Section~\ref{sec:domain-metamodel}. The module contains domain-specific concepts such
as a \inline{timeloop} and various constructs to define particle-based
simulations. In Figure~\ref{fig:ppme-transformation}, the \inline{timeloop} statement
is analyzed in the first transformation stage and a PPML right-hand side specification
(cf. Figure~\ref{fig:grayscott-ppml}, Lines $53$--$65$) is extracted. Similarly, the
creation of particles is expanded to several initialization and macro calls in the
representation of the module, which is closer to the target language.

The majority of the model-transformations are part of the top-level package
\inline{ppme.modules}. Various mapping scripts are used to \emph{pre-process} the
input-model for collecting information required in later transformation steps.
%
To produce the intermediate code (i.e., PPML code), MPS' \emph{text
gen} capabilities are used (cf. \cite{MPS32TextGen}). For each language concept, a
text generation component can be specified, defining its textual representation,
e.g., printing the name of a variable (\inline{VariableReference}), or emitting the
code for a loop statement.

%\tn{describe general capabilities of LWs for target code generation}\sk{not sure, if
%we would need this}
We use several transformation scripts to prepare the text-generation phase.
Therefore, we have defined multiple intermediate models resembling the macros and
first-class language constructs in PPML to stepwise refine the input model. This
includes collecting information about the differential operators used in equations,
adding explicit discretization statements for them, creating and populating right-hand side
declarations of PPML, adding ODE declarations, managing control files, expanding
random-number initialization, deriving field and property declarations, transforming
foreach loops into their PPML counterparts, and adding PPML-specific type annotations.
%
Exemplarily, we discuss the construction of right-hand-side declarations.

\subsubsection{Example Transformation}
%\jc{Is it possible to list all transformations, probably with a short description,
%and then only explain the ones you explained in detail. This would help to remove
%vagueness.}
%
%%
%\begin{figure}[tp]
%  \centering
%  \includegraphics[width=0.75\textwidth]{img//ppme-replaceRandoms.pdf}
%  \caption{%
%  Program-graph transformation translating random-number expressions to variable references (red arrows).
%  }
%  \label{fig:ppme-replaceRandoms} % chkTex 24
%\end{figure}
%%
%PPME offers high-level abstractions for initializing and using random-number generators from
%within an expression by writing, e.g., \inline{random<integer>} to generate a random integer value. 
%The system transforms this into corresponding code by adding a variable-declaration to the preamble
% and replacing the random expressions by references to the declared variable.
%Figure~\ref{fig:ppme-replaceRandoms} illustrates this transformation. The expression
%is replaced by a variable reference to \inline{rnd_1} and a random value is
%assigned to this variable right before the expression statement. 

%\sk{This random-number stuff could be removed. It has too many flaws.}

\begin{figure}[t]
  \includegraphics{img/ppme-populateRHS}
  \caption{Excerpts from the script that composes a PPML \inline{RHSMacro} from a PPME \inline{deqn} specification.}
  \label{fig:ppme-populateRHS}
\end{figure}

The \inline{populateRHS} transformation is responsible for extracting
right-hand-side definitions from \inline{deqn} statements\revii{, which model differential equations.} \revii{In PPME, these equations can be written
directly in code.
To transform them into PPML, we use \inline{RHSMacro}s, which represent 
the right-hand side definitions in the target language and, in turn, can be transformed into PPML macro code.}
%
The \inline{deqn} statements are matched and extracted by the code generator using transformation scripts \revii{in MPS' built-in scripting language}.
The scripting language is statically typed and borrows ideas from object-oriented and functional programming that are well-suited for model transformations, \revii{including}
higher-order functions, and type-based selectors on trees and lists. \revii{For example, the \inline{descendants} selector visits a tree or list and collects references to nodes of a given type, like iterators in an object-oriented language. 
In addition, higher-order functions such as \inline{map} or \inline{where} allow developers to map or filter lists by applying a given (anonymous) function, like in a functional program.} 
%
The left panel 
of Figure~\ref{fig:ppme-populateRHS} shows the script that implements the \inline{populateRHS} transformation. 
It iterates over all blocks of \inline{deqn} statements in a
program, and derives corresponding \inline{RHSMacro}s. A key issue in this process is to identify the used
differential operators \revii{contained in a \inline{deqn} statement}  (l. 2) and the accessed variables (ll. 13--18). 
A \revii{PPML} particle-loop, evaluating the differential operators over these variables, is assembled by transforming each statement in
the \inline{deqn} \revii{via delegation to \inline{transform}} (ll. 9--11). \revii{Finally, the created macro object is added to the model root and then used for generating the PPML right-hand side.}

% JC: Next as separate paragraph - (issue 13)
The script excerpt in the right panel of Figure~\ref{fig:ppme-populateRHS} shows the body
of the recursive \inline{transform()} function. It takes a statement of a
differential equation and enriches the given macro with information. For each
differential equation statement $\frac{\partial\arrowOp{c}{f}}{\partial{t}} = e$
(\inline{stmt}), the affected particle attribute ($f$) is extracted (ll. 2--6).
Subsequently, the accessed particle fields and properties are extracted and explicitly
added to the \texttt{RHSMacro} (ll. 11--20). Finally, the differential equation is
translated to an assignment expression \revii{that replaces the original definition in the model and  is later translated to PPML statements for the generated code of the right-hand side}.

Figure~\ref{fig:ode-comparison} shows a comparison of the original PPME block and the
resulting PPML code for the Gray-Scott example (cf. Section~\ref{sec:ppml}). 
It integrates the governing equations discretized over the particle list $c$ using the 
4-th-order Runge-Kutta method (``rk4'') for time integration. 
%
\begin{figure}[t]
\centering
\includegraphics{img/ppme-rhs_comparison}
\caption{PDE specification in PPME (top) and the generated right-hand side in PPML (bottom).}
\label{fig:ode-comparison}
\end{figure}
%
In PPME, a developer conveniently defines equations over attributes of a particle
list \inline{c}. The IDE automatically extracts the required information. First, two
applications of differential operators,
\lstinline[mathescape]{$\nabla^2$c$\rightarrow$U} and
\lstinline[mathescape]{$\nabla^2$c$\rightarrow$V}, are identified. The local
variables \inline{dU} and \inline{dV} are inserted to hold the intermediate result of
applying the operators. Both the particle loop and the right-hand-side block itself
hold derived information about the accessed particle fields, \inline{U} and
\inline{V}. Furthermore, \inline{dU} and \inline{dV} are treated like other scalar
fields. Note that the access of particle list attributes (\inline{c$\rightarrow$U})
is transformed to access of particle attributes by inserting a loop over particles and accessing attributes of the
loop variable \inline{U_p}.
%
The example demonstrates some of the key benefits of our approach over the
original PPML code: since all required information is extracted by the PPME
compiler, redundant statements such as \inline{get_fields}, \inline{apply_op} and
\inline{sca_fields} are avoided, which leads to less code, less compile-time errors, 
and an improved readability. Readability is further improved by the PPME editor natively 
supporting basic mathematical notation, such as the Nabla operator $\nabla$ and the partial 
derivative $\partial$.
% subsection code_generation (end)


\input{32-case-studies.tex}
% section the_ppm_environment (end)
