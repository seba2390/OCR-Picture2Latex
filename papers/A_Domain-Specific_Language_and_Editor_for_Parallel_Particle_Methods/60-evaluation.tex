% vim: set ts=2 sw=2 sts=2:
% vim: set wrap:

\section{Evaluation}
\label{sec:evaluation}
%In this section we evaluate PPME w.r.t. the major challenges it was meant to address.
%
%\paragraph{Reducing the Knowledge Gap}
\label{par:evaluation-reducing_the_knowledge_gap}
One of PPME's primary goals is to reduce the knowledge gap in scientific programming.
This is achieved by providing domain-specific abstractions at the language level for
particle-mesh simulations, based on those previously offered by PPML. This is
complemented with features of a modern IDE, such as code completion and syntax highlighting,
guiding the scientific programmer using domain-specific notations 
that are free of the overhead otherwise introduced by parallel programming.  
%
In addition, the formal type system and its optional
extensions considerably improve error detection. They prevent a series of common
errors at development-time and provide developers with meaningful feedback. Errors
are captured and reported at the DSL level, instead of the level of the generated code.
In comparison with PPML, PPME improves error detection and handling of the following kinds:
%
\begin{itemize}
%
\item \emph{PPM instantiation errors.} PPME inherently generates statements in the order
that is expected by the PPM call protocols. Frequently, such errors would otherwise only be 
discovered at runtime.
%
\item \emph{PPML redundant redeclaration errors.} PPML requires a proper redeclaration of
fields and operators that are accessed in loops or right-hand-side specifications. A missing 
or wrong declaration leads to compile-time or runtime errors. Since PPME
analyzes the code to derive the required information, such errors become impossible.
%
\item \emph{Syntax errors in Fortran code.} Except for explicitly inlined Fortran code, PPME 
has its own expression language so that syntactic errors in Fortran expressions, as in PPML,
are impossible.
%
\item \emph{Type errors in Fortran code.} PPME has its own type checker so that static 
type errors in the generated Fortran code are not possible.
%
\item \emph{Dimension-related errors.} Due to dimension support, PPME is capable of 
statically detecting errors in expressions and differential equations. If not detected, such errors
can silently corrupt the simulation result, wasting HPC resources.
\end{itemize}  


  %
  % Counting WLOC (Written Lines of Code) for better metric on the implementation effort:
  %
  % ------+-------+-------+--------
  % WLOC  | PPME  | PPML  | Fortran
  % ------+-------+-------+--------
  % GS    | 28    | 53    | 623
  % LJ    | 72    | 75    | 480
  % NB    | 51    | 58    | 469
  % ------+-------+-------+--------
  %
  \begin{figure}[tp]
    \centering
    \footnotesize
    \begin{tabular}{l c c c c}
      \toprule
        & PPME  & PPME*   & PPML  & Fortran   \\
      \midrule
      Gray-Scott (complete)
        & 46    & 28      & 53    & 623       \\
      Gray-Scott (RHS)
        & 4     &  4      & 9     & 103       \\
      \midrule
      Lennard-Jones (complete)
        & 88    & 72      & 75    & 480       \\
      \midrule
      N-Body (complete)
        & 69    & 51      & 58    & 469       \\
      \bottomrule
      \multicolumn{5}{r}{\scriptsize PPME*: Written Lines of Code (WLOC)}
    \end{tabular}
    \caption{Comparison of lines of code for PPME, PPML, and PPM/Fortran.}
    \label{fig:comparison-loc}
  \end{figure}
  %
Besides error detection, PPME achieves program sizes similar to PPML or even smaller. Figure~\ref{fig:comparison-loc} compares the source lines of code (SLOC)
of the implemented case studies for PPME and the generated PPML and Fortran codes.
Since PPME is not a conventional editor but a projectional one, we use 
\emph{written lines of code (WLOC)} as a second metric in column \emph{PPME*}. 
This takes into account that PPME programs typically contain some lines that have not been 
entered by the developer, but are generated by the editor (e.g., optional configuration 
fields). 
%
Considering SLOC, in the Lennard-Jones and N-body examples, the PPME programs are
larger than the generated PPML code with ratios of $88:75$ ($117\,\%$) and $69:58$ ($119\,\%$).
In contrast, in the Gray-Scott example, PPME requires less space with a ratio of $50:62$ ($81\,\%$).
The reduction in the latter case is due to the built-in constructs for solving PDEs, which
are not used in the other examples.
%
Considering WLOC, PPME reduces the code sizes in all examples. In the 
Lennard-Jones and N-body examples, the corresponding ratios versus PPML go down to $96\,\%$ and 
$88\,\%$, respectively. For Gray-Scott, the code size goes down to $52\,\%$.

\revii{In terms of performance, there is no difference between the execution time 
of code generated from PPME and an equivalent hand-written PPML version. 
This is due to the fact that the PPML output code generated from PPME is identical to the hand-written PPML code.
Any performance difference between PPML and plain Fortran linked against the PPM Library was found to be
less that $2\,\%$ in previous experiments~\cite{Awile:2010a}, whereas PPM Fortran was 
found to generally perform better than hand-parallelized Fortran code that does not use the PPM Library~\cite{Sbalzarini2006a}.
} 

\revii{PPME also has some drawbacks. In comparison to PPML and other programming languages, 
version control turns out to be more complicated. Since files are serialized using XML, 
conventional text-based diff and merge operations are difficult to apply. While
MPS has built-in support for most of the established version-control systems, 
the resulting workflow is different from the text-based approaches and not always as 
efficient. For instance, even if the rendered program  did not visibly change, or only a small 
edit was applied,  serialization may change a lot, causing more merge conflicts in 
collaborative development scenarios.}

\revii{Another difference between PPME and general-purpose languages is that convenience support for user-defined 
functions and types is not built into the PPML language. For the development of our current application examples,  
it was not necessary to have these concepts in the language. However, this may change in the future, demanded by 
more complex applications. Language extension is one of the key features of language-oriented programming 
in PPME/MPS, which was, in turn, not the case for PPML.}
