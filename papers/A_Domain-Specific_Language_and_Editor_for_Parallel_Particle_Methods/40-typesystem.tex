% vim: set ts=2 sw=2 sts=2 tw=85:
% vim: set wrap breakindent:
% !TEX root = master.tex        --- atom

\subsection{Types and Dimensions} % (fold)
\label{sec:types_units}

  Based on the domain model, we present a static type-inference mechanism,
  which relies on a formal type system for particle abstractions. The error
  detection capabilities resulting from the hierarchy of types and inference rules
  are key to constructively improve code quality of simulations written
  in PPME, as it detects errors at compile time and provides meaningful feedback to
  the developer. In addition, we
  present an optional unit calculus extension to the type system. This can be used to perform automatic consistency checks of expressions.
% subsection types_units (end)

\subsubsection{Type Hierarchy} % (fold)
\label{sub:type_hierarchy}
  %The underlying language workbench allows to freely define custom types by language concepts.
  The type hierarchy is built around the metamodel shown in
  Figure~\ref{fig:domain-model}, i.e., all types derive from \inline{Type} as a
  common supertype.  The type system can be divided into two parts: a base type
  system and a domain-specific extension.

  \newcommand{\TP}[2][Xdummy]{\ensuremath{\mathit{#2}\ifstrequal{#1}{Xdummy}{}{\langle\mathit{#1}\rangle}}}

  % -- Base Types -----------------------------------------------------------
  The base type system consists of a set of primitive types
    $\mathcal{P} = \{ \TP{String}, \TP{Boolean}, \TP{Real}, \TP{Integer} \}$
  and type-inference rules over this set.
  %The set $\mathcal{P}$ of primitive types contains the well-known types \inline{String} for character sequences, \inline{Boolean} for truth values, \inline{Integer} for integers, and \inline{Real} as an %abstraction for the real numbers.
  % \[ \mathcal{P} = \{ String, Boolean, Real, Integer \} \]
  %Additionally, PPME knows two kinds of parameterized types for vectors and matrices, denoted by \lstinline{Vector<X>} and \lstinline{Matrix<X>} where \inline{X} is a \emph{type parameter}.
  Additionally, $\mathcal{C} = \{ \TP[X]{Vector}, \TP[X]{Matrix} \}$ represents a set
  of container types for matrices (i.e., tensors of rank 2) and vectors (i.e., tensors of rank 1) with components of type $X$.
   %A vector and matrix represent one-dimensional and two-dimensional arrays with components of type \inline{X}, respectively.
   %These polymorphic types are joined under an abstract \lstinline{ContainerType} in the implementation and are denoted by the set $\mathcal{C}$.
  %\[ \mathcal{C} = \{ Vector\langle{}X\rangle{}, Matrix\langle{}X\rangle{} \} \]
  The set of base types $\mathcal{T}_\mathit{Base} = \mathcal{P} \cup \mathcal{C}$ is
  composed of primitive types $\mathcal{P}$ and container types $\mathcal{C}$.

  % -- Domain-speicfic Types ------------------------------------------------
  % The domain-specific extensions to the type system are located in \lstinline{de.ppme.core}.
  These basic types are complemented by domain-specific types for particle methods,
  i.e., types that represent particles, particle lists, and different kinds of particle
  properties. These are:
  $\mathcal{D} = \{ \TP{Particle}, \TP{ParticleList}, \TP{Field}, \TP{Property},
  \TP{Displacement} \}$.
  Furthermore, the boundary of the simulation domain and the data-distribution topology of the underlying PPM framework are captured in the set $\mathcal{O}=\{ \TP{Topology}, \TP{Boundary} \}$. The set
  $\mathcal{T}_\mathit{PPM} = \mathcal{D} \cup \mathcal{O}$ of domain-specific types
  is then composed of $\mathcal{D}$ and $\mathcal{O}$.
  %
  %\[ \mathcal{T}_\mathit{PPM} = \mathcal{D} \cup \mathcal{O} = \{ \TP{Particle}, \TP{ParticleList}, \TP{Field}, \TP{Property}, \TP{Displacement} \} \cup \{ Topology, ... \} \]

  Finally, $\mathcal{T} = \mathcal{T}_{Base} \cup \mathcal{T}_{PPM}$ denotes the set
  of all types in PPME. Note that this way of constructing $\mathcal{T}$ indicates the
  flexibility of language implementations in modern language workbenches like MPS and
  language-oriented programming in general. This fundamental type hierarchy can be
  extended in the future, adding new domain-specific concepts.

  %SK: I think we do not need to discuss this further
  %This enables a
  %continuous refinement of the given implementation towards new use cases.\sk{Discuss
  %again in impl section.}\jc{That last point is kind of unclear to me.} \tn{e.g.,
  %\inline{Image} as special particle list, or \enquote{improving} existing types
  %(simply added size to vectors)}
% subsection type_hierarchy (end)

\subsubsection{Syntax of Expressions} % (fold)
\label{sub:syntax_of_expressions}

\revii{
  In PPME the standard set of expressions well-known by programmers is extended
  by domain-specific operations and expressions tailored for the domain.
  Figure~\ref{fig:expr-grammar} presents the syntax of expressions in PPME as
  production rules of a context-free grammar.
  Note that some domain-specific expressions (e.g., differential operators) are
  only available in a specific context.

  \tn{Differential operators as domain-specific expressions (e.g., Laplace and
  Jacobi) are restricted to the context of RHS statements. A right-hand side
  statement is not an expression, thus, it is not covvered by this section.}

  \tn{PPME-Lang itself is not context free, and I don't know how much sense it
  would make trying to represent the complete syntax of PPME in a grammar. The
  review comment addresses section 4.2.2 which only deals with expressions}
}

  \begin{figure}
    \centering
    \footnotesize
    \begin{minipage}[t]{.4\textwidth}
      \begin{grammar}
        <expr> ::= <expr> ( `&&' | `||' ) <expr>
        \alt <expr> ( `==' | `!=' ) <expr>
        \alt <expr> ( `<' | `>' | `<=' | `>=' ) <expr>
        \alt <expr> ( `+' | `-' ) <expr>
        \alt <expr> ( `*' | `/' | `^' ) <expr>
        \alt <unaryExpr>

        <unaryExpr> ::= `-' <unaryExpr>
        \alt `!' <unaryExpr>
        \alt \lit{$\sqrt{}$} <unaryExpr>
        \alt <primaryExpr>

        <varAccess> ::= Identifier
      \end{grammar}
    \end{minipage}
    %
    \begin{minipage}[t]{.4\textwidth}
      \begin{grammar}
        <primaryExpr> ::= <literal>
        \alt `(' <expr> `)'
        \alt <varAccess>
        \alt <particleAccess>
        \alt <arrayAccess>

        <literal> ::= IntegerLiteral
        \alt RealLiteral
        \alt StringLiteral
        \alt BooleanLiteral

        <particleAccess> ::= <expr> \lit{$\rightarrow$} Identifier

        <arrayAccess> ::= <expr> `[' <expr> `]'
      \end{grammar}
    \end{minipage}
    \caption{\revii{Syntax of expressions in PPME.}}
    \label{fig:expr-grammar}
  \end{figure}

  \paragraph{Basic Syntactic Sets} % (fold)
  \label{par:basic_syntactic_sets}

  The basic syntactic sets in PPME are comprised mainly of \emph{literals} for
  primitive types and \emph{variables} (cf.
  Figure~\ref{tab:typesystem:basic_syntactic_sets}). Literals are typed in a natural
  way, e.g., integers have type $Integer$ and decimals have type $Real$. More
  complex sets can be derived from the basic syntactic sets for variables and
  literals. The abstract syntax of these derived syntactic sets is given by the form
  of expressions in PPME.
  %
  \begin{figure}[tp]
    \centering
    \footnotesize
    \setlength{\tabcolsep}{0.5em}
    \begin{tabular}{lll}
      \toprule
      \textbf{booleans}  & $b$    & $b \in \mathbb{B} = \{ true, false \}$         \\
      \textbf{strings}   & $s$    & e.g., $s = \mathtt{"PPME"}$                  \\
      \textbf{integers}  & $n, m$ & $n, m \in \mathbb{N}$                          \\
      \textbf{reals}     & $r$    & e.g., $r = 3.14$ or $r = 6.62\mathrm{E}{-34}$\\
      \textbf{variables} & $v$    & $v \in Var = \{ a, b, \dots, x, x_2, \dots \}$
      \\
      \bottomrule
    \end{tabular}
    \caption{Basic syntactic sets and their notation.}
    \label{tab:typesystem:basic_syntactic_sets} % chkTex 24
  \end{figure}
  % paragraph basic_syntactic_sets (end)

  \paragraph{Unary Expressions ($\ominus(e)$, with $\ominus \in \{ -, !, \sqrt{} \}$)}
  \label{par:unary_expressions}

    PPME supports three unary operations, the unary minus $-e$, the logical not $!e$,
    and the square root $\sqrt{e}$. Obviously, this definition \revii{alone} allows for
    \enquote{nonesense} expressions such as taking the square root of a string. The
    remainder of this section therefore presents rules for well-formedness and type
    conclusion to prevent erroneous phrases.
    %   \[ \ominus \in \{ -, !, \sqrt{} \} \]
  % paragraph unary_expressions (end)

  \paragraph{Binary Expressions ($e_1 \otimes e_2$, where $\otimes \in \otimes_\mathit{arith} \cup \otimes_\mathit{logi} \cup \otimes_\mathit{rel}$)}
  \label{par:binary_expressions}

    Various binary operations are supported. First, PPME allows for typical arithmetic
    operators
      $\otimes_{arith} = \{ +, -, *, /, \text{\^{}} \}$
    Second, there are operators for the logical \emph{and} and \emph{or}
      ($\otimes_{logi} = \{ \&\&, || \} $).
    Third, the common relational operators are available
      ($\otimes_{rel} = \{ ==, !\!\!=, <, >, <=, >= \}$).
    % The union of these three categories yields the set of binary operations in PPME.
    As for unary operations, the type system will check well-formedness of binary
    expressions and decide on the resulting type.
    %\[ \otimes \in \otimes_{arith} \cup \otimes_{log} \cup \otimes_{comp} \]
    % \begin{align*}
    %   \otimes_{arith} \hfill&= \{ +, -, *, /, \text{\^{}} \}  \\
    %   \otimes_{log}   \hfill&= \{ \&\&, || \}                 \\
    %   \otimes_{rel}   \hfill&= \{ ==, !=, <, >, <=, >= \}
    % \end{align*}
  % paragraph binary_expressions (end)

  \paragraph{Domain-specific Operations}
  \label{par:domain_specific_operations}

    A strength of PPME is that domain-specific operations are seamlessly
    integrated into the language. They allow for concise notation of mathematical
    concepts, preserving the expressiveness of the mathematical notation. Following the
    domain model, fields and particle properties are defined on particle lists, and the language
    offers the syntactic concept \emph{particle list access} (PLA) to access these fields
    and properties. In a similar manner, the value of a field discretized over particles,
    or any other property of a specific particle, can be accessed via a \emph{particle access} (PA) operation.
    Given a particle list $ps$, a particle $p$ from this list, a field $f$ and a
    property $x$ both defined on $ps$, the access operations of field $f$ and property
    $x$ are represented by an arrow:%
%
    \[ \arrowOp{ps}{f}, \qquad \arrowOp{ps}{x}, \qquad \arrowOp{p}{f}, \qquad \arrowOp{p}{x} \]

    Intuitively, the result of a PLA is the whole field or property over the particle
    list. Additionally, PPME allows the developer to access the default properties of a
    particle, e.g., its position: $\arrowOp{p}{\mathit{pos}}$.
    %
    Finally, there are notations for differential operators \revii{in the
    context of right-hand side statements}. Simulation developers can use these
    operators when simulating continuous models (e.g., PDEs), staying close to
    the mathematical notation. This includes, for example, the Laplacian
    ($\nabla^2 e$) used in the Gray-Scott reaction-diffusion example.
  % paragraph domain_specific_operations (end)

  \paragraph{Access Operations ($v[i]$, $m[i][j]$)} % (fold)
  \label{par:acces_operations}
    The language also offers means to access elements of array-like structures such
    as matrices and vectors. Access operations are denoted by square brackets
    containing the index to access. Similarly, elements of non-scalar particle properties
    can be accessed using the same notation. Let $ps$ be a particle list
    with a non-scalar field $f$, and $p \in ps$ a particle from $ps$, then
    $\arrowOp{p}{f}[i]$ denotes the access of the $i^{th}$ element of $f$ on particle $p$.
  % paragraph acces_operations (end)

% subsection syntax_of_expressions (end)

\subsubsection{Formal Type System}
\label{sec:type_rules}

  \revii{
    Every literal and variable in PPME has an associated type, and the type of derived expressions often depends on
    their arguments' types.
    The formal type system describes the conclusions that can be drawn from a PPME program over its types, by defining
    rules for well-formedness of typed expressions.
    For instance, the PLA operator can only be used on particle lists, which is ensured by the static type-inference
    mechanism.
    Overall, the type rules ensure that expressions behave as expected in the context of particle methods. 
  }

  % The description of the type system uses the following notational agreements and terminology.
  A \emph{typing environment} $\Gamma$ associates variable names $x$ and types $\tau$
  as a set of pairs $\langle x, \tau \rangle$, commonly written as $x : \tau$. A
  lookup of a variable's type is denoted by $\Gamma(x)$, where $\Gamma(x) = \tau$ if
  and only if the environment contains an entry for the variable $\langle x, \tau
  \rangle \in \Gamma$. Otherwise, $\Gamma(x)$ is undefined.
  %
  We further define the subtype relationship: if $T$ and $S$ are types, then
  ${T}<{S}$ denotes that $T$ is a (direct) \emph{subtype} of $S$, and $S$ is a
  \emph{supertype} of $T$. ${T}{<^{*}}{S}$ is the reflexive transitive closure of $<$,
  that is, $S$ can be reached from $T$ in the type hierarchy. In the remainder, we
  use $\leq$ to refer to ${<^{*}}$.
  %
  We follow the notation of~\cite{Clement1986}. That is, each type-inference rule
  defines the conclusion that can be drawn if all $n$ premises hold:
  %
  \[
    \begin{prooftree}
      \Hypo{\mathit{premise}_1}
      \Hypo{\dots}
      \Hypo{\mathit{premise}_n}
      \Infer3{\mathit{conclusion}}
    \end{prooftree}
  \]
  %
  As premises, we allow typings as well as other predicates, e.g., for specifying a
  subtype relation.
  %
  %-- type inference rules ------------------------------------------------
  \begin{figure}[t]
    %-- variables ---------------------------------------------------------
    %\begin{minipage}[t]{.50\textwidth}
    \footnotesize
    %%
    \begin{center}
      \textsc{Var}
      \begin{prooftree}%\label{eq:typerule_var}
        \Hypo{\Gamma(v) = \tau}
        \Infer1{\Gamma \vdash v : \tau}
      \end{prooftree}
      %%
      \textsc{VarDecl}
      \begin{prooftree}%\label{eq:typerule_vardecl}
        \Hypo{\phantom{G}}
        \Infer1{\Gamma \vdash \tau \text{ } x : \Gamma \cup \{x = \tau \}}
      \end{prooftree}
      %%
      \textsc{VarInit}
      \begin{prooftree}%\label{eq:typerule_varinit}
        \Hypo{\Gamma \vdash e : \tau'}
        \Hypo{\tau' \leq \tau}
        \Infer2{\Gamma \vdash \tau \text{ } x = e : \Gamma \cup \{x = \tau \}}
      \end{prooftree}
    \end{center}
    %%
    \begin{center}
      \textsc{Paren}
      \begin{prooftree}%\label{eq:typerule_paren}
        \Hypo{\Gamma \vdash e : \tau}
        \Infer1{\Gamma \vdash (e) : \tau}
      \end{prooftree}
      %%
      \textsc{Assign}
      \begin{prooftree}%\label{eq:typerule_assign}
        \Hypo{\Gamma \vdash x : \tau}
        \Hypo{\Gamma \vdash e : \tau'}
        \Hypo{\tau' \leq \tau}
        \Infer3{\Gamma \vdash x = e : \tau}
      \end{prooftree}
    \end{center}
    %-- container and particle access -------------------------------------
    \begin{center}
      \textsc{VecAcc}
      \begin{prooftree}%\label{eq:typerule_vecacc}
        \Hypo{\Gamma \vdash v : \mathbb{V}\langle\tau\rangle}
        \Hypo{\Gamma \vdash i : \mathbb{Z}}
        \Hypo{i \geq 0}
        \Infer3{\Gamma \vdash v[i] : \tau}
      \end{prooftree}
 	    %%
      \textsc{MatAcc}
      \begin{prooftree}%\label{eq:typerule_matacc}
        \Hypo{\Gamma \vdash m : \mathbb{M}\langle\tau\rangle}
        \Hypo{\Gamma \vdash i,j : \mathbb{Z}}
        \Hypo{i,j \geq 0}
        \Infer3{\Gamma \vdash m[i][j] : \tau}
      \end{prooftree}
    \end{center}
    %%
    \begin{center}
      \textsc{PartScaAcc}
      \begin{prooftree}%\label{eq:typerule_partscaacc}
        \Hypo{\Gamma \vdash p : \mathbb{P}}
        \Hypo{\Gamma \vdash f : \mathcal{E}\langle \tau, 1 \rangle}
        \Infer2{\Gamma \vdash \arrowOp{p}{f} : \tau}
      \end{prooftree}
      %%
      \textsc{PartVecAcc}
      \begin{prooftree}\label{eq:typerule_partvecacc}
        \Hypo{\Gamma \vdash p : \mathbb{P}}
        \Hypo{\Gamma \vdash f : \mathcal{E}\langle \tau, n \rangle, n \geq 2}
        \Infer2{\Gamma \vdash \arrowOp{p}{f} : \mathbb{V}\langle\tau\rangle}
      \end{prooftree}
    \end{center}
    %-- unary and binary operations ---------------------------------------
    \begin{center}
      \textsc{Unary}
      \begin{prooftree}%\label{eq:typerule_unary}
        \Hypo{\Gamma \vdash e : \tau}
        \Hypo{\tau_\ominus(\tau) \neq \bot}
        \Infer2{\Gamma \vdash \ominus\,e : \tau_\ominus(\tau)}
      \end{prooftree}
      %%
      \textsc{BinLog}
      \begin{prooftree}%\label{eq:typerule_binlog}
        \Hypo{\Gamma \vdash e_1 : \mathbb{B}}
        \Hypo{\Gamma \vdash e_2 : \mathbb{B}}
        \Infer2{\Gamma \vdash e_1 \otimes_{log} e_2 : \mathbb{B}}
      \end{prooftree}
	  \end{center}
    %%
    \begin{center}
      \textsc{BinRel}
      \begin{prooftree}%\label{eq:typerule_binrel}
        \Hypo{\Gamma \vdash e_1 : \tau_1}
        \Hypo{\Gamma \vdash e_2 : \tau_2}
         \Hypo{\tau_\otimes(\tau_1,\tau_2) \neq \bot}
        \Infer3{\Gamma \vdash e_1 \otimes_{rel} e_2 : \mathbb{B}}
      \end{prooftree}
      %%
      \textsc{BinAri}
      \begin{prooftree}%\label{eq:typerule_binarith}
        \Hypo{\Gamma \vdash e_1 : \tau_1}
        \Hypo{\Gamma \vdash e_2 : \tau_2}
        \Hypo{\tau_\otimes(\tau_1,\tau_2) \neq \bot}
        \Infer3{\Gamma \vdash e_1 \otimes_{arith} e_2 : \tau_\otimes(\tau_1, \tau_2)}
      \end{prooftree}
    \end{center}
    %%
    \begin{center}
      \textsc{ErrUnary}
      \begin{prooftree}
        \Hypo{\Gamma \vdash e : \tau \quad \tau_{\ominus}(\tau) = \bot }
        \Infer1{\Gamma \vdash \ominus(e) : \mathbb{E}}
      \end{prooftree}
      \qquad
      \textsc{ErrBin}
      \begin{prooftree}
        \Hypo{\Gamma \vdash e_1 : \tau_1}
        \Hypo{\Gamma \vdash e_2 : \tau_2 \quad \tau_{\otimes}(\tau_1, \tau_2) = \bot}
        \Infer2{\Gamma \vdash e_1 \otimes e_2 : \mathbb{E}}
      \end{prooftree}%
    \end{center}%
    %-- bottom box --------------------------------------------------------
    \begin{center}%
      \begin{tcolorbox}[enhanced,colback=white,left=0pt,right=0pt,top=0pt,boxsep=0pt,boxrule=0pt,toprule=1pt,colframe=white!60!black,rightrule=1pt,arc=0pt,outer arc=0pt,leftrule=1pt,bottomrule=1pt,width=.95\textwidth,after skip=0pt,before skip=0pt]
      \footnotesize
        \begin{minipage}{\textwidth}
         \begin{equation*}
           \ominus         \in \{-, !, \sqrt{\phantom{e}}\},\;
           \otimes_{arith} \in \{ +, -, *, /, a^b \},\;
           \otimes_{log}   \in \{ \&\&, || \},\;
           \otimes_{rel}   \in \{ ==, !=, <, >, <=, >= \}
         \end{equation*}
        \end{minipage}
        \begin{minipage}{\textwidth}
          \begin{equation*}
            \revii{\mathbb{B} = \mathit{Boolean}},\;
            \mathbb{Z} = \mathit{Integer},\;
            \mathbb{R} = \mathit{Real},\;
            \mathbb{P} = \mathit{Particle},\;
            \mathbb{E} = \mathit{Error}
          \end{equation*}
        \end{minipage}
        \begin{minipage}{\textwidth}
          \begin{equation*}
            \mathbb{V} = \mathit{Vector},\;
            \mathbb{M} = \mathit{Matrix},\;
            \mathcal{E} = \mathit{Field/Property},\;
          \end{equation*}%
        \end{minipage}%
      \end{tcolorbox}%
    \end{center}%
    % ---------------------------------------------------------------------
    \caption{Type rules for expressions in PPME.}%
    \label{fig:type_rules}%
  \end{figure}%

  Figure~\ref{fig:type_rules} shows the type rules for expressions implemented in
  PPME. The type of a variable is given by the typing environment $\Gamma$ (rule
  \textsc{Var}). A variable declaration adds a new entry to the typing environment
  (rules \textsc{VarDecl} and \textsc{VarInit}). Type rules for unary
  (\textsc{Unary}) and binary operations (\textsc{Bin*}) can be defined with a
  general scheme, where the derived type information depends on the operation
  ($\ominus$ or $\otimes$) and the types of the operand(s). This also simplifies the
  implementation of the type system and makes it extensible.%\jc{Since you do a detailed intro to the notation, should you introduce $\vdash$?}
  %
  The type inference for unary operators $\ominus\in\{-,\sqrt{\phantom{x}},!\}$ can
  be summarized as follows: The logical not $!$ can be applied only to boolean
  arguments $e : \bool$ and its result is boolean as well. The unary minus is
  applicable for numerical expressions with $\tau \in \{ \integer, \real \}$ and will
  not change their types. Similarly, the square root operator can be applied to
  arguments of numerical type and the result will be a real number (or a runtime exception
  if the result would be a complex number, which is not included in the current static type system).
  The more detailed type-inference tables for binary arithmetic expressions
  $\tau_\otimes$ can be found in
  Figure~\ref{tab:typesystem_binary_operation_exponentiation}. In the tables,
  abbreviated forms for the types are used, where $\mathcal{E}$
  denotes a particle property or discretized data from a field.
  %in the PDE loop. We use this information in the code generator to derive the according statements that
  %were needed to be added manually by the user in PPML (using things like "sca_fields" etc.).
  % But I agree, for the type analysis, we probably do not need to make this distinction.
  The integers $n$ are $m$ denote the size of the data (i.e., the number of
  elements in the vector). Additionally, $\uparrow(\tau_1, \tau_2)$
  denotes the least common super-type of $\tau_1$ and $\tau_2$. Note that, for the
  sake of brevity, we did not include the inference tables of the remaining
  expressions. If $\tau_\otimes$ is undefined it is denoted by $\bot$.
  %
  Moreover, the rules that end on \textsc{Acc} (\textsc{*Acc}) define the type
  inference for scalar and vector access to particle properties, which is a core task
  of the system.

  % -- type inference tables ------------------------------------------------
  \begin{figure}[tp]
    \begin{minipage}{\textwidth}
      \centering
      \scriptsize
      \renewcommand*{\thefootnote}{\fnsymbol{footnote}}
      \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } c|cccc}
        \toprule
        \parbox[b][][b]{1.5cm}{$\bm{\tau_{+|-} (\tau_1, \tau_2)}$}
          & \integer & \real & \vect{X} %& \field{X,n}
          & \prop{X,n}
        \\
        \midrule
        \integer & \integer & \real & \vect{\uparrow(\integer,X)} %& \field{\uparrow(\integer,X), n}
                             & \prop{\uparrow(\integer,X), n}
        \\
        \real & \real & \real & \vect{\uparrow(\real,X)} %& \field{\uparrow(\real,X), n}
                              & \prop{\uparrow(\real,X), n}
        \\
        \vect{Y} & \vect{\uparrow(Y, \integer)} & \vect{\uparrow(Y, \real)} & \vect{\uparrow(Y, X)} & $\bot$ %& ---
        \\
  %      \field{Y, m} & \field{\uparrow(Y, \integer),m} & \field{\uparrow(Y, \real),m} & --- & \field{\uparrow(Y, X), n}\footnotemark[2] & ---
    %    \\
        \prop{Y, m} & \prop{\uparrow(Y, \integer),m} & \prop{\uparrow(Y, \real),m} & $\bot$ %& ---
          & \prop{\uparrow(Y, X), n}\footnotemark[2]
        \\
        \bottomrule
      \end{tabular*}
      \raggedright \footnotemark[2] if $n = m$
      \vspace{2pt}
    \end{minipage}
    \vspace{5pt}
    \begin{minipage}{\linewidth}
      \centering
      \scriptsize
      \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } c|cccc} % chkTex  -2
        \toprule
 %       $\bm{\tau_{*}(\tau_1, \tau_2)}$ & \integer & \real & \vect{X} & \field{X,n} & \prop{X,n}
        $\bm{\tau_{*}(\tau_1, \tau_2)}$ & \integer & \real & \vect{X}  & \prop{X,n}
        \\
        \midrule
        \integer & \integer & \real & \vect{\uparrow(\integer, X)} & \prop{\uparrow(\integer, X),n}
      %  \integer & \integer & \real & \vect{\uparrow(\integer, X)} & \field{\uparrow(\integer, X),n} & \prop{\uparrow(\integer, X),n}
        \\
        \real & \real & \real & \vect{\uparrow(\real, X)}  & \prop{\uparrow(\real, X),n}
 %       \real & \real & \real & \vect{\uparrow(\real, X)} & \field{\uparrow(\real, X),n} & \prop{\uparrow(\real, X),n}
        \\
         \vect{Y} & \vect{\uparrow(Y, \integer)} & \vect{\uparrow(Y, \real)} & $\bot$ & $\bot$
%      \vect{Y} & \vect{\uparrow(Y, \integer)} & \vect{\uparrow(Y, \real)} & --- & --- & ---
        \\
%        \field{Y,m} & \field{\uparrow(Y, \integer),m} & \field{\uparrow(Y, \real),m} & --- & --- & ---
 %       \\
        \prop{Y,m} & \prop{\uparrow(Y, \integer),m} & \prop{\uparrow(Y, \real),m} & $\bot$ & $\bot$
%         \prop{Y,m} & \prop{\uparrow(Y, \integer),m} & \prop{\uparrow(Y, \real),m} & --- & --- & ---
        \\
        \bottomrule
      \end{tabular*}
    \end{minipage}
    \vspace{5pt}
    \begin{minipage}{\linewidth}
      \scriptsize
      \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } c|cccc} % chkTex  -2
        \toprule
%        $\bm{\tau_{/}(\tau_1, \tau_2)}$ & \integer & \real & \vect{X} & \field{X,n} & \prop{X,n}
        $\bm{\tau_{/}(\tau_1, \tau_2)}$ & \integer & \real & \vect{X} & \prop{X,n}
        \\
        \midrule
%        \integer & \real & \real & \vect{\tau_{/} (I, X)} & \field{\tau_{/} (I, X),n} & \prop{\tau_{/} (I, X),n}
        \integer & \real & \real & \vect{\tau_{/} (I, X)}  & \prop{\tau_{/} (I, X),n}
        \\
%        \real & \real & \real & \vect{\tau_{/} (R, X)} & \field{\tau_{/} (R, X),n} & \prop{\tau_{/} (R, X),n}
        \real & \real & \real & \vect{\tau_{/} (R, X)} & \prop{\tau_{/} (R, X),n}
        \\
%        \vect{Y} & \vect{\tau_{/} (Y, \real)} & \vect{\tau_{/} (Y, \real)} & --- & --- & ---
        \vect{Y} & \vect{\tau_{/} (Y, \real)} & \vect{\tau_{/} (Y, \real)} & $\bot$ & $\bot$
        \\
 %       \field{Y,m} & \field{\tau_{/} (Y, \real),m} & \field{\tau_{/} (Y, \real),m} & --- & --- & ---
  %      \\
 %       \prop{Y,m} & \prop{\tau_{/} (Y, \real),m} & \prop{\tau_{/} (Y, \real),m} & --- & --- & ---
         \prop{Y,m} & \prop{\tau_{/} (Y, \real),m} & \prop{\tau_{/} (Y, \real),m} & $\bot$ & $\bot$
        \\
        \bottomrule
      \end{tabular*}
    \end{minipage}
    \vspace{5pt}
    \begin{minipage}{\linewidth}
     \scriptsize
     %\setlength\tabcolsep{0}
      \begin{tabular*}{\textwidth}{@{\extracolsep{\fill} } c|cccc} % chkTex  -2
        \toprule
%        $\bm{\tau_{a^b}(\tau_1, \tau_2)}$ & \integer & \real & \vect{X} & \field{X,n} & \prop{X,n}
        $\bm{\tau_{a^b}(\tau_1, \tau_2)}$ & \integer & \real & \vect{X} & \prop{X,n}
        \\
        \midrule
%        \integer & \integer & \real & --- & --- & ---
        \integer & \integer & \real & $\bot$ & $\bot$
        \\
%        \real & \real & \real & --- & --- & ---
        \real & \real & \real & $\bot$ & $\bot$
        \\
%        \vect{Y} & \vect{\tau_{a^b} (Y, I)} & \vect{\tau_{a^b} (Y, R)} & --- & --- & ---
        \vect{Y} & \vect{\tau_{a^b} (Y, I)} & \vect{\tau_{a^b} (Y, R)} & $\bot$ & $\bot$
        \\
      %  \field{Y,m} & \field{\tau_{a^b} (Y, \real),m} & \field{\tau_{a^b} (Y, \real),m} & --- & --- & ---
       % \\
%        \prop{Y,m} & \prop{\tau_{a^b} (Y, \real),m} & \prop{\tau_{a^b} (Y, \real),m} & --- & --- & ---
        \prop{Y,m} & \prop{\tau_{a^b} (Y, \real),m} & \prop{\tau_{a^b} (Y, \real),m} & $\bot$ & $\bot$
        \\
        \bottomrule
      \end{tabular*}%
    \end{minipage}%
    \caption{Type inference tables for binary operations $\otimes\in\{+,-\}$,  $\otimes = *$, $\otimes = /$, and exponentiation $a^b$.}
    \label{tab:typesystem_binary_operation_exponentiation} % chkTex 24
  \end{figure}
  % -------------------------------------------------------------------------

  \paragraph{Type Errors} % (fold)
  \label{par:typing_errors}

    All expressions matching one of the rules presented above are
    \emph{well-formed}, and their type can be inferred by the system. However, it
    may occur that the user enters a faulty expression for which no type inference is
    possible, yielding a \emph{typing error}. In this case, PPME has to communicate
    the error to the developer and provide meaningful information on where the error
    is located.
    %
    To formalize this, we introduce an \emph{error type} $\mathbb{E}$ used as a
    result for non-well-formed expressions~\cite{Plotkin1981,Plotkin2004}.
    %
    There are different causes for typing errors, e.g., incompatible types or
    undefined behavior. For instance, the exponentiation of a scalar with a string is
    not a meaningful mathematical operation and should yield a typing error in the
    corresponding expression. Error detection is not limited to arithmetic
    expressions, but covers domain-specific concepts as well.
    Furthermore, errors might be propagated, invalidating the parenting expression. To
    support this in the type system, we add two extra rules \textsc{ErrUnary} and
    \textsc{ErrBin}. A typing error $\mathbb{E}$ occurs when type resolution fails,
    i.e., if $\tau_\ominus(\tau')$ and $\tau_\otimes(\tau_1, \tau_2)$ are undefined.
    %
  % paragraph typing_errors (end)

\subsection{Dimension Annotations} % (fold)
\label{sub:dimension_annotations}

  Adding the notion of measurement units to a programming language benefits software
  developers in many ways, especially in checking the physical consistency of equations. Verifying dimensional
  integrity prevents errors in expressions that may be hard to detect
  otherwise. The language and type system extension for dimension annotations hence adds an
  additional level of analysis to detect inconsistencies at compile-time.
  %
  Early work by \cite{Karr1978} presented a \enquote{units calculus}, a method
  to manage relationships and conversions of units, to be incorporated in programming
  languages. In \cite{Cmelik1988} and \cite{Umrigar1994} the authors
  extended the idea of measurement units to general \emph{dimensional analysis},
  covering dimensional classes of units, e.g., length or mass, meaning that
  quantities with the same dimension but different units differ only by a conversion factor.
  Dimensional analysis fits neatly into the concept of type inference in
  functional languages, establishing the base for units and dimensions in functional
  languages~\cite{Wand1991,Kennedy1994,Kennedy1997,Hayes1995}.
  %

%\paragraph{Dimension Declaration and Specification} % (fold)
%  \label{dimension_declaration_and_specification}
In PPME, we consider dimensions and units as additional annotations to types and expressions
that are processed by an extended type system, with $\mathcal{I}$ the set of
dimensions supported by this system.
%
%The developer defines the elementary dimensions, derived
%dimensions can be defined for readability.     %
Dimensions without specification, such as length $l$, mass $m$, or time $t$, are called
a \emph{fundamental}. We denote fundamental dimensions with $\check{\delta}$
and the set of fundamental dimensions as $\check{\mathcal{I}}\subseteq{\mathcal{I}}$. Additional
\emph{derived dimensions} $\delta$, such as acceleration or force, can be composed from others
by means of multiplication and exponentiation, e.g., for acceleration $a = l \cdot t^{-2}$.
While all derived dimensions can be composed from fundamental dimensions only, PPME also allows definitions from other derived dimensions to simplify notation. This is described by the following grammar:
%The dimension calculus in PPME works uniformly over fundamental, derived, and
%computed dimensions. Therefore, we introduce the notion of a \emph{dimension
%specification} $\delta \in \mathcal{I}$  of the form
%
  \[ \delta ::= \check{\delta} ~|~ \delta_1 \cdot \delta_2 ~|~ \delta^n \, , \]
%
where $\hat{\delta} \in \hat{\mathcal{I}}$, $n \in \mathbb{Z}$, and derived dimensions
$\delta_1$, $\delta_2$, and $\delta$.
%
% SK: NOTE: Above grammar is compact: \delta is used as nonterminal and
% element of the language. Alternatively, we could use
% \[ d::= \check{\delta} ~|~ d_1 \cdot d_2 ~|~ d^n\] where d is used as a distinguished
% nonterminal. Furthermore the grammar does not consider just reusing dimensions
% that were already defined so that terms, e.g., for acceleration may repeat.
%
To make dimensions comparable, they are represented
in \emph{base form}, i.e., as a combination of $k>{0}$ fundamental dimensions $\check{\delta}_i$ raised to some integer
exponent $n_i$ where each $\check{\delta}_i$ occurs at most once.
%
A base form of $\delta$ can be constructed by recursively replacing all derived dimensions
in $\delta$ by their declaration, and grouping all occurrences of the same fundamental dimension
$\check{\delta}_i$ in a single equivalent power representation $\check{\delta}_i^{n_i}$.
We denote the expansion and base form of $\delta$ by $\lceil \delta \rceil$ with
%
  \[ \lceil \delta \rceil := \{ \check{\delta}_1^{n_1}, \check{\delta}_2^{n_2}, \dots, \check{\delta}_k^{n_k} \} \, . \]
%
Based on this definition, two dimensions $\delta_1$ and $\delta_2$ \emph{match} if $\lceil \delta_1 \rceil
= \lceil \delta_2 \rceil$, denoted by $\delta_1 \equiv \delta_2$,.

  % paragraph dimension_declaration_and_specification (end)

 % \paragraph{Dimension Type Rules and Errors} % (fold)
%  \label{par:dimension_type_rules_and_errors}

    Dimensions can be easily integrated into the PPME type system by extending it
    with dimension-specific rules and retaining the original inference mechanism.
%    We utilize the type system engine for checking and infering dimensions. Thus, the
 %   formal type system presented in \ref{sec:type_rules} is extended with rules for
 %  the unit calculus. The type inference is deferred to the original type system.
%
Given a type $\tau$ and a dimension $\delta$, we denote the
\emph{annotated type} by $\hat{\tau} = [\tau; \delta]$. In particular, any type
$\tau$ can be annotated with the \emph{empty dimension} $\emptyset$ without
changing semantics by using $e : [\tau; \emptyset]$ instead of $e : \tau$. The annotation of
metadata to types or literals is denoted by curly braces, i.e., $\tau\{\delta\} :
[\tau; \delta]$, and $e\{\delta\} : [\tau;\delta]$ instead of $e : \tau$.
%
Moreover, for dimension inference, we use a notation similar to the
type inference table in Figure~\ref{tab:typesystem_binary_operation_exponentiation}.
For instance, $\delta =
\mathcal{I}_\otimes(\delta_1,\delta_2)$ denotes that $\delta$ is inferred from the
operand dimensions $\delta_1$ and $\delta_2$ and the operation $\otimes$.

% JC: Next as separate paragraph - (issue 13)
Finally, the original type rules shown in Figure~\ref{fig:type_rules} need to be adapted.
As this adaptation is mostly straightforward, we only show the most relevant rules in
Figure~\ref{fig:dimension_rules}.
%%%% SK: explanations of the rules can potentially be omitted
The rules for handling variable references
(\textsc{Var}) and variable declarations (\textsc{VarDecl} and \textsc{VarInit})
have been expanded with annotated dimensions.  Assignment expressions
(\textsc{Assign}) now take the annotated dimension into account.  The general
scheme for unary (\textsc{Unary}) and binary operations
(\textsc{BinOp}) is, likewise, extended for annotated types.
%
Besides type inference ($\tau_\ominus$ and $\tau_\otimes$), dimensions are inferred through
$\mathcal{I}_\ominus$ and $\mathcal{I}_\otimes$. The rule \textsc{ErrDim} exemplary
shows the additional potential for error detection introduced by dimensions: even if types match,
a dimension error is still detectable.

    %-- dimension inference rules ---------------------------------------------------
    \begin{figure}[t]
      \footnotesize
      %%
      \begin{center}
        %
         \textsc{Var}
        \begin{prooftree}[separation=1em]
          \Hypo{\Gamma(v) = [\tau; \delta]}
          \Infer1{\Gamma \vdash v : [\tau; \delta]}
        \end{prooftree}
        %
        \textsc{VarDecl}
        \begin{prooftree}[separation=1em]
          \Hypo{\phantom{\Gamma}}
          \Infer1{\Gamma \vdash \tau\{\delta\}\, x : \Gamma \cup\{ x =  [\tau; \delta]\}}
        \end{prooftree}
        %
        \textsc{VarInit}
        \begin{prooftree}[separation=1em]
          \Hypo{\Gamma \vdash e : [\tau'; \delta']}
          \Hypo{\tau' \leq \tau}
          \Hypo{\delta' \equiv \delta}
          \Infer3{\Gamma \vdash \tau\{\delta\}\, x = e: \Gamma \cup\{ x =  [\tau; \delta]\}}
        \end{prooftree}
      \end{center}
      %
      \begin{center}
      %
        \textsc{ASSIGN}
        \begin{prooftree}[separation=1em]
          \Hypo{\Gamma \vdash x : [\tau; \delta]}
          \Hypo{\Gamma \vdash e : [\tau'; \delta']}
          \Hypo{\tau' \leq \tau}
          \Hypo{\delta' \equiv \delta}
          \Infer4{\Gamma \vdash x = e : [\tau; \delta]}
        \end{prooftree}
      %
        \textsc{Unary}
        \begin{prooftree}[separation=1em]
          \Hypo{\Gamma \vdash e : [\tau; \delta]}
          \Hypo{\tau_\ominus(\tau) \neq \bot}
          \Hypo{\mathcal{I}_\ominus(\delta) \neq \bot}
          \Infer3{\Gamma \vdash \ominus\,e : [\tau_\ominus(\tau); \mathcal{I}_\ominus(\delta)]}
        \end{prooftree}
        \end{center}
        %
        \begin{center}
        \textsc{BinOp}
        \begin{prooftree}[separation=1em]
          \Hypo{\Gamma \vdash e_1 : [\tau_1; \delta_1]}
          \Hypo{\Gamma \vdash e_2 : [\tau_2; \delta_2]}
          \Hypo{\tau_\otimes(\tau_1,\tau_2) \neq \bot}
          \Hypo{\mathcal{I}_\otimes(\delta_1,\delta_2) \neq \bot}
          \Infer4{\Gamma \vdash e_1 \otimes e_2 : [\tau_\otimes(\tau_1, \tau_2); \mathcal{I}_\otimes(\delta_1, \delta_2)]}
        \end{prooftree}
      \end{center}
      %
      \begin{center}
        \textsc{ErrDim}
        \begin{prooftree}[separation=1em]
          \Hypo{\Gamma \vdash e_1 : [\tau_1; \delta_1]}
          \Hypo{\Gamma \vdash e_2 : [\tau_2; \delta_2]}
          \Hypo{\tau_\otimes(\tau_1,\tau_2) \neq \bot} % we give preference to type errors ...
          \Hypo{\mathcal{I}_\otimes(\delta_1, \delta_2) = \bot}
          \Infer4{\Gamma \vdash e_1 \otimes e_2 : \mathbb{E}}
        \end{prooftree}
      \end{center}
      %
      \caption{Type rules for dimension-annotated expressions in PPME.}
      \label{fig:dimension_rules}
    \end{figure}
    %--------------------------------------------------------------------------------

     %
    \begin{figure}
      \centering
      \ssmall
      \begin{prooftree}[separation=1em]
        \Hypo{\color{black}\Gamma \vdash \arrowOp{p}{v} : [\real, v]}
        \Hypo{\Gamma \vdash 0.5 : [\real, \emptyset]}
        \Hypo{\Gamma \vdash \arrowOp{p}{a} : [\real, a]}
        \Hypo{\Gamma \vdash \arrowOp{p}{F} : [\real, m \cdot a]}
        \Hypo{\Gamma \vdash \mathit{mass} : [\real, m]}
        \Infer2[(1)]{\Gamma \vdash \arrowOp{p}{F} / \mathit{mass} : [\real, a]}
        \Infer2[(2)]{\Gamma \vdash \arrowOp{p}{a} + \arrowOp{p}{F} / \mathit{mass} : [\real, a]}
        \Infer2[(3)]{\Gamma \vdash 0.5 * (\arrowOp{p}{a} + \arrowOp{p}{F} / \mathit{mass}) : [\real, a]}
        \Hypo{\Gamma \vdash {\mathit{delta}\_t}^2 : [\real, t^2]}
        \Infer2[(4)]{\Gamma \vdash 0.5 * (\arrowOp{p}{a} + \arrowOp{p}{F} / \mathit{mass}) * {\mathit{delta}\_t}^2: [\real, a \cdot t^2]}
        \Alter{\color{black}}
        \Infer2[(E)]{\Gamma \vdash \arrowOp{p}{v} + 0.5 * (\arrowOp{p}{a} + \arrowOp{p}{F} / \mathit{mass}) * {\mathit{delta}\_t}^2 : \mathbb{E}}
        \Alter{\color{red!90!black}}
      \end{prooftree}
      %
      \begin{tcolorbox}[enhanced,colback=white,left=0pt,right=0pt,top=2pt,bottom=2pt,boxsep=0pt,boxrule=0pt,toprule=1pt,colframe=white!60!black,rightrule=1pt,arc=0pt,outer arc=0pt,leftrule=1pt,bottomrule=1pt,width=.95\textwidth,after skip=0pt,before skip=2pt]
        \begin{center}
          $(1)\, \tau_{/}(\real,\real) = \real, \mathcal{I}_{/}(m \cdot a, m) = a$
          \qquad
          $(2)\, \tau_{+}(\real,\real) = \real, \mathcal{I}_{+}(a, a) = a$
         \qquad
          $(3)\, \tau_{*}(\real,\real) = \real, \mathcal{I}_{*}(\emptyset, a) = a$
          \\
          $(4)\, \tau_{*}(\real,\real) = \real, \mathcal{I}_{*}(a, t^2) = a \cdot t^2$
          \qquad
          ${\color{red!90!black}(E)}\, \tau_{+}(\real,\real) = \real, {\color{red!90!black}\mathcal{I}_{+}(v, a \cdot t^2) = \bot}$
        \end{center}
      \end{tcolorbox}%
      \caption{
        Example deduction using the extended type system.
        \revii{The applied type inference rule $\tau_\otimes$ and dimension inference rule $\mathcal{I}_\otimes$ for
        respective steps (1) to (4), and (E) are shown in the box. The failing dimension inference rule is marked in red.}
      }
      \label{fig:type_deduction}
    \end{figure}
    %
    As an example for applying the type system, consider the following PPME expression
    that has been modified from the Lennard-Jones case study discussed in
    Section~\ref{sub:case_studies}:
    %
     \[ \arrowOp{p}{v} + 0.5 * (\arrowOp{p}{a} + \arrowOp{p}{F} / \mathit{mass}) * {\mathit{delta}\_t}^{\color{red!90!black}2} \, . \]
    %
    Here, $p$ refers to a particle whose properties $v$ (velocity) and $a$ (acceleration),
    and the force field $F$ are used together with the free variables $\mathit{mass}$ and $\mathit{delta}\_t$ (time)
    to compute an update in a larger simulation. We introduced a small error into the expression: $\mathit{delta}\_t$ has an
    exponent of $2$ instead of $1$. Since this does not have an impact on the overall type of the expression ($\mathit{\real}$),
    a conventional type system cannot detect this error. However, using dimensions, the problem becomes discoverable, as shown
    by the deduction depicted in Figure~\ref{fig:type_deduction}. In step $(1)$, the type and dimension of the subexpression
    $\arrowOp{p}{F} / \mathit{mass}$ is deduced from its compartments ($[\real, a]$).
    Step $(2)$ deduces the type of the enclosing addition \revii{of $\arrowOp{p}{a}$ and $\arrowOp{p}{F}/mass$}
    (again $[\real, a]$).
    In step $(3)$, the type remains the same because of \revii{multiplication with the constant 0.5}.
    Step $(4)$ computes the type of the multiplication with ${\mathit{delta}\_t}^2$ as $[\real, a \cdot t^2]$. Finally, in step
    $(E)$, the type system discovers that the outermost sum is infeasible since  $[\real, v]$ and $[\real, a \cdot t^2]$ are incompatible,
    deducing error type $\mathbb{E}$. In contrast, if the expression would have been correct, the calculus would have
    derived $[\real, v]$ as the overall type.
     % paragraph dimension_type_rules_and_errors (end)

% subsection dimension_annotations (end)
