%%Moved into standalone because of strange
\begin{figure}[t]
\includegraphics{img/ppml-grayscott}%
\label{fig:grayscott-ppml}%
\caption{PPML program to numerically solve the 2D Gray-Scott reaction-diffusion system on distributed-memory computer systems.}%
\end{figure}

\section{The Parallel Particle Mesh Language PPML}
\label{sec:ppml}
The Parallel Particle-Mesh Language (PPML)~\cite{Awile:2013,Awile:2013a} provides domain-specific abstractions to ease the development of distributed-memory 
particle-mesh simulations with the PPM HPC library~\cite{Sbalzarini2006a,Sbalzarini:2010,Awile:2010a}. The language is smoothly embedded into Fortran2003---the
implementation language of PPM. The major advantage of relying on PPML over using \revii{the PPM library} directly is that complex library protocols and parallelization code are hidden from the user. Instead, PPML provides first-class concepts for particle programming such as \emph{particles},
\emph{neighbor lists} (with optimized implementations in PPM), particle properties like \emph{vector} and \emph{scalar fields}, and \emph{differential-operator
 definitions}. Furthermore, particle-specific foreach loops are supported, as well as loops over discrete time steps.
%
 For high-performance parallelization, PPML supports distributed memory with message passing based on MPI. Several macro commands
 are provided to help handle the MPI setup, create topologies (i.e., decomposing the domain and assign subdomains to processes), distribute particles
 over these topologies, and exchange data at subdomain boundaries (cf.~\cite{Sbalzarini2006a}).

\subsection{A Simple Application Example}
\label{sub:a_simple_application_example}
To illustrate how parallel simulations can be implemented in PPML, we discuss an example of a Gray-Scott reaction-diffusion system, taken from the
PPML paper \cite{Awile:2013}.
%
A Gray-Scott reaction-diffusion system describes \revii{the concentrations (in normalized dimensionless units)} of two chemicals $u$ and $v$ that react with each other
and diffuse~\cite{Gray:1983}. The process can be described by a system of two partial differential equations that define the evolution of \revii{the chemicals' concentrations}, $u$ and $v$, over time:
%
\begin{align}
	\label{eq:u}\frac{\partial{u}}{\partial{t}}& = {D_u}\Delta{u} - uv^2 + F(1 - u)\\
	\label{eq:v}\frac{\partial{v}}{\partial{t}}& = {D_v}\Delta{v} + uv^2 - (F + k)v \, . 
\end{align}
%
Equation~\ref{eq:u} describes the time derivative of $u$ as a sum of three terms: First is the \emph{diffusion term} ${D_u}\Delta{u}$, where $D_u$ is a predefined diffusion constant
and $\Delta{u}$ the Laplacian (divergence of the gradient) of $u$. Second is the \emph{reaction term} $- uv^2$ defining how much of $u$ is converted to $v$ by the reaction. The last term in Eq.~\ref{eq:u} is the \emph{replenishment term}, defining how much of fresh $u$ is added to keep the reaction alive,
depending on a constant \emph{feed rate} $F$.
%
\revii{Equation~\ref{eq:v}} describes the time derivative of $v$ also as a sum of reaction, diffusion and, instead of a replenishment term, a \emph{diminishment term}. $D_v$ is the constant diffusion rate of $v$ and $- (F + k)v$ defines how much of $v$ is taken out (consumed) from the system, depending on
$F$ and a \emph{removal rate} $k$.%\jc{Isn't this too much details?}

This continuous model can be solved numerically using particle methods and PPML. To do so, $u$ and $v$ are discretized as particle properties and particles
are distributed over the entire domain. Furthermore, the differential operators (i.e., the Laplacians) need to be discretized according to the used method. After
providing initial values of $u$ and $v$ at particles, an approximate solution can be computed for a series of time steps.

%\sk{Should we call it solver, simulation, simulator or ...?}
Figure~\ref{fig:grayscott-ppml} shows the corresponding PPML \emph{client} program as a multi-part listing that highlights the different ingredients of the program. The first part on the left-hand side
of the figure contains variable
and constant declarations, the boundary condition, as well as declarations of external arguments  allowing users to parametrize the simulation. The second part declares $u$
and $v$ as scalar fields \inline{U} and \inline{V} and discretizes them over particles. Furthermore, a topology is created to distribute the particles on a computer cluster.
In the third part, the initial values of \inline{U} and \inline{V} are set using a PPML \inline{foreach} loop that iterates over all particles in the domain, by default assigning \inline{U} a value
of $1$ and \inline{V} a value of $0$. However, within a radius of $\sqrt{0.1}$ around the center, a small random amount of $v$ is added to start the reaction.
%
The fourth part (on top of the right-hand side of Figure~\ref{fig:grayscott-ppml}) contains the definition and discretization of the Laplace operator and initializes a particle neighbor list
with a specific \inline{cutoff}. \revii{The cutoff (i.e., the range of the particle--particle interactions) is set such that each particle interacts with all neighboring particles that are closer than four times the} average inter-particle distance. The remaining two portions of the figure specify the \inline{timeloop}, which
sequentially loops over the specified range of time steps, in each step evolving the solution by calling the PPM solver with the specified right-hand side, updating the
particle properties, exchanging data at inter-process boundaries, and printing the intermediate results to the file system. The right-hand side specification contains the
reaction-diffusion equations to be solved with an explicit invocation of the discretized Laplacian over both fields yielding respective vectors of intermediate results. Another PPML particle
\inline{foreach} loop computes the contributions of each individual particle using \LaTeX-like formula expressions, where underscores access individual particles.%\jc{Can you put numbers for the ``parts'' in the fig? and probably use code lines in the text?}
%
{\begin{figure}
\centering
\begin{minipage}[c]{0.24\textwidth}%
\centering\includegraphics[scale=0.6]{img/gc_0.png}
\\\scriptsize $t=\emptyset$
\end{minipage}%
~
\begin{minipage}[c]{0.24\textwidth}%
\centering\includegraphics[scale=0.6]{img/gc_1.png}
\\\scriptsize $t=0$
\end{minipage}%
~
\begin{minipage}[c]{0.24\textwidth}%
\centering\includegraphics[scale=0.6]{img/gc_2.png}
\\\scriptsize $t_i>>t_0$
\end{minipage}%
~
\begin{minipage}[c]{0.24\textwidth}%
\centering\includegraphics[scale=0.6]{img/gc_3.png}
\\\scriptsize $t_j>>t_i$
\end{minipage}%
\caption{Some intermediate results produced by the PPML Gray-Scott program.}%
\label{fig:grayscott-ppml-sim}%
\end{figure}}
%
Figure~\revii{\ref{fig:grayscott-ppml-sim}} shows some intermediate results over a small domain at different time steps that have been produced by this PPML program, choosing $k=0.051$, $F=0.015$, $D_u = 2\cdot 10^{-5}$, and $D_v = 10^{-5}$. For these parameters, the Gray-Scott system forms spatial patterns that are hypothesized since Alan Turing to be the chemical basis of biological growth and morphogenesis \cite{Turing:1952}.

\subsection{Advantages over Conventional Programming}
The program shown in Figure~\ref{fig:grayscott-ppml} nicely demonstrates some of the major benefits of DSLs in scientific HPC. Most of the boilerplate code
for instantiating PPM and managing parallelism with MPI is hidden from the developer. It is automatically generated by the PPML source-to-source compiler, emitting a plain Fortran
program, which is then compiled and linked with the PPM library by a standard Fortran compiler. The size ratio of the PPML source and the generated Fortran program
is 85:668, which means that the developer is freed from the burden of writing an extra 583 lines of boilerplate code.

The improved program readability is a further advantage of PPML over writing a plain Fortran program. Thanks to built-in domain-specific concepts and other specialized constructs, such as
particle loops and underscore accessors, the program is more declarative and thus \revii{more} readable, so that other domain experts can easily understand \revii{it}.
%
Finally, PPML was designed as an extensible \revii{language, apparently embedded into Fortran as a host language}. This way, it circumvents one of the major 
obstacles of using closed, stand-alone DSLs, namely a lack of expressiveness that may prevent facets of a problem to be described using the abstractions at hand. If a problem cannot be described properly using PPML, developers \revii{can always use} plain Fortran (e.g., lines 28, 29, and 31) or they may define additional PPML macros.
%
\revii{However, since PPML lacks a well-defined interface between the DSL and its host language, it is difficult to properly analyze the code and derive  context information from it. This lack of context largely prevents automatic compile-time code optimization in PPML. 
Such optimizations are easier with non-embedded DSLs, where language interfaces need not to be considered.}
%JC: Here we say that embedding is good in case of lack of expressiveness. What is then our argument for a non-
%embedded one? Are we sure there we do not leave unsupported ``facets''?
%SK: Yes, embedding is good if it is done in the right way and does not destroy the benefits of the DSL.

\subsection{Limitations in the Current PPML Design}
The current design and implementation of PPML has some limitations that hamper code optimization and debugging. The most important limitation is that the language is
not based on a formal domain model, which would enable reasoning about PPML programs to automatically check consistency, e.g., using a formal type system. Moreover,
the language syntax is underspecified. Similar to an island grammar~\cite{moonen_generating_2001}, only some parts of the language are modeled explicitly,  while others remain undefined.
%
Consider Figure~\ref{fig:grayscott-ppml} again. Parts of the program that are recognized by the PPML \revii{source-to-source} compiler are highlighted in either gray (macro calls including list of arguments)
or blue (first-class language constructs). These are the structural ``islands'' in the sense of an island grammar, while the non-highlighted parts are ``water'', i.e., parts of the program that are treated as a list of
characters \revii{that do not provide any additional information to the PPML compiler}.  
%
This \revii{fragmentary view on the code} allows for only shallow analyses of input programs \revii{during the preprocessing phase}, leaving most syntax and type errors undetected \revii{so that these are inherited by the generated program}. 
\revii{If such a program is then fed into a Fortran compiler to produce an executable,
the compiler will detect these issues and associate them with the preprocessed code. However, the developer has neither seen nor written this automatically generated Fortran code and can therefore not trace back the errors to his PPML program. Debugging PPML programs is therefore unpractical.} 
%
Even worse, some problems manifest only during or after execution by causing unintended
results, e.g., through an unsuitable argument or wrong arrangement of calls.

By leveraging domain knowledge, one can define
a complete domain model for the language implementation \revii{so that syntactic elements and semantic relations can be identified and used in a compiler.  
This way, syntactic problems and problems related to the language semantics can be detected early when processing DSL code (e.g., differential operators that are not used in an equation or have the wrong type of operand).}
This further provides the \revii{groundwork} for improving user experience by adding features known from integrated development environments (IDEs) (e.g., syntax highlighting and code completion) and from
compilers (e.g., optimizations such as tiling, program variants, or expression rewrites that only become possible through the additional information). \revii{This is enabled here by formulating a domain metamodel and a formal type system for the application domain of particle methods.}
%
% JCM: Again: a bit against these kinds of sentences. If I jump to the next section as a reader, because that's the one I want to read, I wouldn't get to read this sentence ;-)
%In the following sections, we show how we achieved these goals in PPME, the successor of PPML, using language-workbench technology.
% SK: I think this is a matter of style. I normally write these sentences to somehow glue sections together. But
% I also do not have a problem leaving them out if this is done consistently.
