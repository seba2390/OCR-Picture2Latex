\section{Conclusions}
\label{sec:conclusions}
We have presented PPME, an adaptable and extensible programming environment environment with a domain-specific language for particle-mesh methods.
It aims to simplify the development of scientific simulations through domain-specific abstractions and automatic generation of client code that links with the PPM library.
Leveraging the language workbench MPS, we earned features that are typical for 
modern development environments (e.g., syntax highlighting, automatic code completion, etc.) and
also features that are due to the methodology of projectional editing (e.g., mathematical 
notation). Furthermore, MPS provided us with a type-system language and a powerful
concept of arranging our environment in a modular way, which also is one of the key enablers 
for extensible language design and implementation, one of the major goals of PPME.

We demonstrated PPME's capabilities in that respect
in two ways: First, we developed a dimensional calculus on top of the original type system,
including an extension for checking and declaring dimensions, or even measurement units.
Errors discovered by the type system and the dimensional analysis are instantaneously reported to the user at design time. 
Second, we added support for automatic accuracy improvements of floating-point
expressions by adopting Herbie as an external tool and integrating additional 
value-range specifications into the language. Since both extensions are designed  
as independent plug-in solutions, they do not interfere with the base language and
the framework can easily be adapted to other cases, and developers are free to use 
the extensions only if desired.

Despite the obvious advantages of PPME, there are some obstacles that derive from MPS' basic principles of projectional
editing and modular language specification. 
Due to the complexity of MPS, it is not easy for scientific programmers to 
%MPS has a steep learning curve. The amount
%different language aspects and specification languages easily overwhelms new developers, 
%frequently similar concepts behave differently in different languages. Hence, if scientific 
%programmers intend to 
develop own extensions for PPME (e.g., for loading data from
a specific type of file). They have to become familiar with the concepts of MPS, which re-iterates 
the problem of the knowledge gap in scientific programming. PPME therefore allows the user to include custom Fortran code as inline blocks. While strictly speaking this is a design breach in a non-embedded DSL, it offers a pragmatic solution. Other issues with MPS come from 
projectional editing itself, which leaves less freedom than text editing w.r.t.~writing
comments or incomplete intermediate code. However, after some training, developers normally
get used to the tool (cf.~\cite{Voelter2013}). Another potential source of problems is that
programs are not stored as plain text, so that using version control outside of PPME/MPS is difficult.

In the future, we will extend PPME to support more 
particle and mesh abstractions, including inter-particle {\em connections}, {\em neighbor lists}, and {\em meshes} of different topology. We also want to expand PPME to better support 
high-level parallelization constructs and analyses to further improve code generation and 
runtime scalability by leveraging the domain knowledge for more intelligent mapping 
and distribution of computations onto underlying parallel hardware.
Finally, we will improve PPME's code generation process by adding another layer of abstraction
to better integrate the target language and make the backend exchangeable. This way, we 
will be able to support the successor of the PPM library, OpenFPM, which is currently developed in C++.


