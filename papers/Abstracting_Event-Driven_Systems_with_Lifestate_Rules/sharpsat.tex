% Organization of the section
% 
%
%
%\paragraph{Overview.}
% High level comment on the learning algorithm: goal is to estimate
% the likelihood of a rule.
In contrast to the two-phase probabilistic automata approaches,
we propose an algorithm that directly learns a lifestate specification from the
set of signature traces $\abstraceset$ that is potentially easier to
interpret.
%The motivation is that probabilistic models are difficult to interpret.

% Short description of the algorithm:
The learning algorithm proceeds by computing a weight for each
possible rule in $\RuleSet$ using the traces in $\abstraceset$ and
then obtains a lifestate specification by selecting
the rules that meet a weight threshold.
%
The weight assigned to a rule is an average, among all the traces in
$\abstraceset$, of the fraction of the total executions that are
sound for that rule.

% Hidden states problem:
%   - Interesting states cannot be observed in the system
%   - we adopt a non-deterministic semantic to
Intuitively, the ideal settings to compute the weight is to
observe the sequence of signature states and transitions
(a \emph{signature path}).
%
The main difficulty we face is that the internal state of the
permitted messages (i.e., the signature state
$\enSigState[\absof{\trace}][\absof{\eventmap}][\absof{\callinmap}]$)
is not observable.
%
To address the problem, we propose an abstraction of
the signature paths, which we use in our learning algorithm.
%%%%

We assume no prior knowledge on the internal behavior of the
framework and define the most conservative abstraction via the \emph{non-deterministic 
transition relation} $\jstep[\nondet]{ \absof{\state} }{ \absof{\state}' }$ that, upon
invoking a \emph{permitted} enable or allow signature transition $\absof{\trans}$, can
\emph{non-deterministically} change the internal state of the system 
(i.e., permits or prohibits any other message) 
but keeps the semantics of disallow and disables as in Figure~\ref{fig:specification}.  
%Formally, we define \emph{non-deterministic transition relation}
%$\jstep[\nondet]{ \absof{\state} }{ \absof{\state}' }$ by weakening \textsc{Enabled}, \textsc{Allowed} of Figure~\ref{fig:specification} as follows:
%\( \enSigState[ (\enEvt{\absmsg})\absof{\trace}][\absof{\eventmap}][\absof{\callinmap}] \longrightarrow_{\nondet}  \enSigState[ \absof{\trace} ][ \absof{\eventmap'}][ \absof{\callinmap'} ]
%\) for $\absof{\eventmap'}\in\AlphabetCb$, $\absof{\callinmap'}\in\AlphabetCi$ if $\absmsg \in \absof{\eventmap}$, and
%\( \enSigState[ (\enCi{\absmsg})\absof{\trace}][\absof{\eventmap}][\absof{\callinmap}] \longrightarrow_{\nondet}  \enSigState[ \absof{\trace} ][ \absof{\eventmap'}][ \absof{\callinmap'} ]
%\) for $\absof{\eventmap'}\in\AlphabetCb$, $\absof{\callinmap'}\in\AlphabetCi$ if $\absmsg \in \absof{\callinmap}$.
This choice of abstraction may produce a large number
of spurious behaviors that could affect
the quality of rules we learn, but we make the following observations:
\begin{inparaenum}[(i)]%
\item the imprecision introduced by the spurious transition
may be reduced by observing a large number of traces;
\item with a further knowledge of the framework, we can
reduce the non-determinism (i.e. reducing the abstract paths),
hence improving the quality of the learned specification.
\end{inparaenum}
%
%
%% %
%% The non-deterministic semantic only assumes that:
%% %
%% \begin{inparaenum}[(i)]
%% \item the message $\initforce$ is initially enabled, it disables
%% itself and it cannot be enabled or disabled by other messages;
%% \item the invocation of a message cannot permit itself (a message must
%% be permitted to be executed).
%% \end{inparaenum}
%% %

The main challenge with this approach is that enumerating all abstract 
paths for a signature trace is intractable. To overcome this problem, 
we represent the set of possible abstract paths symbolically
encoded as a propositional logic formula, to leverage 
efficient model counting solvers.

\subparagraph{Learn Specifications by Counting Paths.}
% Non-deterministic transition relation
% Set of paths (sequence of states and transition)
% Soundness for paths
% Weight for trace, rule
% Weight for trace set and rule
% Final specification
%
Given a signature trace
$\abstrace\colon \absof{\trans}_1 \ldots \absof{\trans}_n$, let
$\AbsPaths{\abstrace}$ denotes the set of all the sequences of
states and transitions (\emph{paths}) under the non-deterministic
semantics.
%
%For each rule $\specEnable{\absforce}{\absmsg}$ (resp. 
%$\nspecArrow \specDisableOp, \specArrow \specAllowOp, \nspecArrow \specDisallowOp$),
For each rule kind $\specEnable{\absforce}{\absmsg}$
(resp. $\nspecArrow \specDisableOp, \specArrow \specAllowOp, \nspecArrow \specDisallowOp$),
we say that the rule is ``matched'' in a state of the path if, in that state,
the message $\absmsg$ is enabled (resp. disabled, allowed, disallowed)
and the abstract transition executes the message $\absforce$.

We want to count all the paths of a trace such that the ratio of the number of
states of the path that match the rule over the total number of times we seen
$\absforce$ in the trace is greater than a weight $w$.
%
For a signature trace $\abstrace$, we
call \(\AbsPathsRule{\abstrace}{\absrule}\) such set of paths.

%
%% \begin{definition}[$\weight$-Weighted Nondeterministic Soundness]\label{def:weighted-ndt-soundness}
%% %
%% A signature path 
%% \(
%% \abspath \colon 
%% { \enSigState[ \absof{\trans}_1 \ldots \absof{\trans}_n][\cdot][\cdot] } 
%% \longrightarrow_{\nondet}
%% \cdots
%% \longrightarrow_{\nondet}
%% { \enSigState[\cdot][\absof{\eventmap}_{n+1}][\absof{\callinmap}_{n+1}] }
%% \) is $\weight$-\emph{sound} with respect to a lifestate specification
%% $\absof{\directiveset}$ if
%% %
%% for each rule $\absrule\colon \absforce\dashrightarrow\absmsg \in \absrules$,
%% $k_{\absrule} \geq w \cdot n_i$,
%% %
%% where $n_i$ is the number of messages $\absforce$ in $\abstrace$, and $k_{\absrule}$ is the number of times there is a transition $i$
%% in $\abspath$ (i.e. \(
%% { \enSigState[ \absof{\trans}_i\ldots ][\absof{\eventmap}_i][\absof{\callinmap}_i] }
%% \longrightarrow_{\nondet}
%% { \enSigState[ \absof{\trans}_{i+1}\ldots ][\absof{\eventmap}_{i+1}][\absof{\callinmap}_{i+1}] }
%% \))
%% %
%% such that $\absof{\trans}_1 = \absforce$ and
%% $\absof{\eventmap}_i$ and $\absof{\callinmap}_i$ changes according to $\absrule$
%% %
%% (e.g., if $\absrule$ enables an event $\absmsg$, then $\absmsg \in \absof{\eventmap}_{i+1}$).
%% \end{definition}
%% \(\AbsPathsRule{\abstrace}{\absrule} \defeq \{\abspath \in \AbsPaths{\abstrace} \ |\  \abspath \text{ is } \) \(\weight \text{-sound wrt. } \absrule\}\).
%
Given a signature trace $\abstrace$ and a rule $\absrule$,
the \emph{frequency} of $\absrule$ in $\abstrace$ with weight
$\weight$, is given by:
\[
\TraceFreq{\weight}{\absrule}{\abstrace} \defeq
\frac{\Card{\AbsPathsRule{\abstrace}{\absrule}}}{\Card{\AbsPaths{\abstrace}}}\;.
\]
%
%% $\TraceFreq{\weight}{\absrule}{\abstrace}$ counts the number of paths
%% in $\abstrace$ that are $\weight$-sound with respect to
%% $\absrule$.
%
The notion can naturally be lifted to a set of signature traces
$\abstraceset$ by taking the geometric mean of the fractions of the
observed traces.
%\(
%\TraceFreq{\weight}{\absrule}{\abstraceset} \defeq
%\Big(\prod_{\abstrace \in \abstraceset}{\TraceFreq{\weight}{\absrule}{\abstrace}}\Big)^{\frac{1}{\Card{\abstraceset}}}
%\)

Let $\delta$ be a real constant. The final specification is
\(
\absof{\directiveset} \defeq \{\absrule\ |\ \TraceFreq{\weight}{\absrule}{\abstraceset} \ge \threshold \}
\).
The threshold $\delta$ is needed to select only the rules that, according to
the frequency value, more likely capture the framework behavior.

%%
%In the above presentation, a path does not distinguish the case when
%a transition labeled with $\absforce$ permits (resp. prohibits) a
%message, and the message is already permitted (resp. prohibited), from
%the case where the transition does not change the state of the system
%at all.
%%
%For example, in the the path
%\(
%\enSigState[\enkwEvt\absmsg_1][\{\absmsg_2\}][\cdot]
%\longrightarrow_{\nondet}
%\enSigState[\enkwCi\absmsg_2][\{\absmsg_2\}][\cdot]
%\)
%we may either conclude that $\absmsg_1$ enables $\absmsg_2$ or that
%$\absmsg_1$ does not have any effect on
%$\absof{\eventmap}$ and $\absof{\callinmap}$.
%%
%In the symbolic encoding we decided to distinguish among both cases,
%to consider the case where a message keeps to permit or prohibit
%another message.


%\paragraph{Symbolic encoding.}
The number of paths in the sets $\AbsPaths{\abstrace}$ and
$\AbsPathsRule{\abstrace}{\absrule}$ is exponential in the total
number of messages.
%
Thus, it is not feasible to explicitly enumerate them.
%
Our solution is to encode all the paths in
$\AbsPaths{\abstrace}$ as a propositional logic formula.
The intuition is that each (complete) model of this formula
represents a path in $\AbsPaths{\abstrace}$.
%
Hence, we cast the problem of counting the cardinality of
$\AbsPaths{\abstrace}$ to the problem of counting the number of
models of the Boolean formula, for which several
efficient tools exist (e.g.~\cite{sharpsattool}).
%
The encoding is an adaptation of Bounded Model Checking~\cite{bmc},
a technique that encodes all the paths of length $k$ of a transition
system.
%%SQUEEZE%% For lack of space, we report the encoding in \secref{sec:appendix-symb-enc}.



