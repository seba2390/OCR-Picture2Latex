\section{Interface Mapper}\label{s:interface}

% WHAT ABOUT PATH LENGTH??

The output of the interaction mining step is a table \diffspil representing subtree differences between pairs of queries in the query log.  We map this table into an interaction graph $G = (P_{log}, E)$  where each query is a vertex and each record is a directed edge $e = (p_i, p_j, l_e)$ that is labeled with a description of the interaction.  The graph is a multi-graph because each pair of queries can be connected by multiple transformations.  Our goal is to generate a set of interfaces $\mathbb{I}$ that can express the queries in this graph.  Doing so involves three challenges: 1) identifying candidate widgets for each edge in the graph, 2) extracting domain and template functions to instantiate those widgets, and 3) mapping subsets of the interaction graph to widgets in an interface. The remainder of this section describes how we tackle those problems.


\subsection{Preprocessing the Interaction Graph}
Recall that a widget $w = (t_\pi, \Omega_w, f_w)$ is instantiated with an interaction $t_\pi$, a domain $\Omega_w$, and a template function $f_w$ that maps elements in the domain to a subtree.  We now describe how to extract template functions and domains from \diffspil.  At a high level, we extract parameterized tree templates from the subtrees in the \diffspil table, and use the parameter values to construct the domains.  We will also use these reults to label the edges in the interaction graph.

\stitle{Template Functions: }  We use the subtrees in \diffspilns$.\tau_2$ to extract template functions.    To do so, we replace the $n$ primitive values in a subtree $\tau$ with $n$ parameters to create a parameterized subtree template $\tau^p$; the table $\mathbb{T} = (\tau^p, v_\mathbb{T})$ is modeled as its template $\tau^p$ along with its parameter values $v_\mathbb{T} = (v_\mathbb{T}^{i})_{i \in [1,n]}$.   We then group the trees by their templates, and for each group $g_{\tau^p}$, collect the parameter values for all trees in the group.  We then keep the indices $K \subseteq [1,n]$ of the parameters that have at least one change, and result in a per-group table $\mathbb{V}_{\tau^p} = \{(v_\tau^k | k \in K) | \tau \in g_{\tau^p} \}$.  This table represents the parameter values that vary across the same parameterized subtrees.

Each widget $w_i^\theta$ has a $k$-dimensional domain.  For instance a range slider has domain $(v_1, v_2) \in \mathbb{R}^2$.  A parameterized subtree can be mapped to a widget $w$ if there exists a bijection between attributes in its values in table $\mathbb{V}_{\tau^p}$ and dimensions in $w_i^\theta$'s domain, such that each binding is within $\Omega_\theta$.  If so, the template function $f_{w_i^\theta}$ is simply the inverse bijection from the widget's tuple state to the attributes in the values table that are then bound to the parameters in the template subtree.

\stitle{Labeled Edges: }  Each edge $e$ in the interaction graph represents a record $r$ in \diffspil.  We label the edge $l_e = (r.\pi, r.\tau_2^p)$ with its path $r.\pi$ and subtree template $r.\tau_2^p$.   We also annotate the edge with its parameter value $v_{r.\tau_2}$.   Finally, an edge could be mapped to multiple widgets---for instance, selecting from a set of options can be expressed by a dropdown and textbox---and we call these the edge's {\it candidate widgets} $W_e$.


\subsection{Widget Mapping}
The next step is to build a set of interfaces $\mathbb{I}$ that can express all the queries in the log.  To do so, we will first define the closure of an interface $I_{closure}$, and its cost $C_I$ in terms of the interaction graph, and show that the interface generation problem is NP-hard by a reduction from the {\it set cover} problem.   We then describe a graph contraction heuristic along with optimizations to speed up the process.  To simplify the description, we will first assume that each edge has a single candidate widget, each transformation is a scalar, and each \lang statement generates at most one edge between any pair of queries\footnote{\small{A \lang statement can generate an output table with multiple records, say due to multiple numbers changing, and each record corresponds to a transformation.}}.  We will then relax these restrictions.

An interface $I = (p^I_0, W^I)$ consists of an initial query $p^I$ and a set of widgets.  We define its closure as the set of reachable queries; a query $p_i$ is reachable by $I$ if there exists some path from $p^I_0$ to $p_i$ that consists of edges expressible by some widget in $W^I$.  An edge $e$ is expressible by a widget $w$ if its path and templated subtree are the same as the widget's.

The domain of widget $w \in W^I$ is defined as the union of the annotated values of the edges that it expresses in $I_{closure}$.   This domain is used to compute its cost $C_w(\Omega_w)$, and subsequently the cost of the set of interface $\mathbb{I}$.


\stitle{NP-Hardness: } We now sketch the reduction from set cover to the interface generation problem.
\begin{proof}
Given a universe of items $\mathbb{U} = \{u_1,\cdots,u_n\}$ and a set of $m$ subsets that covers $\mathbb{U}$, $\mathbb{S} = \{ S_i \subseteq \mathbb{U} | i \in [1, m]\}$, set cover identifies the {\it minimal} set of subsets $\mathbb{S}^* \subseteq \mathbb{S}$ such that $\mathbb{U} = \cup_{S \in \mathbb{S}^*} S$.

We can construct an interaction graph $G = (\mathbb{U}, E)$ where each subset $S_i$ forms a clique $\{ (u_i, u_j) | u_i, u_j \in S_i \} \subseteq E$, whose edges are labeled with the subset's id $l_e = S_i$.  The edges in $S_i$'s clique are expressible by a unique candidate widget $w_i$, and the cost of a widget is $0$ if its domain is empty, and $1$ otherwise.  Adding a widget $w_i$ to an interface adds all elements in $S_i$ into the closure, and the set of widgets in the resulting set of interfaces $\mathbb{I}$ forms the subset sum solution.
\end{proof}




\stitle{Simple Heuristic Solution: }  We present a greedy heuristic to solve the interface generation problem.  We initialize the solution $\mathbb{I}_0 = \{ I_i | i \in [1, |P_{log}|]\}$ by assigning an interface $I_i = (p_i, \{\})$ for each query $p_i \in P_{log}$.  We then greedily merge pairs of interfaces until the total cost of the interfaces does not further decrease.

A pair of interfaces $(I_i, I_j)$ are merge candidates if there exists zero or more edges that connect a query $p_i \in {I_i}_{closure}$ to a query $p_j \in {I_j}_{closure}$.  Let edge $e_{ij}$ be used to merge the interfaces.   The resulting merged interface $I_{ij} = (p^{I_i}_0, W^{I_{ij}})$ uses the initial query from $I_i$, and combines the widgets from both interfaces, along with the (single) candidate widget for the edge $e_{ij}$: $W^{I_{ij}} = W^{I_i} \cup W^{I_j} \cup W_{e_{ij}}$.   $W^{I_{ij}}$ can then be reduced by merging widgets that represent the same transformations: two widgets $w_a,w_b \in W^{I_{ij}}$ with the same paths and feature functions can be merged into a single widget $w_{ab}$ with domain $\Omega_{w_a} \cup \Omega_{w_b}$.


For each iteration $k$, we identify the pair of interfaces that, if merged, will most reduce the total cost:
\begin{align*}
(I_i^*, I_j^*) &= \argmax_{(I_i, I_j) \in \mathbb{I}_k\times\mathbb{I}_k} C_{I_i} + C_{I_j} - C_{I_{ji}}\\
\mathbb{I}_{k+1} &= (\mathbb{I}_k - \{I_i^*, I_j^*\}) \cup \{I_{ij}^*\}
\end{align*}


\begin{example}
Figure~\ref{fig:merging} illustrates an example merge. The top two interfaces are initialized with their respective queries.  The queries differ in the constant in the equality predicate and there is a corresponding edge between the two queries. The interfaces are merged by mapping the edge to a toggle widget that picks between $NY$ and $LA$.  Note that the cost function  for the toggle widget will be high if the domain does not have exactly two values; if there are more queries with different $city$ values in the predicate, then other widgets such as a dropdown will have a lower cost and be chosen.
\end{example}

\begin{figure}[thb]
  \centering
  \includegraphics[width=.9\columnwidth]{figures/merging.png}
  \caption{Merging two interfaces.}
  \label{fig:merging}
\end{figure}


\stitle{Multiple Candidate Widgets:}
In practice, a given edge $e$ can have multiple candidate widgets $W_e$.  Rather than binding an edge to a specific widget in the initial interface set, we propagate all candidates throughout the heuristic solution.  To do so, we need to define how two candidate widgets are merged, how their costs are estimated.  Once we have finished the interface merging process, we then select the lowest cost interfaces from each candidate set. %, and how to compute the change in costs between two interface sets.

Merging candidate sets $W_{e_1}$ and $W_{e_2}$ means computing the union of the two sets $W_{e_1,e_2} = W_{e_1} \cup W_{e_2}$ and performing the domain merging procedure described above. The cost of a candidate set $C_{W_e} = min(C_w | w \in W_e)$ is defined by the minimum cost widget in the set.

%  = [\ubar{C_{W_e}}, \bar{C_{W_e}}]$ is defined by the minimum $\ubar{C_{W_e}}$ and maximum $\bar{C_{W_e}}$ costs of the individual widgets $w \in W_e$.  We define the change in costs due to merging two widget sets as the maximum change in the costs: $To compute the change in costs due to merging two widget sets, we compute th  It is possible to propogate the minimum for $C_{W_{e}} = max(\{ C_w | w \in W_{e}\})$ }

\stitle{Multiple Edges:}
A given \diffspil table for queries $p_i, p_j$ can contain $n>1$ records, each representing an edge with a different path between the pair of queries in the graph.  However, in order to fully transform $p_i$ into $p_j$, we must apply the transformations for {\it all} the edges.   To account for this, we model these edges $e_1,\cdots,e_n$ as a single ``super-edge'' $e_{1\cdots n}$  whose candidate widget set is the cross product of each edge's candidate set $W_{e_{1\cdots n}} = \varprod_{i=0}^n W_{e_i}$.

\stitle{Collection-based Changes}
Most languages support expressions that represent collections; for instance the SQL \texttt{FROM} clause is a set of range variable definitions, and the \texttt{GROUPBY} clause is a list of grouping expressions. Yet, the model described in Section~\ref{sec:diff} does not account from interactions that manipulate sets.  For instance, the output of a \lang statement that looks for numerical differences over the program fragments \texttt{[1,2,3]} and \texttt{[1,4]} would output a table with the following $(\tau_1, \tau_2)$ pairs: $(2\rightarrow4), (3\rightarrow null)$.  Naively, each pair would be modeled as a separate widget. In many cases, it would be preferable to map the pairs to a multi-selection widget such as a checkbox list that can express collections.

To automatically translate such \diffspil tables into a single collection-based interaction, we use a procedure similar to extracting template functions.  We first collect the set of all subtrees in \diffspil: $\mathrm{T} = \cup_{r \in \diffspil} \{ r.\tau_1, r.\tau_2 \} $.  For each $\tau \in \mathrm{T}$, we look for the subtree $\phi_\tau$ rooted at its closest strict ancestor node that is annotated as a list node type. If no such subtree exists one or more subtrees, we stop.  Otherwise, we then replace $\tau$ in $\phi_\tau$ with a parameter variable to create a templated ancestor subtree $\phi^p_\tau$.  If all templated ancestors are identical, then that suggests that the subtrees are elements of a collection, and we map the entire \diffspil table to a single collection-interaction edge whose candidate widgets are collection-based widgets such as checkbox or multi-select.


\subsection{Generating Interfaces}
Once we have identified the optimal set of interfaces $\mathbb{I}^*$, we select the lowest cost widget from each of the candidate sets based on the final widget domains.  At this point it is possible to run a standard interface layout algorithm~\cite{sears1993layout}, and then render each interface as a tab in a web application.  We render the query output using the developer provided $exec()$ function.  In our implementation for SQL query logs, we position the widgets manually and we use a simple visualization generator similar to ShowMe~\cite{mackinlay2007show} or APT~\cite{mackinlay1986automating} if the number of attributes in the query output is small, and otherwise render a table.


% Let us formalize this cost. Consider a cover $\mathcal{C} = \{(p_i, p_j)\}$  Let $T^{\mathcal{C}}=\{t_\pi^1, \ldots, t_\pi^{|P|}\}$ describe the set of all the interactions it contains. From $T^{\mathcal{C}}$, we can build several interfaces $I^{\mathcal{C}}_i = (p^{\mathcal{C}}_i, W^{\mathcal{C}}_i)$. To do so, we assign any covered query to $p^{\mathcal{C}}_i$ and any set of widgets compatible with $P$'s transformations to $W^{\mathcal{C}}_i$. The cost of the cover $\mathcal{C}$ is the cost of the best possible interface~$I^{\mathcal{C}}_*$. We obtain it by testing every possible widget-interaction mapping and keeping the cheapest solution.

% While the minimum edge cover can be found in a polynomial time in a normal graph, our variant of the problem is NP-hard.
% \begin{proof}
% We can reduce from set cover optmization problem (known to be NP-hard) to widget maping . Let $U$ denote the universe and $S$ the collection of sets. We perform the reduction as follows. We create a query in the interaction graph for each elemement of $U$. Then we add an edge labelled $s$ for each pair of nodes that correspond to an element of $s \in S$. We create one widget for each set $s$, with a fixed complexity 1. Finding the minimal set of widgets that covers the graph is equivalent to finding the minimal set of sets that covers $U$.
% \end{proof}




