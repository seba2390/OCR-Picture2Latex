\section{Related Work}

% Nede to address:
% - PL synthesis to create edges between two programs.  Cite flashfill, potterswheel, etc
% - what else did I mention?

\stitle{User Interface generation:}
Jayapandian et al. automate form-based record search and creation interfaces by analyzing the content of the database~\cite{jayapandian2008automated}. In contrast, we use example queries to synthesize analysis interfaces. In future work, we plan to borrow these ideas and take data and query semantics into account. The UI literature offers a large body of work on model-based interface design~\cite{puerta1994model, vanderdonckt1994automatic, nichols2004improving}, which rely on the developer to provide high level specifications and focus on layout. The above works do not explicitly leverage query logs.

\stitle{Development Libraries:} Tools such as Sikuli~\cite{yeh2009sikuli} or Microsoft Access let non-technical users build their own interfaces. They improve upon lower-level libraries (e.g., Bootstrap) but still require programming and debugging. Similarly, reactive languages (e.g., d3.express~\cite{d3express}, Shiny~\cite{chang2015shiny}, EVE~\cite{eve}, etc) still require programming and are limited to value changes rather than structural program changes.

\stitle{Log Mining:} Historically query log mining has been used in the database literature to detect representative workloads for performance tuning~\cite{chaudhuri1998autoadmin,hellerstein2007architecture}. More recently, it has been used to support data exploration. QueRIE~\cite{eirinaki2014querie} and SnipSuggest~\cite{khoussainova2010snipsuggest} produce context-sensitive suggestions from existing queries at the string level. Query steering~\cite{dimitriadou2014explore} uses a Markov model to produce new statements. Log mining is also extremely common in web search~\cite{silvestri2009mining}, e.g., to augment search results~\cite{hearst2009search}, make suggestions~\cite{cai2016survey} or enable exploration~\cite{chirigati2016knowledge}. \sys exploits and summarizes the structural changes found in query logs into interactive interfaces.

\stitle{Visualization Recommendation:} Visualization recommendation tools such as Panoramic Data~\cite{zgraggen2014panoramicdata}, Zenvisage~\cite{siddiqui2016effortless} and Voyager~\cite{wongsuphasawat2016voyager} constitute a recent and complementary research direction. Those tools help recommend similar data to a given view, while \sys seeks to generate the exploration interface itself.

\stitle{Interface Redesign:}  Interface redesign includes responsive designs that adjust the presentation or selects alternative widgets based on the display size or modality~\cite{adaptive1993}. Similar interface redesign techniques have been used to reduce data entry errors in survey design~\cite{kuangusher}. Those techniques are complementary to ours, which focuses on identifying and selecting task-specific interactions.

\stitle{Programming Languages:} The motivations behind \sys{} are close to those of domain specific languages (DSLs)~\cite{hudak1997domain}, with the major difference that \sys{} targets the interaction domain. A subset of the DSL literature discusses how to build task-specific compilers~\cite{cleaveland1988building}; we will incorporate those ideas in future work.
A related domain of research is \emph{program synthesis}, which seeks to construct programs that satisfy a high level logical description. For instance, Potter's Wheel~\cite{raman2001potter} and Foofah~\cite{jin2017foofah} build data transformation programs based on input and output examples. We target a different problem---\sys{} analyzes query logs, not  input-output pairs.