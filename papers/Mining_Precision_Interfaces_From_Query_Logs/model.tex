\section{Modeling Interactions}\label{s:model}

\begin{table}[b]
	\small
	\centering
	\begin{tabular}{rl}
			\toprule
			\textbf{Symbol}  & \textbf{Description}   \\
			\midrule
			$I$, $I_{closure}$  & Interface, its closure (expressible queries) \\
			$p \in P_{log}$  & Query $p$ in  query log $P_{log}$\\
			$\pi$, $\tau$  & Path in an AST, a subtree \\
			$t_\pi$ & Interaction that replaces subtree rooted at $\pi$ \\
			$\theta$, $w$  & Widget type and widget \\
			$C_\theta(), C_w()$  & Cost functions for widget type and widget \\
			$\Omega_\theta$, $\Omega_w$  & Domain for widget type and widget \\
			$f_w$  & Template function for widget $w$\\
			$\alpha_i$  & Cost function weight \\
			$s$ & \lang statement \\
			\bottomrule
			\\
	\end{tabular}
	\label{t:symbols}
	\caption{Summary of notations.}
\end{table}

This section describes the formal model of query logs and interactions on which we built \sys{}. The key idea is to model interactions as tree transformations, which serve to bridge the structural differences that we mine from the query logs with the interface components that users directly manipulate.



\subsection{Modeling Queries}\label{s:model-progs}

We assume that the input query log $P_{log}$ can be modeled as a table \texttt{queries} that contains the query id $pid$, parsed query $p$, along with any relevant metadata about the queries (e.g., the user that executed the program, the timestamp, the analysis session, etc):
{\small\begin{center}
  \texttt{queries(pid, p, tstamp, user, ...);}
  \end{center}
}
In order to support a variety of programming languages, we rely on the language's grammar and parse structure rather than query semantics.

\begin{figure}[h]
\centering
\includegraphics[width=\columnwidth]{figures/asts}
\caption{\small Example ASTs for two SQL queries that differ in the second project clause (blue) and the constant in the equality predicate (red). }
\label{f:asts}
\end{figure}
We model a query $p$ as a canonicalized abstract syntax tree (AST) generated by a parser.  Figure~\ref{f:asts} shows two (simplified) examples of ASTs for two SQL queries.
We assume that each AST node consists of its node type, a set of attributes, and an ordered list of child nodes.  For instance the binary expression \texttt{cty = USA} is represented by the \texttt{BiExpr} node type, its attribute \texttt{op:=}, and two children for the left and right sub-expressions.  Its second child is a string literal \texttt{StrExpr} with value \texttt{USA}.

In addition, we assume the existence of a table that indicate how terminal nodes map to primitive data types (e.g., string literals map to \texttt{StrExpr}, integers map to \texttt{IntExpr}), as well as the node types that represent lists of sub-expressions (e.g., \texttt{Project} consists of a list of \texttt{ProjectClause} nodes).  Primitive data types are straightforward to identify as literal expressions in the language grammar.  Similarly, list nodes can either be identified by a language expert, or determined automatically by searching the language's grammar file for common idioms.  For instance, the SQLite grammar defines the list of output expressions \texttt{sel\_core} as a project clause (represented by the \texttt{sel\_result} non-terminal) followed by zero or more additional project clauses:
{\small
  \begin{verbatim}
  sel_core = (sel_result (whitespace comma sel_result)*)\end{verbatim}
}
Explicitly modeling list nodes lets \sys map multi-selection widgets, which can specify sets of values, to collection-based tree modifications that insert, reorder, or delete multiple AST subtrees.  For instance, a checkbox list of table attributes could be used to specify the list of attributes to return in the project clause.

%\ewu{Do we also assume that unordered lists are sorted?}
Finally, we assume that logical expressions are {\it canonicalized} into conjunctive normal form.  This allows us to model logical expressions as a list of lists (e.g., \texttt{AND}s of \texttt{OR}s) rather than a complex binary tree structure of \texttt{AND} and \texttt{OR} operators.  This reduces tree mis-alignment issues that can be caused when adding a logical expression to e.g., the \texttt{WHERE} clause of a query restructures the expression subtree (Figure~\ref{f:canonicalize}).

\begin{figure}[b]
\centering
\includegraphics[width=.9\columnwidth]{figures/canonicalize}
\caption{Examples of non/canonicalized versions of ASTs for a SQL \texttt{WHERE} clause with two and three predicates. Canonicalization flattens the tree.}
\label{f:canonicalize}
\end{figure}


Although this process must be done for each language (and dialect), it only needs to be setup once (e.g., by an admin).  In this paper, the authors have provided drivers to model SQL and SPARQL queries.

\subsection{Interactions as Query Differences}
\label{sec:diff}
Given a list of ASTs, we would like to identify all structural differences
between pairs of trees.  To do so, we use a fast ordered tree matching
algorithm~\cite{bille2005survey,thomas2001introduction} that preserves ancestor
and left-to-right sibling relationships when matching nodes between the two
trees. The algorithm first computes the preorder traversal of both trees. It
goes on to the next node if the current pair of nodes matches. When the algorithm
finds a pair of nodes that cannot be mapped, it uses backtracking to return to
the last pair of nodes that has already been mapped and tries to map them to
some other candidate.  The algorithm has $O(\Pi_{i\in\{1,2\}} (T_i \times
min(L_i,D_i)))$ complexity where $T_i,L_i,D_i$ are respectively the size,
number of leaves, and the tree depth of the $i^{th}$ tree.

We model all pairwise AST differences in a set of queries $P$ as a logical table of differences \difftablens$_P$ that contains the sub-tree differences as output by a tree-alignment algorithm.  Specifically, \difftablens$_P$ contains foreign key references $pid_1$, $pid_2$ to the queries $p_1$ and $p_2$, the unique path $\pi$ to the sub-tree differences, and the sub-trees $\tau_1$ and $\tau_2$ that differ.
{\small
  \begin{center}
    \texttt{diffs($did$, $pid_1$, $pid_2$, $\pi$, $\tau_1$, $\tau_2$)}
  \end{center}
}
Additions and deletions in the ASTs can be represented by setting $\tau_1$ or $\tau_2$ to \texttt{null}, respectively. Let \difftable be shorthand for \difftablens$_{P_{log}}$.
\begin{example}\label{e:asts}
The pair of ASTs in Figure~\ref{f:asts} differ in the project clause and the equality predicate.  These differences would be modeled as two records in \difftable:
\begin{center}\small
\hspace*{-.1in}
        \begin{tabular}{ccclll}
            \toprule
            $id$ & \textbf{$pid_1$}  & \textbf{$pid_2$}    & \textbf{$\pi$}& \textbf{$\tau_1$}& \textbf{$\tau_2$}\\
            \midrule
            0 & 0 & 1 & 0/1/0   & \texttt{ColExpr(sales)} & \texttt{ColExpr(costs)} \\
            1 & 0 & 1 & 2/0/0/1 & \texttt{StrExpr(USA)} & \texttt{StrExpr(EUR)} \\
            \bottomrule
            \\
        \end{tabular}

\end{center}
The paths specify the index of each child along the path.  For instance, the first row's path follows the root node to \texttt{PROJECT} (0/), to the second \texttt{ProjClause} (0/1/), to its only child (0/1/0).  The transformation is to replace the \texttt{sales} column expression with \texttt{costs}.  The second row replaces the string expression \texttt{USA} with the string \texttt{EUR}.
\end{example}
Note that \difftable is a logical representation used to mine for interactions.   Our experiments show it is too costly to fully materialize \difftable for all but the smallest query logs.  In addition, not all structural differences are meaningful for generating interfaces.  Section~\ref{s:pilang} introduces a simple filtering language to identify meaningful subsets of \difftable.


\stitle{Interactions: } Interactions are the abstraction that connects records in the \difftable, which represent the locations and examples of structural changes in queries, with interface components, which translate user interactions into query transformations.  To this end, we model an interaction $t$ as a tree transformation function:
\begin{definition}
An interaction $t$ maps an AST $p$ into another AST $p'$ by substituting the subtree rooted at $\pi$ by a new subtree $\tau$:
  $t_{\pi}(p, \tau) = p'$
\end{definition}
%& Q^{IN}_t \times \Pi_{\text{\texttt{(XPATH)}}} \times \mathrm{T} \to Q^{OUT}_t\\

\begin{example}
Continuing the example in Figure~\ref{f:asts}, the following interactions changes $p_1$'s project clause and then the equality predicate and outputs $p_2$:
$$p_2 = t_{2/0/0/1}(t_{0/1/0}(p_1, \texttt{ColExpr(costs)}), \texttt{StrExpr(EUR)}) $$
\end{example}


\stitle{Interaction Graph: } The table \difftable can be modeled as an {\it interaction graph}, where each query is a node, and a directed edge $p_i \xrightarrow{t_\pi, \tau} p_j$ is labeled with an interaction such that $p_j = t_\pi(p_i, \tau)$.  There can be multiple labeled edges between two nodes.  These two representations are interchangable, however the graph formulation is useful for generating interfaces in Section~\ref{s:interface}.

\subsection{Interfaces}

A given interactive interface $I = (p^I_0, W^I)$ represents the AST $p^I_0$ of an initial query  along with a set of interaction components $W^I$ such as buttons, sliders, selection, dragging, panning, and other manipulations that can be interactively expressed. In a slight abuse of terminology, we term these components {\it widgets}\footnote{\small Although we use the term widgets for simplicity, it also represents user manipulations such as panning that do not have a visual representation.}.  Each widget $w \in W$ incrementally transforms the current query $p^I_i$ into the next query $p^I_{i+1} = w(p^I_i)$, whose output is rendered in the interface. In effect, $I$ represents the set of queries expressible by applying all possible sequences of its widgets to its initial query $p^I_0$, which we term the closure $I_{closure}$ of the interface.  $exec()$ and $render()$ runs and renders the query AST.


We model a widget $w^\theta$ as an instance of a widget type $\theta$.  Consider the dropdowns in Figure~\ref{f:dummy}. A dropdown is a {\it type} of widget that renders a list of possible options that the user can select from, and its state stores the currently selected option; it is suitable for choosing from a small set of string options, and is more challenging to use when there are more than a dozen options.

 More generally, a widget type consists of a domain that restricts the allowable values $\Omega_\theta$, along with a generic cost function $C_\theta(\Omega) \in \mathbb{R}$ that quantifies how ``good'' the widget type is for a given domain $\Omega \subseteq \Omega_\theta$.  For instance, the general domain of a dropdown is the set of all possible strings, while for a range slider it is a pair of numbers $\{(v_{min}, v_{max}) \in \mathbb{R}^2 | v_{min} < v_{max}\}$.  Although these general domains are broadly defined, they are important for identifying candidate widgets that can express a given structural change.  We describe the cost function in the next subsection.

A widget $w^\theta = (t_{\pi}, \Omega_w, f_w)$ is an {\it instance} of a widget type $\theta$ that is instantiated with a specific domain $\Omega_w \subseteq \Omega_\theta$, as well as specifications of how the state of the widget should be used to modify a program.  The latter is specified by an interaction $t_{\pi}$ along with a {\it template function} $f_w(o) = \tau$ that maps an element $o \in \Omega_w$ to a subtree $\tau$ that can be passed as an argument to the interaction. Let $o_{w} \in \Omega_w$ be the current state of the widget; then applying the widget to the current query is equivalent to:
$$w(p) = t_{\pi}(p, f_w(o_w))$$

\begin{example}
Consider the interface in Figure~\ref{f:dummy}: it contains three dropdown widgets and its current query is the following SQL query whose output is rendered as a line chart: {\small\begin{center}
\texttt{SELECT date as x, sales as y FROM sales WHERE cty = 'US'}
\end{center}} The top \texttt{Column X} widget $w_{top}$ uses the selected value to modify the column expression \texttt{date} in the first projection clause; its domain is the set of attribute names in the table $\Omega_{w_{top}} = \{date, sales, \cdots\}$, its function $f(o) = ColExpr(o)$ returns a column expression populated with the specified attribute name, and its interaction replaces the subtree rooted at the first project clause with the output of $f(o_{w_{top}})$. Similarly, the middle widget sets the column expression of the second project clause, while the bottom widget modifies the string literal in the equality expression of the \texttt{WHERE} clause.
\end{example}
Our definition of widgets simply specifies a domain and widget state, and is not bound any specific form element.  This allows \sys to be easily extended to new interaction components or even different modalities such as voice or touch gestures.

% \ewu{At some point, we should observe that the natural restrictions on widgets provides hints about what types of changes are even worth detecting, independent of \lang, since some changes are not really expressible}.

\stitle{Invalid Queries: }  Since \sys operates at the syntactic level, certain combinations of AST transformations might lead to non-executable queries.  Although this is unlikely for common transformations such as adding expression clauses or tuning parameters, it is still possible.  One solution is to speculatively parse and execute queries in the interface's closure, and visually disallow interactions that lead to these ASTs.  If the space of queries is small, this can be a way to both verify and pre-compute results for performance purposes.    %  If the    \ewu{probably need to address invalid queries at some point.  Can say that we can always verify the queries syntactically and visually disallow any interactions that generate syntactically invalid queries.  In fact, the possibility of such invalid queries in the interface's closure can be done automatically.  It's harder to check for semantic correctness, could try executing the query and disallowing interactions that cause $exec()$ to fail.}

\stitle{Ranking Interfaces:}
It is clear that there are many possible interfaces that could be used to express the same query log.  For instance, given a query log $P_{log}$, an interface may generate $|P_{log}|$ buttons, where each button widget $w_i$ represents query $p_i \in P_{log}$ and shows its result when pressed.  However, if all of the queries were identical except for a numerical constant that represents a threshold, then a single numerical slider would succinctly express the same set of queries.   Thus it is desirable to define a scoring function in order to rank and select the ``best'' interfaces.

The literature on assessing interactive interfaces is continuously evolving and has found a variety of characteristics that affect interface usability.   The GOMS family of interface analysis techniques  assign each user operation a cost and measure interface efficiency based on the cost to complete higher level goals~\cite{john1996goms,card1983psychology}.  Similarly, the amount of visual clutter~\cite{rosenholtz2007measuring} or even number of pixels needed to render the interface~\cite{peytchev2006web,jones1999improving} can affect readability. To flexibly support this range of interface measurements, we allow developers to specify multiple cost functions for the widget types.  As introduced in the previous subsection, the cost function for a widget type $\theta$ is defined as:
 $$C_\theta(\Omega) = \sum^k_{i=1} \alpha_{i} \times C^i_\theta(\Omega)$$
\noindent where $C^i_\theta(\Omega) \in [0, 1]$ is the $i^{th}$ cost function defined for the widget type by the developer.  We assume that each widget type has $k$ cost functions, whose outputs are between $[0, 1]$---a button may return $1$ if its domain contains more than one element, and $0$ otherwise: $max(0, min(1, |\Omega|-1))$.  Similarly, a checkbox list may increase linearly with the size of the domain: $min(1, \frac{|\Omega|}{12})$.  The $\alpha_{i}$ terms are user-controllable knobs to specify which cost functions matter more to the user.  For instance, in a setting with small screen resolution, the user may prioritize simpler interfaces that are easier to use than more complex and efficient interfaces that would necessitate scrolling or repeatedly zooming in~\cite{peytchev2006web}.

For an interface $I$, we estimate the interface complexity as weighed sum of its widgets:
$$C_I = \sum_{w^\theta \in W}  C_\theta(\Omega_w)$$


\stitle{Multiple Interfaces: }
In many cases, having \emph{one} interface that expresses all the queries in the log is not the optimal solution. Suppose for instance that our log contains only a pair of queries $\{p_0, p_1\}$ and that those queries are very different from each other. One approach is to create an interface $I=(p_0, \{w\})$ where $w$ is a widget that expresses the complex transformation between $p_0$ and $p_1$. Another approach is to create two interfaces $I_0=(p_0, \{\})$ and $I_0=(p_1, \{\})$, such that each interface expresses exactly one program.
To model this flexibility, we support sets of interfaces $\mathbb{I}$. We estimate that the complexity $C_\mathbb{I}$ as the sum of its interfaces:$C_\mathbb{I} = \sum_{I \in \mathbb{I}} (c_0 + C_I)$, where $c_0 \in [0, 1]$ is a constant cost for each new interface.   Similarly, we define the \emph{closure} $\mathbb{I}_{closure}$ as the union of its interface's closures: $\mathbb{I}_{closure} = \bigcup_{I \in \mathbb{I}}  I_{closure}$.
% Second, we intrduce the \emph{init} widget. The \emph{init} widget is enabled by default for each interface. It desribes the fixed cost induced by adding a  new interface. Thus, it helps us model the trade-off between covering and splitting.


\subsection{Interface Generation Problem}\label{s:problem}
We can now define the main problem statement:
\begin{problem}[Interface Generation]
  Given a query log $P_{log}$, a threshold $\gamma$ for the percentage of the query log to cover, and the $\alpha_i$ weights for the cost functions, generate the optimal set of interfaces $\mathbb{I}^*$ such that:
  \begin{itemize}[topsep=-1mm, itemsep=0mm]
  \item $|\mathbb{I}^*_{closure} \cap P_{log}| \ge \gamma \times |P_{log}|$
  \item $C_{\mathbb{I}^*}$ is minimal
  \end{itemize}
\end{problem}

Our aim is to find a set the minimal interface which closure includes a given proportion $\gamma$ of the queries in the log.

\stitle{Solution Overview:} Our solution decomposes this problem in two steps.  The first is to efficiently mine the query log to identify meaningful structural changes that can be mapped to interactions; directly using the table \difftable can lead to overly complex and incoherent interfaces because it can contain both irrelevant differences as well as differences that syntactically appear similar but are semantically different.  To address this issue,  Section~\ref{s:pilang} introduces a domain specific language called \lang to filter \difftable.  An added benefit is that the filtering operations defined by \lang statements can be pushed into the query parsing and tree alignment steps of the system to improve the end-to-end runtime.

The second step is to map these changes to the appropriate widget types, and instantiate the widgets by generating each widget $w$'s domain $\Omega$, interaction $t_\pi$ and template function $f_w$.  To do so, Section~\ref{s:interface} describes how interface generation is modeled as a subset cover problem, and how to instantiate each widget from the changes output from the \lang statements.




% Clearly this problem is hard.  Need to identify the widgets that can express query log changes and choose those that minimize the cost of the interface.  Although it is possible to automatically find all possible structural changes, it is very slow and leads to overly complex interfaces whose interactions may not be semantically meaningful.  Thus, we allow developers to easily filter, rank and group query changes using a domain specific language called \lang.

%Assuming that the user has (perhaps manually) performed OLAP cube navigation that generates a sequence of queries $Q = \{q_0,\cdots,q_n\}$, the precision interfaces problem is to synthesize an interface where $P_0=q_i$, along with a set of interactions that can express these OLAP queries in $Q$


\iffalse
   \begin{problem*}
   Given a set of widget types $\{\Theta_m\}_{m \in 1..T}$ and a set of paths and parameters as described above, find a set of widgets $W = \{w_1, \ldots, w_N\}$ that solves:
   \begin{equation*}
   \begin{split}
   \text{Argmin}_{I} & \sum_{w \in I} \sum_{m \in 1..M_{\Theta_w}} \alpha_m \cdot C_m^w(\Omega_w)\\
   \text{s.t.~~}  &   \mathcal{C}(I) = Q^{LOG}
   \end{split}
   \end{equation*}
   \end{problem*}
\fi








