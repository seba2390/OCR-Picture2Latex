We have previously defined interactions as(I forgot). The interaction miner identifies incremental changes between every pair of queries$ (q_i,q_j)$ in the query log and constructs an edge between $q_i$ and $q_j$ in the interaction graph. The edge is labeled as $(p,\omega)$ using the definition of interaction, where p denotes where the queries are different and $\omega$ denotes how they are different. In this case, there will be an edge between every pair of queries. However, we do not wish to identify all kinds of incremental changes --- we are only interested in the interactions that can be eventually mapped to one or more widgets in the interface. Consider the following two pairs of queries:
\begin{verbatim}
Q1: SELECT * FROM users WHERE age BETWEEN 18 and 25
Q2: SELECT * FROM users WHERE age BETWEEN 40 and 50

Q3: SELECT  name   FROM planets
Q4: SELECT diapers FROM grocery
\end{verbatim}
There are both two changes between $(Q1,Q2)$ and $(Q3,Q4)$, but $(Q1,Q2)$ can be easily mapped to a slider that changes the value for age, while it is hard to think about a widget to map $(Q3,Q4)$ to. As the scope of interactions is very large and  different users might be interested in different interactions,  automatically mining the useful interaction patterns seems infeasible. Let P be a function such that $$P(q,q') = (\omega,p) \cup \{\text{NULL}\}.$$
This function returns NULL if the interaction between $(q,q')$ does not map to any widget, and returns $(\omega,p)$ if it does. If we can make it easy for the user to give us this function, then we could do a pairwise comparison and generate the interaction graph using these rules.
Therefore, we have designed the language PI-Lang for users to express the increment changes between queries that they are interested in.\\\\
We present PI-Lang in this section, a domain specific language for expressing structural differences between the AST representation of pairs of queries. The reason PI-Lang works with low level AST transformation instead of string level differences is that analysts have their own preferred language (e.g., SQL, Python). Since these languages have different syntax, A PI-Lang program consists of three clauses, the \emph{from} clause, the \emph{where} clause and the \emph{match} clause. We now describe each clause in further detail.
\subsubsection{From Clause}
Recall that the goal of PI-Lang programs is to express structural differences between AST trees, the \emph{from} clause specifies where the difference happens. It consists of several X-Path like expressions, enabling users to define variables and to bind them to nodes in the AST trees. Two \emph{from} clause examples are given below:\\\\
\textbf{1. WhereClause///ValueExpression as a;} defines a variable a and assign it the value of all nodes with node type “value expression” that has a ancestor with node type “WhereClause”. Nodes whose node type is not “ValueExpression” or do not have an ancestor with node type “WhereClause” are ignored. \\\\
\textbf{2. ProjectClauses as b;} defines a variable b. The program traverses through the entire AST tree and assigns all nodes with the node type “ProjectClauses” to variable b.\\


\noindent As shown in the above examples, each path expression can be mapped to several nodes in the AST trees. A///B specifies that A is an ancestor of B, A//B and A/B specifies that A is the parent or a sibling of B respectively. Parentheses can be used to specify precedence (\texttt{(A//B)/C}).  Finally, the nodes that match the path expression can be bound to a named variable using the \texttt{<pathexpr> AS <variable name>} expression. The expressive power of the from clause statements are equivalent to the full XPath language, as the allowed operations(i.e. parent/ancestor/sibling/parentheses) are exactly the name, and users are able to point to any node in the tree using these operations.\\\\
Every path expression or from clause statement correspond to two sets of nodes, one for each AST tree. Consider the pair of query (Q1,Q2). The first set of nodes are all nodes in the AST representation of Q1 that matches the path expression, while the second set of nodes are all nodes in the AST representation of Q2 that matches the same path expression. Our program then returns a table with the following schema.
\begin{verbatim}
Table: (PI-Lang, Variable_name, Values_old, Values_new, Paths_old, Paths_new)
\end{verbatim}
The first two columns of this table will be explained in later sections. In all cases, the Path variable contains the path of the variable in the AST tree. It is a list of pairs [...[node type, index]...] where node type is the type of node encountered and index is its index in the traversal. For instance, consider the following PI-Lang statement and the two queries:
\begin{verbatim}
SELECT a, b, d from A
SELECT a, b FROM A
\end{verbatim}
Then, the table will be:
\begin{center}
    \begin{tabular}{| l | l | l | l | l |}
    \hline
    ...& ValuesOld & ValuesNew& PathsOld & PathsNew \\ \hline
    .. & a & a& [...,[result column, 0]] &[...,[result column, 0]] \\
    ... & b & b& [...,[result column, 1]] &[...,[result column, 1]] \\
    ... & d & null& [...,[result column, 2]] &null \\
    \hline
    \end{tabular}
\end{center}
\subsubsection{Where Clause}
The \emph{where} clause is a boolean expression over the variables defined in the \emph{from} clause that specifies how they may differ. The statement generates a match when the expression evaluates to true. The suffixes @new and @old can be appended to a range variable to reference the corresponding nodes in two AST trees respectively. Finally, we support convenience expressions to help perform set comparisons between the two versions of the path expressions. For instance, T@old subset T@new specifies that new nodes were inserted into T, whereas $|T| = 1$ checks that there is only one matching node. To better illustrate the syntax, a \emph{from} and \emph{where} clause example is given below:
\begin{verbatim}
FROM ProjectClauses as b;
WHERE b@old subset b@new;
\end{verbatim}
The incremental changes in the AST level we want to identify is: if the project clauses of query 1 is a subset of query 2 while everything else is the same. This difference can be later mapped to interactions and widgets, which will be explained in the next section. Besides the subset operations, other allowed operations are listed in the following tables:
The operations supported in our language is listed in the following tables:
\begin{table}[h]
\centering
\begin{tabular}{ |l|l|l| }
\hline
\multicolumn{3}{ |c| }{Supported Set Operations} \\
\hline
Syntax & Examples & Explanation \\ \hline
union& a union b & the union of two sets \\ \hline
intersect& a intersect b & the intersect of two sets \\ \hline
difference& a difference b & the difference of two sets \\ \hline
subset & a subset b&  returns true if $a \subseteq b$\\ \hline
equal & a equal b&  returns true if $a = b$\\ \hline
notequal & a notequal b&  returns true if $a \not= b$\\ \hline
$|$ $|$ & $|a|$&  number of elements in a \\ \hline
\end{tabular}
\caption{Supported Set Operations}
\end{table}
\begin{table}[h]
\centering
\begin{tabular}{ |l| }
\hline
\multicolumn{1}{ |c| }{Supported Arithmetic Operations} \\
\hline
+, -, *, /, $>$, $>=$, $<$, $<=$, $==$, $!=$, ...\\
\hline
\end{tabular}
\caption{Supported Arithmetic Operations}
\end{table}
\subsubsection{Match Clause}
Users label PI-Lang statements in the where clause. First of all, users give a name for the transformation described in the from clause and the where clause. Secondly, out of all variables defined in the from clause, users pick one variable for the table construction process described in section 1.1. Consider the following example:
\begin{verbatim}
SELECT a, b, d from A
SELECT a, b FROM A

FROM ProjectClauses as val
WHERE val@old != val@new
MATCH pc-diff(val)
\end{verbatim}
Then, the table will be:
\begin{center}
    \begin{tabular}{| l | l | l | l | l | l |}
    \hline
    PILang&VariableName& ValuesOld & ValuesNew& PathsOld & PathsNew \\ \hline
    pc-diff & val&... & ...& ... &... \\
    pc-diff & val&... & ...& ... &... \\
    pc-diff & val&... & ...& ... &... \\
    \hline
    \end{tabular}
\end{center}
This table, along with the name chosen for the transformation will be used by the widget selector.
\subsubsection{Examples}
The following statement identifies pairs of queries with different string literals in an equality expression within their \emph{where} clause. The \emph{from} clause matches all string literal nodes that are children of equality expressions in the filter clause. These nodes are bound to T. The WHERE clause checks that there is a single string literal that has changed (and implicitly that nothing else in the ASTs have changed). If there is a match, then we add an edge between the two input ASTs and label the edge change-where-equal.
\begin{verbatim}
FROM where//expr[op="="]//strliteral AS T
WHERE T@old not equal T@new AND |T| = 1
MATCH change-where-equal(T)
\end{verbatim}
The following PI-Lang program identifies pairs of queries that are only different in their project clauses. It matches the pair of query to project-subset when the project clauses of query 1 is a subset of query 2. The \emph{from} clause matches all projectclauses nodes that has a project node as its parent and binds them to the variable T. The \emph{where} clause checks if the subset operation, and the \emph{match} clause adds an edge between the two input ASTs with the label project-clause-add if the \emph{where} clause returns true.
\begin{verbatim}
FROM Project//ProjectClauses as T;
WHERE T@old subset T@new;
MATCH project-clause-add(T)
\end{verbatim}
\subsubsection{Syntactic Sugar}
The \emph{from} clause is able to express tree structures and select a set of nodes that comply to it. However, the path expressions in the \emph{from} clause fail to express quantitative filters on the nodes. For example, they fail to return only all value expressions that are greater than 2. These filters can be incorporated in the \emph{where} clause, but often leads to very complicated \emph{where} clause expressions. To simplify PI-Lang programs, we allow quantitative filters in the \emph{from} clause. When the path expressions in the \emph{from} clause are executed, two tables are created for each variable, one for each tree, and the name of these tables correspond to the defined variable name. For example, if the pair of tree we are comparing is the tree representation of (Q1,Q2), and our path statement is ``ProjectClause//TableExpression as tables", then two tables(i.e. table@old and table@new) will be constructed. To allow quantitative filters, we allow SQL statements to define new variables on top of the path expressions(e.g. SELECT top 1 from tables as id).

\subsection{Scopes and Contexts}
PI-Lang programs are capable of expressing tree level differences, and mapping specific differences to a set of predefined interactions. However, PI-Lang program fails to identify only incremental changes, and solely identifying these tree level changes are not enough to generate an interface. We first show why PI-Lang program fails to identify incremental changes and why the interface generator fails to generate an interface by only having the graph generated by the interaction miner. Next, we present the definition of scopes and contexts to solve these questions.\\\\
Consider these two pairs of queries and the following PI-Lang statement. Our goal is to identify pairs of queries that are only different in their project clauses but are exactly the same everywhere else. Therefore, only (Q1,Q2) satisfies this constraint, while (Q3,Q4) does not. However, since the project clauses of Q3 and Q4 are also different, the boolean expression in the where clause evaluates to true. As a result, an edge will be be added between Q3 and Q4, and will be labeled as project-clause-different.
\begin{verbatim}
Q1: SELECT a,c FROM t1 WHERE a < 0 AND a > -3
Q2: SELECT a,b FROM t1 WHERE a < 0 AND a > -3

Q3: SELECT    *    FROM planets WHERE name = "EARTH"
Q4: SELECT diapers FROM grocery WHERE price < 5

FROM Project//ProjectClauses as T;
WHERE T@old != T@new;
MATCH project-clause-different
\end{verbatim}

\subsubsection{Scopes}
In order to solve the first issue, we define scope as the subtree that is allowed to change. In the project-change example, the scope should be the ``project-clause" node, which represents only the subtree under ``project-clause'' nodes can change. If the change further satisfies the where clause, an edge will then be added between this pair of query. However, if the change under the ``project-clause'' nodes  satisfies the boolean expression in the where clause but there are other changes out of the scope, then the edge will not be added. Scopes can be defined by a ``+'' sign in the path expressions of the \emph{from} clause. ``ProjectClause'' and ``WhereClause'' are defined as the scope in the following two examples respectively.
\begin{verbatim}
Example 1: FROM Project//+ProjectClause as T;
Example 2: FROM +WhereClause//value as T;
\end{verbatim}
