\section{Introduction}
\label{sec:intro}

Data analysis is a fundamental driver of modern decision making, and interactive interfaces are a powerful way for users to express their analyses. A well-designed interface provides interaction components for the users to easily accomplish their tasks and hides the technical complexity of the underlying system.  For instance, the Google Finance stock trend visualization incorporates a time-range filter so that users from a broad audience can explore prices over time. The same interface would not satisfy market analysts who want to aggregate sales information and perform roll-ups and drill-downs; for them, a rich interface such as Tableau would be preferable.  In a more extreme scenario, a single text box that lets users type a full program would be effective for engineers who want---and have the technical skills---to write all possible programs. This leads to the following observation:
\textbf{an interactive interface describes a set of programs, and its effectiveness depends on whether this set matches the operations that the users want to express.}
% . To perform it, users need interfaces that are easy to use. For example, a programmer may use a query language, which has considerable expressive power but requires technical expertise. A marketing analyst may prefer a visual exploration tool such as Tableau, which is simpler to use but more restrictive. As the majority of users are non-technical, interactive analysis interfaces are essential. Yet, creating an interface that is appropriately designed for a task is a challenge, because it requires a detailed understanding of which abstractions are relevant for the users and which are not. An ideal interface, a \emph{precise} interface, lets users define \emph{exactly} the sequence of operations that they need to perform their task. It mirrors perfectly the universe of programs that are useful for the users.

Designing interfaces poses two challenges traditionally addressed by experts:
{\it specifying} of a universe of programs that is relevant for a given task, and {\it developing} an interactive interface that can express it.
For example, consider Tableau~\cite{stolte2002polaris}, a popular visual data exploration tool. Tableau's designers carefully identified a common, and valuable, set of analytical data operations (OLAP) and mapped those to widgets in an interactive interface. Thus, they designed shelves to select measures or dimensions, and contextual menus to pick aggregates. Users did not need to learn SQL, and could easily manipulate queries by clicking, dragging and dropping interface components. Although this process was hugely successful, the cost---years of research and development---is not available for every task.

We believe that there is opportunity to drastically reduce the costs of interface construction through {\it data-driven} approaches.
Given a {\it trace of programs}---perhaps automatically logged by data processing systems---we may infer an interactive interface that can express them.
Although imperfect, this process can be largely automated, enabling us to scale interface construction and serve a long tail of users for whom it may not be feasible to manually build custom interfaces.
Our long term vision is to generate tailored interfaces for every user and every task based on their past analyses.

% We argue that \textbf{interface creation does not need to fully rely on technical experts, and can instead be \emph{data-driven}}. If an interactive interface is a representation of a set of programs, then given a trace of programs generated during an analysis session, we could invert the process and infer an interactive interface. Because this process would be automatic, it could allow us to scale up interface design and serve a long tail of users that previously could not afford custom interfaces. And so, our vision is to build a tailored interface for every user and every task, by mining the programs that users have run for past analyses.

This paper is a first step towards this vision.  We propose {\it query logs} as the API for interactive interface generation because, increasingly, such logs are automatically collected by data processing systems by way of provenance capture subsystems~\cite{ground,scheidegger2008tackling}, as part of recovery and auditing mechanisms such as DBMS query logs~\cite{malviya2014rethinking}, or by user-facing applications such as Jupyter.
 Our discussions with several businesses have identified several compelling use cases for generating interfaces from those logs:


\stitle{Tailored dashboards:} An IOT startup (name anonymized) regularly performs tailored analyses for its customers. For simple cases, the engineers create custom front-ends with a dashboard builder. But the tool does not support complex statements (e.g., nested queries), and therefore the employees spend considerable time writing queries, including the CTO of the firm. For each case, they check out a text file that contains past queries, identify the statements that they need, customize them, copy-paste them and possibly update the document and check it in. A tool to build interfaces from queries would allow them to quickly set up expressive front-ends for each case and each customer.
 % At the firm, DBAs are often tasked with performing SQL-based analysis for end-users from other organizational units, because those users do not know how to write queries and interpret the schema of the database.  They expressed the desire to quickly build interfaces for the common queries and hand those interfaces directly to the end-users. However, they do not have the time to identify the relevant analyses and translate them into user interfaces; automating this process would be desirable.

\stitle{Auditing: } The employees of a large consulting firm perform financial audits by running previous programs (e.g., queries and macros) and performing what-if style analyses. In most cases, this task involves changing parameters, in order to test the robustness of financial indicators. But the auditors are not interested in programming.  \sys can be viewed as a way to summarize query logs into more accessible interactive visual interfaces.
% An interactive interface to perform the calculations and view the results would ease their burden.
%In a sense, an interface is simply an interactive summary of the past program log that is being audited, and potentially presents a simpler interface to explore and understand the log.

% \stitle{Interface Redesign:} In the long term, new consumer devices and the ways that people interact with these devices will continue to change, and lead to interactions and widgets that cannot be currently anticipanted.  The current approach of manual redesign for each interaction setting and modality may benefit from approaches   To catch up with this, interfaces often needed to be manually redesigned, which is often not scalable as the scope of interactions is too large (e.g. VR, AR, touch, natural language). However, since the analysis that should be supported are already known in the form of query logs of older systems, it will be useful to have a tool that allows users to choose which widgets to support and automatically generate an up-to-date interface.

%Although the interfaces that we expect to generate cannot be as polished and high quality as those that we could generate manually, we expect them to be highly effective for the task that they support; and thus we call them \emph{Precision Interfaces}.


%\stitle{Optimizing and Reproducing Analytics Pipelines: } Oftentimes, data scientists build data processing pipelines. For instance, a machine learning engineer working on a search engine may extract click logs from a central Hive repository, group the results by search query, separate the links that were clicked from those that were not, and build a learning-to-rank model over the results. Typically, she will repeat this analysis dozens of times to find the best combination of features and parameters. An interface would avoid tedious and error-prone rounds of copy-pasting. Furthermore, the data scientist may need to collaborate with other engineers, and have them replicate the results. An interface would ease the collaboration, by abstracting away the details of the source code.
\smallskip

To this end, we present \sys, an automatic tool to generate task-specific interactive interfaces from query logs.  \sys focuses on supporting different query languages\footnote{\small Our methods are based on abstract syntax trees, which we expect will generalize to different query languages.  However, our evaluation focuses on SQL and SPARQL queries.  We use ``program'' and ``query'' interchangeably in the text.} and different types of interface components (e.g., dropdowns, selections, panning, etc).  It takes a log as input (say, collected by IT) and generates a set of interactive web applications to express the queries in this log.  To do so, it parses the queries into canonicalized parse trees, compares pairs of trees to identify structural changes, and maps common types of changes to interface components.  Our focus is on identifying the salient interactions from query logs, and not necessarily the interface design per se.  Further, we are currently database agnostic and do not leverage information such as the schema, query plans, and the data.

Building \sys requires solving several key challenges.  First, we need to develop a unified mathematical model for queries and interfaces, which should be rich enough to express a wide range of real-life scenarios and incorporate user preferences but simple enough to remain tractable. Second, not all structural changes are meaningful and mapping all possible changes to interactions would lead to unusable interfaces---we need to devise a method to filter and identify the most important ones. Third, the space of all the interfaces that we can generate for a given set of query transformations grows exponentially with the size of this set. We need to define constraints and heuristics to quickly find good solutions and scale to logs that contain tens, or hundreds, of thousands of query. To tackle those challenges, we make the following contributions:
\begin{itemize}[leftmargin=*, topsep=0mm, itemsep=0mm]
\item We formalize the problem of mining structural changes in query logs and mapping them to interactive interfaces.  The problem definition is general to any language with a well-defined grammar, and a wide range of interaction components (including non-mouse interactions).
\item We introduce a DSL called \lang to specify interesting structural changes. This helps generate an interaction graph where each node is a query and each labeled edge is a structural change identified by a \lang statement.
\item We map the interface construction problem to edge cover over the interaction graph and use a contraction-based heuristic to quickly solve the problem.
\item We evaluate \sys{} on four query logs that span two query languages (SQL and SPARQL) and contains both synthetic and real-world statements. Our optimizations are 2OOM faster than the baseline, and lets us generate interfaces for logs of $>75k$ queries within 12 minutes.  The interfaces improve upon an existing interface that generated the queries, and are comparable with human crafted interfaces.

\end{itemize}

