\section{Appendix}
\subsection{Considerations of Header Files} 
In %\ref{sec:Vulnerability and patch signature generation}
Section III B:Locating Signature Instructions and Challenges, when we locate the vulnerable binary code from source code, in some cases, certain CVEs include source code changes in the corresponding header (.h) files. 
However, such CVEs are less frequent in number (i.e., 26 CVEs in total out of nearly 1000 CVEs). 
After manually analyzing the changes in the header (.h) files due to the addition of patching codes, we discovered three types of changes, including \textbf{1) Change in MACRO values}, \textbf{2) change in structure member variables} (i.e., changing, adding, or deleting structure member variables, and \textbf{3) change in the function definition}. 




\mypara{Change of MACRO value.}
%In source-code-level, after changing the MACRO value in the .h file, all the references in the .c files are also updated during compiling. For example, in the .h file, we change source code line \texttt{\#define HAVE\_DIRENT\_H 1} to \texttt{\#define HAVE\_DIRENT\_H 0}. And we do not need to change anything in the corresponding .c file referencing MACRO value \texttt{HAVE\_DIRENT\_H}. During compiling, all the instructions in the output binary code referencing MACRO value \texttt{HAVE\_DIRENT\_H} are updated to the new value 0. Therefore, only inspecting the .c file can not detect the .h MACRO value related changes. This can be solved by scanning .c files for changed MACRO values from .h files. 
Diffing the source code versions cannot detect MACRO value changes in the .h file (e.g., \texttt{\#define HAVE\_DIRENT\_H 1} to \texttt{\#define HAVE\_DIRENT\_H 0}).
However, we omit this concern due to the tiny number of the MACRO changing related CVEs (i.e., 8 out of nearly 1000 CVEs). 

\mypara{Change of structure member.}
Structure members can be modified in a few ways --- changing, adding, or deleting. 
\autoref{fig:struct_change} demonstrates some examples for each type.
Specifically, changing structure members include renaming the member and changing the type of existing member. \autoref{fig:struct_change} B and C shows two examples of renaming member and changing member type, respectively.
The source code with red text font represents the code to be deleted, and the green font means the instructions to be added in the patched version. 
%An intuition to solve this problem is to analyze the .h files for changed structure members, and add those structure member-related instruction changes into signature. 
If a structure member is deleted, the .c files source codes mentioning the member must also be deleted. 
Those source code line changes can be detected by diffing the .c files. 
For the adding or changing structure members cases, it is difficult to detect the changes by diffing the .c source codes. 
For example, assume that we observe a structure member is added, as shown in \autoref{fig:struct_change} E, one may think that the added structure member \texttt{new\_member} may not have a corresponding update in the .c file referencing it. 
To identify this case's frequency, we manually inspected all 26 CVEs.
We found that when members are added or changed in the structure, there must be corresponding new source code lines updated in the .c files referencing them.
Therefore, in approximately 1000 vulnerability functions, we found in 100\% cases, the changed or added members have corresponding references in the .c files.
A possible explanation is that the newly added or changed structure members are specifically designed to be used in the .c files to avoid vulnerabilities. \autoref{fig:struct_change} D and E show two examples of deleting and adding a structure member, respectively.
In the approximate 1000 vulnerabilities, we observe that all the structure member changing, adding, or deleting can be detected with the diff tool.

\begin{figure}[!h]
\centering
\includegraphics[width=0.47\textwidth]{graphs/struct_change.pdf}
\caption{Examples of structure member changes. A is the original structure in the vulnerable version. B to E are the examples in the patched version. Red fonts mean the instructions to be deleted, and green font means the new instructions to be added in the patched version. The example is from openjpeg version 1.5.0.}
\label{fig:struct_change}
\end{figure}

\mypara{Change of function definition.}
Changing of function definition refers to changing function calling parameters (e.g., change function definition \texttt{static void j2k\_write\_sot(opj\_j2k *j2k)} to \texttt{static void j2k\_write\_sot(opj\_j2k *j2k, int lenp)}).
This category of change can be reflected in the source code. 
Function calling parameter changes can be detected in the .c files referencing that function because the source code must be updated to handle different parameters. 
Since we are extracting vulnerable function signatures between the vulnerable and patched versions, newly added functions and deleted functions are out of scope because they either only exists in the vulnerable version or only in the patched version. 

