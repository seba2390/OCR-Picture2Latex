\section{Methodology}
\label{sec:methdlg}

%\begin{figure*}[t]
%\centering
%\includegraphics[width=\textwidth]{graphs/methodology.pdf}
%\caption{\name consist of three steps: Data Preparation, Signature Extraction, and Signature Matching.}
%\label{fig:methodology}
%\end{figure*}

This section presents the design of \name. \name's four components are shown as \autoref{fig:methodology}. 


\subsection{Data Preparation}
\label{sec:data preparation}
We collect many already well-studied vulnerabilities from several publicly-available open source projects to build the vulnerability database. 
According to \cite{viva}, vulnerabilities tend to be fixed in new versions of software releases. 
Thus, the vulnerability-related versions consist of the last pre-patching and the first post-patching versions.
The last pre-patching and the first post-patching version will be used later to extract the signatures.
We download all the vulnerability-related versions for each project and record each CVE's information. 
Specifically, for each CVE, we record its related vulnerable source code file name and the vulnerability-related functions within them. 
We also record each CVE's affect versions for later preparing testing binaries for evaluation. 


\mypara{Challenges} 
Not all vulnerability-related functions exist in the compiled binary code due to the automatic function-inlining behavior. 
Automatic function-inlining refers to merging a function \texttt{FuncA} into another function \texttt{FuncB} that calls back \texttt{FuncA}. 
If vulnerable functions are inlined, it would be challenging to locate them in the binary code. 
This case holds even if we manually turn off the function-inline option during compilation. 
Hence, it is challenging for us to generate binary signatures. 


\mypara{Solution} 
We need to ensure that the database contains no inlined functions in the compiled binaries.
\name automatically analyzes the source code files and edits the functions in the source code files to inform the compiler not to inline the function.
Technically, \name inserts a non-inline tag \texttt{\_\_attribute\_\_((noinline))} before each vulnerable function in all related versions to preserve the tagged functions in the compiled binary code. 
For each CVE, \name loads the CVE's information to retrieve its vulnerable source code files along with the corresponding vulnerable functions. 
Then for each related version (i.e., the last pre-patching version and the first post-patching), \name analyzes the vulnerable source code file to locate the vulnerable functions and automatically insert no-inline tags. 
Finally, we compile these versions into binaries with the same default compilation options. 



\subsection{Locating Signature Instructions and Challenges}
\label{sec:Vulnerability and patch signature generation}
We generate signatures related to vulnerabilities and patches using the source codes and compiled binary codes. 
For each vulnerable function, we generate its signatures in two steps --- 1) generate source-level vulnerability-related instructions, 2) locate vulnerability-related binary instructions through mapping. 


\subsubsection{Generating Source-level Vulnerability-related Instructions} 
We prepare the last pre-patching and the first post-patching versions using the information we retrieved in \autoref{sec:data preparation}. 
Subsequently, we generate vulnerability and patch-related signatures on the source code level. 
We use the \texttt{diff} tool\footnote{https://man7.org/linux/man-pages/man1/diff.1.html} to extract source-code-level patched instructions.
There are three types of source-code-level patches in the \texttt{diff} outputs. 
1) Added instructions that are used in the patched version and absent in the vulnerable version, as shown in \autoref{fig:add_example}.
2) Deleted instructions that are removed from the vulnerable version and absent in the patched version as shown in \autoref{fig:delete_example}. 
3) Changed instructions that are updated from the vulnerable version to the patched version, as shown in \autoref{fig:change_example}. 
The changed instructions usually share the same context instructions among the two versions.
 

\subsubsection{Locating Vulnerability-related Binary Instructions through Mapping} 
We use the source-to-binary mapping with the binary's debugging information to locate the source code's corresponding assembly instructions.
Although \name employs the simple idea, there are practical challenges primarily in two aspects. 
\begin{enumerate}
 \item Asymmetric source-binary mapping: it is challenging to map source line changes in the source code files (e.g., .cpp or .c file) to the corresponding binary file,
 \item Identification of vulnerability-specific source lines.
\end{enumerate}



%\begin{figure}
%\centering
%\includegraphics[width=0.4\textwidth]{graphs/one_src_mul_bin.pdf}
%\caption{An example of one source code line mapping to multiple basic blocks in binary code. The example is from openjpeg 1.5.0 version.}
%\label{fig:1src2block}
%\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=0.37\textwidth]{graphs/mis_map.pdf}
\caption{An example of a missing match between source code and binary code. The first two lines 1226 and 1228 do not have any mapping instructions in binary code because the assembly code does not need to specify the type information for functions and variables. Line 1230 maps to two different basic blocks. Line 1231 maps to one basic block. This example is extracted from openjpeg version 1.5.0.}
\label{fig:missingmap}
\end{figure}



\mypara{Two challenges to map source code files} 
\begin{itemize}
    %\item  \textbf{C1:} One source code line may corresponds to multiple binary code blocks. For example, \autoref{fig:1src2block} shows an example mapping between the source code and the binary code. The source code line maps to two binary basic blocks because the source code line contains two conditions (i.e., \texttt{j2k->cur\_tp\_num == 0} and \texttt{cp->cinema == 0}) concatenated with the \texttt{\&\&} symbol.
    \item \textbf{Challenge1: Asymmetric source-binary mapping.} 
    Not all the source code lines have a matching binary code instruction. 
    For example, \autoref{fig:missingmap} shows an example of missing mapping between source code and binary code. 
    Lines 1226 and 1228 declare new variables but do not map to any binary instructions because the variables at the binary level are directly used without explicit type declaration due to the binary code convention. 
    
    \item \textbf{Solution1:} 
    Generally, the source code lines declaring new variables (e.g., line 1226 and 1228 in \autoref{fig:missingmap}) do not have a mapping binary code because of binary code convention.  %infers their types before the binary code convention directly uses the variables without declaration. 
    %Therefore, changes in declaring source code lines do not have corresponding binary codes.
    However, it does not affect finding the binary signatures. 
    We further elaborate on the following two cases: 
    1) If a new variable declaration is added, it must be used later in some other source code lines, implying that the correlated source lines still exist after diffing source codes of the patched and vulnerable functions. 
    2) If a variable's name is changed, the source code referring to that variable must change, which is detected by diffing the source codes. 
    For a variable with type change (e.g., change from a defined structure \texttt{structA} to an updated structure \texttt{structA'}), source code lines using that variable tend to change because of different type usage (e.g., defining different fields in the different structure type). 
\end{itemize}


\begin{itemize}
\item \textbf{Challenge2: Identification of vulnerability-specific source lines.} 
  The add type signature is challenging to represent. 
  Because the add type signature only exists in patched versions, the added instructions imply the existence of a patch rather than the vulnerability itself. 
  Therefore, there are no direct vulnerable instructions from the vulnerable version. 
  For example, \autoref{fig:add_example} shows an example of the add type signature in the source-code level. 
  Green lines (lines B2 to B6 on the right-hand side) are the added lines in the patched version, and grey lines are the unchanged lines across the two versions. 
  The absence of the green lines in the vulnerable version implies a vulnerability.
  However, other random functions may lack added instructions without the same vulnerability. 
  Therefore, the lack of added instructions cannot be directly used as the vulnerable signature. 
  We need to infer the vulnerability signature in the vulnerable version to detect vulnerability existence.
 
\item \textbf{Solution2:} 
To represent add type vulnerability signature, our solution is to focus on the context. 
For example, lines A1 and B1 in \autoref{fig:add_example} are unchanged in the two versions. 
A1 flows to A2 in the vulnerable version,  while B1 flows to B2 in the patched version. 
The control flow from the unchanged instruction A1 to the following instruction A2 is regarded as the vulnerability signature in \name. 
%we aim at representing the vulnerability by the existence rather than the lack of existence of the signature. 
%For example, in \autoref{fig:addExample}, line B2 to B6 are inserted between A1 and A2. Therefore, A2 and B2 share the same predecessor A1 and B1.
Conversely, the control flow from B1 to B2 is regarded as a patch signature. 
Since the added instructions are inserted at some point within the function, they must have identical context instructions (e.g., A1 and B1 in the example) with different subsequent instructions (e.g., A2 and B2). For simplicity, we explain this concept at the source code level. But we extract add type signatures at the binary level. For more details refer to \autoref{sec:form}.
\end{itemize}


\begin{figure}[!t]
\begin{subfigure}[b]{0.5\textwidth}
         \centering
         \includegraphics[width=\textwidth]{graphs/add_example.pdf}
         \caption{Add Type}
         \label{fig:add_example}
\end{subfigure}

\begin{subfigure}[b]{0.5\textwidth}
         \centering
         \includegraphics[width=\textwidth]{graphs/delete_example.pdf}
         \caption{Delete Type}
         \label{fig:delete_example}
\end{subfigure}

\begin{subfigure}[b]{0.5\textwidth}
         \centering
         \includegraphics[width=\textwidth]{graphs/change_example.pdf}
         \caption{Change Type}
         \label{fig:change_example}
\end{subfigure}

\caption{Examples of add, delete and change types. Green lines are the newly added or changed instructions in the patched version. Red lines are the deleted or changed lines in the vulnerable version. Grey lines are the intact lines. }%The example is extracted from openjpeg version 1.5.0.}
\label{fig:addExample}
\end{figure}


%\subsubsection{Mapping binary instructions from source-code-level instructions}\label{sec:mapping binaries}
%Until now, we are able to locate source-code-level vulnerability-related instructions. In this subsection we further locate the corresponding binary code instructions. Remember we turn on debug symbols when compiling the source code. Therefore, we extract source-binary mapping information from the binary code reading the debugging information by using the \texttt{objdump} tool. The output of \texttt{objdump} contains a mapping between each source code line and their corresponding binary code instructions. 

\subsection{Constructing Context-aware Binary-level Signatures}
\label{sec:form}

We construct the binary-code-level signatures before storing them in the database for signature matching. 
Simply storing the sets of instructions in the database as vulnerable signatures and detecting those signatures' existence in the query binary code may not be beneficial. 
As mentioned in \autoref{sec:Vulnerability and patch signature generation}, added instructions in the patched binary cannot directly be used to form a vulnerability signature because it only indicates patches. 
The term \textit{context} refers to the adjacent blocks' instructions of the vulnerable binary instructions. 
The vulnerable binary instructions are usually short.
If we generate signatures by simply concatenating those instructions into a sequence, the signature may carry inadequate information to prevent false positives.
Therefore, we propose to form new structures by combining the context and the vulnerable instructions. 
Our newly combined structure gives the signature adequate uniqueness to boost the performance of signature matching.
We propose to build the context around the vulnerable signature instructions through generalization to reduce false positives. 
For instance, the extracted signature instructions size is small (e.g., only 3 instructions).
Checking the existence of signature instructions without context information makes the signature not unique enough, leading to excessive mismatches (false positives). 


Since the added instructions in the patched version have blocks directly preceding them, the counterpart preceding blocks in the vulnerable version should have different instructions following them. 
Therefore, we capture local control flows around the preceding blocks in the vulnerable version to represent the vulnerability signature.  


\begin{figure}[!t]
\centering
\includegraphics[width=0.47\textwidth]{graphs/leading.pdf}
\caption{An example of binary-code-level add signature and the steps to extract the corresponding binary signature.}
\label{fig:leading}
\end{figure}

We propose to generate the binary-level signature with control-flow information. 
Firstly, we define several terms. 
\begin{itemize}
   \item \textbf{Add Batch}. When newly added source code snippets are mapped to binary code blocks, the newly added blocks could either be directly connected to each other (e.g., block 4 and 5 in \autoref{fig:leading}) or separate from each other (e.g., block 4 and 9 in \autoref{fig:leading}).
   An \textbf{add batch} is made up of the added blocks that are strongly connected to each other.
   As shown in \autoref{fig:leading}, block $(4, 5, 6)$ and block $(9, 10)$ are two add batches.
   \item \textbf{Leading Blocks.} 
   The \textbf{leading block} is the unchanged block immediately preceding an added batch.
   As shown in \autoref{fig:leading}, blocks 1 and 7 are two leading basic blocks because they immediately precede two add batches.
   \item \textbf{Parents-children Structure.} We define a parents-children structure to store the control flow and literal information for add and change signatures. 
   Specifically, in one parents-children structure, we have an initial block from the function as the parent. 
   We include the chosen block's children blocks in the function into the parents-children structure. 
   Conversely, we can select a child block before including its parents to establish a parents-children structure.
   \item \textbf{Block List Structure}. We define a block list structure to store only the literal information when control-flow information is not available or unnecessary. 
   In one block list structure, we store all the vulnerable binary instructions grouped by blocks.
\end{itemize}


We store both vulnerable and patch signatures. 
Vulnerability signatures are generated from the instructions in the vulnerable version. 
This signature type consists of parents-children structures or block list structures. 
Patch signature consists of the instructions that only exist in the patched version and only consists of the block list structure. 
Patch signature is used to reduce the false positives further. 
Despite the vulnerability match score, the patch signature directly implies a patch. 
The vulnerable signatures contain three types: 1) add, 2) delete, and 3) change.
Those signatures have different structures to capture different information because different signature type has different nature. 
We capture various information for different signature types to enrich the signature information.


For the \textbf{add type signature}, to locate the add type binary signatures, we \textbf{A)} retrieve the added binary instructions in the patched version (i.e., the output of the operations in \autoref{sec:Vulnerability and patch signature generation}). 
\textbf{B)} We find the leading basic blocks in the patched version binary.
\textbf{C)} We find its counterpart leading basic block in the vulnerable version binary. 
\textbf{D)} We include the vulnerable binary's leading basic blocks' children blocks as a parents-children structure in the signature. 
%We also analyze the added binary codes in the patched version and extract the instructions that only exist in the patched version as the patch signatures. 


%Because the vulnerability does not lies in the boundary blocks themselves. Rather, the vulnerability lies in the control-flow connection between the boundary blocks and their neighbours. 
For the \textbf{delete type signature}, we directly locate the mapping binary instructions and store those instructions into block list structures as delete signatures since the deleted instructions usually map to multiple blocks. Since the mapped blocks are usually sufficient in amount, lexical information already makes the signature unique for matching. If we record their control-flow information we will use excessive parents-children structures. 
We exclude any patch signature for this signature type because the patched version does not have any unique instruction that does not exist in the vulnerable version.


The \textbf{change type signature} has two categories, including one-block-change and many-blocks-change. 
Many-block-change means the changed instructions are distributed in multiple blocks (i.e., distributed in neighbor blocks or blocks that are not directly connected). 
One-block-change is the case if all the changed instructions are accommodated in one block in the binary code. 


\begin{table*}[!t]
\centering
\caption{Information of the seven selected open-source projects.}
\label{tab:projects}
\footnotesize
\begin{tabular}{l|l|c|c|c|c|c|c|c}
\hline
\textbf{Project} & \textbf{Domain} &\textbf{Versions(\#)} & \textbf{Binary Files(\#)} & \textbf{.c Files(\#)} & \textbf{.h Files(\#)} & \textbf{CVEs(\#)} & \textbf{Vulnerable Functions(\#)} & \textbf{Avg Size}\\
 \hline
Tcpdump &Packet Analyzer& 20 &152 &167 &78 &192 &213 &20.45 \\

Curl &Data Transferring&  67 &315 &419 &197 &111 &231 &44 \\

OpenSSL &Protocols& 51 &755 &903 &243 &114 &220 &205 \\

Openjpeg &Image Processing&  15 &104 &205 &139 &94 &187 &24.50 \\

LibPNG &Image Processing& 63 &39 &36 &14 &52 &50 &6.90 \\

Libtiff &Image Processing& 30 &69 &102 &24 &142 &169 &12.30 \\

FFmpeg &Multimedia Processing& 104 &1206 &1591 &629 &201 &211 &584 \\

\hline
\textbf{Total} & various & 350 &2640 &3423 &1324 &906 &1281 &897.15 \\
\hline
\end{tabular}
\end{table*}



\mypara{Many-block-change}
If the change is many-block-change, we will need to record both control-flow and lexical information in the database since the change sites are usually small in size. This category of signature provides rich information as it contains adequate lexical information (i.e., binary instructions) from multiple blocks or control-flow information between those blocks. 
Therefore, for each block in a many-block-changes structure, if its neighbor (i.e., either predecessor or successor block) is a change block, we include this neighbor to form a parents-children structure. 
If none of its neighbor blocks is changed, all changed instructions are grouped as a block in the signature. Note that if the many-block-change contains a deeper level other than two levels (i.e., the level of parents-children structure), we use multiple parents-children structures to cover all the strongly connected blocks. For example, if block $A$ flows to block $B$, and block $B$ flows to block $C$, we will have two parents-children structures to cover the flow from $A$ to $B$ and from $B$ to $A$ respectively.

\mypara{One-block-change}
Conversely, if the change is a one-block-change, the information is limited because we only have lexical information without control flow information. 
Thus, we need to add more control flow information to enhance the signature and reduce potential mismatch. 
We include its parent blocks in a parents-children structure to enhance the signature. 
We include the children blocks in the parents-children structure if it has no parent block.  

\mypara{Patch signatures}
We generate signatures for patches. 
After we generate vulnerable signatures as above, we diff the vulnerability-related sites in both versions. 
We identify the instructions that only exist in the patched version and store it using a block list structure as the patch signature.


\subsection{Signature Matching}
We detect the vulnerability's existence by using both vulnerability and patched signatures. 
For the add signature, we search for each vulnerable parents-children structure in the query binary code. 
Then, we check for the existence of a patch signature. 
If a patch is found, the function is directly considered patched. 
For the delete signature, we search for the existence of the blocks from the block list structures. 
We do not match patch signatures for the delete type because the delete type does not has unique instructions in the patched version. 
%We do not need patch signatures for such cases to decide whether it is vulnerable or patched.
For the change signature, we search for the existence of each parents-children structure or block list structure in the query binary code. Subsequently, we check the existence of the patch signature. 
If the patch is found through a query, the function is considered patched (denoted by $P=1$);  otherwise, $P=0$. 

We propose a measurement of the vulnerability existence score ($Sim$) to demonstrate the probability of the query function containing a given vulnerable signature. 
Specifically, a final score of vulnerability existence is calculated as follows:
\[Sim=\begin{cases}\frac{\Sigma_{i=1}^{len(S)}Matched(S[i])}{\Sigma_{i=1}^{len(S)}Total(S[i])} &\text{if }P=0\\0 &\text{if }P=1
\end{cases}\]
where $Sim$ represents the result similarity score to the vulnerable signature. 
$S$ represents one vulnerable signature. 
A signature consists of one or multiple structures (a structure is either parents-children structure or block list structure). 
$len()$ calculates the number of structures regarding an input signature.
$S[i]$ represents a structure. 
$Matched()$ calculates the number of instructions matched between the input structure and the given query binary function. 
If the structure is parents-children structure $PS$, $Matched()$ searches through the query binary to find the similar parents-children structure $PS'$ with the maximum similarity. 
Then $Matched()$ counts the instructions shared between $PS$ and $PS'$. 
If the structure is a block list structure, $Matched()$ finds all the blocks with the maximum similarity to each block in the block list structure before $Total()$ aggregates the total instruction number of the input structure.  


