\section{Design and Implementation of Sentinel Array}

Sentinel Array is an auxiliary structure that contains sentinels, which indicate the minimum key of each cache line of the origin array. The Sentinel Array size is decided by the machine and the original array size. Given a typical cache line size of 64 bytes and a sentinel (minimum key) in 8B, one cache line contains eight sentinels, which are respectively from eight cache lines of KV pairs. Therefore, a Sentinel Array in one cache line is able to support a B+-tree node in 512B (64$\times$8). For a B+-tree node in 2KB with 32 cache lines, a Sentinel Array with four cache lines suffices. In the worst case for searching over such a 2KB node, all four cache lines of Sentinel Array and one cache line of KV pair are scanned. So in all, there are five cache misses. However, in the worst case of searching the original 2KB node incurs 32 cache misses. Concretely, employing a Sentinel Array significantly reduces cache misses.

We note that Sentinel Array is not enforced consistency with cache line flush and memory fence. Then reason is that Sentinel Array could be reconstructed from keys in the original B+-tree node if the system crashes down. State-of-the-art B+-trees developed for NVM embrace comprehensive mechanisms to guarantee the consistency of KV pairs.

\subsection{Search of Sentinel Array}

\begin{figure}[htbp]
\centerline{\includegraphics[width=0.5\textwidth]{./Search_alg.pdf}}
\caption{An illustration of searching 140 in a B+-tree node}
\label{search_alg}
\end{figure}

\begin{figure*}[t]
	\centering
	\subfigure[Average latency (1m data, search, $\mu$s)]{
		\centering
		\includegraphics[width=0.48\columnwidth]{./1m_search.pdf}
		\label{1m_search} 
	}%
	%\hspace{.001in}
	\subfigure[Average latency (1m data, insertion, $\mu$s)]{
		\centering
		\includegraphics[width=0.48\columnwidth]{./1m_insert.pdf}
		\label{1m_insertion} 
	}%
	%\hspace{.001in}
	\subfigure[Average latency (10m data, search, $\mu$s)]{
		\centering
		\includegraphics[width=0.48\columnwidth]{./10m_search.pdf}
		\label{10m_search} 
	}%
	%\hspace{.001in}
	\subfigure[Average latency (10m data, insertion, $\mu$s)]{
		\centering
		\includegraphics[width=0.48\columnwidth]{./10m_insert.pdf}
		\label{10m_insertion} 
	}%
	\centering
	\caption{A Comparison of Six Trees on Inserting and Searching 1/10 Million Keys}
	\label{10m_testing} 
\end{figure*}

\begin{figure}[t]
	\centering
	\subfigure[Average latency (100m data, search, $\mu$s)]{
		\centering
		\includegraphics[width=0.48\columnwidth]{./100m_search.pdf}
		\label{100m_search} 
	}%
	%\hspace{.001in}
	\subfigure[Average latency (100m data, insertion, $\mu$s)]{
		\centering
		\includegraphics[width=0.48\columnwidth]{./100m_insert.pdf}
		\label{100m_insertion} 
	}%
	\centering
	\caption{A Comparison of Six Trees on Inserting and Searching 100 Million Keys}
	\label{100m_testing} 
\end{figure}

Fig.~\ref{search_alg} exemplifies the process of searching with Sentinel Array. The target key is 140. We assume that four KV pairs occupy one cache line for 16B KV pointer size in total and 64B cache line's size.  As shown by the left part of Fig. 4, to reach 140, we need to traverse four cache lines, thereby causing four cache misses. With a Sentinel Array shown on the right part of Fig. 4, we only need to check the cache line of sentinels and the actual cache line holding key 140 and its corresponding value, i.e., two cache misses. Algorithm \ref{alg:search} illustrates the algorithmic steps of searching with Sentinel Array. We note that we add Sentinel Arrays to a B+-tree's leaf nodes without loss of generality.

\begin{algorithm}[!htbp]
    \caption{Search With Sentinel Array}
    \label{alg:search}
    \begin{algorithmic}[1]
        \REQUIRE The target key.
        \ENSURE The pointer of value of target key.
        \STATE $begin\_index = 0$
        \FOR{($i=1$; $i<\frac{n}{count\_in\_line}$; $i++$)}
            \STATE $//$ $count\_in\_line$ is number of KV pairs counted in one cache line
            \IF{$key < sentinel\_array[i]$}
                \STATE break
            \ENDIF
            \STATE $begin\_index = begin\_index + count\_in\_line$
        \ENDFOR
        \STATE Search the node's array begin with $begin\_index$
    \end{algorithmic}
\end{algorithm}


\subsection{Update of Sentinel Array}
From time to time, keys are inserted and deleted in a B+-tree node. Therefore, we need to update the node's Sentinel Array, which is simply updated with the original data array.  Because the Sentinel Array is reconstructable from consistent KV pairs, the update of it is efficient without using cache line flush or memory fence.

\subsection{Multi-threading Access}

Sentinel array is added to a B+-tree node as an auxiliary component. A node-level lock shared with the original B+-tree node helps to support multi-threading write/read with the Sentinel Array.
