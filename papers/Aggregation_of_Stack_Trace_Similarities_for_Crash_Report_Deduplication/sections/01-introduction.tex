\section{Introduction}\label{sec:introduction}

Software systems often use built-in bug tracking tools or crash reporting systems~\cite{crs_1,crs_2,crs_3} to get the information about the occurring crashes and errors from their users.
An important feature of such reports is that they often do not have a textual description of the problem, and the stack trace remains as the main source of information~\cite{s3m}.
An example of a stack trace is presented in~\Cref{fig:stacktrace}.
The stack trace consists of an ID, a timestamp, an error, and a list of frames --- an ordered list of methods that constitute the stack of calls that lead to the error.

For the exact same error, several reports can be recorded that become fuzzy duplicates~\cite{lerch,tracesim,s3m}.
Duplicates are caused by multiple users having a problem caused by the same error.
For example, $72\%$ of crash reports received for the IntelliJ Platform (a platform for building integrated development environments developed by JetBrains) are duplicates~\cite{tracesim}. 
Allowing developers to efficiently work with the reports requires us to de-duplicate them and group them by error type.
Since there are usually a lot of reports~\cite{durfex,many_reports_1}, it is not feasible to group them manually, as this implies a detailed study of each crash report, which is too time-consuming~\cite{researh_about_capacity}. 

\begin{figure}[t]
\centering
    \includegraphics[width=\columnwidth]{figures/example.pdf}
    \centering
    \vspace{-0.4cm}
    \caption{An example of a stack trace from the NetBeans dataset~\cite{s3m}.}
    \vspace{-0.4cm}
    \label{fig:stacktrace}
\end{figure}

Most modern methods~\cite{modani,lerch,durfex,tracesim,s3m} assign the incoming stack trace to one group or another based on the choice of the most similar stack trace in the group: locate a stack trace which is the most similar to the new one, and put the new one into that group. 
The disadvantage of this approach is that despite having all the similarity values to all stack traces in the group, we only use the information about the nearest one, and the overall structure of the group is not taken into account.
Some techniques also use the information about the group structure.
For example, the authors of CrashGraphs~\cite{crash_graphs} represent the group and the incoming stack trace as a directed graph. 
However, in this case, the situation is somewhat opposite: the information about the nearest stack trace in the group is lost. 

The results of these works that study different methods---based on the nearest stack trace~\cite{modani,lerch,durfex,tracesim,s3m} and based on the group structure~\cite{crash_graphs}---lead to the idea that both of these sources of information are important. 
In this work, we aim to develop an approach that would take into account the advantages of all the existing methods and test it on real-world data from a large software company.

The idea behind our approach is to use one of the existing methods to find the similarity between the incoming stack trace and stack traces in the group, and then aggregate the received information (the values of the calculated similarity, the number of stack traces in the group, etc.).
Another improvement that we propose is to use the information about the time of occurrence (timestamps) of the stack traces.
This is important because it gives us an idea of how far in time the group's stack traces are relative to the incoming stack trace. 
By aggregating all this information, we build an \ag, which determines the similarity between the stack trace and the group, thus making it possible to further rank the similarity to groups and select the closest one.

The approach is implemented as a simple and straightforward linear model that calculates the weighted sum of the constructed features.
The architecture of our approach is designed specifically to be as quick and efficient as it could to be used in production.
To evaluate the increase in the performance that the \ag brings about, we test it on two different datasets: the open-source dataset from the NetBeans IDE collected in our previous work~\cite{s3m}, as well as a new industrial dataset collected within JetBrains, a large developer of IDEs and other software. 
Upon acceptance, we will release this dataset to facilitate further research in the area.
The \ag shows the increase in the Recall Rate Top-1 metric ($\mathrm{RR} @ 1$) of $15$ percentage points for the NetBeans dataset and of $8$ percentage points for the JetBrains dataset, compared to existing state-of-the-art solutions. 
Such a significant difference demonstrates the usefulness and the potential of the proposed approach.

Next, we compare our approach with another simple way of aggregating the information about the similarities --- namely, various $k$-NN-based approaches. 
However, our experiments show that, when compared to the baselines, these approaches only reach the increase of $4$ percentage points in the $\mathrm{RR} @ 1$ metric on the NetBeans dataset, and $2$ percentage points on the JetBrains dataset, indicating that the \ag and the temporal information lead us to better performance.

Finally, to better understand the performance of the \ag, we study the coefficients of the model with which it aggregates the features.
As can be expected, the most important feature is the similarity to the nearest stack trace, the feature used in the majority of existing methods.
However, the results also show that the histogram of the similarities to all the stack traces in the group that takes timestamps into account helps the model as well.
This analysis can help researchers improve the \ag in the future.

Overall, our contributions in this paper are as follows:
\begin{itemize}
    \item \textbf{\ag}: We propose a new approach that takes into account all the available stack traces and their time of occurrence. 
    The implementation of the model with documentation is available online on GitHub: \url{https://github.com/nkarasovd/AggregationModel}. 
    \item \textbf{Dataset}: We collected a new large dataset using the anonymized proprietary data from the JetBrains software company, it contains 236,174 stack traces and 9,163 groups. 
    We will release the dataset upon acceptance.  
    \item \textbf{Evaluation}: We describe our experience with the \ag, which experimentally shows its usefulness for stack trace grouping. 
    Our approach outperforms existing methods by $15$ and $8$ percentage points in Recall Rate Top-$1$ metric on the NetBeans and JetBrains datasets, respectively.
\end{itemize}