\section{Experiments}
\label{sec:exp}

We systematically tested the proposed algorithms and optimization strategies with both synthetic and real datasets, described below. All experiments were conducted on a Linux machine with two Intel Xeon Platinum 8268 24-core 2.9GHz Processors and 384GB RAM.  All code is available at \url{https://github.com/DataResponsibly/mew-supplementals}. 

\paragraph{Synthetic data generators}

The synthetic partial orders are generated by RSMs.
Let $\mathsf{RSM}(\bsigma, \Pi, p)$ denote the preference model of a voter where $\bsigma = \angs{\enum{\sigma}}$ and $\Pi(i, j) = \frac{\phi^{j-1}}{1+\phi+...+\phi^{m-i}}$, which makes its item selection order equivalent to $\mallows(\bsigma, \phi)$.
Then uniformly draw probabilities $p: \set{1, \ldots, m-1} \rightarrow \text{Uniform}(0, p_{max})$ where $p_{max}$ is part of the parameter setup in our experiments.

Partially partitioned preferences are generated with specified numbers of partitions. First, create an ordered list of partitions, and randomly choose an item for each partition to guarantee that each partition has at least one item. Then, create an additional partition for the missing items. Finally, assign each of the remaining items to a random partition, including the ``missing items'' partition.  Fully partitioned preferences are generated in a similar fashion, except that there is no partition for the missing items. Partial chains also use this generator, except that it stops at the first step where each partition has been assigned a single random item.

Truncated rankings are generated by first drawing a ranking from the uniform ranking distribution, and keeping only the top and the bottom parts of the ranking.

\paragraph{Real datasets} We worked with three real datasets with different voting profile types.
\e{CrowdRank}~\cite{DBLP:conf/webdb/StoyanovichJG15} is a dataset of partial chains over movies collected from Amazon Mechanical Turk.
It consists of 50 human intelligence tasks (HITs), each of which asked 100 users to rank 20 movies that they were familiar with.
%
\e{MovieLens} is a dataset of movie ratings collected by GroupLens (\url{www.grouplens.org}).
We used the most frequently rated movies and converted movie ratings by the same user into partially partitioned preferences. We then obtained a partially partitioned voting profile with 200 movies and 6040 users.
%
\e{Travel}~\cite{8635080} is a dataset of ratings of European attractions that belong to 24 categories in Google Reviews. The ratings are average values given by each user for each attraction category.
We converted these average ratings into a fully partitioned voting profile with 24 attraction categories and 5456 users.

\subsection{Performance optimizations}
\label{sec:exp:pruning}

\rev{We tested the performance of optimization strategies over synthetic partial voting profiles, with 10 candidates under three voting rules.
The partial orders are generated by $\mathsf{RSM}(\bsigma, \Pi, p)$ and $p_{max}$ as described above.
In each voting profile, all voters share the same reference ranking $\bsigma$ and insertion probabilities $\Pi$, and their item selection orders are equivalent to $\mallows(\bsigma, \phi)$.
For the convenience of discussion, we use $\phi$ as the setting that describes $\Pi$.}

\rev{\paragraph{Candidate pruning}
We turned off voter grouping to test the performance of candidate pruning.
For each parameter setting, we generated 10 voting profiles, fixing 10,000 voters and $\phi = 0.5$, varying $p_{max}$, and computed \mew with and without candidate pruning.
We present speedup as a function of $p_{max}$ for $10,000$ voters in Figure~\ref{fig:strategies:pruning}, for plurality, 2-approval and Borda.  We observe that pruning never hurts performance, and that it is more effective for higher values of $p_{max}$, the parameter that controls the density (number of preference pairs) in a partial order.  Pruning is most effective for plurality, followed by 2-approval and then by Borda.}     
\rev{We thus conclude that these performance optimizations are effective at reducing the running time of \mew computation, and we use both optimizations in all remaining experiments.}

\begin{figure}[tb!]
	\centering
	\subfloat[candidate pruning]{
		\label{fig:strategies:pruning}
		\includegraphics[width=0.3\textwidth]{figs/synthetic_posets_10_candidates_10000_voters__speedup_vs_pmax}
	}\hspace{5em}
	\subfloat[voter grouping]{
		\label{fig:strategies:grouping}
		\includegraphics[width=0.3\textwidth]{figs/synthetic_posets_10_candidates__grouping_speedup_vs_voters}
	}
	\caption{\rev{Performance of optimization strategies over partial voting profiles, with 10 cand., $\phi=0.5$. Candidate pruning with 10,000 voters;  effectiveness improves with $p_{max}$. Voter grouping with $p_{max}=0.1$; effectiveness improves with \#voters.}}
	\label{fig:strategies}
\end{figure}

\rev{\paragraph{Voter grouping}
In this experiment, we turned off candidate pruning, and tested the voter grouping optimization.
For each parameter setting, we generated 10 voting profiles, fixing $\phi = 0.5$ and $p_{max} = 0.1$, varying the number of voters, and computed \mew with and without voter grouping. 
The speedup of voter grouping is the running time without voter grouping divided by the running time with voter grouping. Figure~\ref{fig:strategies:grouping} demonstrates that voter grouping never hurts performance, and that the speedup realized by this optimization increases with the number of voters.}

\begin{figure}[b!]
	\centering
	\subfloat[running time]{
		\label{fig:parallel:time}
		\includegraphics[width=0.3\textwidth]{figs/synthetic_posets_10_candidates_1m_voters__parallel_runtime_vs_threads}
	}\hspace{5em}
	\subfloat[speedup]{
		\label{fig:parallel:speedup}
		\includegraphics[width=0.3\textwidth]{figs/synthetic_posets_10_candidates_1m_voters__parallel_speedup_vs_threads}
	}~
	\caption{\rev{Parallel implementation for MEW over partial voting profiles of 10 candidates, 1 million voters, $\phi=0.5$, and $p_{max}=0.1$. The speedup due to parallelism is nearly linear in the number of worker processes.}}
	\label{fig:parallel}
\end{figure}

\paragraph{Parallel computation of \mew} \rev{Algorithm~\ref{alg:pruning} gives a sequential implementation of \mew, with linear complexity in the number of voters. To handle a large volume of voters in real-world settings, the computation of \mew can be easily parallelized by turning off the candidate pruning strategy and allocating all votes to different CPU cores.}
\rev{We tested the parallel implementation of \mew over 10 synthetic partial voting profiles of 10 candidates and 1 million voters.
The partial orders are generated with $\phi = 0.5$ and $p_{max} = 0.1$, using the same methodology as in Section~\ref{sec:exp:pruning}.
Figure~\ref{fig:parallel:time} demonstrates that the solver runs faster with more worker processes.
In Figure~\ref{fig:parallel:speedup}, the speedup of the parallel solver relative to the sequential solver increases linearly with the number of worker processes.}

\subsection{Incomplete voting profiles}

\paragraph{Partial voting profiles}
A collection of synthetic profiles of 10 candidates are generated to test the scalability of the solver in Section~\ref{sec:algorithms:exact}.
Synthetic partial orders are generated in the same way as in Section~\ref{sec:exp:pruning}.  We generated 10 voting profiles for each parameter setting, and calculated the \mew under three voting rules, with performance optimizations discussed in Section~\ref{sec:optimize}.

\begin{figure}[tb!]
	\centering
	\subfloat[1000 voters]{
		\label{fig:posets:phi}
		\includegraphics[width=0.3\textwidth]{figs/synthetic_posets_10_candidates_1000_voters__time_vs_phi}
	}\hspace{5em}
	\subfloat[$\phi = 0.5$]{
		\label{fig:posets:voters}
		\includegraphics[width=0.3\textwidth]{figs/synthetic_posets_10_candidates_1000_voters__time_vs_voters}
	}~
	\caption{Running time over partial voting profiles, fixing 10 candidates and $p_{max}=0.1$. \mew is determined fastest under plurality, slowest under Borda. Running time is insensitive to changes in $\phi$ (voter preference diversity). Running time increases linearly with the number of voters.}
	\label{fig:posets}
\end{figure}

Figure~\ref{fig:posets} demonstrates the impact of voting rules on the running time.  \mew is determined fastest under plurality, followed by 2-approval, and finally, by Borda.  In Figure~\ref{fig:posets:phi}, the $\phi$ parameter of the Mallows model is varied to test the impact of voter consensus level on the running time, which turns out to be minor. Figure~\ref{fig:posets:voters} shows the linearly increasing running time with the number of voters.

\begin{figure}[b!]
	\centering
	\includegraphics[width=0.3\linewidth]{figs/synthetic_posets_cw__time_vs_cw}
	\caption{Running time over partial orders increases exponentially with cover widths.  100 partial orders generated with RSM over 10 candidates, $p_{max}=0.1$, and insertion probabilities equivalent to Mallows with $\phi=0.5$.}
	\label{fig:cw}
\end{figure}

\e{Partial orders and cover width.} A benchmark of partial orders is prepared to investigate the impact of the cover width parameter, discussed in Section~\ref{sec:preliminaries:pref}, on performance. We fixed the reference ranking of the RSM over 10 candidates, and made its insertion probabilities equivalent to $\phi = 0.5$ in Mallows.
For each partial order, we sample a new vector of edge construction probabilities with $p_{max} = 0.1$, generating 100 partial orders.
Figure~\ref{fig:cw} shows that the exact solver for partial orders has exponential complexity with the cover width, which is consistent with our complexity analysis.

\e{Partially partitioned voting profiles.} Synthetic profiles are generated with the parameter settings in Figure~\ref{fig:pp}.
For each  setup, we generated 10 profiles and calculated the \mew with the solver in Theorem~\ref{theorem:tractability_of_parparVP} and Algorithm~\ref{alg:pruning}.
Figure~\ref{fig:pp} shows their average running time to demonstrate the scalability w.r.t. the number of partitions, candidates, and voters.
In Figure~\ref{fig:pp:k}, the running time decreased with greater number of partitions.
Figures~\ref{fig:pp:m} and~\ref{fig:pp:n} show that the running time increases linearly with more candidates and voters.

\begin{figure}[tb!]
	\centering
	\subfloat[80 cand, 1000 voters, varying \#partitions]{
		\label{fig:pp:k}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_ppwm_80_candidates_1000_voters__time_vs_k}
	}\hfill
	\subfloat[1000 voters, 5 partitions, varying \#cand]{
		\label{fig:pp:m}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_ppwm_1000_voters_5_partitions__time_vs_candidates}
	}\hfill
	\subfloat[\rev{80 cand, 5 partitions, varying \#voters}]{
		\label{fig:pp:n}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_ppwm_80_candidates_5_partitions__time_vs_voters}
	}\hfill
	\caption{Average time over partially partitioned profiles. It declines with more partitions in the voter preferences, increases with more candidates in the voting profile, and increases linearly with the number of voters.}
	\label{fig:pp}
\end{figure}

\e{Fully partitioned voting profiles.} The setup of this experiment is identical to that of the partially partitioned preferences above.
While Figure~\ref{fig:fp:m} also gives the linear  growth of running time with increasing number of candidates, Figure~\ref{fig:fp:k} shows opposite trends between Borda and the other two voting rules. It turns out that under Borda rule, the pruning strategy benefits from the increasing number of partitions.
In comparison, after turning off the pruning strategy, the running time of computing \mew under the Borda rule increased from 0.76 seconds to 0.79 seconds.

\begin{figure}[tb!]
	\centering
	\subfloat[80 cand, 1000 voters, varying \#partitions]{
		\label{fig:fp:k}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_pp_80_candidates_1000_voters__time_vs_k}
	}\hfill
	\subfloat[1000 voters, 5 partitions, varying \#cand]{
		\label{fig:fp:m}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_pp_1000_voters_5_partitions__time_vs_candidates}
	}\hfill
	\subfloat[\rev{80 cand, 5 partitions, varying \#voters}]{
		\label{fig:fp:n}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_pp_80_candidates_5_partitions__time_vs_voters}
	}\hfill
	\caption{Average time over fully partitioned profiles. It increases under plurality and 2-approval, but declines under Borda, with more partitions in the voter preferences. It increases linearly when adding more candidates or voters.}
	\label{fig:fp}
\end{figure}

\e{Partial chain voting profiles.} The setup of this experiment is almost identical to the experiments of partitioned voting profiles, except that the number of partitions is now the chain size. Figure~\ref{fig:pc} presents the average running time to compute the \mew with candidate pruning under various parameter settings.
In Figure~\ref{fig:pc:k}, running time increases mildly with chain size under Borda, while it even drops under plurality and 2-approval. \rev{In Figures~\ref{fig:pc:m} and~\ref{fig:pc:n}, the running time increases linearly with more candidates and voters.}

\begin{figure}[tb!]
	\centering
	\subfloat[80 cand, 1000 voters, varying chain size]{
		\label{fig:pc:k}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_pc_80_candidates_1000_voters__time_vs_k}
	}\hfill
	\subfloat[1000 voters, chain size 5, varying \#cand]{
		\label{fig:pc:m}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_pc_1000_voters_5_partitions__time_vs_candidates}
	}\hfill
	\subfloat[\rev{80 cand, chain size 5, varying \#voters}]{
		\label{fig:pc:n}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_pc_80_candidates_5_partitions__time_vs_voters}
	}\hfill
	\caption{Average time over partial chain profiles is more sensitive to the Borda rule when increasing the chain size, and increases linearly with the number of candidates or voters for all rules.}
	\label{fig:pc}
\end{figure}

\e{Truncated voting profiles.} In this experiment, we fixed the number of candidates to be 80, and varied the top and bottom sizes of the truncated rankings, and the number of voters.
For each parameter setting, we generated 10 voting profiles and computed the average running time of \mew with the candidate pruning strategy. 

Figure~\ref{fig:tr:tb} demonstrates that the top and bottom size has no impact on the running time over plurality and 2-approval, which is expected since these voting rules only need information about the top-1 or 2 ranked candidates. Under Borda, \mew computation is faster for higher top and bottom size, also as expected, since uncertainty in the truncated rankings decreases accordingly.  Finally, Figure~\ref{fig:tr:n} demonstrates that the running time over truncated voting profiles increases linearly with the number of voters.

\begin{figure}[tb!]
	\centering
	\subfloat[80 cand, 1000 voters]{
		\label{fig:tr:tb}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_tr_80_candidates_1000_voters__time_vs_k}
	}\hspace{5em}
	\subfloat[\rev{80 cand, top / bottom size 5}]{
		\label{fig:tr:n}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_tr_80_candidates_5_k__time_vs_voters}
	}~
	\caption{Average time over truncated voting profiles. It stays the same for plurality and 2-approval, but steadily decreases, when increasing the top and bottom sizes of the truncated rankings. It increases linearly with the number of voters.}
	\label{fig:tr}
\end{figure}

\subsection{Probabilistic voting profiles}

\e{Mallows voting profiles.}
We generate synthetic profiles to test the performance of the RIM solver over its special case, the Mallows model.  We vary the number of candidates from 10 to 80, and the dispersion parameter $\phi$ from 0.1 to 0.9, generate 10 profiles for each parameter setting, and report the average running time, with pruning, in Figure~\ref{fig:mallows}.
Figure~\ref{fig:mallows:m} shows that the solver scales well with the number of candidates, while Figure~\ref{fig:mallows:phi} shows that the time to compute \mew is insensitive to the Mallows parameter $\phi$.

\begin{figure}[tb!]
	\centering
	\subfloat[$\phi = 0.5$, varying \#candidates]{
		\label{fig:mallows:m}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_mallows_1000_voters_phi_05__time_vs_m}
	}\hspace{5em}
	\subfloat[10 candidates, varying $\phi$]{
		\label{fig:mallows:phi}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_mallows_10_candidates_1000_voters__time_vs_phi}
	}~
	\caption{Average time over Mallows voting profiles, fixing 1000 voters. It increases linearly with the number of candidates, while the $\phi$ has little impact over the running time.}
	\label{fig:mallows}
\end{figure}

\e{RSM voting profiles.} This experiment uses exactly the same voting profiles as the experiment above for Mallows models. Since rRSM generalizes the Mallows model, we converted the Mallows models into rRSM instances and invoked the RSM solver for these converted voting profiles.
Compared to Figure~\ref{fig:mallows:m}, Figure~\ref{fig:rsm:m} shows better scalability with regards to increasing number of candidates, especially for the plurality and 2-approval rules.
Figure~\ref{fig:rsm:phi} gives a similar conclusion as Figure~\ref{fig:mallows:phi} that the dispersion of the preferences has little impact over the running time.

\begin{figure}[tb!]
	\centering
	\subfloat[$\phi = 0.5$, varying \#candidates]{
		\label{fig:rsm:m}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_rsm_1000_voters_phi_05__time_vs_m}
	}\hspace{5em}
	\subfloat[10 candidates, varying $\phi$]{
		\label{fig:rsm:phi}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_rsm_10_candidates_1000_voters__time_vs_phi}
	}~
	\caption{Average time over RSM voting profiles, fixing 1000 voters. It increases linearly with the number of candidates, while the equivalent $\phi$ has little impact over the running time.}
	\label{fig:rsm}
\end{figure}

\subsection{Combined voting profiles}

\e{Mallows with fully partitioned preferences.} In this experiment, we investigate the impact of the Mallows $\phi$ on the running time.
All voting profiles have 10 candidates, 1000 voters, and 2 partitions for the partitioned preferences.
Figure~\ref{fig:mallows|fp} shows that the Mallows $\phi$ has little impact on the running time, and that the running time under plurality and 2-approval rules are almost identical.  Similar trends were observed for more than 2 partitions, and we do not report these results here.

\e{Mallows with truncated rankings.} The setup of this experiment is similar to the above, for Mallows combined with fully partitioned preferences, except that the top and bottom sizes of the truncated rankings are fixed to be 3, instead of fixing the number of partitions.
Figure~\ref{fig:mallows|tr} demonstrates that the dispersion $\phi$ has little impact on the running time.  Similar trends were observed for other truncated ranking sizes, and we do not report these results here.

\e{Mallows with partial orders.} The setup of this experiment is similar to the previous two experiments for combined voting profiles. All voters in a profile have the same Mallows model. Their partial orders are generated by RSMs whose selection probabilities are derived from dispersion $\phi$ of their Mallows, and each voter has an independent edge construction probability vector sampled from $p_{max} = 0.9$. Figure~\ref{fig:mallows|po} shows that $\phi$ substantially impacts the running time: The computation of \mew is faster with a small $\phi$ value, especially for Borda.  This is expected, because the voters exhibit stronger consensus for lower values of $\phi$, and so the pruning strategy is more effective.

\begin{figure}[tb!]
	\centering
	\subfloat[$\mallowsPartitionVP$]{
		\label{fig:mallows|fp}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_mallowsWfp_10_candidates_1000_voters__time_vs_phi}
	}\hfill
	\subfloat[$\VP^{\mallows \text{+TR}}$]{
		\label{fig:mallows|tr}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_mallowsWtr_10_candidates_1000_voters__time_vs_phi}
	}\hfill
	\subfloat[$\VP^{\mallows \text{+PO}}$]{
		\label{fig:mallows|po}
		\includegraphics[width=0.3\linewidth]{figs/synthetic_mallowsWpo_10_candidates_1000_voters__time_vs_phi}
	}~
	\caption{Average time over combined voting profiles. The $\phi$ has little impact over the running time when the Mallows models are combined with fully partitioned preferences or truncated rankings, while the running time increases with $\phi$ for voting profiles of the Mallows combined with partial orders, especially under the Borda rule. }
	\label{fig:combined}
\end{figure}


\begin{figure}[tb!]
	\centering
	\includegraphics[width=0.3\linewidth]{figs/real_crowdrank__time_vs_rule}
	\caption{Running time on CrowdRank. Computing \mew under Borda is slower than under plurality or 2-approval.}
	\label{fig:crowdrank}
\end{figure}

\subsection{Real datasets}

Figure~\ref{fig:crowdrank} compares the running time of computing \mew under 3 voting rules for the 50 HITs in CrowdRank.
Recall that each HIT has its own set of 20 movies and 100 partial chains over these movies.
The experiment result shows that the voting rule has a significant impact on the running time.
It took much longer to compute \mew under the Borda rule, compared to plurality and 2-approval.

\begin{table}[b!]
	\caption{Computing \mew for real datasets}
	\begin{tabular}{@{}cccccc@{}}
		\toprule
		\multirow{2}{*}{Dataset} & \multicolumn{1}{c}{\multirow{2}{*}{\#cand}} & \multicolumn{1}{c}{\multirow{2}{*}{\#voters}} &                       \multicolumn{3}{c}{Running time (in seconds)}                        \\
		\cmidrule(l){4-6}     &          \multicolumn{1}{c}{}          &          \multicolumn{1}{c}{}          & \multicolumn{1}{c}{plurality} & \multicolumn{1}{c}{2-approval} & \multicolumn{1}{c}{Borda} \\ \midrule
		MovieLens         &                  200                   &                  6040                  &           \rev{137}           &           \rev{140}            &         \rev{344}         \\ \midrule
		Travel          &                   24                   &                  5456                  &          \rev{0.57}           &           \rev{0.49}           &        \rev{0.35}         \\ \bottomrule
	\end{tabular}
	\label{tab:movielens_n_travel}
\end{table}

Table~\ref{tab:movielens_n_travel} presents the running time of \mew over MovieLens and Travel, with number of items
$m$ (\ie movies and attraction categories, respectively), and  number of voters $n$. 
MovieLens is a partially partitioned voting profile of 200 movies.
It took about 38 minutes to compute the \mew under both plurality and 2-approval rules, and the winner is \e{American Beauty} in both cases.
In comparison, \e{Star Wars: Episode IV - A New Hope} is the winner under Borda, computed in around 100 minutes. 
Travel is a fully partitioned voting profile with 24 attraction categories. It took less than 1 second to compute the \mew under all three voting rules, which yields \e{museums} as the winner.