We have provided the first comprehensive set of ideas to handle
infinite graph streaming with bulk expiration events, including theory
and a prototype implementation.  Despite its use of the network interconnect
and MPI message passing rather than memory access, the prototype sometimes
matches the ingestion rate of a purely on-node Intel/TBB benchmark.  Slow
downs are data-dependent and might be mitigated by a multithreaded
implementation and algorithm engineering.  Furthermore, performance of
a single \XSCC ring will benefit from advances in computer architecture.
Although our prototype operates correctly, future work would be
necessary to engineer a production version.


To close, we consider the possibility improving X-Stream's ingestion
rate by orders of magnitude.  It is
possible to do this if we leverage a key property of most real graphs:
\emph{the giant component}.  Suppose that we must ingest such a graph
via hundreds or thousands of disjoint streams, and suppose that we
instantiate an independent \XSCC instance for each.  We note that with
overwhelming likelihood, each \XSCC instance will ingest a portion of
the global giant component.  Using ideas from Section~\ref{sec:non-constant},
each \XSCC instance can stream its $O(\log n)$-sized components out to
a ``small-component server'' (and notify that server of vertices in
components that have joined the giant component).  The small-component
server would handle any connectivity query not involving the giant
component (of which there are relatively few). Full detail is
beyond the scope of this paper and we leave for future work.
