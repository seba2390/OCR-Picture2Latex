\setcounter{algorithm}{0}
\begin{algorithm*}
\caption{This is the driver function for an X-Stream implementation that is
compliant with Invariants~\ref{inv:normal-1}, \ref{inv:normal-2}, and
\ref{inv:aging-1}, and Property~\ref{prop:all-recycled}.
         \label{algo:pseudocode-driver}}
         X-Stream connected components driver \\
\makealgtitle
\begin{algorithmic}[1]

\Procedure{ProcessBundle}{\Call{PrimaryEdge}{e}, \Call{PayloadEdges}{$e_i$}}
%\LeftComment{Precondition: input ``raft'' containing $\Call{Primary}{e}, \Call{Payload}{e_i}$, where payload exists only during aging}
\State  \Call{PackingSpaceAvailable}{} $= k$  \Comment{ the output buffer has size $k$ and is initially empty}
    \If {\Call{EmptyEdge}{$e$}}
\State  \Call{Pack}{EmptyEdge}  \Comment{any call to \Call{Pack}{} decrements \Call{PackingSpaceAvailable}{}}
    \Else \ \ \ \Call{ProcessEdge}{$e$}
    \EndIf
    \For {$e_i \in \Call{PayloadEdges}{}$} \Comment{there are payload edges only during aging or non-constant query processing}
\State  \Call{ProcessEdge}{$e_i$}
    \EndFor

\If {\Call{Not}{AGING}}
\State \Call{Emit}{PackedBundle}
\State \Return
\EndIf
\LeftComment{Aging-related logic}
    \If {\Call{Loader}{}}
        \If {\Call{Head}{}}  \Comment{the Head's testing \& resolution phase}
            \For {$i = 1, k-1$} 
\State          $e'$ = {\Call{PopEdge}{UNTESTED}} 
                \If {\Call{EmptyEdge}{$e'$}}
\State              \Call{Pack}{LoaderToken}
\State              \Call{Break}{}
                \EndIf
                \If {\Call{AgingPredicatePassed}{$e'$}}
                    \If {$i = k-1$ \mbox{and} \Call{Full}{}} 
\State                  \Call{Pack}{$e', \Call{Primary}{}$} \Comment{jeopardy edge}
                    \Else
\State                  \Call{ProcessEdge}{$e'$} \Comment{\Call{Head}{} immediately resolves surviving edge}
                    \EndIf
                \Else
\State              \Call{Delete}{$e'$}
                \EndIf
            \EndFor
        \Else   \Comment{ Downstream resolution phase (all testing has finished)}
            \For {$i \in 0, \ldots, \Call{PackingSpaceAvailable}{} - 1$}
\State          $e'$ = \Call{PopEdge}{UNRESOLVED}
                \If {\Call{NULL}{$e'$}}
\State              \Call{Pack}{LoaderToken}
\State              \Call{Break}{}
                \Else
\State              \Call{Pack}{e'}
                \EndIf
            \EndFor
        \EndIf
    \Else  \Comment{ Downstream testing phase}
        \If {\Call{Not}{HEAD} \Call{And}{} \Call{NotEmpty}{UNTESTED}}
            \For {$i = 1, k-1$} 
\State          $e'$ = {\Call{PopEdge}{UNTESTED}}
                \If {\Call{AgingPredicatePassed}{$e'$}}
\State              \Call{PushEdge}{$e'$, UNRESOLVED} 
                \Else
\State              \Call{Delete}{$e'$}
                \EndIf
            \EndFor
        \EndIf
    \EndIf
\State \Call{Emit}{PackedBundle}
\EndProcedure
\end{algorithmic}
\end{algorithm*}


Algorithms~\ref{algo:pseudocode-driver} and \ref{algo:pseudocode-functions}
show the \XSCC driver and constituent functions, respectively, for 
processing edges. We do not show full detail for token passes, commands,
and queries.
These functions maintain the invariants and produce a compliant XS-CC
% macro foils LaTeX line breaking
implementation.  We used this pseudocode as guidance for the code
that produces our experimental results.

Each \XStream processor executes \Call{ProcessBundle}{} whenever it receives
the next bundle of edge slots, regardless of its current execution mode
(normal or aging).  It will process each slot in turn, and the 
constituent functions \Call{ProcessEdge}{}, \Call{ProcessPotentialTreeEdge}{},
and \Call{StoreOrForward}{} determine what to pack into an
output bundle destined to flow downstream.

Note that the top-level logic of processing the primary and payload
edges of a bundle is the same in Algorithm~\ref{algo:pseudocode-driver}, 
regardless of execution mode.  When a new
edge arrives from the stream, processors upstream of (and including) the 
building processor will classify it as tree or non-tree using the
relabeling logic of Section~\ref{sec:relabeling} (Lines 15-18 of 
\Call{ProcessEdge}{} and Lines 2-4 of \Call{ProcessPotentialTreeEdge}{}).
The builder stores any new tree edge. We ensure that this is
possible via logic to jettison an unresolved edge if one exists 
(only during aging; Lines 9 and 16 of \Call{StoreOrForward}{}), or else 
to jettison a non-tree edge (Line 15
of \Call{StoreOrForward}{}).  This progression of jettison logic maintains
Invariants~\ref{inv:normal-1} and \ref{inv:normal-2}.

Suppose that the head processor $p_H$ receives notification of an aging event
at \XStream tick $t$.  \XStream ticks $t$ and $t+1$ are especially interesting. 
If a new edge arrives in the input stream at $t+1$, it must be stored 
in $p_H$ (which
is now acting as both the builder $p_B$ and the loader $p_L$) in
order to maintain Invariant~\ref{inv:aging-1}.  However, $p_H$ has had only
one tick to initiate the process of testing its edges against the aging
predicate.  That means that it tested $k-1$ edges in tick $t$.  Suppose all
of these edges survived the predicate and therefore couldn't be deleted.
This is a jeopardy condition, and it was handled during tick $t$ by 
Lines 20-21 of 
\Call{ProcessBundle}{}.  Favoring the new edge, $p_H$ jettisoned in the
primary slot of its output bundle the last of the $k-1$ unresolved edges
it created in that tick.  Therefore, at tick $t+1$ we are assured that $p_H$ 
can store a new stream edge.

During aging, the loader $p_L$ packs unresolved edges into the empty payload
slots in incoming bundles to be sent around the ring.  When these edges
arrive at $p_H$, they are processed as if they were new stream edges,
classified as tree or non-tree, and incorporated into the data structures
in $\{p_H,\ldots,p_B\}$ by the same invariant-maintaining constituent 
functions that handle new edges.  One optimization we include is that
$p_H$ need not actually pack and send its unresolved edges around the
ring.  Rather, in Lines 13-23 of \Call{PackBundle}{}, $p_H$ simply tests
against the aging predicate and immediately processes its tested edges
rather than calling them unresolved.  

As aging proceeds, the \Call{Loader}{} token is passed downstream whenever
a processor exhausts its list of unresolved edges (Lines 28-31 of 
\Call{ProcessBundle}{}). Once the \Call{Loader}{} token exits the tail
processor, Property~\ref{prop:all-recycled} is established.


\begin{algorithm*}
\caption{These three constituent functions comprise the 
X-Stream algorithm for maintaining connected components.\label{algo:pseudocode-functions}}
         X-Stream constituent functions \\
\makealgtitle
\begin{algorithmic}[1]
\LeftComment{Processor $p_a$ receives an edge}
\Procedure{ProcessEdge}{$e=(u,v,R_{a-1}(u),R_{a-1}(v))$}
          \If {\Call{Duplicate}{e}} \Comment{regardless of $p_a$'s position in the chain, duplicate edges don't propagate downstream}
\State        \Call{SetNewestTimestamp}{e}  \Comment{During aging, either $e$ or its stored duplicate could be the newest}
              \If {\Call{Primary}{e}}
\State            \Call{Pack}{EmptyEdge} \Comment{bundles drive \XS ticks, \Call{ProcessBundle}{} requires a primary edge}
              \EndIf
\State        \Call{Return}{}
          \EndIf
          \If {\Call{DownstreamOfBuilder}{}} \Comment{$p_B \prec p_a$ : $p_a$ stores only non-tree and/or unresolved edges}
              \If {\Call{Primary}{e}} \Comment{need to store this edge if we can in order to ensure Invariant~\ref{inv:normal-2}}
\State            \Call{StoreOrForward}{e}        \Comment{\Call{StoreOrForward}{} accepts $e$ or packs it for output}
              \Else \Comment{\Call{Payload}{e}, i.e., aging}
\State            \Call{Pack}{e}         \Comment{processors downstream of the Builder simply propagate payload edges}
              \EndIf
\State        \Call{Return}{}
          \EndIf
\LeftComment{Processor $p_a$ contains connected component information, i.e., $p_a \prec = p_B$} 
          \If {$R_{a-1}(u) = R_{a-1}(v)$}   \Comment{previously-discovered non-tree edge}
\State        \Call{StoreOrForward}{e} 
          \ElsIf {\Call{Not}{\Call{ProcessPotentialTreeEdge}{e}}}\Comment{newly-discovered non-tree edge}
\State        \Call{StoreOrForward}{e}
          \EndIf
\EndProcedure
\end{algorithmic}

\begin{algorithmic}[1]
\Procedure{ProcessPotentialTreeEdge}{e=(u,v,\ldots)}
\State   $(R_a(u),R_a(v)) = $ \Call{Relabel}{e}
         \If {$R_a(u) = R_a(v)$}  \Comment{newly-discovered non-tree edge}
\State        \Call{Return}{FALSE}
         \EndIf
         \If {\Call{Builder}{}}      \Comment{builder $p_B$ must ingest tree edge $e$}
\State        \Call{Assert}{\Call{StoreOrForward}{e} = STORE} \Comment{ensure Invariant~\ref{inv:normal-1}}
              \If {\Call{FullOfTreeEdges}{}}
\State             \Call{Pack}{BuilderToken} \Comment{can be encoded with a bit; doesn't take a whole slot}
              \EndIf
         \Else \ \ \ \Call{Pack}{e}  \Comment{$p_a$ has previously sealed, so it is already full of tree edges}
         \EndIf
\State   \Call{Return}{TRUE}\Comment{still a potential tree edge; downstream processors will determine that}
\EndProcedure
\end{algorithmic}

\begin{algorithmic}[1]
\Procedure{StoreOrForward}{e=(u,v,\ldots)}
\LeftComment{Precondition: if $e$ is a tree edge, this processor is not full of TREE edges}
         \If {\Call{Full}{}}
             \If {\Call{Tail}{}}
\State            \Call{Fail}{} \Comment{the system is totally full}
             \EndIf
             \If {\Call{Unresolved}{$e$}}
\State                 \Call{Pack}{$e$}
\State                 \Call{Return}{FORWARD}
             \EndIf
\State       $e_p = $ \Call{PopEdge}{UNRESOLVED} \Comment{jettison an unresolved edge to keep a resolved one, if possible}
             \If {\Call{EmptyEdge}{$e_p$}} \Comment{no more edges to resolve}
                  \If {\Call{NonTree}{$e$}}
\State                 \Call{Pack}{$e$}  \Comment{no need to jettison a non-tree edge if $e$ is non-tree}
\State                 \Call{Return}{FORWARD}
                  \Else \Comment{by precondition, there must be a non-tree edge to jettison}
\State                 \Call{Pack}{\Call{PopEdge}{NONTREE}} \Comment{jettison a non-tree edge to keep a tree edge}
                  \EndIf
             \Else \ \ \ \Call{Pack}{$e_p$}
             \EndIf
         \EndIf
         \If{\Call{Primary}{e}} \Call{Pack}{\Call{EmptyEdge}{}}  \Comment{every output raft needs a primary edge}
         \EndIf
\State   \Call{Accept}{e}  \Comment{perform UNION/FIND if $\Call{Tree}{e}$}
\State   \Call{Return}{STORE}
\EndProcedure
\end{algorithmic}
\end{algorithm*}
