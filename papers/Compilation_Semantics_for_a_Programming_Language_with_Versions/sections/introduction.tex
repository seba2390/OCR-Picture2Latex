\section{Introduction}
\label{introduction}
Updating dependent software packages is one of the major issues in software development. Even though a newer version of a package brings improvements, it also brings the risk of breaking changes, which can make the entire software defective.

We argue that this issue originates from the principle of most programming languages that only allow the use of one version of a package at a time. Due to this principle, developers are faced with the decision to either update to a new, improved version of a package that requires many changes or to remain with an older version. The problem gets worse when a package is indirectly used. This dilemma often results in delays in adopting upgrades, leading to stagnation in software development and maintenance~\cite{6676878,10.1007/s10664-014-9325-9}.

\emph{Programming with versions}~\cite{Tanabe:2018:CPA:3242921.3242923,Tanabe_2021,batakjava2022,bundling2023} is a recent proposal that allows programming languages to support multiple versions of programming elements at a time so that the developer can flexibly cope with incompatible changes. \corelang{} is the core calculus in which a \emph{versioned value} encapsulates multiple versions of a value (including a function value). The \corelang{} type system checks the consistency of each term so that a value produced in a version is always passed to functions in the same version. The calculus and the type system design are based on coeffect calculus~\cite{brunel_core_2014,Orchard:2019:Granule}.

While \corelang{} offers the essential language constructs to support multiple versions in a program, the language is far from practical. For example, with  multiple versions of a module, each version of the function must be manually represented inside a versioned value (i.e., a record-like expression). \corelang{} is as simple as lambda calculus, yet it has a verbose syntax due to the coeffect calculus. In short, there are aspects of versioning in \corelang{} that a surface language compiler can automate.

We propose the functional language \mylang{} as a surface language for \corelang{} along with its compilation method. In \mylang{}, a function name imported from an external module represents a multi-version term, where each occurrence of the function name can reference a different version of the function. The \mylang{} compiler translates a program into an intermediate language \vlmini{}, a version-label-free variant of \corelang{}, determines the version for each name occurrence based on a type and version inference algorithm, and translates it back into a version-specialized Haskell program.
\mylang{} also offers the constructs to explicitly control versions of expressions, which are useful to keep using an older version for some reason.  

This paper presents the following techniques in \mylang{}: (a) \emph{an application of Girard's translation} for translating \mylang{} into \vlmini{}, (b) \emph{the bundling} for making a top-level function act as a versioned value, and (c) \emph{a type and version inference algorithm} for identifying the version of each expression with respect to the \corelang{} type system. Finally, we prove the soundness of the inference system and implement a \mylang{} compiler. Code generation converts a \mylang{} program into a version-specialized Haskell program using the solution obtained from z3~\cite{10.1007/978-3-540-78800-3_24}.

\vspace{-0.5\baselineskip}
\paragraph{Paper Organization.}
Section \ref{overview} introduces incompatibility issues and fundamental concepts in programming with versions with \corelang{} and \mylang{}.
Section \ref{compilation} introduces bundling and Girard's transformation.
Section \ref{inference} presents an algorithmic version inference for \mylang{}.
Section \ref{implementation} features an implementation of \mylang{}, and Section \ref{casestudy} introduces a case study that simulates an incompatible update made in a Haskell library.
Finally, Section \ref{conclusion} discusses further language development and concludes the paper by presenting related work and a conclusion.