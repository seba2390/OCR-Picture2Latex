\section{Algorithmic Type Inference}
\label{inference}
\input{./rules/rule_algorithmic_typing}
We develop the algorithmic type inference for \vlmini{} derived from the declarative type system of \corelang{}~\cite{Tanabe:2018:CPA:3242921.3242923,Tanabe_2021}.
The type inference consists of two judgments: \emph{type synthesis} and \emph{pattern type synthesis}.
The judgment forms are similar to Gr~\cite{Orchard:2019:Granule}, which is similarly based on coeffect calculus.
While Gr provides type-checking rules in a bidirectional approach~\cite{10.1145/2544174.2500582,10.1145/3290322} to describe resource constraint annotations and performs unifications inside the type inference, \vlmini{} only provides synthesis rules and unification performs after the type inference.
In addition, Gr supports user-defined data types and multiple computational resources, while \vlmini{} supports only built-in data structures and specializes in version resources.
The inference system is developed to be sound for declarative typing in \corelang{}, with the proof detailed in Appendix \ref{appendix:vlmini_safety}.

Type synthesis takes type variable kinds $\Sigma$, a typing context $\Gamma$ of term variables, and a term $t$ as inputs. Type variable kinds $\Sigma$ are added to account for distinct unification variables for types and version resources.
The synthesis produces as outputs a type $A$, type variable kinds $\Sigma'$, type constraints $\Theta$, and dependency constraints $\mathcal{C}$.
The type variable kinds $\Sigma$ and $\Sigma'$ always satisfy $\Sigma \subseteq \Sigma'$ due to the additional type variables added in this phase.

Pattern type synthesis takes a pattern $p$, type variable kinds $\Sigma$, and resource environment $R$ as inputs. It synthesizes outputs, including typing context $\Gamma$, type variable kinds $\Sigma'$, and type and dependency constraints $\Theta$ and $\mathcal{C}$.
Pattern type synthesis appears in the inference rules for $\lambda$-abstractions and case expressions. It generates a typing context from the input pattern $p$ for typing $\lambda$-bodies and branch expressions in case statements.
When checking a nested promoted pattern, the resource context $R$ captures version resources inside a pattern.

\subsection{Pattern Type Synthesis}
% \input{./rules/rule_pattern_synthesis}
Pattern type synthesis conveys the version resources captured by promoted patterns to the output typing context. The rules are classified into two categories, whether or not it has resources in the input resource context $R$. The base rules are \textsc{pVar}, \textsc{p}$\Box$, while the other rules are resource-aware versions of the corresponding rules. The resource-aware rules assume they are triggered within the promoted pattern and collect version resource $r$ in the resource context.

The rules for variables \textsc{pVar} and \textsc{[pVar]} differ in whether the variable pattern occurs within a promoted pattern. \textsc{pVar} has no resources in the resource context because the original pattern is not inside a promoted pattern. Therefore, this pattern produces typing context $x:A$. \textsc{[pVar]} is for a variable pattern within the promoted pattern, and a resource $r$ is recorded in the resource context. The rule assigns the collected resource $r$ to the type $A$ and outputs it as a versioned assumption $x:\verctype{A}{r}$.

The rules for promoted patterns \textsc{p}$\square$
propagate version resources to the subpattern synthesis. The input type $A$ is expected to be a versioned type, so the rule generates the fresh type variables $\alpha$ and $\beta$, then performs the subpattern synthesis considering $A$ as $\vertype{\alpha}{\beta}$. Here, the resource $\alpha$ captured by the promoted pattern is recorded in the resource context. Finally, the rule unifies $A$ and $\vertype{\alpha}{\beta}$ and produces the type constraints $\Theta'$ for type refinement.









\subsection{Type Synthesis}
The algorithmic typing rules for \vlmini{}, derived from declarative typing rules for \corelang{}, are listed in Figure \ref{fig:rule_algorithmic_typing}. We explain a few important rules in excerpts.

The rule $\Rightarrow_{\textsc{abs}}$ generates a type variable $\alpha$, along with the binding pattern $p$ of the $\lambda$-abstraction generating the typing context $\Gamma'$. Then the rule synthesizes a type $B$ for the $\lambda$-body under $\Gamma'$, and the resulting type of the $\lambda$-abstraction is $\alpha \rightarrow B$ with the tentatively generated $\alpha$.
With the syntax sugar, the type rules of the contextual-let are integrated into $\Rightarrow_{\textsc{abs}}$.
Instead, $\lambda$-abstraction does not just bind a single variable but is generalized to pattern matching, which leverages pattern typing, as extended by promoted patterns and data constructors. 

The rule $\Rightarrow_{\textsc{pr}}$ is the only rule that introduces constraints in the entire type inference algorithm.
This rule intuitively infers consistent version resources for the typing context $\Gamma$. Since we implicitly allow for weakening, we generate a constraint from $\Gamma'$ that contains only the free variables in $t$, produced by \emph{context grading} denoted as $[\Gamma]_\textsf{Labels}$.
Context grading converts all assumptions in the input environment into versioned assumptions by assigning the empty set
for the assumption with no version resource.

Finally, the rule generates constraints from $\Gamma'$ and a fresh type variable $\alpha$ by constraints generation defined in the lower part of Figure \ref{fig:rule_algorithmic_typing}.
The rules assert that the input type variable $\alpha$ is a subset of all the resources of the versioned assumptions in the input environment $\Gamma$. The following judgment is the simplest example triggered by the type synthesis of $\pr{\app{f}{x}}$.
\begin{align*}
r:\labelskind,s:\labelskind \,\vdash\, \alpha \sqsubseteq_{c} f:\verctype{\ftype{\inttype}{\inttype}}{r}, x:\verctype{\inttype}{s} \rhd \alpha \preceq r \land \alpha \preceq s
\end{align*}
The inputs are type variable $\alpha$ and the type environment ($f:\verctype{\ftype{\inttype}{\inttype}}{r}, x:\verctype{\inttype}{s}$). In this case, the rules generate variable dependencies for $r$ and $s$, each resource of the assumptions, and return a constraint combined with $\land$.

\subsection{Extensions}
\subsubsection{Version Control Terms}
The rule for $\verof{l}{t}$ uses the same trick as ($\Rightarrow_\textsc{pr}$), and generates label dependencies from the input environment $\Gamma$ to $\cs{l}$. Since $\verof{l}{t}$ only instructs the type inference system, the resulting type is the same as $t$.
$\unver{t}$ removes the version resource from the type of $t$, which is assumed to be a versioned value. We extend Girard's translation so that $t$ is always a versioned value.
Since a new resource variable is given to the term by the promotion outside of \textbf{unversion}, the inference system guarantees the version consistency inside and outside the boundary of \textbf{unversion}.
The list of the rules is provided in Appendix \ref{appendix:vlmini_version_control_terms}.


% \vspace{-\baselineskip}
\subsubsection{Data Structures}
To support data structures, Hughes et al. suggest that coeffectful data types are required to consider the interaction between the resources inside and outside the constructor~\cite{EPTCS353.6}. They introduce the derivation algorithm for \emph{push} and \emph{pull} for an arbitrary type constructor $K$ to address this.

\begin{center}
\begin{minted}{haskell}
push : @$\forall$@{a b: Type, r: Labels}. (a,b)[r] -> (a[r],b[r])
push [(x, y)] = ([x], [y])
pull : @$\forall$@{a b: Type, m n: Labels}. (a[n],b[m]) -> (a,b)[n@$\sqcap$@m]
pull ([x], [y]) = [(x, y)]
\end{minted}
\end{center}

Following their approach, we developed inference rules for pairs and lists.
When a data structure value $p$ is applied to a function $f$, the function application $\app{f}{p}$ is implicitly interpreted as $\app{f}{(\app{pull}{p})}$. As a dual, a pattern match for a data structure value $\caseof{p}{\overline{p_i \mapsto t_i}}$ is interpreted as $\caseof{(\app{push}{p})}{\overline{p_i \mapsto t_i}}$.
Appendix \ref{appendix:vlmini_data_structures} provides the complete set of extended rules.
