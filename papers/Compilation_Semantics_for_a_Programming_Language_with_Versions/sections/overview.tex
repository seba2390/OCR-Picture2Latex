% Section Template
\section{Overview} % Main Section title
\label{overview}
\subsection{Motivating Example}
\label{sec:motivatingexample}
\input{./figs/fig2-1}
First, we will explain a small example to clarify incompatibility issues. Consider a scenario where an incompatible change is made to a dependent package. Figure \ref{fig2-1} shows the package dependencies in a file explorer \mn{App} based on a hash-based file search. This function is developed using the system library \mn{Dir} and the cryptography library \mn{Hash}. For simplicity, we equate packages and modules here (each package consists of a single module), and we only focus on the version of \mn{Hash}. The pseudocode is written in a Haskell-like language.

Before its update, \mn{App} depends on version 1.0.0 of \mn{Hash} (denoted by $\dashrightarrow$). The \mn{App}'s \fn{main} function implements file search by a string from standard input using \fn{mkHash} and \fn{exists}.
The function \fn{mkHash} is in version 1.0.0 of \mn{Hash}, and it generates a hash value using the MD5 algorithm from a given string. \mn{Hash} also provides a function \fn{match} that determines if the argument string and hash value match under \fn{mkHash}.
The function \fn{exists} is in version 1.0.0 of \mn{Dir}, which is also dependent on version 1.0.0 of \mn{Hash}, and it determines if a file with a name corresponding to a given hash exists. 

Due to security issues, the developer of \mn{App} updated \mn{Hash} to version 2.0.0 (denoted by \textcolor{red}{$\longrightarrow$}). In version 2.0.0 of \mn{Hash}, SHA-3 is adopted as the new hash algorithm. Since \mn{Dir} continues to use version 1.0.0 of \mn{Hash}, \mn{App} needs two different versions of \mn{Hash}. 
Various circumstances can lead to this situation: \mn{Dir} may have already discontinued maintenance, or functions in \mn{Dir}, other than \fn{exists}, might still require the features provided by version 1.0.0 of \mn{Hash}.

Although the update does not modify \mn{App}, it causes errors within \mn{App}. Even if a file with an input filename exists, the program returns \texttt{Not Found} error contrary to the expected behavior. The cause of the unexpected output lies in the differences between the two versions required for \fn{main}. In line 6 of \mn{App}, an SHA-3 hash value is generated by \fn{mkHash} and assigned to \texttt{digest}. Since \fn{exists} evaluates hash equivalence using MD5, \texttt{exists digest} compares hashes generated by different algorithms, evaluating to \texttt{false}.

This example highlights the importance of version compatibility when dealing with functions provided by external packages. Using different versions of \mn{Hash} in separate program parts is fine, but comparing results may be semantically incorrect. Even more subtle changes than those shown in Figure \ref{fig2-1} can lead to significant errors, especially when introducing side effects or algorithm modifications that break the application's implicit assumptions. Manually managing version compatibility for all external functions is unfeasible.

In practical programming languages, dependency analysis is performed before the build process to prevent such errors, and package configurations requiring multiple versions of the same package are rejected. However, this approach tends towards conservative error reporting.
In cases where a core package, which many other libraries depend on, receives an incompatible change, no matter how minuscule, it requires coordinated updates of diverse packages across the entire package ecosystem~\cite{10.1007/s10664-014-9325-9,Tanabe_2021,semvertrick}.



\subsection{\corelang{}}
\label{core}
\corelang{}~\cite{Tanabe:2018:CPA:3242921.3242923,Tanabe_2021} is a core calculus designed to follow the principles: (1) enabling simultaneous usage of multiple versions of a package, (2) ensuring version consistency within a program. \corelang{} works by encapsulating relevant terms across multiple versions into a record-like term, tagged with a label indicating the specific module version. Record-like terms accessible to any of its several versions are referred to as \emph{versioned values}, and the associated labels are called \emph{version labels}.

% \vspace{-\baselineskip}
\subsubsection{Version Labels}
Figure \ref{syntax:lambdavl} shows the syntax of \corelang{}.
Given modules and their versions, the corresponding set of version labels characterizes the variation of programs of a versioned value. 
In \corelang{}, version labels are implicitly generated for all external module-version combinations, in which $M_i$ is unique, with the universal set of these labels denoted by $\mathcal{L}$. 
Specifically, in the example illustared in Figure \ref{fig2-1}, $\mathcal{L} = \{l_1,l_2\}$ and $l_1 = \{\mn{Hash} = 1.0.0,\,\mn{Dir} = 1.0.0\}, l_2 = \{\mn{Hash} = 2.0.0,\,\mn{Dir} = 1.0.0\}$.
The size of $\mathcal{L}$ is proportional to $V^M$ where $M$ is the number of modules and $V$ is the maximum number of versions.

\input{syntax/lambdavl}
% \vspace{-\baselineskip}
\subsubsection{Syntax of \corelang{}}
\corelang{} extends \lrpcf{}~\cite{brunel_core_2014} and GrMini~\cite{Orchard:2019:Granule} with additional terms that facilitate introducing and eliminating versioned values.
Versioned values can be introduced through versioned records $\nvval{\overline{l_i=t_i}}$ and promotions $\pr{t}$.
A versioned record encapsulates related definitions $t_1,\ldots,t_n$ across multiple versions and their version labels $l_1,\ldots,l_n$.
For instance, the two versions of \fn{mkHash} in Figure \ref{fig2-1} can be bundled as the following version record.
\begin{align*}
\mathit{mkHash}\quad:=\quad
&
\begin{aligned}
    \{&l_1=\lam{s}{\textnormal{\com{make MD5 hash}}},\\
    &l_2=\lam{s}{\textnormal{\com{make SHA-3 hash}}}\}
\end{aligned}
\end{align*}

In \corelang{}, programs are constructed via function application of versioned values. A function application of \fn{mkHash} to the string \texttt{s} can be written as follows.
\begin{align*}
\mathit{app}\quad:=\quad
\begin{aligned}
&\clet{\mathit{mkHash'}}{\mathit{mkHash}}{
    \\&\clet{s}{
        \pr{``\mathtt{compiler.vl}"}
    }{
        \pr{\app{\mathit{mkHash'}}{s}}
    }
}
\end{aligned}
\end{align*}

This program ($app$ hereafter) makes a hash for the string ``\texttt{compiler.vl}" and is available for both $l_1$ and $l_2$.
The contextual let-binding $\clet{x}{t_1}{t_2}$ provides the elimination of version values by binding a versioned value for $t_1$ to $x$, thus making it accessible in $t_2$.
Promotion $\pr{x}$ offers an alternative way to introduce versioned values, making any term $t$ act as a versioned value.

The evaluation of terms $t_i$ stored in a versioned value $\nvval{\overline{l_i=t_i}}$ and $\pr{t}$ is postponed until a specific version label is later specified.
To proceed with a postponed evaluation of a versioned value, we use extraction $u.l_k$. Extraction specifies one versioned label $l_k$ for the versioned value $u$ and recursively extracts the inner term $t_k$ corresponding to $l_k$ from $\nvval{l_i=t_i}$, and $t$ from $\pr{t}$ as follows.
\begin{align*}
\mathit{app}\#l_1\quad:=\quad
&
\begin{aligned}
&\clet{\mathit{mkHash'}}{\mathit{mkHash}}{
    \\&\clet{s}{
        \pr{``\mathtt{compiler.vl}"}
    }{
        \pr{\app{\mathit{mkHash'}}{s}}
    }
}.l_1
\end{aligned}\\
\longrightarrow^* \quad&\app{(\lam{s}{\textnormal{\com{make MD5 hash}}})}{``\mathtt{compiler.vl}"}\\
\longrightarrow^{\phantom{*}}\quad &\texttt{4dcb6ebe3c6520d1f57c906541cf3823}
\end{align*}

Consequently, $\mathit{app}\#l_1$ evaluates into an MD5 hash corresponding to $l_1$.
\vspace{-\baselineskip}
\subsubsection{Type of Versioned Values}
The type of a versioned value is expressed as \vertype{r}{A}, assigning a set of version labels $r$, called \textit{version resources}, to a type $A$. Intuitively, the type of a versioned value represents the versions available to that versioned value. For example, $\mathit{mkHash}$ and $\mathit{app}$ are typed as follows.
\begin{align*}
\mathit{mkHash}\,:\,\vertype{\{l_1,l_2\}}{\left(\ftype{\strtype{}}{\strtype{}}\right)}\quad
\mathit{app}\,:\,\vertype{\{l_1,l_2\}}{\left(\ftype{\strtype{}}{\strtype{}}\right)}
\end{align*}

The types have $\{l_1,l_2\}$ as their version resource, illustrating that the versioned values have definitions of $l_1$ and $l_2$.
For function application, the type system computes the intersection of the version resource of subterms.
Since the promoted term is considered to be available in all versions, the version resource of the entire function application indicates $\{l_1,l_2\} = \{l_1,l_2\} \cap \mathcal{L}$.

For extractions, the type system verifies if the version resource contains the specified version as follows.
\begin{align*}
\mathit{app}\#l_1\,:\,\ftype{\strtype{}}{\strtype{}} \quad
\mathit{app}\#{\textcolor{red}{l_3}}\,:\,\textcolor{red}{(rejected)}
\end{align*}

Assuming $\mathcal{L} = \{l_1,l_2,l_3\}$, $\mathit{app}\#{\textcolor{red}{l_3}}$ is rejected by type checking because the version resource of $\mathit{app}$ does not contain $l_3$. Conversely, $\mathit{app}\#l_1$ is well-typed, but note that the resultant type lost its version resource. It is attributed to the design principle that it could be used in other versions upon extraction.

The \corelang{} type system incorporates the notion of version consistency in addition to the standard notions of preservation and progress. Proofs of these theorems can be found in Appendix \ref{appendix:lambdavl_safety}.





\subsection{Programming with Versions in \mylang{}}
\input{figs/fig2-3}
Our contributions enjoy the benefits of programming with versions on a $\lambda$-calculus-based functional language \mylang{}. To achieve this, we develop a compilation method between lambda calculus and \vlmini{}, a version-label free variant of \corelang{}, and a version inference algorithm to infer the appropriate version of expressions.

In \mylang{}, (1) all versions are available for every module, and (2) the version of each expression is determined by expression-level dependency analysis. This approach differs from existing languages that determine one version for each dependent package.
Figure \ref{fig2-3} shows how the programs in Figure \ref{fig2-1} are interpreted in \mylang{}.
The \mylang{} compiler bundles the interfaces of multiple versions and generates a cross-version interface to make external functions available in multiple versions.
The \mylang{} type system enforces version consistency in \fn{main} and selects a newer version if multiple versions are available. Thus it gives the version label $\{\mn{Hash} = 2.0.0,\,\mn{Dir} = 1.0.0\}$ to dependent expressions of \fn{main}. As a result, since \mn{Hash} version referenced from \mn{Dir} is no longer limited to 1.0.0, \texttt{exists digest} is evaluated using SHA-3 under the context of \mn{Hash} version 2.0.0.

Furthermore, \mylang{} provides \emph{version control terms} to convey the programmer's intentions of versions to the compiler. For example, to enforce the evaluation in Figure \ref{fig2-3} to MD5, a programmer can rewrite line 7 of \mn{App} as follows.

\begin{minted}[linenos,numbersep=2pt,highlightcolor=white,firstnumber=7,highlightlines={7}]{haskell}
  if @\vlkey{ver}@ [@\textcolor{blue}{\textbf{Hash}}@=1.0.0] of (exists digest)
\end{minted}
The program dictates that \texttt{exists digest} is evaluated within the context of the \mn{Hash} version 1.0.0. Consequently, both \fn{mkHash} and \fn{match}, which depend on \texttt{exists digest}, are chosen to align with version 1.0.0 of \mn{Hash}.
Moreover, \mylang{} provides \texttt{\vlkey{unversion} t}. It eliminates the dependencies associated with term \texttt{t}, facilitating its collaboration with other versions under the programmer's responsibility, all while maintaining version consistency within its subterm.
Thus, \mylang{} not only ensures version consistency but also offers the flexibility to control the version of a particular part of the program.

