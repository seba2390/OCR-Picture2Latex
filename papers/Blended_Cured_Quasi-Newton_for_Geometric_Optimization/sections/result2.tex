\section{Evaluation}
\label{sec:results}

\subsection{Implementation}

We implemented a common test-harness code to enable the consistent
evaluation of the comparitive performance and convergence behavior
of SGD, PN, CM, AQP, L-BFGS and BCQN across a range of energies and
geometry optimization tasks including parameterization as well as
2D and 3D deformations, where these methods allow. For AQP this extends
the number of energies it can be tested with, while more generally
providing a consistent environment for evaluating all methods. We
hope that this code will also help support the future evaluation
and development of new methods for geometry optimization.

The main body of the test code is in MATLAB to support rapid
prototyping.  All linear system solves are performed with MATLAB's
native calls to SuiteSparse~\cite{Chen:2008:ACS} with additional
computational-heavy modules, primarily common energy, gradient and
iterative LCP evaluations, implemented in C++.  As linear solves
are the bottleneck in all methods covered here, an additional
speed-up to all methods is possible with
Pardiso~\cite{Petra:2014:AAI,Petra:2014:RTS} in place of SuiteSparse;
however, as discussed in Section~\ref{sec:pardiso} this does not change
the relative merits of the methods, and would add an additional external
dependency to the test code. For verification we also confirm that
iterations in the test-harness AQP and CM implementations match the
official AQP~\cite{Kovalsky:2016:AQP} and CM~\cite{Shtengel:2017:GOV}
codes.

All experiments were timed on a four-core Intel
3.50GHz CPU. We have parallelized the damped Jacobi LCP iterations
with Intel TBB; with more cores the overhead reported below for LCP
iterations is expected to diminish rapidly.
For all UV parameterization problems we compute 
initial locally injective embeddings via the initialization code
from Kovalsky et al.~\shortcite{Kovalsky:2016:AQP}. On rare occasions
this code fails to find a locally injective map, so we
then revert to a Tutte embedding as a failsafe using the initialization
code from Rabinovich et al.~\shortcite{Rabinovich:2016:SLI}. To
enforce Dirichlet boundary conditions, i.e.\ positional constraints,
we use a standard subspace projection~\cite{Nocedal:2006:Book}, i.e.\
removing those degrees of freedom from the problem.
When line search is employed we first find a
maximal non-inverting step size with Smith and
Schaefer's method~\shortcite{Smith:2015:BPW}, followed by standard
line search with Armijo and curvature conditions.

\subsection{Termination} 
\label{sec:term_results}

To evaluate termination criteria behavior we first instrumented two
geometry optimization stress-test examples: the \emph{Swirl}
deformation~\cite{Chen:2013:PSI} and the \emph{Hilbert curve} UV
parametrization~\cite{Smith:2015:BPW}. We run both examples to
convergence ($10^{-6}$ using our characteristic gradient) reaching
the final target shapes for each. Within these optimizations we
record the 2-norm of gradient, the vertex-normalized 2-norm of
gradient, the
relative error measure~\cite{Kovalsky:2016:AQP,Shtengel:2017:GOV}
and our characteristic gradient norm for all iterations.

\begin{figure}[t]
\vspace{3mm}
\centering
\includegraphics[width=1\linewidth]{figures/Figures_Term/Swirl_Term_Compare}
\caption{\bfi{Termination criteria comparison.} {\bf Left to right:}
We find key points in the sequential progress of the optimized mesh
in the Swirl optimization (ISO energy) example at regular intervals of $10\times$ decrease
in our characteristic norm. We compare with the relative error measures at these same points.}
\label{fig:swirl_term_compare}
\vspace{3mm}
\end{figure}

Figure~\ref{fig:swirl_term_compare} shows the Swirl mesh
obtained during BCQN iteration at regular intervals of $10\times$
decrease in our characteristic norm. Observe
that they correspond to natural points of progress;
see our supplemental video of the entire optimization sequence
for reference. For comparison we also provide the corresponding relative
error measures, which varies much less steadily.

In Figure~\ref{fig:ours_yaron} we compare
termination criteria more closely for a UV parametrization
problem, the Hilbert curve example. We plot our characteristic gradient norm
(blue) and the relative energy error~\cite{Kovalsky:2016:AQP,Shtengel:2017:GOV}
(orange) as BCQN proceeds. Note
that the characteristic gradient norm provides consistent decrease
corresponding to improved shapes and so provides a
practical measure of improvement. The local error in energy, on the
other hand, varies greatly, making it impossible to judge how much
global progress has been made towards the optimum.

\begin{figure}[h!]
\vspace{3mm}
\centering
\includegraphics[width=1\linewidth]{figures/Figure_A_4/ours_yaron}
\caption{\bfi{Measuring improvement.} 
Solving a UV parametrization of the Hilbert curve with BCQN, we plot our
characteristic gradient norm in \blue{blue} and the relative energy
error in \orange{orange} as the method proceeds, on a logarithmic scale.
Iterates are shown at decreases in the characteristic gradient norm
by factors of 10, illustrating its efficacy as a global measure of progress,
while the relative energy error measures only local changes with little
overall trend.}
\label{fig:ours_yaron}
\vspace{3mm}
\end{figure}

Figure~\ref{fig:term_compare_2} illustrates consistency across
changing tolerance values, mesh resolutions, and scales.
example.  We show the iterates at measures
$10^{-3}$, $10^{-4} $and $10^{-5}$ for both our characteristic gradient
norm and the raw gradient norm, for meshes with varying refinement and
varying dimension (rescaling coordinates by a large factor). Similar
to Figure~\ref{fig:term_compare_1} comparing the vertex-normalized gradient
norm, there are large disparities for the raw gradient norm, but our
characteristic gradient norm is consistent.

\begin{figure}[h!]
\vspace{3mm}
\centering
\includegraphics[width=1\linewidth]{figures/Figures_Term/grad_l2_geo_compare}
\caption{\bfi{Termination criteria comparison across mesh refinement and scale.}
{\bf Left and right}: we show the Swirl optimization
when our characteristic norm (left) and the standard gradient
norm (right) reach $10^{-3}, 10^{-4}$ and $10^{-5}$.
{\bf Top to bottom}: the rows show
optimization with a coarse mesh, a fine mesh, and the
same fine mesh uniformly scaled in dimension by $100\times$.
Note the consistency across mesh resolution and scaling
for our characteristic norm and
the disparity across the standard gradient norm.}
\label{fig:term_compare_2}
\end{figure}

\paragraph{Tolerances} The Swirl and Hilbert curve examples are
both extreme stress tests that require passing through low curvature
regions to transition from unfolding to folding; see e.g.,
Figure~\ref{fig:swirl_term_compare} above and our videos. For these
extreme tests we used a tolerance of $10^{-6}$ for our characteristic
gradient norm to consistently reach the final target shape.
However, for most practical geometry optimization tasks such a tolerance
is excessively precise. In experiments across a wide range of
energies and UV parametrization, 2D and 3D deformation tasks,
including those detailed below, we found that
$\|\nabla E(x)\| \leq 10^{-3} \langle W \rangle \| \ell(V,T) \|$
consistently obtained good-looking solutions with essentially no
further visible (or energy value) improvement possible. We
argue this is a sensible default except in pathological examples.
For all examples discussed here and below, with the exception of the
Swirl and the Hilbert curve tests, we thus use $\epsilon=10^{-3}$ for
testing termination.

\begin{figure*}[h!]
\centering
\includegraphics[width=1\linewidth]{figures/Figure_A_3/iso_2d_scale_table}
\caption{\bfi{UV Parameterization Scaling, Timing and Sparsity.}
Performance statistics and memory use for increasing mesh
sizes up to 23.9M triangles, comparing BCQN with AQP, PN
and CM. For the Gorilla UV parametrization with ISO energy we
repeatedly double the mesh resolution and, for each method, report
number of iterations to convergence (characteristic norm $< 10^{-3}$),
wall-clock time (seconds) to convergence, and the nonzero fill-in
for the linear systems solved by each method. We use \red{\bf*} to
indicate out-of-memory failure for matrix factorization; see
\S\ref{sec:results} for discussion. Also note that stencils for CM
and PN are identical (differing only by actual entries) while AQP
and BCQN both solve with the same smaller scalar Laplacian.}
\label{fig:2d_scale_table}
\end{figure*}


\subsection{Newton-type methods}
\label{sec:newton-type}

While Newton's method, on its own, handles convex energies like ARAP well~\cite{Chao:2010:ASG}
it is insufficient for nonconvex energies: modification of the Hessian is
required~\cite{Shtengel:2017:GOV,Nocedal:2006:Book}. Here we examine
the convergence, performance and scalability of Projected Newton (PN)~\cite{Teran:2005:RQF},
a general-purpose modification for nonconvex energies, and
CM~\cite{Shtengel:2017:GOV}, a more recent convex majorizer currently restricted
to 2D problems and a trio of energies (ISO, Symmetric ARAP and NH), and compare them with 
AQP and BCQN.
For the 2D parameterization problems in Figure~\ref{fig:2d_scale_table}
we can compare all four methods while for the 3D deformation
problems in Figures~\ref{fig:3d_scale_table} and \ref{fig:3d_large_defo}
CM is not applicable.

As we increase the size of the 2D problem by mesh refinement in
Figure~\ref{fig:2d_scale_table}, both CM and PN maintain low and almost constant
iteration counts to converge, with CM enjoying an advantage for larger problems;
in Figure~\ref{fig:3d_scale_table} 

Figures~\ref{fig:2d_scale_table}, \ref{fig:3d_scale_table}, and
\ref{fig:3d_large_defo} examine the scaling behavior of the various
methods under mesh refinement, for 2D parameterization and 3D deformation.
The Newton-type methods PN and CM (when applicable) maintain low
iteration counts that only grow slowly with increasing mesh size;
from the outset BCQN and AQP require more iterations, though the iteration count
also grows slowly for BCQN. Nonetheless, BCQN is the fastest across
all scales in each test as its overall cost per iteration remains much lower.
BCQN iterations require no re-factorizations (which scales poorly, particularly
in 3D, as discussed in Section \ref{sec:alg}) and only solves
smaller and sparser scalar Laplacian problems per coordinate compared
to the larger and denser system of CM and PN. This advantage for BCQN only
increases as problem size grows; indeed, for the largest problems BCQN
succeeded where CM and PN ran out of memory for factorization.

\subsection{A Note on Solving Proxies and Pardiso} 
\label{sec:pardiso}

Recent methods including CM have taken advantage of the efficiencies
and optimizations provided by the Pardiso solver.
While this can improve runtime of the factorization and backsolves
by a constant factor, it cannot change the asymptotic lower bounds on complexity;
the sparse matrix orderings in both SuiteSparse and Pardiso already appear
to achieve the bound on typical mesh problems.
In tests on our computer, across a large range of scales in two and
three dimensions, we found Pardiso was occasionally slower than
SuiteSparse but usually 1.4 to 3 times faster, and at most to 8.1 times faster
(for backsolving with a 3D scalar Laplacian).

Individual iterates of AQP have the same overall efficiency as BCQN (dominated
by the linear solves); switching to Pardiso leaves the relative performance of the two methods
unchanged. While CM and PN are even more dependent on the efficiency of the linear solver,
due to more costly refactorization each step, the same speed-ups possible with Pardiso also apply to
BCQN, so again there is no significant change in relative performance between the
methods.

\begin{figure}[h!]
\vspace{3mm}
\centering
\includegraphics[width=1\linewidth]{figures/Figure_A_2/iso_3d_scale_table}
\caption{\bfi{Three-Dimensional Deformation Scaling, Timing and
Sparsity.} Performance statistics and memory use for increasing
mesh sizes up to 7.8M tetrahedra, comparing BCQN with AQP
and PN. (CM does not extend to 3D.) We initialize a bar with a
straight rest shape to start in a tightly twisted shape, constraining
both ends to stay fixed and then optimize over increasing resolutions.
For each method we report number of iterations to convergence
(characteristic norm $< 10^{-3}$), wall-clock time (seconds) to
convergence, and the nonzero fill-in for the linear system solved
by each method. We use \red{\bf*} to indicate out of memory for the
computation on our test system; see \S\ref{sec:results} for discussion.
}
\label{fig:3d_scale_table}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=1\linewidth]{figures/Figure_A_7/3d_defo}
\caption{\bfi{Armadillo Deformation Test}. We compare three-dimensional
deformation optimizations of a 1.5M element tetrahedral mesh of the
T-pose armadillo with BCQN and PN. We constrain the armadillo's
feet to rest position, its hands to touch the ground and use the
LBD method to create a locally injective
initialization for the solvers. Here BCQN requires 393 iterations
to converge while PN converges in just 9. However, as BCQN is much
cheaper and more scalable per iterate it takes only 4,148 seconds,
while PN spends 13,447 seconds.}
\label{fig:3d_large_defo}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=1\linewidth]{figures/Figure_6A/uv_table_1}
\caption{\bfi{UV parameterization.} {\bf Top row:}  3D meshes  for
UV parametrization with ISO, MIPS, and CONF distortion energies.
{\bf Middle two rows:} converged maps and texturing from BCQN on
ISO examples. {\bf Bottom:} for each method / problem pair we report
number of iterations to convergence (characteristic norm $< 10^{-3}$)
and wall-clock time (seconds) to convergence. We use ${\bf \dagger}$
to indicate when AQP does not converge; see \S\ref{sec:1st}.}
\label{fig:uv_table}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=1\linewidth]{figures/Figure_7A/2d_table_1}
\caption{\bfi{Two-Dimensional Deformation.} {\bf Top:}  initial
conditions and vertex constraints (blue points) for deformation
problems minimizing ISO, MIPS, and NH deformation energies. {\bf
Middle:} converged solutions from BCQN on ISO examples. {\bf Bottom:}
for each method / problem pair we report number of iterations to
convergence (characteristic norm $< 10^{-3}$) and wall-clock time
(seconds) to convergence. We use ${\bf \dagger}$ to indicate when
AQP does not converge; see \S\ref{sec:1st}.}
\label{fig:2d_defo_table}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[width=1\linewidth]{figures/Figure_8A/3d_table_1}
\caption{ \bfi{Three-Dimensional Deformation.} {\bf Top:}  initial
conditions for vertex-constrained deformation problems minimizing
ISO and MR deformation energies. {\bf Middle:} converged solutions
satisfying constraints from BCQN on MR examples. {\bf Bottom:} for
each method / problem pair we report number of iterations to
convergence (characteristic norm $< 10^{-3}$) and wall-clock time
(seconds) to convergence. }
\label{fig:3d_defo_table}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{First-order methods}
\label{sec:1st}

Among existing first-order methods for geometry optimization AQP
has so far shown best efficiency~\cite{Kovalsky:2016:AQP} with
improved convergence over SGD as well as standard L-BFGS.
Likewise, as we see in Figures\ \ref{fig:2d_scale_table},
\ref{fig:3d_scale_table}, and \ref{fig:3d_large_defo}, when we scale
to increasingly larger problems AQP will dominate over Newton-type
methods and so potentially offers the promise of reliability across
applications. Finally although small BQCN performs a small fixed
amount of extra work per-iteration in the line-search filter and
quasi-Newton update. Thus in Figures\ \ref{fig:2d_scale_table},
\ref{fig:3d_scale_table}, \ref{fig:uv_table} and \ref{fig:3d_defo_table}.
we compare AQP and BCQN over a range of practical geometry optimization
applications: respectively UV-parameterization, 2D deformation, and
3D deformation with nonconvex energies from geometry processing and
physics.  Throughout we note three key features distinguishing BCQN:

\bfi{Reliability and robustness.} 
AQP will fail to converge in some cases, see e.g. Figure\ \ref{fig:aqp_stop}, while BCQN reliably converges. In our testing AQP fails to converge in over 40\% of our tests with nonconvex energies; see e.g. Figures~\ref{fig:uv_table} and \ref{fig:2d_defo_table}.
This behavior is duplicated in our test-harness code and AQP's reference implementation.

\bfi{Convergence speed.} When AQP is able to converge, BCQN consistently provides faster convergence rates for nonconvex energies. In our experiments convergence rates range up to well over 10X with respect to AQP.

\bfi{Performance.} BCQN is efficient. When AQP is able to converge, BCQN remains fast with up to a well over 7X speedup over AQP on nonconvex energies.

\subsection{Across the Board Comparisons} 

Here we compare the performance and memory usage of BCQN with best-in-class geometry optimization methods across the board: AQP, PN and CM for both 2D parameterization and 3D deformation tasks. Results are summarized in Figures\ \ref{fig:2d_scale_table}, \ref{fig:3d_scale_table} and \ref{fig:3d_large_defo}. Note that CM does not extend to 3D.

In Figures~\ref{fig:2d_scale_table} and \ref{fig:3d_scale_table} we examine the scaling of AQP, PN, CM and BCQN to larger meshes and thus to larger problem sizes in both 2D parametrization (up to 23.9M triangles) and 3D deformation (up to 7.8M tetrahedra). As noted above: from the outset, BCQN requires more iterations than CM and PN; however, BCQN's overall low cost per iteration makes it faster in performance across problem sizes when compared to both CM and PN. We then note that AQP, on the other hand, has slower convergence and so, at smaller sizes it often does not compete with CM and PN. However, once we reach larger mesh problems, e.g. $\sim\geq$ 6M triangles in Figure~\ref{fig:2d_scale_table}, the cost of factorization and backsolve of the denser linear systems of CM and PN becomes significant so that even AQP's slower convergence results in improvement. This is the intended domain for which first-order methods are designed but here too, as we see in Figure~\ref{fig:2d_scale_table}, BCQN continues to outperform both AQP as well as CM and PN across all scales. Please see our supplemental video for visual comparisons of the relative progress of PN, CM, AQP and BCQN.
