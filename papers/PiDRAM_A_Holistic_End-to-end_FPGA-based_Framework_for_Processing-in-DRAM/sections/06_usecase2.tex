

\label{sec:drange}

%\outline{reintroduce drange}
{Prior work on DRAM-based random number generation techniques~\cite{olgun2021quactrng,kim.hpca19,talukder2019exploiting} do not integrate and evaluate their techniques end-to-end in a real system.}
\revdel{D-RaNGe~\cite{kim.hpca19} (Section~\ref{sec:background_pudram}) {is a state-of-the-art} DRAM-based true random number generat{ion technique} that leverages the randomness in DRAM activation latency ($tRCD$) failures.} \new{We evaluate one DRAM-based true random number generation technique, D-RaNGe~\cite{kim.hpca19}, end-to-end using PiDRAM.} We implement support for D-RaNGe in PiDRAM by enabling \omi{access to DRAM with} \new{reduced activation latency} (i.e., \omi{$tRCD$ set to values lower than} manufacturer recommendations).

\subsection{D-RaNGe Implementation}

We implement a simple version of D-RaNGe in PiDRAM. PiDRAM's D-RaNGe \omi{controller} collects true random numbers from four DRAM cells in the same DRAM cache block %\footnote{D-RaNGe observes that there can be as many as four TRNG cells in a DRAM cache block} 
\omi{inside} one DRAM bank. 
%These random numbers are put into a 1 KiB buffer in the custom memory controller.
%Application developers can modify the rate at which true random numbers are generated via pumolib. This enables calibrating PiDRAM's TRNG according to workloads' random number requirements, i.e., if the workload requires a high-throughput stream of random numbers, the programmer can increase the rate at the expanse of increased interference with other memory requests.
%\todo{insert figure.}
We implement the \omi{D-RaNGe controller} within the \revf{Periodic Operations Module \new{(Section~\ref{sec:hardware-components})}}. The \omi{D-RaNGe controller} (i) periodically accesses a DRAM cache block with reduced tRCD, (ii) reads four of the TRNG DRAM cells in the cache block, (iii) stores the four bits read from the TRNG cells in a 1 KiB \new{random number buffer}. We reserve multiple configuration registers in the configuration register file (CRF) to configure (i) the \omi{TRNG period (in nanoseconds) used by} the \omi{D-RaNGe controller} to periodically generate random numbers \omi{by accessing DRAM with reduced activation latency} while the buffer is not full (the D-RaNGe controller accesses DRAM every TRNG period), (ii) the timing parameter ($tRCD$) used \omi{to} induc\omi{e} activation latency failures and (iii) the \new{physical} location \new{(DRAM bank, row, column addresses, and bit offset within the DRAM column)} of the TRNG cells \omi{to read}. We implement two pumolib functions: (i) \texttt{buf\_\omi{size}()}, which returns the number of random words (4-bytes) available in the buffer, and (ii) \texttt{rand\_dram()}, which returns one random word that is read from the buffer. {The two functions \new{first} execute PiDRAM instructions in the POC that \new{update} the data register either with (i) the number of random words available \new{(when buf\_s\omi{ize}() is called)} or (ii) a random word read from the random number buffer \new{(when rand\_dram() is called)}. The two functions \new{then} access the data register using LOAD instructions to retrieve \omi{either} the size of the random number buffer or a random number.} The application developer reads true random numbers using these two functions in pumolib.

\noindent
\textbf{\new{Random Cell Characterization.}} D-RaNGe requires the system designer to characterize the DRAM module for activation latency failures to find DRAM cells that fail with a 50\% probability \omi{(i.e., randomly)} when accessed with reduced $tRCD$. \revd{Following the methodology presented in~\cite{kim.hpca19}, the system designer can characterize a DRAM device or use an automated procedure to find cells that fail with a 50\% probability.} \omi{In PiDRAM,} we implement reduced latency access to DRAM by (i) extending the scheduler of the custom memory controller and (ii) adding a pumolib function \texttt{\omi{activation\_failure}(\omi{address})} which induces an activation failure on the DRAM cache block pointed by the \texttt{\omi{address}} parameter.

\subsection{Evaluation and Results}
\label{sec:drange-evaluation}
\textbf{Experimental Methodology.} We run a microbenchmark to understand the effect of the TRNG period on true random number \omi{generation} throughput observed by a program running on the \omi{R}ocket core. The microbenchmark consists of a loop that (i) checks the availability of random numbers using \texttt{buf\_\omi{size}()} and (ii) reads a random number from the buffer using \texttt{rand\_dram()}. \newnew{We execute the microbenchmark until we read one million bytes of random numbers.} 

\begin{figure}[!ht]
  \centering
  \vspace{-5mm}
  \includegraphics[width=0.40\textwidth]{figures/rng-throughput.pdf}
  \vspace{-3mm}
  \caption{TRNG throughput observed by our microbenchmark for TRNG periods ranging from 220 $ns$ to 1000 $ns$}
  \label{fig:trng-throughput}
\end{figure}

\noindent
\textbf{Results.} \omi{The D-RaNGe controller} can perform reduced-latency accesses frequently, every 220 $ns$. Figure~\ref{fig:trng-throughput} depicts the TRNG throughput observed by the microbenchmark for TRNG periods in the range [220 $ns$, 1000 $ns$] with increments of 10 $ns$. We observe that the TRNG throughput decreases from 8.30 Mb/s at 220 $ns$ TRNG period to 1.90 Mb/s at 1000 $ns$ TRNG period. D-RaNGe~\cite{kim.hpca19} reports 25.2 Mb/s TRNG throughput using a single DRAM bank when there are \new{four} random cells in a cache block. PiDRAM's \omi{D-RaNGe controller} can be optimized to generate random numbers more frequently to match D-RaNGe's observed maximum throughput.\footnote{\omi{D-RaNGe has a smaller true random number generation (TRNG) latency (i.e., takes a smaller amount of time to generate a 4-bit random number) than PiDRAM. PiDRAM has a larger TRNG latency due to (i) discrepancies in the data path (i.e., on-chip interconnect) in D-RaNGe's simulated system and PiDRAM's prototype and (ii) \omu{the TRNG period of the D-RaNGe controller (D-RaNGe controller performs a reduced $tRCD$ access only as frequently as one every \SI{220}{\nano\second}).} \omu{The D-RaNGe controller} can be optimized further to reduce the TRNG period \omu{by} down to the DRAM row cycle time ($tRC$ standard timing parameter, typically ~\SI{45}{\nano\second}~\cite{micron2018ddr3}).}} We leave such optimizations to PiDRAM's \omi{D-RaNGe controller} for future work.

%We make two observations.  We observe that the TRNG throughput starts deteriorating when the TRNG period hits 2400 $ns$. \todo{double check results and finalize observations.}

Including the modifications to the custom memory controller and pumolib, implementing D-RaNGe and reduced-latency DRAM access \new{requires} an additional \textbf{190} lines of Verilog and \textbf{74} lines of C code over \X's existing codebase. We conclude that our D-RaNGe implementation (i) provides a basis for \X developers to study end-to-end implementations of \omi{DRAM-based true random number generators}, (ii) shows that \X's hardware and software components facilitate the implementation of new {commodity DRAM based} PuM techniques\omi{, specifically those that are related to security}. Our reduced-latency DRAM access implementation provides a basis for other PuM techniques \omi{for security purposes}, such as \omi{the DRAM-latency physical unclonable functions (}DL-PUF~\cite{kim.hpca18}) \omi{and QUAC-TRNG~\cite{olgun2021quactrngieee} (Section~\ref{sec:use-cases})}. We leave further exploration on end-to-end implementations of D-RaNGe\omi{, DL-PUF, and QUAC-TRNG, as well as end-to-end analyses of \omu{the} security benefits they provide using PiDRAM} for future work.

%Algorithm~\ref{alg:trng_microbenchmark} describes our microbenchmark. Line 2 sets the TRNG period of PiDRAM's TRNG controller. Line 4 loops until the random number buffer contains a valid random number. Line 4 reads a 16-bit true random number from the buffer. Line 3 loops for 512K times such that the microbenchmark reads 1 MBs of true random numbers from the buffer.

\iffalse
\begin{algorithm}[tbh]\footnotesize
        \SetAlgoNlRelativeSize{1.0}
        %\SetAlgoNoLine
        \DontPrintSemicolon
        %\SetAlCapHSkip{0pt}
        \caption{TRNG Microbenchmark}
        \label{alg:trng_microbenchmark}
        for ($period = 100ns$ ; $period$ <= $10000ns$ ; $period$ += $100ns$)\par 
        ~~~~configure\_trng($period$) \par
        ~~~~for ($i = 0$ ; $i$ < 512K ; $i$++)\par
        ~~~~~~~~while ($random\_buffer\_size == 0$); \par
        ~~~~~~~~$read\_random\_number()$; \par
    \end{algorithm}
\fi
