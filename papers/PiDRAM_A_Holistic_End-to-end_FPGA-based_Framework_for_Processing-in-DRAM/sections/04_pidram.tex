%\jgl{I think an overview section would be good. Then, next section can go into implementation details.}
%\jgl{Having an overview figure soon can also help us organize the section/s.} 
%\vspace{-1mm}

\sloppy
\revdel{\atb{We design the \X framework to} {solve system integration challenges and analyze trade-offs of end-to-end implementations of {commodity DRAM based} PuM techniques}
facilitate end-to-end implementations of {commodity DRAM based} PuM techniques.}
\new{Implementing commodity DRAM based PuM techniques end-to-end requires developing new hardware (HW) and software (SW) components or augmenting existing components with new functionality (e.g., memory allocation for RowClone requires a new memory allocation routine in the OS, Section~\ref{sec:rowclone_alignment}).}
To ease the process of modifying various components across the hardware and software stack to implement new PuM techniques, \X provides key HW and SW components. Figure~\ref{fig:pidram-overview} presents an overview of the HW and SW components of the \X framework. \Copy{R4/8}{{Later in Section~\ref{sec:execution-overview}, we describe the general workflow for executing a PuM operation on PiDRAM.}}
\begin{figure*}[!h]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/02_overview.pdf}
  \caption{{PiDRAM overview. {Modified h}ardware {(in green)} and software {(in blue)} components. \revd{Unmodified components are in gray.} {A pumolib function executes load and store instructions in the CPU to perform PuM operations (in red).} We use yellow to highlight the key hardware structures that are controlled by the user to perform PuM operations.}}% \jgl{Rocker Core -> RISC-V CPU Core}}% \jgl{Make those numbers a little bit smaller. They are ugly.}}
  \label{fig:pidram-overview}
\end{figure*}
\label{sec:pidram}
\begin{table*}[!b]
  \centering
  \caption{{Pumolib functions}}
  \label{table:pumolib}
  \scriptsize
  \begin{tabular}{@{} lm{15em}m{46em} @{}}
  \toprule
  {\textbf{Function}} &  {\textbf{Arguments}} &  {\textbf{Description}}\\        
  \midrule
  \textbf{set\_timings} & RowClone\_T1, RowClone\_T2, tRCD & Updates CRF registers with the timing parameters used in RowClone (\emph{T1} and \emph{T2}) and D-RaNGe (\emph{tRCD}) operations.\\
  \textbf{rng\_configure} & period, address, bit\_offsets & Updates CRF registers, configuring the random number generator to to access the DRAM cache block at \emph{address} every \emph{period} cycles and collect the bits at \emph{bit\_offsets} from the cache block.\\
  \textbf{copy\_row} & source\_address, destination\_address & Performs a RowClone-Copy operation in DRAM from the \emph{source\_address} to the \emph{destination\_address}.\\
  \textbf{activation\_failure} & address & Induces an activation failure in a DRAM location pointed by the \emph{address}.\\
  \textbf{buf\_\omi{size}} & - & Returns the \newnew{number of random words in} the random number buffer.\\
  \textbf{rand\_dram} & - & Returns 32 bits \newnew{(\omi{i.e.,} random words)} from the random number buffer.\\
  \midrule
  \end{tabular}
\end{table*}
%We identify \atb{four} common components that are shared across end-to-end implementations of DRAM-based PuM techniques. The two HW components: \textbf{(i) an easy-to-extend memory controller} enables rapid implementation of \juan{specific} DDRx command sequences \juan{necessary to control PuM operations, % beyond
%e.g., sequences that violate} manufacturer-recommended \juan{timing} thresholds to perform PuM operations, \textbf{(ii) an ISA-transparent PuM controller} maintains compatibility between various processor microarchitectures, and provides a way of controlling PuM operations without making invasive modifications to the underlying processor microarchitecture.} 
%\textbf{(iii) a general controller $\longleftrightarrow$ application interface \todo{protocol}} that enables system designers to directly communicate PuM execution parameters to the memory controller, 
%\atb{The two SW components: \textbf{(i) an extensible software library} contains customizable functions which are used by applications to perform PuM operations, \textbf{(ii) a custom supervisor software} provides the necessary OS primitives (e.g., virtual memory) to explore system-level solutions that are required to implement PuM techniques end-to-end. 


%We design \atb{the} \X framework to facilitate end-to-end implementations of \atb{PuM} techniques. Implementing support for PuM techniques requires modifications across the HW/SW stack. \X comprises \atb{\emph{the necessary} HW/SW components} and interfaces to facilitate implementing new PuM techniques. Figure~\ref{fig:pidram-overview} presents an overview of HW/SW components of the \X framework. \X provides (i) ISA-transparent control (i.e., using conventional STORE/LOAD operations) of PuM techniques, \atb{to provide a framework compatible with microprocessors that implement different ISAs, and to enable designers to implement new PuM techniques without interfering with the microarchitecture employed in the system}, (ii) a general \emph{application} $\longleftrightarrow{}$ \emph{controller} interface that \atb{enables applications to express} PuM techniques in hardware, (iii) a new, custom and easy-to-extend memory controller that \atb{facilitates implementation of new} PuM \atb{techniques}, (iv) an extensible software library \atb{that uses the \emph{application} $\longleftrightarrow{}$ \emph{controller} interface to} to control PuM operations, \atb{which enables system designers to quickly implement the software support for PuM techniques} and (v) a \atb{custom} supervisor software that supports the \atb{necessary} OS primitives (e.g., virtual memory) to enable end-to-end exploration of PuM techniques. 
% PiDRAM builds on \atb{top of} the open-source rocket-chip SoC generator, which has been used numerous times to generate silicon-proven hardware~\cite{X}. 

%We demonstrate a prototype of PiDRAM on the Xilinx ZC706 FPGA board. \atb{We explain each component \X comprises in the remainder of this section.}


\subsection{Hardware Components}
\label{sec:hardware-components}

%\todo{Why do we need these structures? What does each component offer, be general/abstract? Motivate why we need these. Bring examples (e.g., we will use this for RowClone as we describe in Section~\ref{X})}

{PiDRAM comprises two key hardware components. Both of these components are designed with the goal to provide a flexible and easy to use framework for evaluating PuM techniques.}

%\X comprises two key hardware components that facilitate the implementation of new \atb{PuM} \tacorevcommon{operations}. \atb{First, to enable ISA-transparent control of PuM techniques, we implement the PuM operations controller (POC). \revd{The CPU} access\revd{es} (using memory LOAD/STORE instructions) the memory-mapped registers in POC to execute in-DRAM operations. Second, to facilitate the implementation of new DDRx command sequences on \X, we implement a modular and flexible custom memory controller.}

\textbf{\ding{182} PuM Operations Controller \newnew{(POC)}.} {POC decodes and executes PiDRAM instructions (e.g., RowClone-Copy~\cite{seshadri2013rowclone} that are used by the programmer to perform PuM operations. POC communicates with the rest of the system over two well{-}defined interfaces. First, it communicates with the CPU over a memory-mapped interface{, where the CPU can send data to or receive data from POC using memory store and load instructions}. The CPU accesses the memory-mapped registers (\emph{instruction}, \emph{data}, and \emph{flag} registers) in POC to execute in-DRAM operations. This improves the portability of the framework and facilitates porting the framework to systems that employ different instruction set architectures. Second, {POC} communicates with the memory controller to perform PuM operations in the DRAM chip over a simple hardware interface. {To do so,} POC (i) requests the memory controller to perform a PuM operation, (ii) waits until the memory controller performs the operation, and (iii) receives the result of the PuM operation from the memory controller. The CPU can read the result of the operation by executing load instructions that target the \emph{data} register in POC.}

%The functions in PuM operations library (pumolib) perform PuM operations by executing LOAD/STORE instructions that target the \atb{instruction, data, and flag} registers.
%\jgl{Last sentence seems disconnected from the explanation of POC.}

%\textbf{PuM Operations \todo{protocol}.} \atb{The PuM operations interface (POI) defines the communication protocol between the POC and the memory controller.} POI implements a general interface that enables application developers to express the information required to execute PuM operations to the memory controller. POI abstracts the hardware communication protocol between the POC and the custom memory controller from the application developer. \atb{By setting the \emph{start} bit in the \emph{flag} register, the application developer initiates a PuM operation. The memory controller responds by setting the \emph{ack} bit in the \emph{flag} register upon receiving the PuM \emph{instruction} and starts performing the corresponding operation. When an operation (e.g., RowClone-Copy) completes, the memory controller sets the \emph{finish} bit in the flag register.}
%POI implements a modified VALID-IO~\cite{X} protocol \atb{on top of} the 128-bit instruction and the 512-bit data signals. POC initiates a PuM operation by setting the \emph{valid} signal \atb{on the POI}. If the memory controller is \emph{ready} to perform the in-DRAM operation, it acknowledges IDOC's request by setting the \emph{ack} signal. The memory controller similarly sets the \emph{valid} signal when it has valid data on the data bus. We implement IDOI to abstract the Chisel3 layer from \atb{PiDRAM designers}. To implement a new in-DRAM operation, it is sufficient for PiDRAM \atb{designers} to modify the pidlib and a \atb{small set of Verilog} modules in the custom memory controller.

\atb{\textbf{\ding{183} Custom Memory Controller.} {PiDRAM's memory controller provides an easy-to-extend basis for {commodity DRAM based} PuM techniques that require issuing DRAM commands with violated timing parameters~\cite{gao2020computedram,kim.hpca19, kim.hpca18, talukder2019exploiting,olgun2021quactrngieee}. 
The memory controller is designed modularly and requires {easy{-}to{-}make} modifications to its scheduler to implement new PuM techniques.} For instance, our modular design enables supporting RowClone operations (Section~\ref{sec:rowclone}) in just 60 lines of Verilog code on top of the baseline custom memory controller's scheduler that implements conventional DRAM operations (e.g., read, write).}

\Copy{R1/6}{\atb{The custom memory controller employs three key sub-modules to facilitate the implementation of new PuM techniques. %: 
(i) \juan{The \emph{Periodic Operations \revf{Module}}} %, which 
periodically \new{issues} DDR3 refresh~\cite{micron2018ddr3} and interface maintenance commands~\cite{softmc.github}. %, 
(ii) \juan{A} simple \emph{DDR3 Command Scheduler} %that 
supports {conventional DRAM operations (e.g., activate, precharge, read, and write)}. \juan{This} scheduler applies an open-bank policy (i.e., DRAM banks are left open following a DRAM row activation) to exploit temporal locality in memory accesses to the DRAM module. {LOAD/STORE memory requests are simply handled by the command scheduler in a latency-optimized way. \new{Thus,} new modules \new{that are implemented to provide new PuM functionality (e.g., a state machine that controls the execution of a new PuM operation)} in the custom memory controller do not compromise the performance of LOAD/STORE memory requests.}}} {(iii) \Copy{R3/6}{\juan{The \emph{Configuration Register File}} (CRF) comprises 16 user-programmable registers that store \newnew{the violated} timing parameters used for DDRx sequences that trigger PuM operations \newnew{(e.g., activation latency used in generating true random numbers using D-RaNGe~\cite{kim.hpca19}, \newnew{see Section~\ref{sec:drange}})} and miscellaneous parameters for PuM implementations (e.g., true random number generation period for D-RaNGe, \newnew{see Section~\ref{sec:drange}}). {In our implementation, CRF stores only the timing parameters used for performing PuM operations (e.g., RowClone and D-RaNGe). We do not store every standard DDRx timing parameter (i.e., non-violated, \omi{which are used exactly as} defined as in DRAM chip specifications) in the CRF. Instead these timings are embedded in the \newnew{command} scheduler.}}}

\begin{figure*}[!t]
  \centering
  \includegraphics[width=0.9\textwidth]{figures/03_flow.pdf}
  \caption{{Workflow for a PiDRAM RowClone-Copy operation}}% \jgl{Rocker Core -> RISC-V CPU Core}}% \jgl{Make those numbers a little bit smaller. They are ugly.}}
  \label{fig:flow}
  
\end{figure*}
\subsection{Software Components}
\label{sec:software-components}
{PiDRAM comprises two key software components that complement {and control} PiDRAM's hardware components {to} provid{e} a flexible and easy to use {end-to-end} PuM framework.} 

%\atb{\X comprises two major software components that are essential to facilitate the implementation and evaluation of PuM techniques \atb{end-to-end}. First, the PuM operations library (pumolib) encapsulates functions to execute PuM operations using POC. For example, a RowClone (Section~\ref{sec:rowclone}) operation requires executing a sequence of LOAD/STORE operations targeting POC registers. Pumolib's RowClone function controls the execution of RowClone operations in \X. Second, to enable end-to-end implementations of PuM techniques, the custom supervisor software provides the necessary OS primitives (e.g., virtual memory, system calls).}

\textbf{\ding{184} PuM Operations Library (pumolib).} {The extensible library (\emph{PuM} \emph{o}perations \emph{lib}rary) allows system designers to implement software support for PuM techniques. Pumolib contains customizable functions that interface with POC to perform PuM operations in real unmodified DRAM chips. The customizable functions \newnew{hide} the hardware implementation details of PuM techniques implemented in \X{} \newnew{from software developers (that use pimolib)}.} For example, {although we expose PuM techniques to software via memory LOAD/STORE operations (POC is exposed as a memory-mapped module, Section~\ref{sec:hardware-components}), PuM techniques can also be exposed via specialized instructions provided by ISA extensions.} Pumolib \newnew{hides} such implementation details from the user of the library and \atb{contributes to the modular design of the} framework. 

%\atb{\juan{The} supervisor software (i.e., system software)} uses this library to perform PuM operations.


We implement a general protocol that defines how {programmers} express the information required to execute PuM operations to the PuM operations controller (POC). {A typical function in {pumolib} performs a PuM operation in four steps: \Copy{R3/3}{It (i) writes a PiDRAM instruction to {the} POC's \emph{instruction} register, (ii) sets the \emph{Start} {flag} in POC's \emph{flag} register, (iii) waits for {the} POC to set the \emph{Ack} {flag} in POC's \emph{flag} register, and (iv) reads the result of the PuM operation from POC's \emph{data} register {(e.g., the true random number after performing a{n in-DRAM true random number generation} operation, Section~\ref{sec:drange})}. {We list the currently implemented pumolib functions in Table~\ref{table:pumolib}.}}}



%\atb{By setting the \emph{start} bit in the \emph{flag} register, the \revd{system designer} initiates a PuM operation. The memory controller responds by setting the \emph{ack} bit in the \emph{flag} register upon receiving the PuM \emph{instruction} and starts performing the corresponding operation. \Copy{R3/3}{When an operation (e.g., RowClone-Copy) completes, the memory controller sets the \emph{finish} bit in the flag register. Pumolib contains template functions that initiate PuM operations in the memory controller by communicating with the POC over the described protocol. \changev{\ref{q:r3q3}}\tacorevc{We list these functions in Table~\ref{table:pumolib}.}}}




\textbf{\ding{185} Custom Supervisor Software.}\revdel{End-to-end implementation of PuM techniques requires modifications across the hardware and software stack.} \X provides a custom supervisor software that \newnew{implements} the necessary OS primitives (i.e., virtual memory \juan{management}, memory \juan{allocation and alignment) \newnew{for end-to-end implementation of PuM techniques}.} %management.
{This facilitates developing end-to-end integration of PuM techniques {in the system} as these techniques require modifications across the software stack. For example, integrating RowClone end-to-end {in the full system} requires a new memory allocation mechanism (Section~\ref{sec:rowclone_alignment}) that can satisfy the memory allocation constraints of RowClone~\cite{seshadri2013rowclone}. \new{Thus, we implement the necessary functions and data structures in the custom supervisor software to implement an allocation mechanism that satisfies RowClone's constraints. This allows \X{} to be extended easily to implement support for new PuM techniques that share similar memory allocation constraints (\newnew{e.g., Ambit~\cite{seshadri.micro17}, SIMDRAM~\cite{hajinazarsimdram}, and QUAC-TRNG~\cite{olgun2021quactrngieee}, as shown in} Table~\ref{table:use-cases}).}}

%PK implements a variety of system calls and supports virtual memory. We implement system support for in-DRAM computation primitives on PK. We augment the memory management module of the PK \atb{to enable RowClone and D-RaNGe} and we implement the PiDRAM library (pidlib) as \atb{a} part of PK (\todo{Section~\ref{X}}).

\subsection{Execution of a PuM Operation}
\label{sec:execution-overview}

{We describe the general workflow for a PiDRAM operation (e.g., RowClone-Copy~\cite{seshadri2013rowclone}, random number generation using D-RaNGe~\cite{kim.hpca19}) in Figure~\ref{fig:flow} over an example \texttt{{copy\_row()}} function that is called by the user to {perform a RowClone-Copy operation} in DRAM.}


{{T}he user makes a system call to the custom supervisor software \scalebox{1.1}{{\ding{172}}} that in turn calls the {\texttt{copy\_row(source, destination)}} function in the {pumolib} \scalebox{1.1}{{\ding{173}}}. The function executes {two} store instructions in the RISC-V core \scalebox{1.1}{\ding{174}}. {The first store} instruction {update{s}} the \emph{instruction} register with the {copy\_row} instruction (i.e., the instruction that performs a {RowClone-Copy} operation in DRAM) \scalebox{1.1}{{\ding{175}}} and {the second store instruction} {set{s} the Start flag in the flag register to logic-1 \scalebox{1.1}{\ding{176}} in POC.} {When the Start flag is set,} POC instructs the PiDRAM memory controller to perform a {RowClone-Copy} operation using violated timing parameters \scalebox{1.1}{\ding{177}}. {{T}he {POC waits until the memory controller starts executing the {operation, after which it}} sets the Start flag to logic-0 and the Ack {flag} to logic-1 \scalebox{1.1}{\ding{178}}{, indicating that it started the execution of the PuM operation}.} {T}he PiDRAM memory controller performs the {RowClone-Copy} operation by issuing a set of DRAM commands with violated timing parameters \scalebox{1.1}{{\ding{179}}}. {{When the last DRAM command is issued, the memory controller} sets the Finish flag (denoted as Fin. in Figure~\ref{fig:flow}) in the flag register to logic-1 \scalebox{1.1}{{\ding{180}}}, indicating the end of execution for the last PuM operation that the memory controller acknowledged.} {The copy function periodically checks {either} the Ack {or the} Finish flag in the flag register {(depending on a user-supplied argument)} by executing load instructions that target the flag register \scalebox{1.1}{\ding{181}}. {When the periodically checked flag is set, the copy function returns.} This way, the copy function optionally blocks until the start {(i.e., the Ack flag is set)} or the end {(i.e., the Finish flag is set)} of the execution of the PuM operation (in this example, RowClone-Copy).\footnote{{The data register is not used in \newnew{a} RowClone-Copy~\cite{seshadri2013rowclone} operation because the result of the RowClone-Copy operation is stored {\emph{in memory}} (i.e., the source {memory row} is copied to the destination {memory row}). The data register is used in \newnew{a} D-RaNGe~\cite{kim.hpca19} operation{, as described in Section~\ref{sec:drange}}. {When used, t}he command scheduler store{s} the random numbers generated by {the} D-RaNGe operation in the data register. To read the generated random number, we implement a pumolib function {called} \texttt{rand\_dram()} that executes load instructions in the {RISC-V} core to retrieve the random number from the data register in POC.}}}}


%\atb{Figure~\ref{fig:pidram-overview} describes the general workflow for executing a PuM operation using the hardware and software components of \X. The application typically executes pumolib functions via system calls to the supervisor software (\boldone). Pumolib implements functions to perform PuM operations (\boldtwo). These functions STORE data to \emph{instruction} and \emph{flag} registers of the PuM operations controller (\boldthree). Setting the \emph{start} bit in the flag register initiates a PuM operation in the scheduler (\boldfour). The scheduler accesses DRAM using timing parameters defined in the configuration register file (CRF). Upon the start and at the end of PuM operations, the scheduler sets the \emph{ack} and the \emph{finish} bits in the flag register, respectively (\boldfive).}
%\jgl{This paragraph seems part of 4.2, but it is not. It deserves a subsection.}

\begin{table*}[b]
    \centering
    \scriptsize
    \caption{\omi{Various} \newnew{known} PuM techniques that can be studied using \X. PuM techniques we implement \juan{in this work} are highlighted in bold.}
    \hspace{1em}
    \begin{tabular}{m{12em}m{10em}m{45em}}
    \toprule
    \textbf{PuM Technique} & \textbf{Description} & \textbf{Integration Challenges} \\
    \midrule
    {\textbf{ComputeDRAM-based~\textbf{\cite{gao2020computedram}}}} \textbf{RowClone~\cite{seshadri2013rowclone}} & Bulk data-copy \juan{and initialization} within DRAM & (i) \emph{memory allocation \juan{and alignment} mechanisms} that map source \& destination operands of a copy operation into same DRAM subarray; (ii) \juan{\emph{memory coherence}, i.e.}, source \revdel{\& destination }operand must be up-to-date in DRAM.\\
    \midrule
    \textbf{D-RaNGe}~\cite{kim.hpca19} & True random number generation using DRAM & (i) periodic generation of true random numbers; (ii) \emph{memory scheduling policies} that minimize the interference caused by random number requests. \\
    \midrule
    {ComputeDRAM-based~\cite{gao2020computedram}} Ambit~\cite{seshadri.micro17} & Bitwise operations in DRAM & (i) \emph{memory allocation \juan{and alignment} mechanisms} that map operands of a bitwise operation into same DRAM subarray; (ii) \juan{\emph{memory coherence}, i.e.}, operands of the bitwise operations must be up-to-date in DRAM. \\
    \midrule
    SIMDRAM~\cite{hajinazarsimdram} & \juan{Arithmetic operations in DRAM} & (i) \emph{memory allocation \juan{and alignment} mechanisms} that map operands of an arithmetic operation into same DRAM subarray; (ii) \juan{\emph{memory coherence}, i.e.}, operands of the arithmetic operations must be up-to-date in DRAM; (iii) \juan{\emph{bit transposition}, i.e., operand bits must be laid out vertically in a single DRAM bitline}. \\
    \midrule
    DL-PUF~\cite{kim.hpca18} & Physical unclonable functions in DRAM & \emph{memory scheduling policies} that minimize the interference caused by generating PUF responses. \\
    \midrule
    \reva{QUAC-TRNG~\cite{olgun2021quactrng} \newnew{and Talukder+~\cite{talukder2019exploiting}}} & \reva{True random number generation using DRAM} & \reva{(i) periodic generation of true random numbers; (ii) \emph{memory scheduling policies} that minimize the interference caused by random number requests; (iii) efficient integration of the SHA-256 cryptographic hash function.} \\
    \bottomrule
    \end{tabular}
    
    \label{table:use-cases}
    
\end{table*}
\subsection{Use Cases}
\label{sec:use-cases}
\atb{\X is primarily designed to study end-to-end implementations of {commodity DRAM based} PuM techniques~\cite{olgun2021quactrng,gao2020computedram,kim.hpca18,kim.hpca19,talukder2019exploiting} on real systems. {Beyond commodity DRAM based PuM techniques}, many prior works propose minor modifications to DRAM arrays to enable various arithmetic~\cite{hajinazarsimdram,deng.dac2018,ferreira2021pluto,angizi2019graphide} and bitwise operations~\cite{seshadri.micro17,seshadri2020indram,seshadri.bookchapter17.arxiv,Seshadri:2015:ANDOR,angizi2019graphide} and security primitives~\cite{orosa2021codic}.}
%\jgl{Not matrix multiplication}. 
{These PuM techniques share common memory allocation and coherenc\newnew{e} requirements (Section~\ref{sec:rowclone_alignment}) that must be satisfied to enable their end-to-end integration {into a real system.} \X{} facilitates the implementation of PuM techniques and enables rapid exploration of such integration challenges on a real DRAM-based system.} \newnew{Table ~\ref{table:use-cases} describes some of the \juan{PuM} case studies \X can enable.}




{\new{Other than providing an easy-to-use basis for end-to-end implementations of commodity DRAM based PuM techniques,} \X{} can be \new{easily} extended with a programmable microprocessor placed near the memory controller to study system integration challenges of Processing-near-Memory (PnM) techniques (e.g., efficient pointer chasing~\cite{impica, hashemi.isca16,cont-runahead}, \new{general-purpose compute~\cite{upmem2018}, machine learning~\cite{kwon2021fimdram, ke2021near, kim2021aquabolt, lee2022isscc, niu2022isscc}, \newnew{databases~\cite{lee2022improving,boroumand2019conda,boroumand2016pim}}, \omi{graph processing~\cite{besta2021sisa}}}).\revdel{ \atb{\X} can be deployed on appropriate FPGA boards as a testbed for new memory devices with compute capability~\cite{upmem2018,kwon2021fimdram}.}}


\subsection{{PiDRAM's HW \& SW Components: Summary}}
\label{sec:component-summary}

\Copy{R3/2}{
{We identify and build two hardware components (PuM Operations Controller and Custom Memory Controller) and two software components (PuM Operations Library, Custom Supervisor Software) as key components that \new{are} commonly required by \new{end-to-end PuM implementaions}. We reuse these key components to implement two different PuM mechanisms (RowClone in Section~\ref{sec:rowclone} and D-RaNGe in Section~\ref{sec:drange}) in PiDRAM. The key components can be reused in the same way {to} implement other PuM mechanisms (e.g., the ones in Table~\ref{table:use-cases}). However, reusing a component does not mean that the component can {simply} be instantiated in a system and the system will be able to perform PuM operations immediately.} 

{We acknowledge that these components require modifications to implement new PuM techniques in PiDRAM and possibly to integrate PiDRAM into other systems. In fact, we quantify the degree of these modifications in our RowClone and D-RaNGe case studies. We show that the key components form a useful and easy-to-extend basis for PuM techniques with our Verilog and C code complexity analyses for both use cases (Sections~\ref{sec:rowclone-experimental-methodology} and~\ref{sec:drange-evaluation}).}
}
\subsection{\X Prototype}
\label{sec:prototype}

\Copy{R3/7B}{\atb{We develop a prototype of the \X framework on an FPGA-based platform. We use the Xilinx ZC706 FPGA board~\cite{zc706} to interface with real DDR3 modules. {Xilinx provides a DDR3 PHY IP~\cite{virtex7mig} that exposes a low-level ``DFI'' interface~\cite{dfi} to the DDR3 module on the board. We use this interface to issue DRAM commmands to the DDR3 module.} We \newnew{use} the existing RISC-V based SoC generator, \omi{Rocket Chip}~\cite{asanovic2016rocket}, to {generate the RISC-V hardware system}. Our custom supervisor software extends the RISC-V \newnew{Proxy Kernel~\cite{riscv-pk}} to support the necessary OS primitives on \X's prototype.} Figure~\ref{fig:prototype} shows our prototype.}

\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\linewidth]{figures/04_prototype.pdf}
    \caption{PiDRAM's FPGA prototype}
    \label{fig:prototype}
\end{figure}


\noindent
\Copy{R1/1B}{{{\textbf{\new{Simulation Infrastructure.}} To \newnew{aid} the users \newnew{in testing}} the correctness of any modifications \newnew{they make} on top of PiDRAM, we provide the developers with a Verilog simulation {environment} that injects regular READ/WRITE commands and custom commands (e.g., update {the Configurable Register File (CRF)}, perform RowClone-Copy, generate random numbers) to the memory controller. When used in conjunction with the Micron DDR3 Verilog model provided by Xilinx~\cite{virtex7mig}, the simulation \newnew{environment} can help the developers \newnew{to} easily understand if something unexpected is happening in their implementation (e.g., {if} timing {parameters} are violated).}}

\noindent
\omi{\textbf{Open Source Repository.} We make PiDRAM freely available to the research community as open source software at \url{https://github.com/CMU-SAFARI/PiDRAM}. Our repository includes the full PiDRAM prototype that has RowClone (Section~\ref{sec:rowclone}) and D-RaNGe (Section~\ref{sec:drange}) implemented end-to-end on the RISC-V system.}