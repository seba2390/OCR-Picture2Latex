\label{sec:extending-pidram}
{We briefly describe the modifications required to extend PiDRAM (i) with new DRAM commands and DRAM timing parameters\new{, (ii) with new case studies,} and (i\new{i}i) to support new FPGA boards.}

\noindent
\textbf{{New DRAM Commands and Timing Parameters.}}
\Copy{R1/1}{{Implementing new DRAM commands or modifying DRAM timing parameters require modifications to PiDRAM's memory controller. This is straightforward as PiDRAM's memory controller's Verilog design \omi{is modular and uses well-defined interfaces: It is composed} of multiple modules that perform separate tasks\revdel{and communicate with each other via well-defined interfaces}. For example, the memory request scheduler comprises \new{two} main components: (1) \emph{command timer}, \new{and} (2) \emph{command scheduler}\new{.}\revdel{, and (3) custom command scheduler} To serve {LOAD and STORE memory} requests, the command scheduler maintains state (e.g., which row is active) for every bank. The command scheduler selects the next DRAM command to satisfy the {LOAD or STORE memory} request and queries the command timer with the selected DRAM command. The command timer checks for all possible standard DRAM timing constraints and outputs a valid bit if the selected command can be issued in that FPGA clock cycle. To extend the memory controller with a new standard DRAM command (e.g., to implement a newer standard like DDR4 \omi{or DDR5}), a PiDRAM developer simply needs to \omi{(i)} add a new timing constraint by replicating the logic in the command timer and \omi{(ii)} extend the command scheduler to correctly maintain the bank state.}}

\noindent
{\textbf{New Case Studies.}}
\Copy{R5/2}{{Implementing new techniques (e.g., those that are listed in Table~\ref{table:use-cases}) to perform new case studies requires modifications to PiDRAM's hardware and software components. We describe the required modifications over an example {ComputeDRAM-based in-DRAM bitwise operations} case study.}

{To implement ComputeDRAM-based in-DRAM bitwise operations, the developers need to (i) extend the \emph{\new{custom command} scheduler} in PiDRAM's memory controller with a new state machine that schedules new DRAM command sequences (ACT-PRE-ACT) with an appropriate set of violated timing parameters (our ComputeDRAM-based in-DRAM copy implementation provides a \omi{solid} basis for this), (ii) expose the functionality to the processor by implementing new PiDRAM instructions in the PuM controller (e.g., by replicating \omi{and customizing} the existing logic for decoding and executing RowClone operations), (iii) and make modifications to the software library to expose the new instruction to the programmer (e.g., by replicating the copy\_row function's behavior, described in Table~\ref{table:pumolib}).}}

\noindent
\textbf{{Porting to New FPGA Boards.}}
\Copy{R3/7A}{{Developing new PiDRAM prototypes on different FPGA boards could require modifications to design constraints (e.g., top level input/outputs to physical FPGA pins) and the DDRx PHY IP depending on the FPGA board. Modifying design constraints is a straightforward task involving looking up the FPGA manufacturer datasheets and modifying design constraint files~\cite{designconstraints}. Manufacturers may provide different DDRx PHY IPs for different FPGAs. Fortunately, these IPs typically expose \omi{similar} (based on the DFI standard~\cite{dfi}) interface\omi{s} to user hardware (in our case, to PiDRAM's memory controller). Thus, \onur{other} PiDRAM prototypes on different FPGA boards can be developed with \omi{small yet careful} modifications to the ZC706 prototype design we provide.}}

