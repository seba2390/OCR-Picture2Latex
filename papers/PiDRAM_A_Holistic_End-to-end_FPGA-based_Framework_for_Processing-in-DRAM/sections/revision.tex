
%\nobalance 
%\section*{{\Large AUTHORS' RESPONSE and SUMMARY OF CHANGES}}

% We thank the reviewers for their valuable feedback. We have addressed all comments. We first list the major changes we made to the paper in this revision. Then, we respond to each reviewer's comments and discuss how we have addressed them in the paper.  \\

\begin{center}
    \LARGE{\textbf{TACO 2022 Revision for:}}\\
    \LARGE{\textit{PiDRAM: A Holistic End-to-end FPGA-based Framework for \underline{P}rocessing-\underline{i}n-\underline{DRAM}}}
\end{center}

\vspace{10pt}

We thank the reviewers for their valuable feedback. We have addressed all comments. We first list the major changes we made to the paper in this revision. Then, we respond to each reviewer’s comments and discuss how we have addressed them in the paper.

The silver boxes list reviewer comments. We append our response for reviewer comments immediately below silver boxes. The yellow text box shows the changes made in the paper to address those comments. We use \textcolor{red}{red}, \textcolor{dark-green}{green}, \textcolor{goldbutdark}{gold}, \textcolor{purple}{purple}, and \textcolor{pink-hot}{pink} to highlight the changes made to address \textcolor{red}{Reviewer 1}, \textcolor{dark-green}{Reviewer 2}, \textcolor{goldbutdark}{Reviewer 3}, \textcolor{purple}{Reviewer 4}, and \textcolor{pink-hot}{Reviewer 5}'s comments and questions. We use the color \textcolor{blue}{blue} to highlight changes we made to address common concerns and improve the clarity in many sections in the paper.\\

\iffalse
\newcommand{\tacoreva}[1]{\textcolor{red}{#1}}
\definecolor{dark-green}{rgb}{0.00, 0.45, 0.00}
\newcommand{\tacorevb}[1]{\textcolor{dark-green}{#1}}
\definecolor{goldbutdark}{rgb}{0.85, 0.65, 0.12}
\newcommand{\tacorevc}[1]{\textcolor{goldbutdark}{#1}}
\newcommand{\tacorevd}[1]{\textcolor{purple}{#1}}
\definecolor{pink-hot}{rgb}{0.98, 0.40, 0.78}
\newcommand{\tacoreve}[1]{\textcolor{pink-hot}{#1}}
\newcommand{\tacorevcommon}[1]{\textcolor{blue}{#1}}
\fi

MAJOR CHANGES TO THE PAPER:
\begin{enumerate}
	\item We added Section~\ref{sec:extending-pidram} (\emph{``Extending PiDRAM''}), which discusses the extensibility of PiDRAM in multiple aspects. This addresses comments \emph{R1/1} from Reviewer 1, \emph{R3/2}, \emph{R3/4}, \emph{R3/7} from Reviewer 3, and \emph{R5/2}, \emph{R5/3}, \emph{R5/4} from Reviewer 5.

	\item We enhanced Section~\ref{sec:rowclone} (\emph{``Case Study \#1: End-to-end RowClone''}) to clearly explain the challenges in implementing RowClone \onur{end-to-end} and clarify our solutions to these challenges. This addresses comments \emph{R2/1} from Reviewer 1 and \emph{R2/3} from Reviewer 2.

	\item We added Table~\ref{table:pumolib} (\emph{``Pumolib functions''}), which describes the functions implemented in PiDRAM's extensible software library. This addresses the comment \emph{R3/2} from Reviewer 3.
	
	\item We compare against a recently published related work, PiMulator, in Section~\ref{sec:related-work}. \onur{ATB: This is not based on a reviewer comment.}

	\item We revised the writing in many sections to make our arguments and descriptions more clear. We use the color \textcolor{blue}{blue} to highlight these changes.
\end{enumerate}

%We respond to each reviewer's feedback in detail on the following pages, and describe the associated changes we made to the revised paper, including changes based on all other comments.

% \renewcommand\contentsname{} % the empty name
% \vspace{5pt}
% \setcounter{tocdepth}{-1}

% \tableofcontents 
% \addtocontents{toc}{~\hfill\textbf{Page}\par}

% \tableofcontents
\def\mydots{\leavevmode\xleaders\hbox to 0.45em{\hfil.\hfil}\hfill\kern0pt}

\vspace{25pt}



\noindent \textbf{\large{Contents}} 
\vspace{5pt}

\noindent \textbf{\hyperlink{reviewer1}{REVIEWER 1}}~\mydots~~27
\vspace{5pt}

\noindent \textbf{\hyperlink{reviewer2}{REVIEWER 2}}~\mydots~~31
\vspace{5pt}

\noindent \textbf{\hyperlink{reviewer3}{REVIEWER 3}}~\mydots~~33
\vspace{5pt}

\noindent \textbf{\hyperlink{reviewer4}{REVIEWER 4}}~\mydots~~38
\vspace{5pt}

\noindent \textbf{\hyperlink{reviewer5}{REVIEWER 5}}~\mydots~~44
\vspace{5pt}

\newpage
%\section*{{\Large \normalfont{\textbf{REVIEWER 1}}}}
\begin{center}
    {\Large \normalfont{\textbf{\hypertarget{reviewer1}{REVIEWER 1}}}}
\end{center}

%\addcontentsline{toc}{section}{REVIEWER 1}
%\label{sec:rev1}

\begin{tcolorbox}
    \begin{enumerate}[label=R1/\arabic*]
        \item \label{q:r1q1} How is the controller modularized? How do you test a customization of PiDRAM? 
    \end{enumerate}
\end{tcolorbox} 

The memory controller’s Verilog design is made up of multiple modules that each perform separate tasks and communicate with each other via well-defined interfaces. For example, the memory request scheduler comprises three main components: (1) command timer, (2) command scheduler, and (3) custom command scheduler:

To serve regular READ and WRITE requests, the command scheduler maintains state (e.g., which row is active) for every bank. The command scheduler selects the next DRAM command to satisfy \onur{a} \onur{LOAD or STORE} \onur{memory} request and queries the command timer with the selected DRAM command. The command timer checks for all possible standard DRAM timing constraints and outputs a valid bit if the selected command can be issued in that FPGA clock cycle. To extend the memory controller with a new standard DRAM command (e.g., to implement a newer standard like DDR4), the user simply needs to (1) add a new timing constraint by replicating the logic in the command timer and (2) extend the command scheduler to correctly maintain the bank state. The user does not need to modify how the components interface with each other. Thus, it is straightforward to add new standard DRAM commands to the memory controller.

To serve PuM commands, a custom command scheduler (we implement two: reduced-latency-read and RowClone-Copy scheduler) takes full control over the scheduling and timing of DRAM commands, as these operations cannot be performed using standard DRAM timings. The command scheduler delegates control \onur{of} the physical DDR interface to a custom command scheduler depending on the request type (e.g., copy, RNG). To implement a new custom command scheduler, the user can replicate the logic in one of the existing custom command schedulers, create a new Verilog module for their new custom command scheduler, and attach it to the command scheduler. While implementing a custom command scheduler is relatively more time-consuming compared to implementing new standard DRAM commands, the modifications are still limited to an independent Verilog module and are not spread across multiple modules (e.g., \onur{they do \emph{not}} require changes to interfaces between modules).

\onur{To enable the users to test} the correctness of their implementation, we provide the users with a Verilog simulation \onur{environment} that injects regular READ/WRITE commands and custom commands (\onur{update the Configurable Register File (CRF)}, perform RowClone-Copy, generate random numbers) to the memory controller. When used in conjunction with the Micron DDR3 Verilog model provided by Xilinx, the simulation \onur{environment} can help the users easily understand if something unexpected is happening in their implementation (e.g., \onur{if} timing \onur{parameters} are violated).

We integrated the relevant parts of our response to Section~\ref{sec:extending-pidram}:\\

\vspace{5pt}
\yyboxbegin
    \Paste{R1/1}
\yyboxend

\onur{We updated} Section~\ref{sec:prototype} \onur{with the following text}:\\

\yyboxbegin
    \Paste{R1/1B}
\yyboxend

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R1/\arabic*]
        \addtocounter{enumi}{1}
        \item \label{q:r1q2} Have you tested the limit of \texttt{alloc\_align()}? How large is the buffer it can allocate?
    \end{enumerate}
\end{tcolorbox} 

\texttt{alloc\_align()} supports arbitrarily-sized allocations and it is bound by the amount of available free (i.e., not allocated) physical memory. We tested RowClone-Copy/Init operations using \texttt{alloc\_align()} with up to 8 MiB of allocation size as we observed diminishing returns on performance improvement provided by RowClone operations from \onur{larger} array sizes.

We added \onur{Footnote 4} to justify why we test up to 8 MiB of allocation size in Section~\ref{sec:methodology-workloads}:

\vspace{5pt}
\yyboxbegin 
    \Paste{R1/2}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R1/\arabic*]
        \addtocounter{enumi}{2}
        \item \label{q:r1q3} In RowClone, PiDRAM relies on CFLUSH to ensure the data in the DRAM is up-to-date. Do you consider the overhead of bringing data back to cache? Is this scenario common?
    \end{enumerate}
\end{tcolorbox} 

We do not consider the overhead of bringing data back to caches in our microbenchmark evaluation (Section~\ref{sec:clflush-overhead}). \onur{We do not quantify how frequently bringing data back to caches occur in the workloads we test.} However, our real workload evaluation captures th\onur{e} overhead \onur{of bringing data back to caches for} the three real workloads we evaluate (Section~\ref{sec:real-workload-study}).

%We show that RowClone operations are more effective in improving performance when \onur{performed} on large amounts of data (Figure~\ref{fig:bare-metal-speedup}). Similar amounts of data, when copied using CPU instructions (i.e., CPU-Copy), would incur similar overheads. This is because the CPU-copy operations would not benefit from the low-latency on-chip caches as the data would not fit in the caches and the majority of the CPU-copy operations would need to access DRAM.

We clarify our CLFLUSH overhead estimation methodology in Section~\ref{sec:clflush-overhead}:

\vspace{5pt}
\yyboxbegin 
    \Paste{R1/3}
\yyboxend 

\newpage

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R1/\arabic*]
       \addtocounter{enumi}{3}
        \item \label{q:r1q4} What is the distribution of dirty cache block rates in real applications?
    \end{enumerate}
\end{tcolorbox} 

Studying the distribution of dirty cache block rates in real applications is not a goal of our work. However, if a large dirty \onur{cache block} rate causes severe overhead in a real application, a system designer would likely decide not to offload the operation to PuM (i.e., performing RowClone-Copy operations instead of CPU-Copy). PiDRAM’s prototype can be useful for studies on different PuM system integration aspects, including offloading decisions (i.e., whether to execute an operation using PuM or using the CPU).

We integrated our response to the reviewer's comment in our revision in Section~\ref{sec:clflush-overhead}:


\vspace{5pt}
\yyboxbegin 
    \Paste{R1/4}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R1/\arabic*]
        \addtocounter{enumi}{4}
        \item \label{q:r1q5} In the Libquantum benchmark, the end-to-end performance with PiDRAM is only increased by 1.3\%, which seems not much. In that case, how useful will RowClone be for general applications?
    \end{enumerate}
\end{tcolorbox} 

The store instructions executed by libquantum to initialize arrays in the CPU-initialization baseline is only 0.2\% \onur{of all dynamic instructions in the libquantum workload}, which amounts to an estimated 2.3\% of the total runtime of libquantum. Thus, the performance improvement provided by RowClone-Initialization (1.3\%)\onur{, which can speed up only this 2.3\% portion of total runtime,} is reasonable. We show that the improvement provided by RowClone-Copy/Initialization operations increases as the copy/initialization \onur{intensity} of workloads increase (please see forkbench and compile evaluation in Section~\ref{sec:real-workload-study}). We expect applications that have large copy/initialization intensit\onur{ies will} greatly benefit from RowClone-Copy/Initialization. For example, RowClone-Copy can improve the performance of \emph{forkbench} by 42.9\%.

\onur{We explain this in Section~\ref{sec:real-workload-study} in the highlighted text:}

\vspace{5pt}
\yyboxbegin 
    \Paste{R1/5}
\yyboxend 

\newpage

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R1/\arabic*]
        \addtocounter{enumi}{5}
        \item \label{q:r1q6} Will the performance of normal DRAM read/write operations be compromised by the additional modules in PiDRAM?
    \end{enumerate}
\end{tcolorbox} 

The additional modules implemented by PiDRAM have no effect on the critical path of LOAD/STORE requests, and therefore the additional modules do not compromise the performance of normal read/write operations. 

We incorporated our response for \ref{q:r1q6} in Section~\ref{sec:hardware-components}:

\vspace{5pt}
\yyboxbegin 
    \Paste{R1/6}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R1/\arabic*]
        \addtocounter{enumi}{6}
        \item \label{q:r1q7} Line numbers are not aligned.
    \end{enumerate}
\end{tcolorbox} 

We thank the reviewer for pointing out the formatting issue. We investigated the issue and we believe this is a problem with the submission template as we use the default submission template.

\newpage

\begin{center}
    {\Large \normalfont{\textbf{\hypertarget{reviewer2}{REVIEWER 2}}}}
\end{center}

% \section*{{\Large \normalfont{\textbf{REVIEWER 2}}}}
% \addcontentsline{toc}{section}{REVIEWER 2}

\begin{tcolorbox}
    \begin{enumerate}[label=R2/\arabic*]
        \item \label{q:r2q1} Clarify what ``characterize the DRAM rows'' and ``conduct the reliability study'' means. 
    \end{enumerate}
\end{tcolorbox} 

We perform RowClone experiments on real DRAM chips to find DRAM row address pairs that can be used reliably for RowClone operations. We have clarified our descriptions in Sections~\ref{sec:rowclone_alignment} and~\ref{sec:rowclone_mechanism} \onur{of} the revision:

\vspace{5pt}
\yyboxbegin 
    \Paste{R2/1C}
\yyboxend 

Section~\ref{sec:rowclone_mechanism}:

\vspace{5pt}
\yyboxbegin 
    \Paste{R2/1A}
\yyboxend 

\vspace{5pt}
\yyboxbegin 
    \Paste{R2/1B}
\yyboxend 

\newpage
\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R2/\arabic*]
        \addtocounter{enumi}{1}
        \item \label{q:r2q2} For some address mapping schemes where bank address bits are located in between row and column address bits, the tables you implemented may become unnecessary.
    \end{enumerate}
\end{tcolorbox} 

For such an address mapping scheme, a single operand is spread across the same row in multiple banks. This coarsens the granularity of RowClone operations as the number of operands that must be copied in unison, to satisfy the granularity constraint, increases. 

Subarray mapping table \onur{(SAMT)} is still required in order to \onur{maintain physical addresses that point to DRAM rows in the same subarray.} Since \onur{RowClone-Copy} operation\onur{s} need to copy data \onur{between the same two rows in} all banks \onur{(i.e., between source and destination DRAM rows pointed by the same row addresses)}, one SAMT for all banks could be used, \onur{given an addressing scheme described by the reviewer,} instead of one SAMT for each bank, \onur{given the addressing scheme we implement}.

We integrated our response to the comment in Section~\ref{sec:rowclone-experimental-methodology} \onur{of} the revision:

\vspace{5pt}
\yyboxbegin 
    \Paste{R2/2}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R2/\arabic*]
       \addtocounter{enumi}{2}
        \item \label{q:r2q3} What is the technical contribution of PiDRAM? We can extend DRAMSim to build the same framework.
    \end{enumerate}
\end{tcolorbox} 

Our framework can be used to evaluate a multitude of PuM techniques (please see Table~\ref{table:use-cases}) end-to-end using a \onur{\emph{real}} system and \onur{\emph{real}} DRAM devices. As an example, we develop a new memory allocation mechanism that can allocate data in a way to satisfy RowClone-Copy operations’ data allocation constraints and evaluate RowClone end-to-end \onur{in a \emph{real} system}. We show that end-to-end RowClone-Copy operations improve performance over traditional CPU-Copy operations.

We already extensively compare PiDRAM against simulators in Section~\ref{sec:related-work} - Simulators. DRAMSim, being a simulator, falls into this category. Based on our comparison, extending DRAMSim to be as capable as PiDRAM (e.g., interacting with real DRAM devices, integrating proprietary device characteristics, fast runtime) would not be possible without developing a hardware design similar to PiDRAM’s. Thus, extending DRAMSim (or other DRAM system simulators) would require \onur{substantial changes and effort we have made to develop PiDRAM, such as developing hardware modules and thoroughly verifying the behavior of the hardware modules, implementing system software support, and developing software libraries to communicate with the hardware modules to perform PuM operations. The resulting system cannot be called a simulator anymore. It would be a \emph{real system prototype} like PiDRAM}.

\newpage 
\begin{center}
    {\Large \normalfont{\textbf{\hypertarget{reviewer3}{REVIEWER 3}}}}
\end{center}

% \section*{{\Large \normalfont{\textbf{REVIEWER 3}}}}
% \addcontentsline{toc}{section}{REVIEWER 3}

\begin{tcolorbox}
    \begin{enumerate}[label=R3/\arabic*]
        \item \label{q:r3q1} Relatively weak on novel research contributions. Claimed contributions are straightforward and do not significantly differ from prior work.
    \end{enumerate}
\end{tcolorbox} 

We present a simple memory allocation mechanism that satisfies RowClone’s memory mapping, alignment, and granularity constraints. \onur{We integrate and evaluate D-RaNGe end-to-end in a real system.} To our knowledge, prior works (i) \onur{on in-DRAM row-copy operations} (RowClone, ComputeDRAM) do not provide a clear description of a working memory allocation mechanism that can be integrated into a real operating system to expose RowClone capability to the programmer\onur{, and (ii) on DRAM-based true random number generation (D-RaNGe, QUAC-TRNG) do not integrate and evaluate DRAM-based true random number generation techniques end-to-end in a real system.}

We adopt the widely-used cache line flush instruction (CLFLUSH) to invalidate and evict cache blocks prior to RowClone operations. We acknowledge that CLFLUSH is not novel (and do not claim otherwise in the paper). Our CLFLUSH implementation could be a basis for future, more efficient mechanisms that will be developed using PiDRAM.

We integrated parts of our response to the paper in Sections~\ref{sec:rowclone} and~\ref{sec:drange}: 

Section~\ref{sec:rowclone}:

\vspace{5pt}
\yyboxbegin 
\Paste{R3/1}
\yyboxend 

Section~\ref{sec:drange}:

\vspace{5pt}
\yyboxbegin 
\Paste{R3/1B}
\yyboxend 

\newpage

\begin{tcolorbox}
    \begin{enumerate}[label=R3/\arabic*]
        \addtocounter{enumi}{1}
        \item \label{q:r3q2} Explicitly summarize the key software/hardware components that would be commonly needed by most of PuM systems. 
    \end{enumerate}
\end{tcolorbox} 

The two hardware \onur{(PuM Operations Controller, Custom Memory Controller)} and two software components \onur{(PuM Operations Library, Custom Supervisor Software)} that we identify and build are already reused across the two different PuM mechanisms we implement (RowClone and D-RaNGe). These components can be reused in the same way \onur{to} implement other PuM mechanisms (e.g., the ones in Table~\ref{table:use-cases}). However, reusing a component does not mean that the component can \onur{simply} be instantiated in a system and the system will be able to perform PuM operations immediately. 

We acknowledge that these components require modifications to implement new PuM techniques in PiDRAM and possibly to integrate PiDRAM into other systems. In fact, we quantify the degree of these modifications in our RowClone and D-RaNGe case studies. We show that the key components form a useful and easy-to-extend basis for PuM techniques with our Verilog and C code complexity analyses for both use cases (Sections~\ref{sec:rowclone-experimental-methodology} and~\ref{sec:drange-evaluation}).

We added Section~\ref{sec:component-summary} to incorporate our response to the revision:

\vspace{5pt}
\yyboxbegin 
\Paste{R3/2}
\yyboxend 

\newpage
\begin{tcolorbox}
    \begin{enumerate}[label=R3/\arabic*]
        \addtocounter{enumi}{2}
        \item \label{q:r3q3} What exact wrapper functions are included in pumolib?
    \end{enumerate}
\end{tcolorbox} 

We list the functions pumolib implements in Table~\ref{table:pumolib} in our revision. The two techniques we implement have substantially different requirements, thus there is nothing common in the pumolib used by these techniques. However, pumolib could be designed to implement common functions among other sets of PuM techniques. For example, both \onur{Ambit} and SIMDRAM (Table~\ref{table:use-cases}) require simultaneously activating multiple DRAM rows to perform the majority operation. Pumolib could implement a \texttt{majority()} function that is used by both of these techniques in a future version of PiDRAM or in future systems that are based on/inspired by PiDRAM.

We list the functions pumolib implements in Table~\ref{table:pumolib}. We revise the surrounding text \onur{in Section~\ref{sec:pidram}} as follows: 

\vspace{5pt}
\yyboxbegin 
\Paste{R3/3}

\centering

\textbf{Table 1. Pumolib functions.}
\vspace{3mm}
  \centering
  \scriptsize
  \begin{tabular}{@{} lm{15em}m{42em} @{}}
  \toprule
  {\textbf{Function}} &  {\textbf{Arguments}} &  {\textbf{Description}}\\        
  \midrule
  \textbf{set\_timings} & RowClone\_T1, RowClone\_T2, tRCD & Updates CRF registers with the timing parameters used in RowClone (\emph{T1} and \emph{T2}) and D-RaNGe (\emph{tRCD}) operations.\\
  \textbf{rng\_configure} & period, address, bit\_offsets & Updates CRF registers to configure the random number generator to generate random numbers by accessing the DRAM \emph{address} in periods of \emph{period} cycles and collecting the bits at \emph{bit\_offsets}.\\
  \textbf{copy\_row} & source\_address, destination\_address & Performs a RowClone-Copy operation in DRAM from the \emph{source\_address} to the \emph{destination\_address}.\\
  \textbf{activation\_failure} & address & Induces an activation failure in a DRAM location pointed by the \emph{address}.\\
  \textbf{buf\_sz} & - & returns the size of the random number buffer\\
  \textbf{rand\_dram} & - & returns 32 bits from the random number buffer\\
  \midrule
  \end{tabular}

\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R3/\arabic*]
       \addtocounter{enumi}{3}
        \item \label{q:r3q4} \onur{Another thing I would like the authors to discuss more clearly is the difficulty of extending the given basic components with new functionalities. For example, it is said the DRAM timing can be configured; how hard would it be to define new commands that do not exit in today's DDRx protocols? Do we as the system architects need to routinely interact with PHY directly?}
    \end{enumerate}
\end{tcolorbox} 

Configuring the DRAM timing and adding new standard commands are relatively straightforward in PiDRAM \onur{and do not require system architects to directly interact with the PHY}. Please see our answer to \ref{q:r1q1} and Section~\ref{sec:extending-pidram} in the revised version that discusses PiDRAM's extensibility in more detail.

\newpage
\begin{tcolorbox}
    \begin{enumerate}[label=R3/\arabic*]
       \addtocounter{enumi}{4}
        \item \label{q:r3q5} \onur{The introduction mentions a few motivations (i.e., insufficient features of existing solutions), such as non-standard DDRx operations, environmental conditions like temperature and voltage, etc. Could you summarize how PiDRAM better handle these issues? Non-standard DDRx operations are related to my previous question about defining new commands.}
    \end{enumerate}
\end{tcolorbox} 

Compared to simulators, PiDRAM allows users to observe the effects of non-standard DDRx operations (e.g., violated tRAS and tRP that we use to perform RowClone), temperature, and voltage on the reliability of PuM operations. No DRAM simulator currently models the reliability of PuM operations under different environmental conditions. Although we do not perform case studies involving the effects of temperature and voltage on the reliability of RowClone and D-RaNGe operations, future versions of PiDRAM could be easily extended (e.g., with \onur{real hardware} that allow\onur{s} controlling DRAM temperature and voltage) to experiment with different DRAM temperature and voltage levels to better understand the effects of these environmental conditions on the reliability of PuM operations while running applications end-to-end. 

\onur{We integrated parts of our response to Section~\ref{sec:related-work} of our revision:}

\vspace{5pt}
\yyboxbegin 
\Paste{R3/5}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R3/\arabic*]
       \addtocounter{enumi}{5}
        \item \label{q:r3q6} What is stored in the CRF? Do registers in CRF have a fixed meaning?
    \end{enumerate}
\end{tcolorbox} 

These registers have a fixed meaning. CRF[0] stores the timing parameters (T1, T2, and violated tRCD) for RowClone and D-RaNGe operations. CRFs[1-4] store the period and the physical location of the cells (row, bank, column, and bit indices) used for the random number generator. 

DDRx timing configurations are complex and 16 registers may not be enough to store all DDRx timing parameters. PiDRAM's goal is not to provide fine-grained control over all timing parameters. The standard timings are embedded within the design of the memory controller. However, CRF’s size can be easily increased and the state machine in the memory controller can be configured to support more non-standard DDRx timings.

We clarify the usage of CRF in Section~\ref{sec:hardware-components} \onur{of the revision:}

%\pagebreak
\vspace{5pt}
\yyboxbegin 
\Paste{R3/6}
\yyboxend 

\newpage
\begin{tcolorbox}
    \begin{enumerate}[label=R3/\arabic*]
       \addtocounter{enumi}{6}
        \item \label{q:r3q7} How can PiDRAM be ported into a newer FPGA board?
    \end{enumerate}
\end{tcolorbox} 

We added discussion on the extensibility of PiDRAM to different FPGA boards in Section~\ref{sec:extending-pidram} \onur{of the} revision:

\vspace{5pt}
\yyboxbegin 
\Paste{R3/7A}
\yyboxend

We extended Section~\ref{sec:prototype}:

\vspace{5pt}
\yyboxbegin 
\Paste{R3/7B}
\yyboxend

\newpage
\begin{center}
    {\Large \normalfont{\textbf{\hypertarget{reviewer4}{REVIEWER 4}}}}
\end{center}

\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \item \label{q:r4q1} It would be good to present some references linked with non-DRAM in-memory computing technologies (e.g., commercial neuromorphic computing offerings) and also abstract frameworks.
    \end{enumerate}
\end{tcolorbox} 

We revised our paper to include citations to a broader range of in-memory computing technologies. These are included within the highlighted block of text in the second paragraph of the introduction \onur{(Section~\ref{sec:introduction})}:

\vspace{5pt}
\yyboxbegin 
\Paste{R4/1}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{1}
        \item \label{q:r4q2} Redundancy in claims. 
    \end{enumerate}
\end{tcolorbox} 

We removed some redundant text in our revision. Please see a list of our deletions below:

\vspace{5pt}
\yyboxbegin
\noindent
\textbf{Related work \onur{(Section~\ref{sec:related-work})}:} ``We design a memory allocation mechanism that satisfies the memory management requirements of RowClone operations.''


\noindent
\textbf{Related work \onur{(Section~\ref{sec:related-work})}:} ``PiDRAM's prototype (i) fully integrates our framework into a RISC-V system, (ii) provides a custom supervisor that supports the necessary OS primitives,  and (iii) enables rapid implementation of PuM techniques using real DRAM chips. Therefore, it enables researchers to conduct end-to-end, full-system studies of PuM techniques.''

\noindent
\textbf{Section 4.1:} ``\X comprises two key hardware components that facilitate the implementation of new \atb{PuM} {operations}. \atb{First, to enable ISA-transparent control of PuM techniques, we implement the PuM operations controller (POC). \revd{The CPU} access\revd{es} (using memory LOAD/STORE instructions) the memory-mapped registers in POC to execute in-DRAM operations. Second, to facilitate the implementation of new DDRx command sequences on \X, we implement a modular and flexible custom memory controller.}.''

\noindent
\textbf{Section 4.2:} ``\atb{\X comprises two major software components that are essential to facilitate the implementation and evaluation of PuM techniques \atb{end-to-end}. First, the PuM operations library (pumolib) encapsulates functions to execute PuM operations using POC. For example, a RowClone (Section~\ref{sec:rowclone}) operation requires executing a sequence of LOAD/STORE operations targeting POC registers. Pumolib's RowClone function controls the execution of RowClone operations in \X. Second, to enable end-to-end implementations of PuM techniques, the custom supervisor software provides the necessary OS primitives (e.g., virtual memory, system calls).}''
\yyboxend

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{2}
        \item \label{q:r4q3} Avoid brackets and comments with ``e.g.'' in the abstract. 
    \end{enumerate}
\end{tcolorbox} 

We revised the abstract to avoid the use of brackets and “e.g.”.

\newpage

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{3}
        \item \label{q:r4q4} Clearly explain PuM, PnM by examples early on in the paper.
    \end{enumerate}
\end{tcolorbox} 

We extended Section~\ref{sec:introduction} with examples for PnM and PuM:

\vspace{5pt}
\yyboxbegin
\Paste{R4/4}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{4}
        \item \label{q:r4q5} Clarify the value of PiDRAM over RowClone and D-RaNGe.
    \end{enumerate}
\end{tcolorbox} 

RowClone proposes the idea of in-DRAM copy operations and evaluates it using simulations. D-RaNGe demonstrates that real DRAM chips can be used to generate random numbers when they are operated with an activation latency (tRCD) value that is smaller than manufacturer-recommended values. Although these works briefly discuss how their ideas could be integrated into a real system, they do not integrate the ideas into real systems \onur{and thus these works do not build working prototypes.}

We show for the first time how RowClone and D-RaNGe can be integrated into a real system by developing the necessary system support that is required to implement the two mechanisms. We show through our case studies that system integration is important as it can have implications for the performance of PuM techniques. For example, we show that cache line flush operations can greatly reduce the throughput improvements RowClone-Copy operations can provide (Section~\ref{sec:clflush-overhead}). This is not quantified in the RowClone paper \onur{(or in any follow-up work we are aware of)}.

The value of end-to-end frameworks like PiDRAM lies in their ability to allow system integration of techniques that are priorly developed in constrained environments (e.g., simulators). For example, a prior work, MetaSys [A], develops an end-to-end framework to integrate a general metadata management system into a computing system and makes new and important observations on how the metadata management system performs. These observations were not made in prior work that developed metadata management systems in constrained environments (e.g., XMem [B] in simulators).

We believe that the example studies that we conduct and the new observations we make signify the importance of end-to-end integration of PuM techniques, similar to how MetaSys did for metadata management systems, and we hope that they inspire researchers to develop new PuM techniques and fully integrate them into an end-to-end system using PiDRAM.

[A] Nandita Vijaykumar et al., ``MetaSys: A Practical Open-source Metadata Management System to Implement and Evaluate Cross-layer Optimizations.'' TACO 2022.

[B] Nandita Vijaykumar et al., ``A Case for Richer Cross-layer Abstractions: Bridging the Semantic Gap with Expressive Memory.'' ISCA 2018.

\newpage
\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{5}
        \item \label{q:r4q6} Better explain DRAM operations in Section 2.1.
    \end{enumerate}
\end{tcolorbox} 

We improved the description by adding a timing sequence diagram of DRAM commands to Figure~\ref{fig:dram-bank-timing-diagram}. We also revised our description of DRAM operations and their effects on the DRAM array to make the description clearer \onur{in Section~\ref{sec:background-dram} of the revision:}

\vspace{5pt}
\yyboxbegin
\Paste{R4/6}
\yyboxend 

\onur{We insert the new figure (Figure~\ref{fig:dram-bank-timing-diagram}-right) below:}

\vspace{5pt}
\yyboxbegin
\includegraphics[width=0.6\textwidth]{figures/timing-diagram.pdf}
\centering

\textbf{Fig. 1b. Timing diagram of ACT, RD, and PRE commands targeting bank 1 (B1).}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{6}
        \item \label{q:r4q7} There is no clear argument why DRAM could be the only choice in PuM in the future.
    \end{enumerate}
\end{tcolorbox} 

We do not claim that DRAM would be the only choice in implementing PuM/PnM techniques going forward. We focus on DRAM in our work as it is the dominant memory technology in current computing systems \onur{and it is possible to develop a prototype using DRAM chips.}

\newpage
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{7}
        \item \label{q:r4q8} Section 4 and Fig. 2 numbering is mixed up.
    \end{enumerate}
\end{tcolorbox} 

\onur{To clearly explain (i) the hardware and software components of PiDRAM, and (ii) the execution flow of a PuM operation, we separated old Fig. 2. into Figures~\ref{fig:pidram-overview} and~\ref{fig:flow}. We refer to the numbers in new Figure~\ref{fig:pidram-overview} in Sections~\ref{sec:hardware-components} and~\ref{sec:software-components}, and to the numbers in new Figure~\ref{fig:flow} in Section~\ref{sec:execution-overview}. We insert the new Figures~\ref{fig:pidram-overview} and~\ref{fig:flow} below:}

\vspace{5pt}
\yyboxbegin
\includegraphics[width=0.9\textwidth]{figures/02_overview.pdf}
\centering

\textbf{Fig. 2. \tacorevcommon{PiDRAM overview. {Modified h}ardware {(in green)} and software {(in blue)} components. \revd{Unmodified components are in gray.} {A pumolib function executes load and store instructions in the CPU to perform PuM operations (in red).} We use yellow to highlight the key hardware structures that are controlled by the user to perform PuM operations.}}

\includegraphics[width=0.9\textwidth]{figures/02_overview.pdf}
\centering

\textbf{Fig. 3. \tacorevcommon{Workflow for a PiDRAM RowClone-Copy operation.}}
\yyboxend 

\newpage
\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{8}
        \item \label{q:r4q9} What happens when you want to switch the DRAM device?
    \end{enumerate}
\end{tcolorbox} 

We \onur{improved the description of} the effort required to use different DRAM devices in PiDRAM \onur{in our revision}. These changes are in Section~\ref{sec:rowclone_mechanism}.

\vspace{5pt}
\yyboxbegin
\Paste{R4/9}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{9}
        \item \label{q:r4q10} Is it sufficient to perform 1000 RowClone operations to be sure that the DRAM will perform correctly in future as well?
    \end{enumerate}
\end{tcolorbox} 

We repeated our experiments after approximately 10 months. We reproduce the same results using the same DRAM device and testing methodology. Although the new experiments increase our confidence in the robustness of RowClone operations in real DDR3 devices, we cannot \onur{absolutely} guarantee that the DRAM device will perform correctly in the future. This could be guaranteed by manufacturers once they develop real DRAM chips with RowClone support. We hope that our work inspires DRAM manufacturers to produce DRAM chips with reliable in-DRAM copy capability. \onur{After that, our work would still be useful as it would allow experimentation and evaluation with such chips that support in-DRAM copy operations.}


\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{10}
        \item \label{q:r4q11} Figure 8b is hard to follow.
    \end{enumerate}
\end{tcolorbox} 

We incorporated the absolute numbers for rcc and rci’s execution times in Figure~\ref{fig:system-copy-speedup2-abs} \onur{(old Figure 8b)} in our revision.


\vspace{5pt}
\yyboxbegin

         \includegraphics[width=0.6\textwidth]{figures/perf-absolute.pdf}
         \centering
         
         \textbf{Fig. 9b. The execution time of \texttt{rcc} and \texttt{rci} in CPU cycles for consecutive array sizes}
\yyboxend 

\newpage
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{11}
        \item \label{q:r4q12} \onur{Page 16, footnote 2 states that forkbench and compile workloads could not be fully executed. How reliable are results then?}
    \end{enumerate}
\end{tcolorbox} 

\onur{The parts of the workloads we execute in our estimation study faithfully represent the copy/initialization intensity of the workloads. We cannot fully execute the workloads because our supervisor software currently does not support all system calls made by these workloads.} We refer the reviewer to our methodology (Section~\ref{sec:real-workload-study}) for the performance estimation study of the two workloads. We believe that the results we obtain following this methodology are sound.

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R4/\arabic*]
        \addtocounter{enumi}{12}
        \item \label{q:r4q13} Why do you need to write more Verilog to implement D-RaNGe. How does PiDRAM help with the implementation?
    \end{enumerate}
\end{tcolorbox} 

There is no open-source Verilog implementation of the D-RaNGe TRNG. We present the lines of code (LOC) numbers for D-RaNGe implemented on top of PiDRAM. We expect a standalone (i.e., without using PiDRAM’s key components) D-RaNGe implementation to take \onur{many} more lines of code and effort, as it would require designing at least a DDR3 controller, and buffers and interfaces to communicate the random numbers with the rest of the system, which PiDRAM already provides. 


\newpage
\begin{center}
    {\Large \normalfont{\textbf{\hypertarget{reviewer5}{REVIEWER 5}}}}
\end{center}

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R5/\arabic*]
        \item \label{q:r5q1} Why cannot you create a configurable memory controller that requires no hardware modifications to implement the techniques you evaluate?
    \end{enumerate}
\end{tcolorbox} 

We believe that PiDRAM can be extended \onur{with features that would allow it to evaluate PuM techniques with no hardware changes in the future.} However, this is not one of the goals of our framework \onur{as it would require substantially more effort and would have downsides due to configurability such as design complexity.}

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R5/\arabic*]
        \addtocounter{enumi}{1}
        \item \label{q:r5q2} How do you extend PiDRAM with new case studies? How do you perform an exhaustive search of all possible command sequences? Are timings set at a global scale?  
    \end{enumerate}
\end{tcolorbox} 

Please see Section~\ref{sec:extending-pidram} in the revised paper where we describe PiDRAM’s extensibility in the context of new case studies.

Although PiDRAM provides parameterizable timing parameters for the PuM techniques it implements (e.g., tRAS, tRP, and tRCD), it is \onur{\emph{not}} designed with the goal of providing parameterizable timing parameters for \onur{\emph{all}} DRAM commands. Allowing an exhaustive search of all possible command sequences with different timings is \onur{\emph{not}} the goal of PiDRAM and thus we do \onur{\emph{not}} provide such capability. We added relevant discussion in Section~\ref{sec:related-work} in our revision where we compare against prior DRAM testing infrastructures.

We extended Section~\ref{sec:extending-pidram} with descriptions on how PiDRAM can be extended with new studies:

\vspace{5pt}
\yyboxbegin 
\Paste{R5/2}
\yyboxend 

Section~\ref{sec:related-work}:

\vspace{5pt}
\yyboxbegin 
\Paste{R5/2B}
\yyboxend 

\newpage
\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R5/\arabic*]
        \addtocounter{enumi}{2}
        \item \label{q:r5q3} Explain in more detail how the framework can be extended.
    \end{enumerate}
\end{tcolorbox} 

We revised the paper to include discussion on how the framework can be extended to implement new techniques in Section~\ref{sec:extending-pidram}. \onur{We refer the reviewer to Section~\ref{sec:extending-pidram} for details on how our work can be extended to (i) implement new DRAM commands and modify timing parameters, (ii) implement new case studies, and (iii) support new FPGA boards.} We will expand on this discussion in the final version of the paper. 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R5/\arabic*]
        \addtocounter{enumi}{3}
        \item \label{q:r5q4} How can PiDRAM be ported to newer DRAM technologies?
    \end{enumerate}
\end{tcolorbox} 

We incorporated discussion on how to support newer DRAM standards in Section~\ref{sec:extending-pidram}. \onur{We include the relevant text from Section~\ref{sec:extending-pidram} below:}

\vspace{5pt}
\yyboxbegin 
\Paste{R3/7A}
\yyboxend 

\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R5/\arabic*]
        \addtocounter{enumi}{4}
        \item \label{q:r5q5} What happens when the size of \texttt{alloc\_align()} is larger than combined rows width? 
    \end{enumerate}
\end{tcolorbox} 

If the \texttt{alloc\_align} size is larger than the combined rows width, or there \onur{are} no more physical pages to allocate, the \texttt{alloc\_align} call fails and causes an exception. We \onur{revised} the discussion in Section~\ref{sec:rowclone_mechanism} to include our answer in the revision:

\vspace{5pt}
\yyboxbegin 
\Paste{R5/5}
\yyboxend 


\bigbreak
\begin{tcolorbox}
    \begin{enumerate}[label=R5/\arabic*]
        \addtocounter{enumi}{5}
        \item \label{q:r5q6} Minor comments\onur{: (i) explicitly mention the concept of violated timing in discussing ComputeDRAM, (ii) make sure that ``VDD'' and ``VDD/2'' and other values are used correctly across the text, (iii) double citation of [66], (iv) in Section 2.2, RowClone is not one of the referenced techniques on the text, expand on [14] instead, (v) Table 1 lists RowClone and Ambit as use cases, but these require modifications to DRAM chips, (vi) footnote 9 would better serve as part of the paragraph, and (vii) typo in ``8192 KiB < N < 8 MiB''.}
    \end{enumerate}
\end{tcolorbox} 

We revised the relevant parts in text to explicitly mention timing violations, fixed inconsistent use of VDD, removed redundant citations, and revised Section~\ref{sec:background-dram}. We revised Table~\ref{table:use-cases} to better describe the techniques we implemented in PiDRAM. We moved the footnote on page 8 into the paragraph. We fixed a typo in the revision.