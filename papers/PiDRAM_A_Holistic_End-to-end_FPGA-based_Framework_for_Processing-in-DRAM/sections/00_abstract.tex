\juan{
\new{Commodity DRAM based processing-using-memory (PuM) techniques that are\revdel{ reliably} supported by off-the-shelf DRAM chips present an opportunity for alleviating the data movement bottleneck at low cost.}
However, system integration of \new{these} techniques imposes non-trivial challenges that are yet to \atb{be} solve\atb{d}. 
Potential solutions to the integration challenges require appropriate tools to develop \newnew{any} necessary hardware and software components. 
Unfortunately, current proprietary computing systems, specialized DRAM-testing platforms, or system simulators do not provide the flexibility and/or the holistic system view that is necessary to \newnew{properly evaluate and} deal with \new{the} integration challenges \new{of commodity DRAM based PuM techniques}.}

\juan{We design and develop \X, \atb{the first} flexible end-to-end framework that enables system integration studies and evaluation of real, {commodity DRAM based} PuM techniques. 
\X provides software and hardware \atb{components} to rapidly integrate PuM techniques across the whole system software and hardware stack. 
We implement \X on an FPGA-based RISC-V system.}
\atb{To demonstrate the flexibility and ease of use of \X, we implement \juan{and evaluate} two state-of-the-art {commodity DRAM based} PuM techniques: \new{(i) in-DRAM copy and initialization (RowClone) and (ii) in-DRAM true random number generation (D-RaNGe)}}.
\revdel{First, we implement %RowClone 
\juan{in-memory copy and initialization. We propose solutions to integration challenges and conduct a detailed end-to-end implementation study.}
\atb{Second, we implement} \juan{a true random number generator in DRAM.}
Our results show that
\juan{the in-memory copy and initialization techniques can} improve the performance of bulk copy operations by 12.6$\times{}$ and bulk initialization operations by 14.6$\times{}$ \juan{on a real system}.
Implementing
\juan{the true random number generator} requires \juan{only} 190 lines of Verilog and 74 lines of C code
\juan{using \X's software and hardware \atb{components}.}} \new{We describe how we solve key integration challenges to make \newnew{such} techniques \newnew{work and be effective} on a real-system prototype, including memory allocation, alignment, and coherence.} \new{We observe that end-to-end RowClone speeds up bulk copy and initialization operations by 14.6$\times{}$ and 12.6$\times{}$, respectively over conventional CPU copy\newnew{, even when coherence is supported with inefficient cache flush operations}.} \new{Over PiDRAM's extensible codebase, integrating both RowClone and D-RaNGe end-to-end on a real RISC-V system prototype takes \newnew{only} 388 lines of Verilog \newnew{code} and 643 lines of C++ code.}