\section{Prioritized Positional Inverse Kinematics for Selective Spraying}
Selective agricultural spraying refers to the task of spraying a specific part of the plant, for example a cluster of grapes. This task is handled as a prioritized positional inverse kinematics problem. Prioritization between the translational and rotational components of the 3T2R task used for continuous spraying remains for this use case. 

\subsection{Prioritized Positional Inverse Kinematics Solver}

\begin{figure*}[!ht]
\centering
\includegraphics[width=0.9\textwidth]{./figures/pik_all_three_newest.png}
\caption{Prioritized positional inverse kinematics examples for the task of selective agricultural spraying. Transparent blue sphere and arrow represent the desired position and desired approach axis orientation of the spraying frame respectively, and the transparent purple sphere represents the desired elbow position.}
\label{fig:pik_fig}
\end{figure*}

Prioritized positional inverse kinematics solver implementation is similar to standard numerical inverse kinematics, iteratively solving the velocity level problem. The velocity level problem is solved as a constrained prioritized task-space control problem, as described in section \ref{sec:cont_spr}. While the standard positional inverse kinematics solvers aim to achieve a commanded end-effector pose, the presented solver has the ability of handling multiple, potentially conflicting tasks with different priorities. 

Solver pseudoalgorithm is given in Algorithm \ref{alg:pik}. The algorithm requires an initial guess for joint positions $\boldsymbol{q}_{initial}$. Task errors and Jacobians are calculated based on the current joint positions $\boldsymbol{q}$ and the type of the task. Error gradients are updated for each task as a difference between the task error in current and previous iteration of the algorithm. Task Jacobians and clamped errors are used to construct a prioritized task space control problem. Finally, a solution to the prioritized task space problem is used to update the current joint positions. If the sum of all task error norms or error gradient norms reaches a threshold the problem is considered to be solved. 
\begin{comment}
\begin{algorithm}
\caption{Positional prioritized inverse kinematics solver.}\label{alg:pik}
$\boldsymbol{q} \gets \boldsymbol{q}_{initial}$\\
tasks $\gets [ ]$ \\
%$\nabla err \gets 0$\;
\While{$\sum \norm{ \boldsymbol{err_i}} \geq \varepsilon_{e}$ \textbf{and} $\sum \norm{ \nabla \boldsymbol{err_i}} \geq \varepsilon_\nabla$}
{
    \For{$i\gets0$ \KwTo N}{
    $\boldsymbol{J}_i$ \gets $getTaskJacobian(\boldsymbol{q}, tasktype_i)$\\
    $\boldsymbol{err}_i$ \gets $getTaskError(\boldsymbol{q}, tasktype_i)$\\
    $\nabla \boldsymbol{err}_i$ \gets $updateGradient(\boldsymbol{err}_i)$\\
    $\boldsymbol{err}_i$ \gets $clampTaskError(\boldsymbol{err}_i, $tasktype$_i)$\\
    tasks.insert($\boldsymbol{J}_i, \boldsymbol{err}_i$)\\
    }
    $\boldsymbol{q}$ \gets $solvePTSC(tasks, constraints)$\\
    tasks.clear$()$ \\
}

\end{algorithm}
\end{comment}

\begin{algorithm}
\caption{Positional prioritized inverse kinematics solver.}\label{alg:pik}
$\boldsymbol{q} \gets \boldsymbol{q}_{\text{initial}}$\\
tasks $\gets [ ]$ \\
%$\nabla \text{err} \gets 0$\;
\While{$\sum \|\boldsymbol{err}_i\| \geq \varepsilon_{e}$ \textbf{and} $\sum \|\nabla \boldsymbol{err}_i\| \geq \varepsilon_{\nabla}$}
{
    \For{$i\gets0$ \KwTo $N$}{
        $\boldsymbol{J}_i \gets \text{getTaskJacobian}(\boldsymbol{q}, \text{tasktype}_i)$\\
        $\boldsymbol{err}_i \gets \text{getTaskError}(\boldsymbol{q}, \text{tasktype}_i)$\\
        $\nabla \boldsymbol{err}_i \gets \text{updateGradient}(\boldsymbol{err}_i)$\\
        $\boldsymbol{err}_i \gets \text{clampTaskError}(\boldsymbol{err}_i, \text{tasktype}_i)$\\
        tasks.\text{insert}$(\boldsymbol{J}_i, \boldsymbol{err}_i)$\\
    }
    $\boldsymbol{q} \gets \text{solvePTSC}(\text{tasks}, \text{constraints})$\\
    tasks.\text{clear}()\\
}
\end{algorithm}
 
Prioritized inverse kinematics library for ROS is available on GitHub\footnote{\url{https://github.com/ivatavuk/pik_ros}}. MoveIt is used to calculate the Jacobians of the specified frames, which must be present in the URDF file of the MoveIt planning group. 

The Jacobians obtained with MoveIt are modified to support any of the following tasks: 
\begin{itemize}
    \item Frame pose task
    \item Frame position task
    \item Frame orientation task
    \item Frame approach axis vector task
\end{itemize}
These task types correspond to the $tasktype_i$ variable in the pseudoalgorithm \ref{alg:pik}. A frame pose task Jacobian is the standard Jacobian matrix, and frame position and orientation task Jacobians correspond to the first and last three rows of the frame pose Jacobian. The Jacobian and the error for the frame approach axis vector task are calculated as described in section \ref{sec:cont_spr}. 

\begin{comment}
 The framework allows for user defined parameters used by solver, which are:
\begin{itemize}
    \item Change in joint angle constraint
    \item Positional clamp magnitude
    \item Orientational clamp magnitude
    \item Use constrained optimization
    \item Error norm threshold
    \item Maximum execution time
    \item Maximum number of iterations
\end{itemize}   
\end{comment}

\subsection{Selective Spraying Examples}
Tasks used in selective agricultural spraying examples are, with decreasing priorities:
\begin{itemize}
    \item Spraying frame position task
    \item Spraying frame approach axis orientation task
    \item Elbow frame position task
\end{itemize}

Like for the continuous spraying, there is a prioritization of the spraying frame position over its approach axis orientation, which correspond to the translational and rotational components of the 3T2R task. The third priority, which fully constrains the positional inverse kinematics problem is the desired elbow frame position.

The solver was tested on three different examples seen in Fig. \ref{fig:pik_fig}, with desired values for all the tasks given in table \ref{tab:pik_examples}. Tasks are set up in such a way that in the first two examples the desired values of the full 3T2R task are feasible, and the elbow position task fully constrains the problem, and in the last example only the position of the spraying frame is feasible (Fig. \ref{fig:pik_fig}). 

\begin{table}[]
    \centering
    \begin{tabular}{c | c c c c}
         Example & \makecell{ Spraying frame \\ position [m] }  & \makecell{ Spraying frame \\ approach axis \\ vector } & \makecell{ Elbow \\ position [m]} \\
         \hline
         1 & [0.4 1.0 0.2] & [0 1 0] & [0.0 -0.5 0.5] \\
         2 & [0.4 1.0 0.8] & [0.511 0.511 0.69] & [0.0 -0.5 0.5] \\
         3 & [0.4 1.0 0.8] & [0.577 0.577 -0.577] & [0.0 -0.5 0.5]
    \end{tabular}
    \caption{Desired values for prioritized tasks used in the examples.}
    \label{tab:pik_examples}
\end{table}

The description of solver performance for the examples is given in Tab. \ref{tab:pik_results}. All experiments were conducted on a $2.2$\textit{GHz} Intel Core i7 processor. It can be noticed that the third example takes the largest amount of time to be solved, which is due to the solution being close to the robot arm singularity. %This is even more noticable when solution polishing is not used, which results in large movements around the singularity that do not improve the solution. 

\begin{table}[]
    \centering
    \begin{tabular}{c | c c c c}
         Example & \makecell{ Task 1 \\ err [m] }  & \makecell{ Task 2 \\ err [rad]} & \makecell{ Task 3 \\ err [m]} & \makecell{ Time \\ \textnormal{[ms]} } \\
         \hline
         1 & 0.00020 & 0.00019 & 0.3525 & 11.09 \\
         2 & 0.00054 & 0.00067 & 0.7222 & 19.86 \\
         3 & 0.00247 & 0.2052 & 0.6253 & 30.07 
    \end{tabular}
    \caption{Task errors and calculation time for the examples.}
    \label{tab:pik_results}
\end{table}

Parameters for the solver used in the examples are:
\begin{itemize}
    \item Use constrained optimization = $True$
    \item Error norm gradient threshold = $1\times 10^{-3}$
    \item Change in joint angle constraint = $10$ [$^{\circ}$]
    \item Use solution polishing = $True$
    \item Polish error norm gradient threshold = $1\times 10^{-2}$
    \item Polish change in joint angle constraint = $3$ [$^{\circ}$]
    \item Positional clamp magnitude = $0.3$ [m]
    \item Orientational clamp magnitude = $30$  [$^{\circ}$]
    %\item Maximum execution time = $\infty$ [s]
    %\item Maximum number of iterations = $\infty$
\end{itemize}

Solution polishing refers to the usage of smaller change in joint angle constraint when the solver is close to the solution, which is detected as \textit{polish error norm gradient threshold} being reached.  
\begin{comment}
\begin{table}[]
    \centering
    \begin{tabular}{c|c|c|c|c}
        Example &               1 & 2 & 3 & 4\\
        Task 1 error [m] &      0.0015632 & 0.0015632 & 0.0015632 & 5.74\\
        Task 2 error [rad] &    0.0015632 & 0.0015632 & 0.0015632 & 5.74 \\
        Task 3 error [m] &      0.0015632 & 0.0015632 & 0.0015632 & 5.74\\
        Time [ms] &             0.0015632 & 0.00126516 & 0.78838 & 5.74 
    \end{tabular}
    \caption{Caption}
    \label{tab:my_label}
\end{table}
\end{comment}

All three tasks are not feasible in any of the given examples, so the solver considers the positional prioritized IK problem solved once task error gradients reach a specified threshold. For most prioritized inverse kinematics applications the same would be the case, as the main strength of this approach is its ability to handle conflicting, infeasible tasks with clearly defined priorities. 
