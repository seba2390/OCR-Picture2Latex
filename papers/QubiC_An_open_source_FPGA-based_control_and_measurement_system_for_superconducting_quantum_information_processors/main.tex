\documentclass{ieeetran}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{multirow}
\usepackage{soul}
\usepackage[caption=false,font=footnotesize,subrefformat=parens,labelformat=parens]{subfig}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}


\title{QubiC: An open source FPGA-based control and measurement system for superconducting quantum information processors}
\author{\IEEEauthorblockN{Yilun Xu,$^1$
Gang Huang,$^1$
Jan Balewski,$^1$
Ravi Naik,$^2$
Alexis Morvan,$^1$
Bradley Mitchell,$^2$
Kasra Nowrouzi,$^1$
David I. Santiago,$^1$
and Irfan Siddiqi$^{1,2}$}
\IEEEauthorblockA{\\$^1$Lawrence Berkeley National Laboratory, Berkeley, CA 94720, USA
\\$^2$University of California at Berkeley, Berkeley, CA 94720, USA
\\Corresponding author: Gang Huang (email: ghuang@lbl.gov)}}

\maketitle

\begin{abstract}
As quantum information processors grow in quantum bit (qubit) count and functionality, the control and measurement system becomes a limiting factor to large scale extensibility. 
To tackle this challenge and keep pace with rapidly evolving classical control requirements, full control stack access is essential to system level optimization. 
We design a modular FPGA (field-programmable gate array) based system called QubiC to control and measure a superconducting quantum processing unit. 
The system includes room temperature electronics hardware, FPGA gateware, and engineering software. 
A prototype hardware module is assembled from several commercial off-the-shelf evaluation boards and in-house developed circuit boards. 
Gateware and software are designed to implement basic qubit control and measurement protocols. 
System functionality and performance are demonstrated by performing qubit chip characterization, gate optimization, and randomized benchmarking sequences on a superconducting quantum processor operating at the Advanced Quantum Testbed at Lawrence Berkeley National Laboratory. 
The single-qubit and two-qubit process fidelities are measured to be 0.9980$\pm$0.0001 and 0.948$\pm$0.004 by randomized benchmarking. 
With fast circuit sequence loading capability, the QubiC performs randomized compiling experiments efficiently and improves the feasibility of executing more complex algorithms. 
%Version2: Facing the challenge of expandability on the room temperature qubit control and measurement system, we developed an open source FPGA based qubit control system called QubiC, to bridge the quantum algorithm and the quantum hardware implementation.
%The QubiC system includes the room temperature electronics hardware, the FPGA gateware and the engineering software together to implement the pulses to control and measure the qubits.
%The QubiC hardware includes three basic building modules: the FPGA/ADC/DAC module, the LO and clock generation, and the RF mixing module.
%The QubiC gateware is capable of the readout synchronous detection and the arbitrary pulse sequence generation from command and memory.
%The QubiC software consists of three different layers, including the API, a portfolio of QCVV experimental scripts and the engineering GUI.
%The single-qubit and two-qubit process fidelities were measure to be 0.9980$\pm$0.0001 and 0.948$\pm$0.004 from the randomized benchmarking on a superconducting quantum processor in a dilution refrigerator, which validated the QubiC system functionality and performance.
%Leveraging the QubiC system, we ran also the RC circuit fast and observed the result improvement with smaller total variational distance values. 
\end{abstract}



\section{Introduction}
The quantum computer represents a paradigm shifting innovation for computing technology, spurring the development of new breakthroughs in science \cite{preskill2018quantum,google2020hartree}.
Superconducting-circuit-based quantum bits (qubits) are a leading platform for quantum information science, with recent demonstrations of quantum advantage \cite{arute2019quantum}.
Qubit control hardware generates and routes complex sequences of radio frequency (RF) signals from room temperature electronics to the quantum processor at cryogenic temperature. 
As the size and complexity of the quantum system increases, the cost-efficient and compact generation of such signals becomes a bottleneck limiting system extensibility in the near term noisy intermediate-scale quantum (NISQ) computing era \cite{vainsencher2019superconducting}.
Thus, hardware elements in a next-generation design should be carefully matched to the needs of both current and potential future superconducting multi-qubit processors, while maintaining the modularity available at the printed circuit board (PCB) design level. 
However, commercially available lab equipment such as arbitrary waveform generators (AWG) and data acquisition cards (DAQ) are designed for general purpose test and measurement applications, and typically cannot keep pace both in terms of footprint and cost as quantum system complexity increases \cite{ryan2017hardware}. 
A customized quantum engineering solution rooted in extensible primitives is needed for the quantum computing community.

The field-programmable gate array (FPGA) architecture allows for customized solutions capable of growing and evolving with the field \cite{salathe2018low}. 
Several FPGA frameworks have been developed for quantum control and measurement \cite{steffen2013deterministic,riste2013deterministic,bultink2016active,gebauer2020state}.
Nevertheless, current FPGA-based control systems are not fully open to the broader quantum community so it is hard to make a general toolbox for information scientific discovery \cite{chen2012multiplexed,ofek2016extending,fu2017experimental}. 
Understanding the full electronics hardware and software stack of the qubit control systems is essential to the system level optimization and extensibility \cite{bertels2020quantum}.
%Having access to each individual layer and make the effort of physics analysis and control demonstration will benefit everyone developing quantum systems.
Furthermore, compiling near-term quantum algorithms directly down to the native hardware descriptions via pulse-level control will improve the reliability of program execution \cite{gokhale2020optimized}.
Recent developments have also explored highly integrated system-on-chip (SoC) solution and moved it to the cryogenic stage \cite{bardin201928,patra2020scalable,pauka2021cryogenic}.
As such efforts mature, they will benefit from a deeper understanding of the control requirements that emerge as system size increases, and will thus rely on broad conceptual explorations rooted in more flexible hardware platforms. 

Here we develop and test the QubiC (Qubit Control) system -- an open source FPGA based RF control system that integrates qubit pulse generation and quantum state measurement \cite{qubic2021repository}.
Leveraging state-of-the-art FPGA technology, QubiC provides fully parametric waveform generation, and allows researchers to access all the control layers.
This scalable and cost-effective system will be a potential open source toolbox for the quantum community.

\section{QubiC system}
We design an FPGA-based qubit control system called QubiC to integrate the execution of gate-based algorithms with native quantum hardware implementation.
%The QubiC system design consists of multiple FPGAs interconnected with each other over the optical fiber to realize the synchronization and data communication. 
QubiC is an open source system which can accommodate users and developers from different layers to enable efficient co-design.
As the starting point, we develop and test a prototype system of a single control unit to demonstrate basic functionality and evaluate performance. 
%The fiber interconnection part is still under development.

The room temperature electronics hardware, the FPGA gateware, and the engineering software are integrated in the QubiC prototype system so as to realize the desired RF pulses to control and measure qubits. 
This prototype system also provides a platform to explore and optimize real-time feedback control such as fast reset \cite{vijay2012stabilizing,riste2012feedback}, and error correction algorithms.% \cite{riste2020real,hu2019quantum,das2020scalable}. 

\subsection{Electronics hardware}
The QubiC prototype hardware employs the heterodyne technique to generate and detect RF signals in a compact manner. 
It includes three basic building modules: the FPGA/ADC(analog-to-digital converter)/DAC(digital-to-analog converter) module to generate/detect the intermediate frequency (IF) signal; the RF mixing module to convert the signal frequency to/from the target frequency; and the local oscillator (LO) generation module to provide low noise LO signals, as shown in Fig.~\ref{fig:HW}.
A series of commercial off-the-shelf (COTS) evaluation boards are selected and assembled with in-house developed RF mixing modules to test functionality and benchmark performance.
Using these COTS evaluation boards enabled us to rapidly develop a hardware platform to study and develop the qubit control logic, while leaving plenty of room for channel density and cost optimization in future iterations.

\begin{figure}[t!]
\centering
\includegraphics[width=1.0\linewidth]{xu1.pdf}
\caption{QubiC prototype hardware. \textbf{MO}: master oscillator, \textbf{CLK}: clock, \textbf{LO}: local oscillator, \textbf{FPGA}: field-programmable gate array, \textbf{DAC}: digital-to-analog converter, \textbf{ADC}: analog-to-digital converter, \textbf{UP}: up converter, \textbf{DN}: down converter, \textbf{QPU}: quantum processor unit. The yellow line indicates the measurement path, while the green line defines the qubit control path.}
\label{fig:HW}
\end{figure}

\subsubsection{FPGA and ADC/DAC module}
The Xilinx VC707 and the Abaco Systems FMC120 boards are chosen for their computational capability and precision analog performance. 
The VC707 evaluation board contains an Xilinx Virtex-7 FPGA \cite{xilinx2012vc707}. 
Each FMC120 board has 4 channels of high speed (1.25~GSPS) 16-bit DACs and 4 channels of high speed (1~GSPS) 16-bit ADCs \cite{abaco2016fmc120}. 
One VC707 and two FMC120 boards are assembled in a 1U rack mount computer chassis with a customized cooling manifold to meet the FMC120 board cooling requirements. 
An external 1~GHz clock is provided to the chassis to run the DACs/ADCs at 1~GSPS, and to run the FPGA DSP at 250~MHz.
Compared with the latest RFSoC (radio frequency system-on-chip) chips, this combination gives us more choices with respect to DAC/ADC selection, particularly when tailoring hardware for specific future applications. 

\subsubsection{RF mixing module}
We develop compact RF up and down mixing modules that integrate the I/Q (in-phase/quadrature) mixer, IF/LO/RF power level adjustments and DC bias fine tuning on a 40~mm $\times$ 80~mm 4-layer PCB board with electromagnetic interference (EMI) shielding.
The RF mixing module is designed to work with RF and LO frequency between 2.5 and 8.5~GHz. 
Typical image rejection and adjacent channel isolation are measured to be $\sim$27~dBc and $\sim$50~dB. 
The RF mixing module provides 5$\times$10$^{-4}$ (V$_{\mathrm{pp}}$/V$_{\mathrm{mean}}$) amplitude stability and 1$\times$10$^{-3}$~radian (pk-pk) phase stability \cite{xu2020rf}. 

\subsubsection{LO generation module}
The noise performance of the LO generation module is critical for high-fidelity qubit operation because imperfections will directly map on to the RF/IF control signal through the RF mixing module. 
The LO frequency also needs to be adjustable from experiment to experiment to accommodate different chip designs. 
Additionally, some qubit operations will require multiple, different LO frequencies synchronized to each other.
At the same time, the size and cost of LO generation should also be factored into design consideration.

We thus use multiple phase locked loops (PLL) with a shared master oscillator (MO) to generate the LO and clock to meet these frequency and low-noise operation requirements.
The Wenzel (501-16843) 100 MHz ultra low noise crystal oscillator is used as the MO for the prototype system \cite{wenzel2006uln}.
The Texas Instruments LMX2595 evaluation modules are used as a PLL given its 20~GHz wide frequency range and low-noise performance \cite{ti2017lmx2595}.
Specifically, we measure the RMS jitter of the ``Wenzel+LMX2595'' module at the LO frequency at the qubit readout resonator frequency (6.52~GHz) and qubit drive frequency (5.50~GHz). 
As shown in Table~\ref{tab:LO}, the RMS jitters of ``Wenzel+LMX2595'' module are 1.0~ps (1~Hz--10~MHz) and 60~fs (100~Hz--10~MHz), which are comparable with the widely-used commercial Keysight signal generator \cite{keysight2021n5183b}.
The relationship between the LO phase noise metrics and the corresponding qubit dephasing spectral densities has been studied and the formula to estimate the operational fidelity bounds on superconducting qubits was derived in \cite{ball2016role}. 
Following the analysis and using the measured phase noise of the ``Wenzel+LMX2595'' configuration, we estimate that for the $\hat{X}$ gate shorter than 10~ms, the LO phase noise contributes $<$ $10^{-5}$ to the gate infidelity, which is much lower than the typical gate infidelity in superconducting qubits. 
This implies that the LO module phase noise is not the dominating factor to the gate fidelity.
Moreover, the ``Wenzel+LMX2595'' module is much more compact in size and lower in cost.

\begin{table}
\centering
\caption{LO RMS jitter}
\label{table}
\setlength{\tabcolsep}{3pt}
\begin{tabular}{c|c|c}
\hline
\multirow{3}{*}{Modules}&\multicolumn{2}{c}{RMS Jitter (@6.52~GHz / @5.50~GHz)}\\
\cline{2-3}
& Integration & Integration \\
& Bandwidth & Bandwidth \\
& (1~Hz--10~MHz) & (100~Hz--10~MHz) \\
\hline
Wenzel+LMX2595 & 1.0~ps / 0.9~ps & 60~fs / 54~fs \\
\hline
Keysight N5183B & 1.0~ps / 0.9~ps & 31~fs / 41~fs \\ 
\hline
\end{tabular}
\label{tab:LO}
\end{table}

\subsubsection{Module synchronization}
To scale the system up, we design the module-to-module synchronization using three layers of protocols \cite{huang2021clock}. 
\begin{itemize}
\item JESD204B subclass 1 \cite{ti2016jesd204b} is used to synchronize multiple DAC chips via the external SYSREF signal. 
\item Direct GPIO (general-purpose input/output) triggers are used to pass and fan out the event information which requires low latency among modules. 
\item Fiber-based synchronization using a protocol similar to the white rabbit \cite{moreira2009white} system is under development to lock the clock phases among the modules and also provide a high speed data communication path. 
\end{itemize}

\subsection{FPGA gateware}
The gateware programmed on the FPGA is the lowest level to implement digital tuneup sequences and algorithmic protocols. 
%The FPGA chip and the tool chains has been been developed rapidly that is capable implement a complex system. 
Modularity is the key to designing reusable and maintainable FPGA gateware code.
The QubiC FPGA gateware is written in the Verilog programming language and it is separated into three modules: the board support package (BSP), the digital signal process (DSP), and the host interface (HOI). 
\begin{itemize}
\item The \textbf{BSP} is hardware specific and used to implement low-level hardware configuration and initialization. 
\item The \textbf{DSP} implements basic qubit control and measurement functions and it is designed to be independent of the low-level FPGA/ADC/DAC selection. 
The DSP runs in a single clock domain and the HOI and BSP handle the clock domain crossing for the required registers, and also buffers the transmitted and received data.
\item The \textbf{HOI} handles all the input and output to and from the host computer, which is the interface that hosts higher level software.
\end{itemize}

The QubiC gateware is capable of generating waveform form parameters, which leads to the benefit of pulse sequence reuse.
The QubiC FPGA DSP is flexible and extensible.
In particular, the QubiC system has the capability of the fast reset by implementing the qubit status classification and the feedback loop in the FPGA gateware with low latency \cite{huang2020qubit}. 
In this section we will focus on the gateware DSP module and the host interface associated with it.

\subsubsection{Gateware DSP}
The basic requirements of qubit control and measurement are to generate pulses at a specified carrier frequency with arbitrary amplitude modulation, and to also synchronously detect the pulse after it goes through the readout resonator.
The hardware module shifts frequencies between the RF and IF, while the gateware DSP module is responsible for the generation and processing of the data stream between the IF signal and the baseband signal.
The QubiC gateware DSP block diagram is illustrated in Fig.~\ref{fig:GW}.

\begin{figure}[!ht]
\centering
\includegraphics[width=1.0\linewidth]{xu2.pdf}
\caption{QubiC gateware DSP block diagram. The \textbf{processing elements} are employed as the up or down converters in the digital domain. \textbf{Real} and \textbf{Imag} denote the real and imaginary parts of the complex envelope value in the \textbf{envelope buffer}. \textbf{AP} represents the amplitude (the magnitude of the complex envelope) and the phase (computed by the carrier frequency and initial phase from the command). \textbf{IQ(IF)} and \textbf{IQ(BB)} are the in-phase and quadrature-phase components of IF and baseband signals, respectively. The fields in the \textbf{command buffer} are condition (fast reset flag), frequency, destination, start, length, phase, element, trig\_t from the most significant bit (MSB) to the least significant bit (LSB). The accumulated values that comprise the integration of the baseband I/Q series over the corresponding DLO are stored in the \textbf{acc buffer}. The \textbf{acq buffer} serves as a live oscilloscope for the ADC/DLO/DAC raw data. M up conversion \textbf{processing elements} are switched to N \textbf{DACs} with the dynamic mapping. K down conversion \textbf{processing elements} can be assigned to process K-qubit readout data simultaneously through the same \textbf{ADC} pair.}
\label{fig:GW}
\end{figure}

% for the IF signal by another layer of modulation/demodulation implement in the processing element module.
% digitally with a complex multiplication of the carrier and the modulation envelope.
% The current version is take the commands from the host computer, generate the arbitrary pulse for the qubits control and measurement, and synchronous detect the response from the qubits and send the result back to the host computer after some preliminary data processing. The qubit status discrimination and fast reset has also been tested in the gateware.

The digital modulation/demodulation between the baseband envelope and the IF data stream is realized by a module called the processing element.
Processing elements can be configured to execute digital up or down conversions.
When used as the up converter, the module generates IF pulses in-phase ($I_{\mathrm{IF}}$) and quadrature-phase ($Q_{\mathrm{IF}}$) components from the gate-specific baseband envelope $I_{\mathrm{BB}}+jQ_{\mathrm{BB}}$, the initial phase $\phi_0$ and the digital local oscillator (DLO) frequency, as in
\begin{equation}
\label{eq1}
I_{\mathrm{IF}} + jQ_{\mathrm{IF}} = (I_{\mathrm{BB}} + jQ_{\mathrm{BB}}) e^{\phi_0} e^{j\omega_{\mathrm{DLO}}t} .
\end{equation}
The carrier frequency is determined by the physical property of the qubits or the readout resonator.
The carrier phase naturally rotates as time evolves; additionally the engineering software can inject additional phase offsets to implement virtual Z gates \cite{mckay2017efficient}.
The pulse envelope is defined or optimized through the qubit gate calibration process, and stored in the FPGA memory point-by-point as complex numbers, each with in-phase and quadrature-phase terms. 
Moreover, this pulse envelope can be used repetitively by indexing the same address area, even if the carrier frequency or phase changes.

The calculated result then feeds into any DAC through an m-to-n switch.
Signals from multiple processing elements can be sent to the same DAC and added together.
For each pulse to be generated, the software needs to specify the processing element, and the DAC to be used for the destination.

When the processing module is used in the down conversion mode, it receives the qubit signals from the ADC, and recovers the baseband I and Q components, which is exactly the opposite operation, as defined by
\begin{equation}
\label{eq2}
I_{\mathrm{BB}} + jQ_{\mathrm{BB}} = \left( I_{\mathrm{IF}} + jQ_{\mathrm{IF}} \right) e^{-j\omega_{\mathrm{DLO}}t} .
\end{equation}
Then the baseband I/Q series are integrated by a vector accumulator, and the results are stored in an ``accumulation buffer'' (acc buffer) for the corresponding channel to determine the qubit final state. 
The raw ADC, DAC, DLO values are available to the host computer through ``acquisition buffers'' (acq buffer) and the integrated I/Q data are available to the host computer through the acc buffer.
%The final qubit state is determined by thresholding the integrated value in the accumulation buffer.
% The integrator acts as a digital low-pass filter for the readout data.
% Putting all these together, the interface from the gateware to the software has these two pieces, the I and Q pairs for the envelope and a sequence of commands.

% \subsubsection{Processing element}
In the QubiC gateware, the processing element is flexible in the waveform generation.
Each processing element has a waveform storage and a phase rotator, but only puts out one waveform at a time. 
Once stopped, it is available to replay another waveform with another configuration. 
Waveform envelopes drawn from that memory can be variable lengths in order to start and stop arbitrarily.
Currently, the envelope buffer of each processing element is 1k deep and 32 bits wide. 
The upper and lower 16 bit words of each envelope point represent the real (I) and imaginary (Q) parts of the pulse envelope respectively.
The conversions between amplitude/phase and I/Q of a complex signal as in \eqref{eq1} and \eqref{eq2}, are implemented with the CORDIC (COordinate Rotation DIgital Computer) algorithm on FPGAs \cite{volder1959the,andraka1998a}.
%CORDIC can perform the polar-to-rectangular conversion efficiently only using a simple lookup table, along with logic to execute shifts and additions, which are naturally amenable to the FPGA.
% Note that the complex DDS (direct digital synthesis) produces a discrete-time, quantized output waveform (I/Q pairs) whose period is controlled by the digital word contained in the envelope memory and phase adjustment. 
% The CORDIC (which is a “shift” and “add” algorithm) is implemented as a polar-to-rectangular conversion due to the efficiency of calculating trigonometric functions in FPGAs.

\subsubsection{Host interface}
A qubit algorithm typically consists of a series of qubit gates and measurements, which are eventually realized by the sequence of RF pulses.
In general, a gate may consist of a series of pulses.
Gate level experiments adopt a pre-calibrated gate pulse, while pulse level experiments need access the parameters for each pulse. 
The host computer interface needs to be designed to accommodate both types of experiments by way of parametric waveform generation.

In the current QubiC gateware, each pulse is defined by the pulse start time, the envelope information, and the carrier information. 
We define a 128-bit command as the interface between the lower level gateware on an FPGA and the higher level software on a host computer:
\begin{itemize}
\item \textbf{Trig\_t} (24 bits) Pulse start time relative to the start of the whole sequence.
\item \textbf{Start} (12 bits) The start address of the envelope data in the envelope buffer.
\item \textbf{Length} (12 bits) The length of envelope buffer to play for this pulse.
\item \textbf{Frequency} (24 bits) The carrier frequency in 1~GHz represented by a 24 bits word. Each step is 1~$\mathrm{GHz}/2^{24}\approx60~\mathrm{Hz}$.
\item \textbf{Phase} (14 bits) The carrier initial phase as the $\phi_0$ shown in (\ref{eq1}). Each step is $360^\circ/2^{14}\approx 0.022^\circ$.
\item \textbf{Element} (8 bits) Processing element index.
\item \textbf{Destination} (2 bits) Destination IQ pair index.
\item \textbf{Condition} (1 bit) Flag for conditional gate, used for the fast reset gate (only available on the specified version of bit file).
\item \textbf{Reserved} 31 bits
\end{itemize}

The 128-bit command provides the parametric waveform generation from the lowest FPGA level.
The QubiC reuses sequences by updating waveform parameters via commands without recompiling or resending the waveform data.

The commands defining quantum circuits are stored in a 64k deep 128-bit wide buffer on an FPGA.
The envelope buffers are also written from the host computer and stored in each processing element. 
All commands repeat at a defined period until the acc buffer is full. 
The acc buffer can be cleared by the software after reading the data.

% For each pulse, the trigger time, pulse envelope start address, pulse length, carrier frequency, and initial phase are combined with the destination DAC index and processing element index to form a 128-bit command.
% The 128-bit command carries the information of ``when'', ``who'', ``where'', ``what'', ``how''. 
% Concretely, the command contains trig\_t (the start time from the trigger), element (the processing element in use), dest (the destination qubit or readout to be controlled), start (the start address in the waveform memory for the processing element), length (the length of the waveform memory to play for the processing element), phini (the initial phase of the carrier), and freq (the driving or measuring frequency of the carrier). 
% The processing element (employed both in transmitter and receiver) consists of an address up-counter, a length down-counter, a phase accumulator, as well as the frequency setting and the destination DAC setting. 
% The processing element is triggered by the new command. 
% When the length down-counter reaches zero, the calculating element marks itself as inactive.

Writing to the command/envelope buffer to generate pulses, and reading from the acc/acq buffer to collect responses are the lowest level software interface provided by the FPGA gateware.
At this level, we have to adhere to the restrictions imposed by the gateware implementation, for example, the maximum pulse envelope length and command depth, the frequency and phase resolution, the longest sequence time etc.
The complexity of the restrictions imposed at this lower level makes it more difficult to use directly. 
However, the advantage is that this layer has full access to the FPGA directly, and mainly serves developers who implement software directly on top of the QubiC gateware. 

\subsection{Engineering software}
The engineering software runs on the host computer, implementing the FPGA buffers/registers input/output and providing the software interface to higher level software or algorithms. 
QubiC engineering software consists of an application programming interface (API), a portfolio of quantum characterization verification and validation (QCVV) experimental scripts and a graphical user interface (GUI). 
% We also specified a structure to describe the quantum processor property as well as the gate/pulse property. In order to exchange pulse schedule information, we use 

% QubiC software is a quantum control oriented software with the core idea to generate the RF pulses to control and read the qubits.
% For a simple example shown in Fig.~\ref{fig:pulse}, we want a gate start at some time after the circuit start.
% The pulse start immediately at the gate start, and lasts 32 ns.
% We want the pulse to be sent to a line or pair of lines named ``Q6.qdrv''.
% And the carrier frequency is specified as ``Q6.freq'', while the initial phase is -1.66 radian.
% The modulation is applied with a DRAG envelope with appropriate parameters.
% Then the overall amplitude is a fraction of DAC full scale.

% The qubit chip and gate configuration are separated in two parts: the frequencies (readout resonator and qubit drive) are the property of each qubits while the gates are the interaction between the control system and the qubits. 
% Each gate is a series of pulses defined by its destination, timing, carrier, amplitude and envelope, which are captured in the JSON (JavaScript Object Notation) format file.
% It is noted that the envelope function is simply a python function (commonly used or customized) returning NumPy array.
% The simple mapping from the gate pulse configuration to the envelope definition function enables us to use any user provided Python function as the pulse envelope to construct a gate, which is essential for the pulse level optimization. 

% \begin{figure}[!ht]
% \centering
% \includegraphics[width=1.0\linewidth]{pulse_cartoon.pdf} 
% \caption{Pulse generation from the software.}
% \label{fig:pulse}
% \end{figure}

%QubiC allows the user to specify: 
%(i)  the qubit drive frequency and readout frequency; 
%(ii) the gate pulse, carrier frequency, initial phase, pulse start time relative to the gate start time, etc; 
%(iii) commonly used envelopes are provided: e.g. cosine edged square, derivative removal by adiabatic gate (DRAG), as well as customized envelopes;
%(iv) the quantum chip(s) hardware configuration, such as DAC/qubit wire mapping, sampling rate, register address mapping, etc.

% This section will explain the three layers of the QubiC engineering software: the application programming interface (API), a portfolio of QCVV (quantum characterization, verification, and validation) experimental scripts and the engineering graphical user interface (GUI).

\subsubsection{Application programming interface}
The Python 3 based API compiles the quantum processor gate pulse specification and the quantum circuit description to gateware commands and pulse envelopes.

The quantum processor gate pulse specification contains two parts: the frequencies (readout resonator and qubit drive) that represent the specific properties of each qubit and the gates that drive interactions between the control system and the qubits. 
Each gate is a series of pulses defined by its destination, timing, carrier, amplitude and envelope.
The quantum processor and gate specifications are captured in the JSON format file, which is generated or updated during the chip calibration.

The quantum circuit description can be written in our native function call or be imported from TrueQ \cite{trueq2020}. 
The measurement result can also be sent back to TrueQ to allow for post-processing of all the data. 
A similar interface to Qiskit/OpenQASM/Cirq \cite{qiskit2020,cross2017open,cirq2020} is under development.

% We developed a Python 3 based application programming interface (API) to generate the gateware commands and pulse envelopes for an arbitrary circuit. 
% There are two distinct types of tasks, and we optimize the compilers accordingly. 
The compiler is the bridge to translate the circuit description into the envelope and command buffers.
There are two distinct types of compilers in the QubiC API. 
The first one is the OPTM (OPTiMize gate) compiler which is used during the chip characterization and gate optimization.
The OPTM compiler accommodates multiple different pulse envelopes, in length, shape or other parameters.
The envelope buffers from all the processing elements are collected together and allocated dynamically so that they can all be used in the specified qubits. 
In the OPTM compiler, the circuit description is written in our native function call.
% with the simple format of ``\textbf{seqs.add(time,gate.modify(parameters))}''.
One can add a gate onto a sequence at a specific time and modify the gate parameters at the compiling time.
%by updating the Python dictionary, which stores the gate configuration in the task.
The validation test is necessary in the OPTM compiler and so it takes longer to compile.
%The OPTM compiler tweaks the gate parameters a lot but only one or two qubits are used in the experiment.
%This typically happens during the chip characterization and gate optimization. 
%Here we implements the OPTM (OPTiMize gate) compiler. 
%Since OPTM and RUNC compilers coexist in the QubiC software, different tasks may have different control flows, as shown in Fig.~\ref{fig:QCVV}. 
%To execute the experimental using OPTM, QubiC software needs to initialize the hardware and generate the sequence with the native function call, in the format of ``seqs.add(time,gate.modify(parameters))''.
%One can modify the gate parameters by updating the Python dictionary in the task. 
%In the OPTM mode, QubiC acquires, processes the data, and visualizes the results.

Another compiler is the RUNC (RUN Circuit) compiler, which is used to run a quantum circuit with calibrated gates on all the qubits simultaneously.
Since only a few predefined gates are applied for each qubit, the envelope memory can be pre-allocated statically to reduce the compiling time. 
In the RUNC compiler, the circuit description can be imported from other languages, which need to be translated to the QubiC format. 
%using the intermediate format of ``\textbf{start$\_$flag,(gate,parameters)$\times$N}''.
%The \textbf{start$\_$flag} denotes the flag for the circuit starting gate.
%One can also modify \textbf{parameters} of \textbf{gates} from the imported circuit.
The validation tests during compiling are skipped to execute long circuits efficiently in the RUNC compiler.

% Another task is to run the quantum circuit based on the calibrated gates. 
% In this case, we need to run all the qubits simultaneously. 
% This compiler is called RUNC (RUN Circuit) compiler. 
% We can import circuits from other languages (TrueQ, Qiskit, Cirq \cite{cirq2020}, etc.) to QubiC RUNC compiler to implement the quantum algorithms.
% By this configurable switching between the two compilers, we balance the compiling time requirement and the pulse envelope memory size on the FPGA chip. 
%If the circuits are imported from other languages such as TrueQ, QubiC needs to switch to the RUNC mode. An intermediate format as ``start$\_$flag,(gate,parameters)*N'' is defined to transfer the TrueQ language to QubiC language. QubiC interacts with the QPU by generating sequences and reading back the qubit status.
%QubiC processes the data, while TruQ visualizes the results.

The OPTM and RUNC compilers coexisting in the QubiC software bring in the flexibility and efficiency for distinct control flows. 
The OPTM compiler targets a comprehensive chip calibration via tweaking multiple parameters with high accuracy in a broad range, while the RUNC compiler specifies a dedicated structure to perform the advanced quantum algorithms in an efficient manner.
Both the OPTM and RUNC are 3-step compilers which are illustrated in Appendix.

\subsubsection{QCVV experiments support}
% To start a new QCVV experiment from the API, we first should inherit from the experiment base class.
% The base class handles the compiling and execution parts of the job.
% Then the application must define the experiment sequence, including the gate sequence and the pulses to be sent out.
% We also need to determine which readout buffer should be read as the result. 
% The readout buffer can be the I/Q buffer, or the ADC raw value buffer which can be served as a live oscilloscope.
% For each application, typically we need to define some application specific post-process and plot generation.
% A series of configuration files are used together with the Python scripts to configure the compiler, to pass the chip and gate configuration for the particular chip or qubit.

% %While the X or Y pulse is set by the fixed phase offset, the virtual Z pulse is set by the accumulated frame which corresponds to adding a phase offset to the drive field for all subsequent X and Y pulses. 
% %Since the qubit control is defined in a rotating frame, the phase modulated to each pulse is the sum of the accumulated phase increment, the fixed phase offset, and the accumulated frame.

A calibrated quantum information processor is the necessary prerequisite to perform QCVV experiments. 
In the current QubiC engineering software, a series of scripts are developed to characterize the quantum information processor and optimize the gates to support the superconducting QCVV experiments.
This type of characterization and optimization routine can also be adapted for other architectures at hand.
Quantum processor characterization begins with time alignment, which measures the latency for the readout signal and aligns it with the DLO.
The single-tone experiment involves measuring all the readout resonator frequencies on the readout bus \cite{chen2012multiplexed}.
We also conduct a punch-out experiment where the drive power is increased significantly to suppress the Josephson nonlinearity of the qubit, yielding a simple spectroscopic signature of viable qubits, and a coarse adjust of the readout amplitude needed to achieve linear operation \cite{reed2010high}.
The qubit drive frequency can be extracted from a two-tone spectroscopy experiment or the chevron pattern obtained from coherent oscillations.
We drive Rabi oscillations with different pulse lengths or amplitudes, and derive a Gaussian mixture model (GMM) for qubit state discrimination. 
A readout correction is employed to statistically calibrate out the effect of classical readout bit-flip errors.
 
%A rough estimate of the qubit X90 and X180 gate pulse can be derived from the Rabi period. 
%The Gaussian Mixture Model (GMM) fitting and prediction, which are used for the qubit state discrimination, are included in the post-processing package.

%The T1 measurement,  Ramsey and spin-echo scripts are used to carry out these measurement. 

% Based on the API, we developed a portfolio of quantum chip characterization methods allowing the optimization and benchmarking of single qubit gate and two-qubits gate. 

%\begin{table}
%\centering
%\caption{Electronics setup and coarse tune}
%%\setlength{\tabcolsep}{3pt}
%\begin{tabular}{p{1.8cm} p{5.5cm}}
%\hline
%Task & Description \\ \hline
%Time alignment & Measure latency for the readout signal and align it with the DLO\\ \hline
%TWPA drive & Adjust the twpa drive frequency and power for the high gain\\ \hline
%Single-tone & Measure all the readout resonator frequencies on the readout bus\\ \hline
%Punch-out & Find out alive qubits and coarsely adjust the readout amplitude to the linear zone\\ \hline
%Two-tone & Find out the qubit drive frequency coarsely\\ \hline
%Chevron pattern	& Measure the qubit response as a function of qubit drive frequency\\ \hline
%Rabi time & Drive Rabi oscillation using different qubit drive pulse length\\ \hline
%Rabi amplitude & Drive Rabi oscillation using different qubit drive amplitude\\ \hline
%\end{tabular}
%\label{tab:qcvv}
%\end{table}

% The following tasks have been implemented on QubiC as Python scripts: readout delay time alignment, travelling wave parametric amplifier (TWPA) \cite{macklin2015quantum} drive, single-tone experiment to measure the readout resonator frequency, punch-out experiment to coarse adjust the readout pulse amplitude to the linear zone, two-tone experiment optimizing the qubit drive frequency, and chevron pattern measurement characterizing the qubit drive response.
% The single qubit gate experiment measures the Rabi-time and Rabi-amplitude oscillation, 

A bounded minimization method \cite{brent2013algorithms} is used to adjust the readout amplitude and frequency together with the qubit drive frequency to maximize the Rabi oscillation contrast. 
To increase the gate repeatability, the gate pulse length is set to be a multiple of the DAC sampling rate and the FPGA clock rate. 
The qubit drive amplitude is optimized for each gate by stacking multiple identical gates at the target pulse width to maximize the recovery probability \cite{sheldon2016characterizing,xu2020automatic}.
With the calibrated single-qubit gate, we can measure the qubit coherence time including the qubit relaxation time ($T_1$) and dephasing time ($T_2$).
The residual oscillation frequency measured by the Ramsey experiment can help us finely tune the qubit drive frequency.
The single qubit gate quality can be validated by the AllXY experiment \cite{reed2013entanglement} and by a conventional randomized benchmarking (RB) sequence \cite{knill2008randomized}. 
%  DRAG parameters optimization
% The Gaussian Mixture Model (GMM) fitting, which is used for the qubit state discrimination by thresholding the integrated value from the I/Q buffer, is included in the post-processing package as well.
%The single-qubit randomized benchmarking (RB) can be executed by TrueQ to verify the single-qubit gate fidelity. 

Two-qubit gate calibration starts with optimizing the cross resonance (CR) pulse to reach full entanglement \cite{sheldon2016procedure}.
The single qubit gate parameters around the CR pulse to construct a CNOT gate are identified by a curve fitting of a full XY-plane measurement of a degenerated state followed by a CR pulse \cite{xu2021automatic}. 
With the circuits from TrueQ, we can execute a two-qubit RB measurement to obtain the two-qubit process fidelity.
%measured by the randomized benchmarking sequence generated and processed by TrueQ.
% We also implement the randomized compiling (RC) to improve the algorithm performance on noisy quantum processors.

\subsubsection{Graphical user interface}
The QubiC GUI (graphical user interface) is being developed to streamline and simplify the complex sequences of hardware calibration tasks.

The GUI client, which is implemented in Bootstrap and JavaScript,  can be used to remotely control the quantum hardware connected by the internet.

The operator can change the qubit bias point in real time, initialize/terminate measurements, and display the results. 
Fig.~\ref{fig:GUI} shows an example of the user-facing GUI web-page for generating a chevron pattern for coherent oscillations. 

\begin{figure}[!ht]
\centering
\includegraphics[width=1.0\linewidth]{xu3.png} 
\caption{Screen shot of GUI while executing the chevron task.}
\label{fig:GUI}
\end{figure}

The GUI server, which is implemented in the Python web framework Flask, runs on a Linux machine located in the proximity of the QubiC FPGA chassis. 
For any measurement requested by the client, the configuration and the measured raw IQ-pairs are saved in local files in the YAML and HDF5 data formats, respectively.
The post processing is done on the server side and the plots are made available for the remote client. 
Any file saved by the GUI server is time-stamped, which allows for the retrieval of the history or tracking of the time stability of the hardware calibration constants.
The finite state machine governs the internal logic of the server and the experiments are executed asynchronously allowing for an early termination by the client.

\section{Bench test}
Putting the electronics hardware, FPGA gateware and engineering software together, we used the QubiC system to generate the desired RF pulses to control and measure the qubits.
Specifically, we performed bench testing to demonstrate fully parametric waveform generation using the destination, timing, carrier, amplitude and envelope parameters.

A simple example is shown in Fig.~\ref{fig:bencha} where we aim to generate a Y180 gate on Q6 (which is a 180 degrees single-qubit gate around the Y-axis of the Bloch sphere on a qubit labeled Q6) starting at some time (defined in the circuit) after the circuit starts.
The in-phase and quadrature components are sent to the IQ channels for the Q6 qubit drive ``Q6.qdrv'' (dest).
The pulse starts immediately (t0) after the gate starts, and lasts 96~ns (twidth).
The carrier frequency is specified as ``Q6.freq'' (fcarrier), while the initial phase is ``numpy.pi/2'' (pcarrier).
The overall amplitude of the pulse is 0.873 of the DAC full scale.
The amplitude modulation is applied with a ``DRAG'' (derivative removal by adiabatic gate \cite{motzoi2009simple}) envelope (env) with appropriate parameters.
This simple mapping from the gate configuration to the envelope definition function enables us to use any user provided Python function as the pulse envelope to construct a gate.

The above-mentioned Y180 gate pulse is generated by DAC pairs as IF I/Q signals. 
The IF signals are then up-converted in the up mixing module to an RF signal. 
In order to measure the Y180 gate pulse, the RF signal is directly connected back to the RF down mixing module, followed by the ADC digitization.
As shown in Fig.~\ref{fig:benchb}, we can successfully generate the parameterized RF pulse, which is essential to the pulse level experiments.

%\begin{figure}[!ht]
%\centering
%\includegraphics[width=1.0\linewidth]{pulse_cartoon.pdf} 
%\caption{Parametric waveform generation. The destination parameter is the destination qubit or readout to be controlled, which is named as \textbf{dest} in the gate configuration. The timing parameter consists of the pulse starting time (\textbf{t0}) and the pulse width (\textbf{twidth}). The carrier frequency (\textbf{fcarrier}) and the initial phase (\textbf{pcarrier}) values are encoded in the carrier parameter. The pulse amplitude (\textbf{amp}) is a fraction of DAC full scale. The envelope function (\textbf{env}) can be any Python function (commonly used or customized) returning NumPy array. }
%\label{fig:pulse}
%\end{figure}

\begin{figure}[t!]
\centering
\subfloat[Gate configuration and envelope definition. The destination parameter is the destination qubit or readout to be controlled, which is named as \textbf{dest} in the gate configuration. The timing parameter consists of the pulse starting time (\textbf{t0}) and the pulse width (\textbf{twidth}). The carrier frequency (\textbf{fcarrier}) and the initial phase (\textbf{pcarrier}) values are encoded in the carrier parameter. The pulse amplitude (\textbf{amp}) is a fraction of DAC full scale. The envelope function (\textbf{env}) can be any Python function (commonly used or customized) returning a NumPy array.]{\includegraphics[width=1.0\linewidth]{xu4a.pdf}
\label{fig:bencha}}
\vfil
\subfloat[Y180 gate with DRAG envelope measured by ADCs. The ADC digitizes the IF signal at a sampling rate of 1~GSPS.]{\includegraphics[width=0.8\linewidth]{xu4b.pdf}
\label{fig:benchb}}
\caption{Parametric waveform generation.}
\label{fig:bench}
\end{figure}

\section{Test with quantum processor}
\subsection{Randomized benchmarking}
Leveraging standard qubit characterization and gate optimization protocols \cite{xu2021automatic}, the QubiC can automatically find and tune a two-qubit system. 
In order to validate the performance of the QubiC system on quantum hardware, we perform streamlined randomized benchmarking \cite{magesan2011scalable} on two of the qubits in an 8-qubit quantum processor \cite{blok2021quantum}. 
%The process fidelity can be extracted from the RB plots \cite{emerson2005scalable,dankert2009exact}.
As shown in Fig.~\ref{fig:rb}, the single-qubit process fidelity \cite{emerson2005scalable,dankert2009exact} is measured to be 0.9980$\pm$0.0001, while the two-qubit process fidelity is measured to be 0.948$\pm$0.004. 
%although we did not implement the software mitigation of crosstalk during the measurement.
%Interleaved randomized benchmarking \cite{magesan2012efficient} and extended randomized benchmarking \cite{wallman2015estimating} are performed in \cite{xu2021automatic} with QubiC, which verify that the control system is not limiting the fidelity.
The RB results demonstrate that the QubiC system can control and measure qubits efficiently, and it should be capable of delivering high-fidelity gates on state-of-the-art processors.

\begin{figure}[t!]
\centering
\subfloat[Single-qubit RB. 100 points per length, 1k shots per point.]{\includegraphics[width=0.8\linewidth]{xu5a.pdf}
\label{fig:rba}}
\vfil
\subfloat[Two-qubit RB. 20 points per length, 2k shots per point.]{\includegraphics[width=0.8\linewidth]{xu5b.pdf}
\label{fig:rbb}}
\caption{Streamlined randomized benchmarking results. Each point corresponds to a measurement result of a random quantum circuit. The curve was fitted with an exponential decay function $\mathrm{A}\mathrm{p}^\mathrm{m}$. The sequence length is expressed in terms of Clifford gates.}
\label{fig:rb}
\end{figure}

\subsection{Randomized compiling}
Randomized compiling (RC) is newly developed technique in quantum computing to tailor and mitigate noise \cite{wallman2016noise,ware2018experimental}.
The RC protocol efficiently compiles an algorithm circuit in a number of different, but equivalent variations. 
Instead of executing just the original ``bare'' circuit, the protocol requires execution of all the variations of the circuit. 
On the conventional control hardware side, it may be challenging to create and upload the various pulse sequences without significant overhead. 
Here, we show that QubiC can execute this general, yet sophisticated compilation protocol on a quantum computer in an efficient manner. 
%For a given ``bare'' circuit, the RC compiler adds several randomized simple gates without increasing circuit depth and maintains the unitary unchanged. 
%We here demonstrated the capability and performance of running the RC circuits on QubiC hardware. 

On the host computer, the circuits are randomly compiled (``Compile'') and transpiled to a device's native gateset (``Transpile'') \cite{hashim2020randomized,trueq2020}.
Afterwards, QubiC transfers the native gate sequences to QubiC command sets (``Transfer'') and then generates the sequences (``SeqGen''). 
The QubiC software prepares the hardware and transports the command and the memory to the QubiC hardware (``Run''). 
The qubit response is acquired from the FPGA (``Acquire'') and processed by QubiC software to discriminate the state (``Process''). 

To evaluate RC efficacy, we compare the measured probability $\mathrm{P}(x)$ with the ideal probability $\mathrm{P}_\mathrm{ideal}(x)$ for the given circuit to calculate the total variational distance (TVD), which is defined as
\begin{equation}
\label{eq3}
\mathrm{TVD}=\frac{1}{2}\sum_{x \in X}|\mathrm{P}(x)-\mathrm{P}_\mathrm{ideal}(x)| ,
\end{equation}
where x is the bit string. 
The TVD parameterizes the probability of measuring an incorrect solution.

We perform the two-qubit RC on the quantum processor, and measure the TVD distributions of bare circuits and RC circuits, as shown in Fig.~\ref{fig:rcdist}. 
Compared to the bare circuits, lower TVD values are observed from the RC process, which means the output distributions are more accurate.

\begin{figure}[!ht]
\centering
\includegraphics[width=0.8\linewidth]{xu6.pdf} 
\caption{TVD distributions obtained from two-qubit randomized compiling. 100 different random bare circuits were generated for sufficient statistics, with an average of 20 RC circuits for each bare circuit. The circuit depth is 5 (two-qubit gates). Each measurement is the average of 1024 shots. The TVD values are 0.150$\pm$0.067 for bare circuits and 0.075$\pm$0.034 for RC circuits.}
\label{fig:rcdist}
\end{figure}

Furthermore, QubiC can execute the RC protocol relatively quickly, as shown in Fig.~\ref{fig:rcspeed}.
The total execution time grows linearly with the increase of the number of RC circuits or the number of two-qubit gates.
The ``Compile'' and the ``Transpile'' account for the majority of the execution time, which are limited by the host computer performance.
The major part of the QubiC execution time is the ``Run'', while command writing is the most time-consuming task in the ``Run''. 
One can observe that the ``Run'' time increases linearly with the number of RC circuits and the number of two-qubit gates respectively, since the command depth also grows linearly. 
The speed of the ``Run'' portion is currently limited by the constraint that the load command only accepts 16k commands and takes $\sim$55~ms to execute. 
This can be made more efficient in future versions of the software.
For a 600~$\mu$s relaxation time, we can load $\sim$100 circuits at a time. 
Currently QubiC takes $<$17~s for 80 cycles and 100 RC circuits with 1024 shots, which is efficient and promising.

\begin{figure}[t!]
\centering
\subfloat[Execution time versus number of RC circuits.]{\includegraphics[width=0.8\linewidth]{xu7a.pdf}
\label{fig:rcspeeda}}
\vfil
\subfloat[Execution time versus number of two-qubit gates.]{\includegraphics[width=0.8\linewidth]{xu7b.pdf}
\label{fig:rcspeedb}}
\caption{Execution time of two-qubit randomized compiling on QubiC. (a) measures the execution time with different number of RC circuits when the circuit depth is 80 (two-qubit gates). (b) measures execution time with different number of two-qubit gates when 100 RC circuits are averaged for each bare circuit. Each measurement is the average of 1k shots. The bar with slash inside is operated on the host computer, which is the main limiting factor in the execution time.}
\label{fig:rcspeed}
\end{figure}

\section{Conclusion}
We develop an open source FPGA based QubiC system which bridges the quantum algorithm and the quantum hardware implementation layers of the computing stack.
The QubiC system includes the room temperature electronics hardware, the gateware, and the engineering software running on it to implement the qubit control pulses, and also to perform quantum state readout. 
QubiC allows researchers to access the full electronics hardware, gateware and software stack, which will enable the execution of a broader class of computation experiments while also facilitating the implementation co-design at each level of the stack in next generation systems. 
The QubiC prototype system functionality and performance were demonstrated by measuring single-qubit and two-qubit process fidelities. 
We obtained RB values of 0.9980$\pm$0.0001 and 0.948$\pm$0.004, respectively, on a 8-qubit superconducting quantum processor operating at the LBNL Advanced Quantum Testbed.
Moreover, we demonstrated that QubiC has the capability to run advanced quantum algorithms such as randomized compiling with promising execution speed. 
QubiC can accommodate the full spectrum of users and developers, and will be a potential open source toolbox for the quantum community.

\section*{Appendix}
\label{appendix}
%\subsection{compiler1}
%\begin{figure}[t!]
%\centering
%\subfloat[OPTM.]{\includegraphics[width=1.0\linewidth]{optm.pdf}
%\label{fig:optm}}
%\vfil
%\subfloat[RUNC.]{\includegraphics[width=1.0\linewidth]{runc.pdf}
%\label{fig:runc}}
%\caption{Qubic software control flow for QCVV experiment.}
%\label{fig:QCVV}
%\end{figure}

\subsection{Compiling procedure}
The compiler is the bridge in the software API to transfer the circuit description into the envelope and command buffers.
The compiling procedure is shown in Fig.~\ref{fig:compiler}.
The three steps of the compilation are:

\begin{figure}[!ht]
\centering
\includegraphics[width=.6\linewidth]{xu8.pdf} 
\caption{Compiling procedure.}
\label{fig:compiler}
\end{figure}

(i) \textbf{Scheduler}: 
The first step is scheduling, which takes in the circuit description together with the compiler configuration to generate the gate sequences with relative timing information. 
For the circuits imported from other language which does not include the timing information, such as OpenQASM, this step is necessary. 
However, if the circuit is written using native function calls, this step can be skipped by assigning an explicit start time to each gate.

(ii) \textbf{Time-Pulse Pair}: 
The second step is to combine the gate sequences with the gate configuration to generate a list of pulses described as TP (time pulse) pairs. 
The qubit chip and gate configuration are generated from the qubit characterization and gate optimization. 
The gate configuration contains information about the pulses used in the gate, including the carrier, the envelope, and the relative timing.
The TP description contains the parameterized gate information, which can then be implemented using different electronics hardware setups. 
The conventional AWG contains idle periods of zero or constant output. 
Rather than inefficiently storing repeated values in the waveform memory, we instead employ the TP pairs to store the time and pulse envelope value in the waveform memory.
At this level, the TP pair can still be human readable, so for the user who is familiar with the pulse should be able to understand the TP description and also check the relative pulse timing.
    
(iii) \textbf{iNdex-Value Pair}: 
The third step includes the hardware configuration, and generates the NV (iNdex value) pair as buffer value for the lower level. 
This is a hardware dependent layer. 
The hardware configuration contains the sampling rate, the physical wiring diagram between the DACs and the qubits and the gateware register maps. 
This only needs to be updated when the quantum chip or the chip wiring changes. 
Separating this step and configuration gives us the opportunity to run the same pulse on different hardware for comparison.

The outputs of the 3-step compiler are the envelope buffer, the command buffer and the simulator to visualize the pulse from the buffer values. 
The commands normally sent to the FPGA are redirected to the on-host analysis and visualisation package, when switching to the simulation mode, which allows verification of correctness of encoded gates.
The final output from the API is the UDP (user datagram protocol) packet, which will be sent out over Gigabit Ethernet to the FPGA hardware.

\section*{Acknowledgment}
This work was supported by the U.S. Department of Energy, Office of Science, Advanced Scientific Computing Research Testbeds for Science program, the High Energy Physics QUANTISED program, and the National Quantum Information Science Research Centers Quantum Systems Accelerator under Contract No. DE-AC02-05CH11231.
The authors would like to thank Larry Doolittle, Qiang Du, Wim Lavrijsen, Thorsten Stezelberger, Anastasiia Butko, Costin Iancu from Lawrence Berkeley National Laboratory, and Akel Hashim, Jean-Loup Ville, Jie Luo, Brian Marinelli, John Mark Kreikebaum, Yosep Kim, Larry Chen, Will Livingston, Noah Stevenson, Gerwin Koolstra, Marie Lu from University of California, Berkeley, and Quantum Benchmark, Inc. for their support.

\begin{thebibliography}{00}

\bibitem{preskill2018quantum} J. Preskill, ``Quantum computing in the NISQ era and beyond,''~\emph{Quantum}, vol. 2, pp. 79, 2018.

\bibitem{google2020hartree} Google AI Quantum~\emph{et al.}, ``Hartree-Fock on a superconducting qubit quantum computer,''~\emph{Science}, vol. 369, no. 6507, pp. 1084--1089, 2020.

\bibitem{arute2019quantum} F. Arute~\emph{et al.}, ``Quantum supremacy using a programmable superconducting processor,''~\emph{Nature}, vol. 574, no. 7779, pp. 505--510, 2019.

%\bibitem{walter2017rapid} T. Walter~\emph{et al.}, ``Rapid high-fidelity single-shot dispersive readout of superconducting qubits,''~\emph{Phys. Rev. Appl.}, vol. 7, no. 5, pp. 054020, 2017.

\bibitem{vainsencher2019superconducting} A. Vainsencher~\emph{et al.}, ``Superconducting qubit control electronics-Part 1/2: system overview and control hardware,'' in \emph{Bulletin of the American Physical Society}, vol. 64, no. 2, V26.00005, Boston, MA, USA, 2019.

\bibitem{ryan2017hardware} C. Ryan~\emph{et al.}, ``Hardware for dynamic quantum computing,''~\emph{Rev. Sci. Instrum.}, vol. 88, no. 10, pp. 104703, 2017.

\bibitem{salathe2018low} Y. Salath{\'e}~\emph{et al.}, ``Low-latency digital signal processing for feedback and feedforward in quantum computing and communication,''~\emph{Phys. Rev. Appl.}, vol. 9, no. 3, pp. 034011, 2018.

\bibitem{riste2013deterministic} D. Riste~\emph{et al.}, ``Deterministic entanglement of superconducting qubits by parity measurement and feedback,''~\emph{Nature}, vol. 502, no. 7471, pp. 350--354, 2013.

\bibitem{steffen2013deterministic} L. Steffen~\emph{et al.}, ``Deterministic quantum teleportation with feed-forward in a solid state system,''~\emph{Nature}, vol. 500, no. 7462, pp. 319--322, 2013.

\bibitem{bultink2016active} C. Bultink~\emph{et al.}, ``Active resonator reset in the nonlinear dispersive regime of circuit QED,''~\emph{Phys. Rev. Appl.}, vol. 6, no. 3, pp. 034008, 2016.

\bibitem{gebauer2020state} R. Gebauer~\emph{et al.}, ``State preparation of a fluxonium qubit with feedback from a custom FPGA-based platform,''~\emph{arXiv:1912.06814}, 2019.

\bibitem{chen2012multiplexed} Y. Chen~\emph{et al.}, ``Multiplexed dispersive readout of superconducting phase qubits,''~\emph{Appl. Phys. Lett.}, vol. 101, no. 18, pp. 182601, 2012.

\bibitem{ofek2016extending} N. Ofek~\emph{et al.}, ``Extending the lifetime of a quantum bit with error correction in superconducting circuits,''~\emph{Nature}, vol. 536, no. 7617, pp. 441--445, 2016.

\bibitem{fu2017experimental} X. Fu~\emph{et al.}, ``An experimental microarchitecture for a superconducting quantum processor,''~\emph{arXiv:1708.07677}, 2017.

\bibitem{bertels2020quantum} K. Bertels~\emph{et al.}, ``Quantum computer architecture toward full-stack quantum accelerators,''~\emph{IEEE T. Quantum Eng.}, vol. 1, pp. 1--17, 2020.

\bibitem{gokhale2020optimized} P. Gokhale~\emph{et al.}, ``Optimized Quantum Compilation for Near-Term Algorithms with OpenPulse,''~\emph{arXiv:2004.11205}, 2020.

\bibitem{bardin201928} J. Bardin~\emph{et al.}, ``A 28nm bulk-CMOS 4-to-8GHz $<$2mW cryogenic pulse modulator for scalable quantum computing,''~\emph{ISSCC Dig. Tech.}, pp. 456--458, 2019.

\bibitem{patra2020scalable} B. Patra~\emph{et al.}, ``A scalable cryo-CMOS 2-to-20GHz digitally intensive controller for 4$\times$32 frequency multiplexed spin qubits/transmons in 22nm FinFET technology for quantum computers,''~\emph{ISSCC Dig. Tech.}, pp. 304--306, 2020.

\bibitem{pauka2021cryogenic} S. J. Pauka~\emph{et al.}, ``A cryogenic CMOS chip for generating control signals for multiple qubits,''~\emph{Nature Electronics}, vol. 4, no. 1, pp. 64--70, 2021.

%\bibitem{horseridge2020} Horse Ridge II. Intel Corporation, Santa Clara, CA, USA. [Online]. Available: 
%\ul{https://newsroom.intel.com/news/intel-debuts-2nd-gen-horse-ridge-cryogenic-quantum-control-chip/}. Accessed on: Dec. 21, 2020.

%\bibitem{homulle2017reconfigurable} H. Homulle~\emph{et al.}, ``A reconfigurable cryogenic platform for the classical control of quantum processors,''~\emph{Rev. Sci. Instrum.}, vol. 88, no. 4, pp. 045103, 2017.

%\bibitem{conway2016fpga} I. Conway Lamb~\emph{et al.}, ``An FPGA-based instrumentation platform for use at deep cryogenic temperatures,''~\emph{Rev. Sci. Instrum.}, vol. 87, no. 1, pp. 014701, 2016.

\bibitem{qubic2021repository} See \ul{https://gitlab.com/LBL-QubiC} for the git repository of the QubiC system. Accessed on: Oct. 14, 2021.

\bibitem{vijay2012stabilizing} R. Vijay~\emph{et al.}, ``Stabilizing Rabi oscillations in a superconducting qubit using quantum feedback,''~\emph{Nature}, vol. 490, no. 7418, pp. 77--80, 2012.

\bibitem{riste2012feedback} D. Riste~\emph{et al.}, ``Feedback control of a solid-state qubit using high-fidelity projective measurement,''~\emph{Phys. Rev. Lett.}, vol. 109, no. 24, pp. 240502, 2012.

%\bibitem{geerlings2013demonstrating} K. Geerlings~\emph{et al.}, ``Demonstrating a driven reset protocol for a superconducting qubit,''~\emph{Phys. Rev. Lett.}, vol. 110, no. 12, pp. 120501, 2013.

%\bibitem{riste2020real} D. Riste~\emph{et al.}, ``Real-time processing of stabilizer measurements in a bit-flip code,''~\emph{npj Quantum Inf.}, vol. 6, no. 1, pp. 1--6, 2020.

%\bibitem{hu2019quantum} L. Hu~\emph{et al.}, ``Quantum error correction and universal gate set operation on a binomial bosonic logical qubit,''~\emph{Nat. Phys.}, vol. 15, no. 5, pp. 503--508, 2019.

%\bibitem{das2020scalable} P. Das~\emph{et al.}, ``A scalable decoder micro-architecture for fault-tolerant quantum computing,''~\emph{arXiv:2001.06598}, 2020.

%\bibitem{heinsoo2018rapid} J. Heinsoo~\emph{et al.}, ``Rapid high-fidelity multiplexed readout of superconducting qubits,''~\emph{Phys. Rev. Appl.}, vol. 10, no. 3, pp. 034040, 2018.

%\bibitem{perego2018a} E. Perego~\emph{et al.}, ``A scalable hardware and software control apparatus for experiments with hybrid quantum systems,''~\emph{Rev. Sci. Instrum.}, vol. 89, no. 11, pp. 113116, 2018.

\bibitem{xilinx2012vc707} VC707. Xilinx, Inc., San Jose, CA, USA. [Online]. Available: 
\ul{https://www.xilinx.com/products/boards-and-kits/ek-v7-vc707-g.html}. Accessed on: Dec. 21, 2020.

\bibitem{abaco2016fmc120} FMC120. Abaco Systems, Inc., Huntsville, AL, USA. [Online]. Available: 
\ul{https://www.abaco.com/products/fmc120-fpga-mezzanine-card}. Accessed on: Dec. 21, 2020.

\bibitem{xu2020rf} Y. Xu~\emph{et al.}, ``RF mixing modules for superconducting qubit room temperature control systems,''~\emph{arXiv:2101.00066}, 2020.

\bibitem{wenzel2006uln} ULN P/N:501-16843. Wenzel Associates, Inc., Austin, TX, USA. [Online]. Available: 
\ul{https://wenzel.com/support/legacy-parts/}. Accessed on: Dec. 21, 2020.

\bibitem{ti2017lmx2595} LMX2595 EVM. Texas Instruments, Inc., Dallas, TX, USA. [Online]. Available: 
\ul{https://www.ti.com/lit/ug/snau219b/snau219b.pdf}. Accessed on: Dec. 21, 2020.

\bibitem{keysight2021n5183b} MXG N5183B. Keysight Technologies, Santa Rosa, CA, USA. [Online]. Available: 
\ul{https://www.keysight.com/us/en/assets/7018-04096/data-sheets/5991-3131.pdf}. Accessed on: Apr. 27, 2021.

\bibitem{ball2016role} H. Ball~\emph{et al.}, ``The role of master clock stability in quantum information processing,''~\emph{npj Quantum Inf.}, vol. 2, no. 1, pp. 1--8, 2016.

\bibitem{huang2021clock} G. Huang~\emph{et al.}, ``Clock synchronization and data exchange between FPGA modules for superconducting qubit control,'' in \emph{Bulletin of the American Physical Society}, R33.00007, 2021.

\bibitem{ti2016jesd204b} JESD204B. Texas Instruments, Inc., Dallas, TX, USA. [Online]. Available: 
\ul{https://www.ti.com/lit/ml/slap161/slap161.pdf}. Accessed on: Apr. 27, 2021.

\bibitem{moreira2009white} P. Moreira~\emph{et al.}, ``White rabbit: sub-nanosecond timing distribution over ethernet,''~\emph{IEEE Int. Symp. Precis. Clock Syn.}, pp. 1--5, 2009.

\bibitem{huang2020qubit} G. Huang~\emph{et al.}, ``Qubit fast reset with QubiC,'' in \emph{Bulletin of the American Physical Society}, vol. 65, no. 1, C71.00233, 2020.

\bibitem{mckay2017efficient} D. C. McKay~\emph{et al.}, ``Efficient Z gates for quantum computing,''~\emph{Phys. Rev. A}, vol. 96, no. 2, pp. 022330, 2017.

\bibitem{volder1959the} J. Volder, ``The CORDIC trigonometric computing technique,''~\emph{IRE Trans. Electron. Comput.}, vol. EC-8, no. 3, pp. 330--334, 1959.

\bibitem{andraka1998a} R. Andraka, ``A survey of CORDIC algorithms for FPGA based computers,'' in \emph{ACM/SIGDA international symposium on field programmable gate arrays}, pp. 191--200, Monterey, CA, USA, 1998.

\bibitem{trueq2020} True-Q. Quantum Benchmark, Inc., Kitchener, ON, Canada. [Online]. Available: 
\ul{https://trueq.quantumbenchmark.com/}. Accessed on: Dec. 21, 2020.

\bibitem{qiskit2020} Qiskit. IBM, Armonk, NY, USA. [Online]. Available: 
\ul{https://qiskit.org/}. Accessed on: Dec. 21, 2020.

\bibitem{cross2017open} A. Cross~\emph{et al.}, ``Open quantum assembly language,''~\emph{arXiv:1707.03429}, 2017.

\bibitem{cirq2020} Cirq. Google LLC, Menlo Park, CA, USA. [Online]. Available: 
\ul{https://github.com/quantumlib/Cirq}. Accessed on: Dec. 21, 2020.

%\bibitem{kjaergaard2020superconducting} M. Kjaergaard~\emph{et al.}, ``Superconducting qubits: Current state of play,''~\emph{Annu. Rev. Conden. Ma. P.}, vol. 11, pp. 369--395, 2020.

\bibitem{reed2010high} M. D. Reed~\emph{et al.}, ``High-fidelity readout in circuit quantum electrodynamics using the Jaynes-Cummings nonlinearity,''~\emph{Phys. Rev. Lett.}, vol. 105, no. 17, pp. 173601, 2010.

\bibitem{brent2013algorithms} R. P. Brent, ``Algorithms for minimization without derivatives,''~\emph{Courier Corporation}, 2013. 

\bibitem{sheldon2016characterizing} S. Sheldon~\emph{et al.}, ``Characterizing errors on qubit operations via iterative randomized benchmarking,''~\emph{Phys. Rev. A}, vol. 93, no. 1, pp. 012301, 2016.

\bibitem{xu2020automatic} Y. Xu~\emph{et al.}, ``Automatic single qubit characterization with QubiC,'' in \emph{Bulletin of the American Physical Society}, vol. 65, no. 1, R68.00010, 2020.

%\bibitem{rudinger2017experimental} K. Rudinger~\emph{et al.}, ``Experimental demonstration of a cheap and accurate phase estimation,''~\emph{Phys. Rev. Lett.}, vol. 118, no. 19, pp. 190502, 2017.

\bibitem{reed2013entanglement} M. D. Reed, ``Entanglement and quantum error correction with superconducting qubits,'' Ph.D. dissertation, Yale University, New Haven, CT, USA, 2013.

\bibitem{knill2008randomized} E. Knill~\emph{et al.}, ``Randomized benchmarking of quantum gates,''~\emph{Phys. Rev. A}, vol. 77, no. 1, pp. 012307, 2008.

\bibitem{sheldon2016procedure} S. Sheldon~\emph{et al.}, ``Procedure for systematically tuning up cross-talk in the cross-resonance gate,''~\emph{Phys. Rev. A}, vol. 93, no. 6, pp. 060302, 2016.

\bibitem{xu2021automatic} Y. Xu~\emph{et al.}, ``Automatic qubit characterization and gate optimization with QubiC,''~\emph{arXiv:2104.10866}, 2021.

%\bibitem{xu2021automatictwoqubit} Y. Xu~\emph{et al.}, ``Automatic two-qubit gate calibration with QubiC,'' in \emph{Bulletin of the American Physical Society}, R33.00008, 2021.

%\bibitem{macklin2015quantum} C. S. Macklin, ``Quantum Feedback and Traveling-wave Parametric Amplification in Superconducting Circuits,'' Ph.D. dissertation, Dept. Phys., UC Berkeley, Berkeley, CA, USA, 2015.

\bibitem{motzoi2009simple} F. Motzoi~\emph{et al.}, ``Simple pulses for elimination of leakage in weakly nonlinear qubits,''~\emph{Phys. Rev. Lett.}, vol. 103, no. 11, pp. 110501, 2009.

\bibitem{magesan2011scalable} E. Magesan~\emph{et al.}, ``Scalable and robust randomized benchmarking of quantum processes,''~\emph{Phys. Rev. Lett.}, vol. 106, no. 18, pp. 180504, 2011.

\bibitem{blok2021quantum} M. S. Blok~\emph{et al.}, ``Quantum information scrambling on a superconducting qutrit processor,''~\emph{Phys. Rev. X}, vol. 11, no. 2, pp. 021010, 2021.

\bibitem{dankert2009exact} C. Dankert~\emph{et al.}, ``Exact and approximate unitary 2-designs and their application to fidelity estimation,''~\emph{Phys. Rev. A}, vol. 80, no. 1, pp. 012304, 2009.

\bibitem{emerson2005scalable} J. Emerson~\emph{et al.}, ``Scalable noise estimation with random unitary operators,''~\emph{J. Opt. B-Quantum S. O.}, vol. 7, no. 10, pp. S347, 2005.

%\bibitem{magesan2012efficient} E. Magesan~\emph{et al.}, ``Efficient measurement of quantum gate error by interleaved randomized benchmarking,''~\emph{Phys. Rev. Lett.}, vol. 109, no. 8, pp. 080505, 2012.

%\bibitem{wallman2015estimating} J. Wallman~\emph{et al.}, ``Estimating the coherence of noise,''~\emph{New. J. Phys.}, vol. 17, no. 11, pp. 113020, 2015.

\bibitem{wallman2016noise} J. Wallman~\emph{et al.}, ``Noise tailoring for scalable quantum computation via randomized compiling,''~\emph{Phys. Rev. A}, vol. 94, no. 5, pp. 052325, 2016.

\bibitem{ware2018experimental} M. Ware~\emph{et al.}, ``Experimental demonstration of Pauli-frame randomization on a superconducting qubit,''~\emph{arXiv:1803.01818}, 2018.

\bibitem{hashim2020randomized} A. Hashim~\emph{et al.}, ``Randomized compiling for scalable quantum computing on a noisy superconducting quantum processor,''~\emph{arXiv:2010.00215}, 2020.

\end{thebibliography}

\end{document}

