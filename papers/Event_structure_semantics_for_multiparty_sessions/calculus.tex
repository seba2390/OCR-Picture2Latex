% !TEX root =cdgS.tex

\section{A Core Calculus for Multiparty Sessions}\mylabel{sec:calculus}

We now formally introduce our calculus, where multiparty sessions are
represented as networks of processes.  We assume the following base
sets: \emph{session participants}, ranged over by $\pp,\q,\pr, \ldots$
and forming the set $\Participants $, and \emph{messages}, ranged over
by $\la,\la',\dots$ and forming the set $\Messages$.

Let $\pi \in \{ \sendL{\pp}{\la}, \rcvL{\pp}{\la} \pc
\pp\in \Participants, \la \in \Messages\}$ denote an \emph{action}.
The action $\sendL{\pp}{\la}$ represents an output of message $\la$ to
participant $\pp$, while the action $\rcvL{\pp}{\la}$ represents an
input of message $\la$ from participant $\pp$.   The
\emph{participant of an action}, $\ptone{\pi}$, is defined by
$\ptone{\sendL{\pp}{\la}}=\ptone{\rcvL{\pp}{\la}}=\pp$.


\begin{definition}[Processes]\mylabel{p} 
 Processes are  defined by:\\
 \[
\begin{array}{lll}
\PP & \coDefGr  & 
\oup\pp{i}{I}{\la}{\PP}%
~~\mid~~  
\inp\pp{i}{I}{\la}{\PP}%
~~\mid~~
\inact
\end{array}
\]
\noindent
where $I$ is non-empty and $\la_h\not=\la_k$ for all $h,k\in I$,
$h\neq k$, i.e.
 messages  in choices are all different.\\
Processes of the shape $\oup\pp{i}{I}{\la}{\PP}$ and
$\inp\pp{i}{I}{\la}{\PP}$ are called {\em output} and {\em input
  processes}, respectively.
\end{definition}\noindent
The symbol $ \coDefGr$, in the definition above and in later
definitions, indicates that the productions should be interpreted
\emph{coinductively}.  
Namely, they define possibly infinite processes.  However, we assume
such processes to be \emph{regular}, that is, with finitely many
distinct subprocesses. In this way, we only obtain processes which are
solutions of finite sets of equations, see~\cite{Cour83}. So, when
writing processes, we shall use (mutually) recursive equations.

Sequential composition ($;$) has higher precedence than choices ($\bigoplus$, $\SigmaB$). 
When $I$ is a singleton, $\oup\pp{i}{I}{\la}{\PP}$ will be rendered as
$\Seq{\sendL{\pp}{\la}}{\PP}$ and $\inp\pp{i}{I}{\la}{\PP}$ will be
rendered as $\Seq{\rcvL{\pp}{\la}}{\PP}$.  Trailing $\inact$ processes
will be omitted.

 
In a full-fledged calculus, messages would carry values, 
namely they would be of the form $\la(\val)$.  For simplicity, we
consider only pure messages here. This will allow us to project global
types directly to processes,  without having to explicitly introduce local
types,  see Section \ref{sec:types}.

\bigskip

Networks are comprised of 
%at least two 
pairs of the form
$\pP{\pp}{\PP}$ composed in parallel, each with a
different participant $\pp$. 
\begin{definition}[Networks]
{\em Networks} are defined by:
%\centerline{$
\[
\Nt = \pP{\pp_1}{\PP_1} \parN \cdots \parN \pP{\pp_n}{\PP_n}  \qquad
 n\geq 1,  \ 
\pp_h \neq \pp_k ~~\text{for any}~~ h, k~(1\leq h,k\leq n).
%$} 
\]
\end{definition}
We assume the standard structural congruence  $\equiv$  on
networks, stating that parallel composition is associative and
commutative and has neutral element $\pP\pp\inact$ for any fresh
$\pp$.

If $\PP\neq\inact$ we write $\pP{\pp}{\PP}\in\Nt$ as short for
$\Nt\equiv\pP{\pp}{\PP}\parN\Nt'$ for some $\Nt'$.  



To express the operational semantics of networks, we use an LTS whose
labels record the message exchanged during a communication together
with its sender and receiver.  The set of \emph{communications},
ranged over by $\alpha, \alpha'$, is defined to be $\{
\Comm{\pp}{\M}{\q} \pc \pp,\q\in \Participants, \M \in \Messages\}$,
where $\Comm{\pp}{\M}{\q}$ represents the emission of a message $\M$
from participant $\pp$ to participant
$\q$.  %We write $\participant{\Comm{\pp}{\M}{\q}}=\set{\pp,\q}$.

\begin{figure}[h]
% \centerline{$
{\small
\[
\begin{array}{c}
\pP{\pp}{\oup\q{i}{I}{\la}{\PP}}\parN \pP{\q}{\inp\pp{j}{J}{\la}{\Q}}\parN\Nt\stackred{\Comm\pp{\la_k}\q}
  \pP{\pp}{\PP_k}\parN \pP{\q}{\Q_k}\parN\Nt~~~\text{where }
   k \in I{\cap}J{~~~~~~\rulename{Com}}
\end{array}
%$}  
\]
}
\caption{
LTS for networks.}\mylabel{fig:netred}\mylabel{fig:procLTS}
\end{figure}


The LTS semantics of networks is specified by the unique rule
$\rulename{Com}$ given in \refToFigure{fig:procLTS}.  
Notice that rule
$\rulename{Com}$  is symmetric with respect to 
input and output
choices.  In a well-typed network (see \refToSection{sec:types}) it
will always be the case that $I\subseteq J$,  ensuring  that participant
$\pp$ can freely choose an output, since participant $\q$ offers all
corresponding inputs. 

\bigskip

In the following we will make an extensive use of finite (and possibly
empty) sequences of communications. As usual we define them as traces.
\begin{definition}[Traces]\label{traces} {\em (Finite) traces} $\comseq \in
  \Comseq$ are defined by:
 % \centerline{$
 \[
  \comseq::=\ee\mid\concat\alpha\comseq
 % $} 
 \]
 We use
  $\cardin{\comseq}$ to denote the length of the trace $\comseq$.\\ 
  The set of {\em participants of a trace}, notation $\participant{\comseq}$, 
  is defined by 
  $\participant{\ee}=\emptyset$ and
  $\participant{\concat{\Comm\pp\la\q}\comseq}=\set{\pp,\q}\cup\participant\comseq$.
\end{definition}
\noindent 
When
$\comseq=\concat{\alpha_1}{\concat\ldots{\alpha_n}}$ ($n\geq 1)$ we
write $\Nt\stackred{\sigma}\Nt'$ as short for
$\Nt\stackred{\alpha_1}\Nt_1\cdots\stackred{\alpha_n}\Nt_n = \Nt'$.

